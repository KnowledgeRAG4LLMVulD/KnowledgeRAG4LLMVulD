[
    {
        "code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task))\n\t\tinit_idle(task, cpu);\n\treturn task;\n}",
        "bug_line_number": [
            6,
            7,
            8
        ],
        "vul": 1,
        "id": 0
    },
    {
        "code": "COMPAT_SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (uru) {\n\t\t\t/* kernel_waitid() overwrites everything in ru */\n\t\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\t\telse\n\t\t\t\terr = put_compat_rusage(&ru, uru);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (!infop)\n\t\treturn err;\n\tif (!access_ok(infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\tuser_access_begin();\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
        "bug_line_number": [
            24,
            25,
            26
        ],
        "vul": 1,
        "id": 2
    },
    {
        "code": "long strncpy_from_user(char *dst, const char __user *src, long count)\n{\n\tunsigned long max_addr, src_addr;\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\tmax_addr = user_addr_max();\n\tsrc_addr = (unsigned long)src;\n\tif (likely(src_addr < max_addr)) {\n\t\tunsigned long max = max_addr - src_addr;\n\t\tlong retval;\n\t\tkasan_check_write(dst, count);\n\t\tcheck_object_size(dst, count, false);\n\t\tuser_access_begin();\n\t\tretval = do_strncpy_from_user(dst, src, count, max);\n\t\tuser_access_end();\n\t\treturn retval;\n\t}\n\treturn -EFAULT;\n}",
        "bug_line_number": [
            12,
            13,
            14,
            15,
            16
        ],
        "vul": 1,
        "id": 4
    },
    {
        "code": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\tm->msg_iov = iov;\n\terr = 0;\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\treturn err;\n}",
        "bug_line_number": [
            12,
            13
        ],
        "vul": 1,
        "id": 6
    },
    {
        "code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN) {\n\t\t\tmsg->msg_namelen = 0;\n\t\t\treturn 0;\n\t\t}\n\t\treturn err;\n\t}\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t\telse\n\t\t\tmsg->msg_namelen = 0;\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}",
        "bug_line_number": [
            13,
            14,
            15,
            16,
            31,
            32
        ],
        "vul": 1,
        "id": 8
    },
    {
        "code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\t/*\n\t * \tThis works for seqpacket too. The receiver has ordered the\n\t *\tqueue for us! We do one quick check first though\n\t */\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\t/* Now we can treat all alike */\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t/* Remove PID */\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_namelen != 0) {\n\t\tstruct sockaddr_ax25 *sax = (struct sockaddr_ax25 *)msg->msg_name;\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t/* We set this correctly, even though we may not let the\n\t\t   application know the digi calls further down (because it\n\t\t   did NOT ask to know them).  This could get political... **/\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "bug_line_number": [
            30,
            31,
            32,
            34,
            35
        ],
        "vul": 1,
        "id": 10
    },
    {
        "code": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n\tmsg->msg_namelen = 0;\n\tif (msg_flags & MSG_OOB)\n\t\tgoto out;\n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\trds_stats_inc(s_recv_delivered);\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = inc->i_hdr.h_sport;\n\t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\tmsg->msg_namelen = sizeof(*sin);\n\t\t}\n\t\tbreak;\n\t}\n\tif (inc)\n\t\trds_inc_put(inc);\nout:\n\treturn ret;\n}",
        "bug_line_number": [
            12
        ],
        "vul": 1,
        "id": 12
    },
    {
        "code": "static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n{\n\tstruct rdma_id_private *listen_id, *conn_id;\n\tstruct rdma_cm_event event;\n\tint offset, ret;\n\tu8 smac[ETH_ALEN];\n\tu8 alt_smac[ETH_ALEN];\n\tu8 *psmac = smac;\n\tu8 *palt_smac = alt_smac;\n\tint is_iboe = ((rdma_node_get_transport(cm_id->device->node_type) ==\n\t\t\tRDMA_TRANSPORT_IB) &&\n\t\t       (rdma_port_get_link_layer(cm_id->device,\n\t\t\tib_event->param.req_rcvd.port) ==\n\t\t\tIB_LINK_LAYER_ETHERNET));\n\tlisten_id = cm_id->context;\n\tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n\t\treturn -EINVAL;\n\tif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\n\t\treturn -ECONNABORTED;\n\tmemset(&event, 0, sizeof event);\n\toffset = cma_user_data_offset(listen_id);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\n\t\tconn_id = cma_new_udp_id(&listen_id->id, ib_event);\n\t\tevent.param.ud.private_data = ib_event->private_data + offset;\n\t\tevent.param.ud.private_data_len =\n\t\t\t\tIB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset;\n\t} else {\n\t\tconn_id = cma_new_conn_id(&listen_id->id, ib_event);\n\t\tcma_set_req_event_data(&event, &ib_event->param.req_rcvd,\n\t\t\t\t       ib_event->private_data, offset);\n\t}\n\tif (!conn_id) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\n\tret = cma_acquire_dev(conn_id, listen_id);\n\tif (ret)\n\t\tgoto err2;\n\tconn_id->cm_id.ib = cm_id;\n\tcm_id->context = conn_id;\n\tcm_id->cm_handler = cma_ib_handler;\n\t/*\n\t * Protect against the user destroying conn_id from another thread\n\t * until we're done accessing it.\n\t */\n\tatomic_inc(&conn_id->refcount);\n\tret = conn_id->id.event_handler(&conn_id->id, &event);\n\tif (ret)\n\t\tgoto err3;\n\tif (is_iboe) {\n\t\tif (ib_event->param.req_rcvd.primary_path != NULL)\n\t\t\trdma_addr_find_smac_by_sgid(\n\t\t\t\t&ib_event->param.req_rcvd.primary_path->sgid,\n\t\t\t\tpsmac, NULL);\n\t\telse\n\t\t\tpsmac = NULL;\n\t\tif (ib_event->param.req_rcvd.alternate_path != NULL)\n\t\t\trdma_addr_find_smac_by_sgid(\n\t\t\t\t&ib_event->param.req_rcvd.alternate_path->sgid,\n\t\t\t\tpalt_smac, NULL);\n\t\telse\n\t\t\tpalt_smac = NULL;\n\t}\n\t/*\n\t * Acquire mutex to prevent user executing rdma_destroy_id()\n\t * while we're accessing the cm_id.\n\t */\n\tmutex_lock(&lock);\n\tif (is_iboe)\n\t\tib_update_cm_av(cm_id, psmac, palt_smac);\n\tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n\t    (conn_id->id.qp_type != IB_QPT_UD))\n\t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\n\tmutex_unlock(&lock);\n\tmutex_unlock(&conn_id->handler_mutex);\n\tmutex_unlock(&listen_id->handler_mutex);\n\tcma_deref_id(conn_id);\n\treturn 0;\nerr3:\n\tcma_deref_id(conn_id);\n\t/* Destroy the CM ID by returning a non-zero value. */\n\tconn_id->cm_id.ib = NULL;\nerr2:\n\tcma_exch(conn_id, RDMA_CM_DESTROYING);\n\tmutex_unlock(&conn_id->handler_mutex);\nerr1:\n\tmutex_unlock(&listen_id->handler_mutex);\n\tif (conn_id)\n\t\trdma_destroy_id(&conn_id->id);\n\treturn ret;\n}",
        "bug_line_number": [
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            51,
            52,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            70,
            71
        ],
        "vul": 1,
        "id": 14
    },
    {
        "code": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();\n\t/* Make sure the transaction is marked as failed */\n\tcurrent->thread.tm_texasr |= TEXASR_FS;\n\t/* This loads the checkpointed FP/VEC state, if used */\n\ttm_recheckpoint(&current->thread, msr);\n\t/* Get the top half of the MSR */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\t/* Pull in MSR TM from user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | ((msr_hi<<32) & MSR_TS_MASK);",
        "bug_line_number": [
            92,
            93,
            102,
            103,
            104,
            105,
            106
        ],
        "vul": 1,
        "id": 16
    },
    {
        "code": "static inline int nvme_reset_subsystem(struct nvme_ctrl *ctrl)\n{\n\tif (!ctrl->subsystem)\n\t\treturn -ENOTTY;\n\treturn ctrl->ops->reg_write32(ctrl, NVME_REG_NSSR, 0x4E564D65);\n}",
        "bug_line_number": [
            1,
            2,
            4,
            5
        ],
        "vul": 1,
        "id": 18
    },
    {
        "code": "\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = 0;\n\t\tkvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\t\tr = -EINVAL;",
        "bug_line_number": [
            5,
            6,
            7
        ],
        "vul": 1,
        "id": 20
    },
    {
        "code": "void kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\tif (vapic_addr)\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\telse\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n}",
        "bug_line_number": [
            0,
            1,
            2,
            3,
            4,
            5,
            6,
            7
        ],
        "vul": 1,
        "id": 22
    },
    {
        "code": "static int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\tr = vapic_enter(vcpu);\n\tif (r) {\n\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\treturn r;\n\t}\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\t\tkvm_check_async_pf_completion(vcpu);\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\tvapic_exit(vcpu);\n\treturn r;\n}",
        "bug_line_number": [
            5,
            6,
            7,
            8,
            9,
            60
        ],
        "vul": 1,
        "id": 24
    },
    {
        "code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn true;\n}",
        "bug_line_number": [
            3,
            4
        ],
        "vul": 1,
        "id": 26
    },
    {
        "code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt = (struct rt6_info *)dst;\n\tif (!dst)\n\t\tgoto out;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}",
        "bug_line_number": [
            5,
            6,
            7,
            8
        ],
        "vul": 1,
        "id": 28
    },
    {
        "code": "static void aead_release(void *private)\n{\n\tstruct aead_tfm *tfm = private;\n\tcrypto_free_aead(tfm->aead);\n\tkfree(tfm);\n}",
        "bug_line_number": [
            3,
            4
        ],
        "vul": 1,
        "id": 30
    },
    {
        "code": "static int kvm_create_vm_debugfs(struct kvm *kvm, int fd)\n{\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\tstruct kvm_stat_data *stat_data;\n\tstruct kvm_stats_debugfs_item *p;\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\tsnprintf(dir_name, sizeof(dir_name), \"%d-%d\", task_pid_nr(current), fd);\n\tkvm->debugfs_dentry = debugfs_create_dir(dir_name, kvm_debugfs_dir);\n\tkvm->debugfs_stat_data = kcalloc(kvm_debugfs_num_entries,\n\t\t\t\t\t sizeof(*kvm->debugfs_stat_data),\n\t\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!kvm->debugfs_stat_data)\n\t\treturn -ENOMEM;\n\tfor (p = debugfs_entries; p->name; p++) {\n\t\tstat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);\n\t\tif (!stat_data)\n\t\t\treturn -ENOMEM;\n\t\tstat_data->kvm = kvm;\n\t\tstat_data->offset = p->offset;\n\t\tkvm->debugfs_stat_data[p - debugfs_entries] = stat_data;\n\t\tdebugfs_create_file(p->name, 0644, kvm->debugfs_dentry,\n\t\t\t\t    stat_data, stat_fops_per_vm[p->kind]);\n\t}\n\treturn 0;\n}",
        "bug_line_number": [
            19,
            20,
            21,
            22
        ],
        "vul": 1,
        "id": 32
    },
    {
        "code": "static void sctp_v4_from_addr_param(union sctp_addr *addr,\n\t\t\t\t    union sctp_addr_param *param,\n\t\t\t\t    __be16 port, int iif)\n{\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_port = port;\n\taddr->v4.sin_addr.s_addr = param->v4.addr.s_addr;\n\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n}",
        "bug_line_number": [
            0,
            1,
            3,
            4,
            7,
            8
        ],
        "vul": 1,
        "id": 34
    },
    {
        "code": "static struct sctp_association *__sctp_rcv_asconf_lookup(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_chunkhdr *ch,\n\t\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\t\t__be16 peer_port,\n\t\t\t\t\tstruct sctp_transport **transportp)\n{\n\tstruct sctp_addip_chunk *asconf = (struct sctp_addip_chunk *)ch;\n\tstruct sctp_af *af;\n\tunion sctp_addr_param *param;\n\tunion sctp_addr paddr;\n\t/* Skip over the ADDIP header and find the Address parameter */\n\tparam = (union sctp_addr_param *)(asconf + 1);\n\taf = sctp_get_af_specific(param_type2af(param->p.type));\n\tif (unlikely(!af))\n\t\treturn NULL;\n\taf->from_addr_param(&paddr, param, peer_port, 0);\n\treturn __sctp_lookup_association(net, laddr, &paddr, transportp);\n}",
        "bug_line_number": [
            16,
            17
        ],
        "vul": 1,
        "id": 36
    },
    {
        "code": "static int i40e_vc_config_queues_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vsi_queue_config_info *qci =\n\t    (struct virtchnl_vsi_queue_config_info *)msg;\n\tstruct virtchnl_queue_pair_info *qpi;\n\tstruct i40e_pf *pf = vf->pf;\n\tu16 vsi_id, vsi_queue_id = 0;\n\tu16 num_qps_all = 0;\n\ti40e_status aq_ret = 0;\n\tint i, j = 0, idx = 0;\n\tif (!test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states)) {\n\t\taq_ret = I40E_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\tif (!i40e_vc_isvalid_vsi_id(vf, qci->vsi_id)) {\n\t\taq_ret = I40E_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\tif (qci->num_queue_pairs > I40E_MAX_VF_QUEUES) {\n\t\taq_ret = I40E_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\tif (vf->adq_enabled) {\n\t\tfor (i = 0; i < I40E_MAX_VF_VSI; i++)\n\t\t\tnum_qps_all += vf->ch[i].num_qps;\n\t\tif (num_qps_all != qci->num_queue_pairs) {\n\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\t}\n\tvsi_id = qci->vsi_id;\n\tfor (i = 0; i < qci->num_queue_pairs; i++) {\n\t\tqpi = &qci->qpair[i];\n\t\tif (!vf->adq_enabled) {\n\t\t\tif (!i40e_vc_isvalid_queue_id(vf, vsi_id,\n\t\t\t\t\t\t      qpi->txq.queue_id)) {\n\t\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t\tvsi_queue_id = qpi->txq.queue_id;\n\t\t\tif (qpi->txq.vsi_id != qci->vsi_id ||\n\t\t\t    qpi->rxq.vsi_id != qci->vsi_id ||\n\t\t\t    qpi->rxq.queue_id != vsi_queue_id) {\n\t\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\t\tif (vf->adq_enabled)\n\t\t\tvsi_id = vf->ch[idx].vsi_id;\n\t\tif (i40e_config_vsi_rx_queue(vf, vsi_id, vsi_queue_id,\n\t\t\t\t\t     &qpi->rxq) ||\n\t\t    i40e_config_vsi_tx_queue(vf, vsi_id, vsi_queue_id,\n\t\t\t\t\t     &qpi->txq)) {\n\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\t\t/* For ADq there can be up to 4 VSIs with max 4 queues each.\n\t\t * VF does not know about these additional VSIs and all\n\t\t * it cares is about its own queues. PF configures these queues\n\t\t * to its appropriate VSIs based on TC mapping\n\t\t **/\n\t\tif (vf->adq_enabled) {\n\t\t\tif (j == (vf->ch[idx].num_qps - 1)) {\n\t\t\t\tidx++;\n\t\t\t\tj = 0; /* resetting the queue count */\n\t\t\t\tvsi_queue_id = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t\tvsi_queue_id++;\n\t\t\t}\n\t\t}\n\t}\n\t/* set vsi num_queue_pairs in use to num configured by VF */\n\tif (!vf->adq_enabled) {\n\t\tpf->vsi[vf->lan_vsi_idx]->num_queue_pairs =\n\t\t\tqci->num_queue_pairs;\n\t} else {\n\t\tfor (i = 0; i < vf->num_tc; i++)\n\t\t\tpf->vsi[vf->ch[i].vsi_idx]->num_queue_pairs =\n\t\t\t       vf->ch[i].num_qps;\n\t}\nerror_param:\n\t/* send the response to the VF */\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,\n\t\t\t\t       aq_ret);\n}",
        "bug_line_number": [
            47,
            48,
            49,
            61,
            62
        ],
        "vul": 1,
        "id": 38
    },
    {
        "code": "SYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,\n\t\tu32, min_complete, u32, flags, const sigset_t __user *, sig,\n\t\tsize_t, sigsz)\n{\n\tstruct io_ring_ctx *ctx;\n\tlong ret = -EBADF;\n\tint submitted = 0;\n\tstruct fd f;\n\tio_run_task_work();\n\tif (flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP))\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -EOPNOTSUPP;\n\tif (f.file->f_op != &io_uring_fops)\n\t\tgoto out_fput;\n\tret = -ENXIO;\n\tctx = f.file->private_data;\n\tif (!percpu_ref_tryget(&ctx->refs))\n\t\tgoto out_fput;\n\t/*\n\t * For SQ polling, the thread will do all submissions and completions.\n\t * Just return the requested submit count, and wake the thread if\n\t * we were asked to.\n\t */\n\tret = 0;\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tif (!list_empty_careful(&ctx->cq_overflow_list))\n\t\t\tio_cqring_overflow_flush(ctx, false, NULL, NULL);\n\t\tif (flags & IORING_ENTER_SQ_WAKEUP)\n\t\t\twake_up(&ctx->sqo_wait);\n\t\tsubmitted = to_submit;\n\t} else if (to_submit) {\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tsubmitted = io_submit_sqes(ctx, to_submit, f.file, fd);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\tif (submitted != to_submit)\n\t\t\tgoto out;\n\t}\n\tif (flags & IORING_ENTER_GETEVENTS) {\n\t\tmin_complete = min(min_complete, ctx->cq_entries);\n\t\t/*\n\t\t * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user\n\t\t * space applications don't need to do io completion events\n\t\t * polling again, they can rely on io_sq_thread to do polling\n\t\t * work, which can reduce cpu usage and uring_lock contention.\n\t\t */\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL &&\n\t\t    !(ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\t\tret = io_iopoll_check(ctx, min_complete);\n\t\t} else {\n\t\t\tret = io_cqring_wait(ctx, min_complete, sig, sigsz);\n\t\t}\n\t}\nout:\n\tpercpu_ref_put(&ctx->refs);\nout_fput:\n\tfdput(f);\n\treturn submitted ? submitted : ret;\n}",
        "bug_line_number": [
            33,
            34,
            35,
            36
        ],
        "vul": 1,
        "id": 40
    },
    {
        "code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}",
        "bug_line_number": [
            5,
            6
        ],
        "vul": 1,
        "id": 42
    },
    {
        "code": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "bug_line_number": [
            6,
            7
        ],
        "vul": 1,
        "id": 44
    },
    {
        "code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}",
        "bug_line_number": [
            3,
            4
        ],
        "vul": 1,
        "id": 46
    },
    {
        "code": "static int hid_parser_global(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 raw_value;\n\tswitch (item->tag) {\n\tcase HID_GLOBAL_ITEM_TAG_PUSH:\n\t\tif (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {\n\t\t\thid_err(parser->device, \"global environment stack overflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(parser->global_stack + parser->global_stack_ptr++,\n\t\t\t&parser->global, sizeof(struct hid_global));\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_POP:\n\t\tif (!parser->global_stack_ptr) {\n\t\t\thid_err(parser->device, \"global environment stack underflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(&parser->global, parser->global_stack +\n\t\t\t--parser->global_stack_ptr, sizeof(struct hid_global));\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_USAGE_PAGE:\n\t\tparser->global.usage_page = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:\n\t\tparser->global.logical_minimum = item_sdata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:\n\t\tif (parser->global.logical_minimum < 0)\n\t\t\tparser->global.logical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.logical_maximum = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:\n\t\tparser->global.physical_minimum = item_sdata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:\n\t\tif (parser->global.physical_minimum < 0)\n\t\t\tparser->global.physical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.physical_maximum = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:\n\t\t/* Units exponent negative numbers are given through a\n\t\t * two's complement.\n\t\t * See \"6.2.2.7 Global Items\" for more information. */\n\t\traw_value = item_udata(item);\n\t\tif (!(raw_value & 0xfffffff0))\n\t\t\tparser->global.unit_exponent = hid_snto32(raw_value, 4);\n\t\telse\n\t\t\tparser->global.unit_exponent = raw_value;\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_UNIT:\n\t\tparser->global.unit = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_SIZE:\n\t\tparser->global.report_size = item_udata(item);\n\t\tif (parser->global.report_size > 128) {\n\t\t\thid_err(parser->device, \"invalid report_size %d\\n\",\n\t\t\t\t\tparser->global.report_size);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_COUNT:\n\t\tparser->global.report_count = item_udata(item);\n\t\tif (parser->global.report_count > HID_MAX_USAGES) {\n\t\t\thid_err(parser->device, \"invalid report_count %d\\n\",\n\t\t\t\t\tparser->global.report_count);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_ID:\n\t\tparser->global.report_id = item_udata(item);\n\t\tif (parser->global.report_id == 0) {\n\t\t\thid_err(parser->device, \"report_id 0 is invalid\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\thid_err(parser->device, \"unknown global tag 0x%x\\n\", item->tag);\n\t\treturn -1;\n\t}\n}",
        "bug_line_number": [
            72,
            73,
            74
        ],
        "vul": 1,
        "id": 48
    },
    {
        "code": "static void hid_close_report(struct hid_device *device)\n{\n\tunsigned i, j;\n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = device->report_enum + i;\n\t\tfor (j = 0; j < 256; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\t\t\tif (report)\n\t\t\t\thid_free_report(report);\n\t\t}\n\t\tmemset(report_enum, 0, sizeof(*report_enum));\n\t\tINIT_LIST_HEAD(&report_enum->report_list);\n\t}\n\tkfree(device->rdesc);\n\tdevice->rdesc = NULL;\n\tdevice->rsize = 0;\n\tkfree(device->collection);\n\tdevice->collection = NULL;\n\tdevice->collection_size = 0;\n\tdevice->maxcollection = 0;\n\tdevice->maxapplication = 0;\n\tdevice->status &= ~HID_STAT_PARSED;\n}",
        "bug_line_number": [
            5,
            6
        ],
        "vul": 1,
        "id": 50
    },
    {
        "code": "static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "bug_line_number": [
            10,
            11,
            33,
            34
        ],
        "vul": 1,
        "id": 52
    },
    {
        "code": "int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tbool slow;\n\t/*\n\t *\tCheck any passed addresses\n\t */\n\tif (addr_len)\n\t\t*addr_len = sizeof(*sin);\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len);\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),\n\t\t\t\t\t      msg->msg_iov, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb,\n\t\t\t\t\t\t       sizeof(struct udphdr),\n\t\t\t\t\t\t       msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\tif (noblock)\n\t\treturn -EAGAIN;\n\t/* starting over for a new packet */\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}",
        "bug_line_number": [
            11,
            12,
            13,
            14,
            15,
            66,
            67
        ],
        "vul": 1,
        "id": 54
    },
    {
        "code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\t/* Our ID is an index into the kvm_regs struct. */\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}",
        "bug_line_number": [
            13,
            14
        ],
        "vul": 1,
        "id": 56
    },
    {
        "code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\t/* do checkpoint to issue discard commands safely */\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t/* It's time to issue all the filed discards */\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}",
        "bug_line_number": [
            44,
            45
        ],
        "vul": 1,
        "id": 58
    },
    {
        "code": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t: : \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\tasm volatile(xstate_fault\n\t\t     : \"0\" (0)\n\t\t     : \"memory\");\n\treturn err;\n}",
        "bug_line_number": [
            9,
            10,
            14,
            15,
            16,
            17,
            18
        ],
        "vul": 1,
        "id": 60
    },
    {
        "code": "static int lme2510_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tstruct lme2510_state *st = d->priv;\n\tusb_reset_configuration(d->udev);\n\tusb_set_interface(d->udev,\n\t\td->props->bInterfaceNumber, 1);\n\tst->dvb_usb_lme2510_firmware = dvb_usb_lme2510_firmware;\n\tif (lme2510_return_status(d) == 0x44) {\n\t\t*name = lme_firmware_switch(d, 0);\n\t\treturn COLD;\n\t}\n\treturn 0;\n}",
        "bug_line_number": [
            2,
            3,
            7,
            8,
            11,
            12
        ],
        "vul": 1,
        "id": 62
    },
    {
        "code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "bug_line_number": [
            8,
            9
        ],
        "vul": 1,
        "id": 64
    },
    {
        "code": "static int FNAME(walk_addr_generic)(struct guest_walker *walker,\n\t\t\t\t    struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t    gva_t addr, u32 access)\n{\n\tpt_element_t pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tunsigned index, pt_access, uninitialized_var(pte_access);\n\tgpa_t pte_gpa;\n\tbool eperm, present, rsvd_fault;\n\tint offset, write_fault, user_fault, fetch_fault;\n\twrite_fault = access & PFERR_WRITE_MASK;\n\tuser_fault = access & PFERR_USER_MASK;\n\tfetch_fault = access & PFERR_FETCH_MASK;\n\ttrace_kvm_mmu_pagetable_walk(addr, write_fault, user_fault,\n\t\t\t\t     fetch_fault);\nwalk:\n\tpresent = true;\n\teperm = rsvd_fault = false;\n\twalker->level = mmu->root_level;\n\tpte           = mmu->get_cr3(vcpu);\n#if PTTYPE == 64\n\tif (walker->level == PT32E_ROOT_LEVEL) {\n\t\tpte = kvm_pdptr_read_mmu(vcpu, mmu, (addr >> 30) & 3);\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (!is_present_gpte(pte)) {\n\t\t\tpresent = false;\n\t\t\tgoto error;\n\t\t}\n\t\t--walker->level;\n\t}\n#endif\n\tASSERT((!is_long_mode(vcpu) && is_pae(vcpu)) ||\n\t       (mmu->get_cr3(vcpu) & CR3_NONPAE_RESERVED_BITS) == 0);\n\tpt_access = ACC_ALL;\n\tfor (;;) {\n\t\tgfn_t real_gfn;\n\t\tunsigned long host_addr;\n\t\tindex = PT_INDEX(addr, walker->level);\n\t\ttable_gfn = gpte_to_gfn(pte);\n\t\toffset    = index * sizeof(pt_element_t);\n\t\tpte_gpa   = gfn_to_gpa(table_gfn) + offset;\n\t\twalker->table_gfn[walker->level - 1] = table_gfn;\n\t\twalker->pte_gpa[walker->level - 1] = pte_gpa;\n\t\treal_gfn = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),\n\t\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\t\tif (unlikely(real_gfn == UNMAPPED_GVA)) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\treal_gfn = gpa_to_gfn(real_gfn);\n\t\thost_addr = gfn_to_hva(vcpu->kvm, real_gfn);\n\t\tif (unlikely(kvm_is_error_hva(host_addr))) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n\t\tif (unlikely(copy_from_user(&pte, ptep_user, sizeof(pte)))) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (unlikely(!is_present_gpte(pte))) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(is_rsvd_bits_set(&vcpu->arch.mmu, pte,\n\t\t\t\t\t      walker->level))) {\n\t\t\trsvd_fault = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(write_fault && !is_writable_pte(pte)\n\t\t\t     && (user_fault || is_write_protection(vcpu))))\n\t\t\teperm = true;\n\t\tif (unlikely(user_fault && !(pte & PT_USER_MASK)))\n\t\t\teperm = true;\n#if PTTYPE == 64\n\t\tif (unlikely(fetch_fault && (pte & PT64_NX_MASK)))\n\t\t\teperm = true;\n#endif\n\t\tif (!eperm && !rsvd_fault\n\t\t    && unlikely(!(pte & PT_ACCESSED_MASK))) {\n\t\t\tint ret;\n\t\t\ttrace_kvm_mmu_set_accessed_bit(table_gfn, index,\n\t\t\t\t\t\t       sizeof(pte));\n\t\t\tret = FNAME(cmpxchg_gpte)(vcpu, mmu, table_gfn,\n\t\t\t\t\tindex, pte, pte|PT_ACCESSED_MASK);\n\t\t\tif (ret < 0) {\n\t\t\t\tpresent = false;\n\t\t\t\tbreak;\n\t\t\t} else if (ret)\n\t\t\t\tgoto walk;\n\t\t\tmark_page_dirty(vcpu->kvm, table_gfn);\n\t\t\tpte |= PT_ACCESSED_MASK;\n\t\t}\n\t\tpte_access = pt_access & FNAME(gpte_access)(vcpu, pte);\n\t\twalker->ptes[walker->level - 1] = pte;\n\t\tif ((walker->level == PT_PAGE_TABLE_LEVEL) ||\n\t\t    ((walker->level == PT_DIRECTORY_LEVEL) &&",
        "bug_line_number": [
            57,
            58
        ],
        "vul": 1,
        "id": 66
    },
    {
        "code": "int intel_uc_fw_fetch(struct intel_uc_fw *uc_fw)\n{\n\tstruct drm_i915_private *i915 = __uc_fw_to_gt(uc_fw)->i915;\n\tstruct device *dev = i915->drm.dev;\n\tstruct drm_i915_gem_object *obj;\n\tconst struct firmware *fw = NULL;\n\tstruct uc_css_header *css;\n\tsize_t size;\n\tint err;\n\tGEM_BUG_ON(!i915->wopcm.size);\n\tGEM_BUG_ON(!intel_uc_fw_is_enabled(uc_fw));\n\terr = i915_inject_probe_error(i915, -ENXIO);\n\tif (err)\n\t\tgoto fail;\n\t__force_fw_fetch_failures(uc_fw, -EINVAL);\n\t__force_fw_fetch_failures(uc_fw, -ESTALE);\n\terr = request_firmware(&fw, uc_fw->path, dev);\n\tif (err)\n\t\tgoto fail;\n\t/* Check the size of the blob before examining buffer contents */\n\tif (unlikely(fw->size < sizeof(struct uc_css_header))) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: invalid size: %zu < %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t fw->size, sizeof(struct uc_css_header));\n\t\terr = -ENODATA;\n\t\tgoto fail;\n\t}\n\tcss = (struct uc_css_header *)fw->data;\n\t/* Check integrity of size values inside CSS header */\n\tsize = (css->header_size_dw - css->key_size_dw - css->modulus_size_dw -\n\t\tcss->exponent_size_dw) * sizeof(u32);\n\tif (unlikely(size != sizeof(struct uc_css_header))) {\n\t\tdrm_warn(&i915->drm,\n\t\t\t \"%s firmware %s: unexpected header size: %zu != %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t fw->size, sizeof(struct uc_css_header));\n\t\terr = -EPROTO;\n\t\tgoto fail;\n\t}\n\t/* uCode size must calculated from other sizes */\n\tuc_fw->ucode_size = (css->size_dw - css->header_size_dw) * sizeof(u32);\n\t/* now RSA */\n\tif (unlikely(css->key_size_dw != UOS_RSA_SCRATCH_COUNT)) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: unexpected key size: %u != %u\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t css->key_size_dw, UOS_RSA_SCRATCH_COUNT);\n\t\terr = -EPROTO;\n\t\tgoto fail;\n\t}\n\tuc_fw->rsa_size = css->key_size_dw * sizeof(u32);\n\t/* At least, it should have header, uCode and RSA. Size of all three. */\n\tsize = sizeof(struct uc_css_header) + uc_fw->ucode_size + uc_fw->rsa_size;\n\tif (unlikely(fw->size < size)) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: invalid size: %zu < %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t fw->size, size);\n\t\terr = -ENOEXEC;\n\t\tgoto fail;\n\t}\n\t/* Sanity check whether this fw is not larger than whole WOPCM memory */\n\tsize = __intel_uc_fw_get_upload_size(uc_fw);\n\tif (unlikely(size >= i915->wopcm.size)) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: invalid size: %zu > %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t size, (size_t)i915->wopcm.size);\n\t\terr = -E2BIG;\n\t\tgoto fail;\n\t}\n\t/* Get version numbers from the CSS header */\n\tuc_fw->major_ver_found = FIELD_GET(CSS_SW_VERSION_UC_MAJOR,\n\t\t\t\t\t   css->sw_version);\n\tuc_fw->minor_ver_found = FIELD_GET(CSS_SW_VERSION_UC_MINOR,\n\t\t\t\t\t   css->sw_version);\n\tif (uc_fw->major_ver_found != uc_fw->major_ver_wanted ||\n\t    uc_fw->minor_ver_found < uc_fw->minor_ver_wanted) {\n\t\tdrm_notice(&i915->drm, \"%s firmware %s: unexpected version: %u.%u != %u.%u\\n\",\n\t\t\t   intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t   uc_fw->major_ver_found, uc_fw->minor_ver_found,\n\t\t\t   uc_fw->major_ver_wanted, uc_fw->minor_ver_wanted);\n\t\tif (!intel_uc_fw_is_overridden(uc_fw)) {\n\t\t\terr = -ENOEXEC;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tobj = i915_gem_object_create_shmem_from_data(i915, fw->data, fw->size);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto fail;\n\t}\n\tuc_fw->obj = obj;\n\tuc_fw->size = fw->size;\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_AVAILABLE);\n\trelease_firmware(fw);\n\treturn 0;\nfail:\n\tintel_uc_fw_change_status(uc_fw, err == -ENOENT ?\n\t\t\t\t  INTEL_UC_FIRMWARE_MISSING :\n\t\t\t\t  INTEL_UC_FIRMWARE_ERROR);\n\tdrm_notice(&i915->drm, \"%s firmware %s: fetch failed with error %d\\n\",\n\t\t   intel_uc_fw_type_repr(uc_fw->type), uc_fw->path, err);\n\tdrm_info(&i915->drm, \"%s firmware(s) can be downloaded from %s\\n\",\n\t\t intel_uc_fw_type_repr(uc_fw->type), INTEL_UC_FIRMWARE_URL);",
        "bug_line_number": [
            83,
            84
        ],
        "vul": 1,
        "id": 68
    },
    {
        "code": "static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tstruct aac_srb_reply* reply;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[32];\n\tvoid *sg_list[32];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t/*\n\t *\tAllocate and initialize a Fib then setup a SRB command\n\t */\n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\taac_fib_init(srbfib);\n\t/* raw_srb FIB is not FastResponseCapable */\n\tsrbfib->hw_fib_va->header.XferState &= ~cpu_to_le32(FastResponseCapable);\n\tsrbcmd = (struct aac_srb*) fib_data(srbfib);\n\tmemset(sg_list, 0, sizeof(sg_list)); /* cleanup may take issue */\n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\tif (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr))) {\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\n\tif (!user_srbcmd) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not make a copy of the srb\\n\"));\n\t\trcode = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tif(copy_from_user(user_srbcmd, user_srb,fibsize)){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy srb from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\tuser_reply = arg+fibsize;\n\tflags = user_srbcmd->flags; /* from user in cpu order */\n\t// Fix up srb for endian and force some values\n\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\t// Force this\n\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\tsrbcmd->flags\t = cpu_to_le32(flags);\n\tsrbcmd->retry_limit = 0; // Obsolete parameter\n\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t  le32_to_cpu(srbcmd->sg.count)));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t/* User made a mistake - should not continue */\n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid: SG with no direction specified in Raw SRB command\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}",
        "bug_line_number": [
            43,
            44
        ],
        "vul": 1,
        "id": 70
    },
    {
        "code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tspin_lock_init(&mm->context.list_lock);\n\tINIT_LIST_HEAD(&mm->context.pgtable_list);\n\tINIT_LIST_HEAD(&mm->context.gmap_list);\n\treturn (pgd_t *) crst_table_alloc(mm);\n}",
        "bug_line_number": [
            2,
            3,
            4,
            5,
            6
        ],
        "vul": 1,
        "id": 72
    },
    {
        "code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\t\t\tASSERT(redir_index < IOAPIC_NUM_PINS);\n\t\t\tredir_content = ioapic->redirtbl[redir_index].bits;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}",
        "bug_line_number": [
            18,
            19
        ],
        "vul": 1,
        "id": 74
    },
    {
        "code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}",
        "bug_line_number": [
            6,
            7
        ],
        "vul": 1,
        "id": 76
    },
    {
        "code": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}",
        "bug_line_number": [
            3,
            4,
            11,
            12
        ],
        "vul": 1,
        "id": 78
    },
    {
        "code": "struct sctp_packet *sctp_packet_config(struct sctp_packet *packet,\n\t\t\t\t       __u32 vtag, int ecn_capable)\n{\n\tstruct sctp_chunk *chunk = NULL;\n\tSCTP_DEBUG_PRINTK(\"%s: packet:%p vtag:0x%x\\n\", __func__,\n\t\t\t  packet, vtag);\n\tsctp_packet_reset(packet);\n\tpacket->vtag = vtag;\n\tif (ecn_capable && sctp_packet_empty(packet)) {\n\t\tchunk = sctp_get_ecne_prepend(packet->transport->asoc);\n\t\t/* If there a is a prepend chunk stick it on the list before\n\t\t * any other chunks get appended.\n\t\t */\n\t\tif (chunk)\n\t\t\tsctp_packet_append_chunk(packet, chunk);\n\t}\n\treturn packet;\n}",
        "bug_line_number": [
            6
        ],
        "vul": 1,
        "id": 80
    },
    {
        "code": "struct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,\n\t\t\t\t    struct nlattr *est, char *name, int ovr,\n\t\t\t\t    int bind)\n{\n\tstruct tc_action *a;\n\tstruct tc_action_ops *a_o;\n\tchar act_name[IFNAMSIZ];\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\tstruct nlattr *kind;\n\tint err;\n\tif (name == NULL) {\n\t\terr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t\terr = -EINVAL;\n\t\tkind = tb[TCA_ACT_KIND];\n\t\tif (kind == NULL)\n\t\t\tgoto err_out;\n\t\tif (nla_strlcpy(act_name, kind, IFNAMSIZ) >= IFNAMSIZ)\n\t\t\tgoto err_out;\n\t} else {\n\t\terr = -EINVAL;\n\t\tif (strlcpy(act_name, name, IFNAMSIZ) >= IFNAMSIZ)\n\t\t\tgoto err_out;\n\t}\n\ta_o = tc_lookup_action_n(act_name);\n\tif (a_o == NULL) {\n#ifdef CONFIG_MODULES\n\t\trtnl_unlock();\n\t\trequest_module(\"act_%s\", act_name);\n\t\trtnl_lock();\n\t\ta_o = tc_lookup_action_n(act_name);\n\t\t/* We dropped the RTNL semaphore in order to\n\t\t * perform the module load.  So, even if we\n\t\t * succeeded in loading the module we have to\n\t\t * tell the caller to replay the request.  We\n\t\t * indicate this using -EAGAIN.\n\t\t */\n\t\tif (a_o != NULL) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto err_mod;\n\t\t}\n#endif\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\t/* backward compatibility for policer */\n\tif (name == NULL)\n\t\terr = a_o->init(net, tb[TCA_ACT_OPTIONS], est, &a, ovr, bind);\n\telse\n\t\terr = a_o->init(net, nla, est, &a, ovr, bind);\n\tif (err < 0)\n\t\tgoto err_mod;\n\tif (tb[TCA_ACT_COOKIE]) {\n\t\tint cklen = nla_len(tb[TCA_ACT_COOKIE]);\n\t\tif (cklen > TC_COOKIE_MAX_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\ttcf_hash_release(a, bind);\n\t\t\tgoto err_mod;\n\t\t}\n\t\tif (nla_memdup_cookie(a, tb) < 0) {\n\t\t\terr = -ENOMEM;\n\t\t\ttcf_hash_release(a, bind);\n\t\t\tgoto err_mod;\n\t\t}\n\t}\n\t/* module count goes up only when brand new policy is created\n\t * if it exists and is only bound to in a_o->init() then\n\t * ACT_P_CREATED is not returned (a zero is).\n\t */\n\tif (err != ACT_P_CREATED)\n\t\tmodule_put(a_o->owner);\n\treturn a;\nerr_mod:\n\tmodule_put(a_o->owner);\nerr_out:\n\treturn ERR_PTR(err);\n}",
        "bug_line_number": [
            5,
            6,
            19,
            20,
            53,
            54,
            55,
            56,
            57,
            58,
            59,
            60,
            61,
            62,
            63,
            64,
            65,
            75,
            76
        ],
        "vul": 1,
        "id": 82
    },
    {
        "code": "int\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n{\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n\t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n\tproc = rqstp->rq_procinfo;\n\t/*\n\t * Give the xdr decoder a chance to change this if it wants\n\t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}",
        "bug_line_number": [
            9,
            10
        ],
        "vul": 1,
        "id": 84
    },
    {
        "code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
        "bug_line_number": [
            10,
            11
        ],
        "vul": 1,
        "id": 86
    },
    {
        "code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}",
        "bug_line_number": [
            9,
            10
        ],
        "vul": 1,
        "id": 88
    },
    {
        "code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\tif (!ss_initialized) {\n\t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}",
        "bug_line_number": [
            6,
            7
        ],
        "vul": 1,
        "id": 90
    },
    {
        "code": "struct task_struct * __cpuinit fork_idle(int cpu)\n{\n\tstruct task_struct *task;\n\tstruct pt_regs regs;\n\ttask = copy_process(CLONE_VM, 0, idle_regs(&regs), 0, NULL,\n\t\t\t    &init_struct_pid, 0);\n\tif (!IS_ERR(task)) {\n\t\tinit_idle_pids(task->pids);\n\t\tinit_idle(task, cpu);\n\t}\n\treturn task;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 1
    },
    {
        "code": "COMPAT_SYSCALL_DEFINE5(waitid,\n\t\tint, which, compat_pid_t, pid,\n\t\tstruct compat_siginfo __user *, infop, int, options,\n\t\tstruct compat_rusage __user *, uru)\n{\n\tstruct rusage ru;\n\tstruct waitid_info info = {.status = 0};\n\tlong err = kernel_waitid(which, pid, &info, options, uru ? &ru : NULL);\n\tint signo = 0;\n\tif (err > 0) {\n\t\tsigno = SIGCHLD;\n\t\terr = 0;\n\t\tif (uru) {\n\t\t\t/* kernel_waitid() overwrites everything in ru */\n\t\t\tif (COMPAT_USE_64BIT_TIME)\n\t\t\t\terr = copy_to_user(uru, &ru, sizeof(ru));\n\t\t\telse\n\t\t\t\terr = put_compat_rusage(&ru, uru);\n\t\t\tif (err)\n\t\t\t\treturn -EFAULT;\n\t\t}\n\t}\n\tif (!infop)\n\t\treturn err;\n\tif (!user_access_begin(infop, sizeof(*infop)))\n\t\treturn -EFAULT;\n\tunsafe_put_user(signo, &infop->si_signo, Efault);\n\tunsafe_put_user(0, &infop->si_errno, Efault);\n\tunsafe_put_user(info.cause, &infop->si_code, Efault);\n\tunsafe_put_user(info.pid, &infop->si_pid, Efault);\n\tunsafe_put_user(info.uid, &infop->si_uid, Efault);\n\tunsafe_put_user(info.status, &infop->si_status, Efault);\n\tuser_access_end();\n\treturn err;\nEfault:\n\tuser_access_end();\n\treturn -EFAULT;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 3
    },
    {
        "code": "long strncpy_from_user(char *dst, const char __user *src, long count)\n{\n\tunsigned long max_addr, src_addr;\n\tif (unlikely(count <= 0))\n\t\treturn 0;\n\tmax_addr = user_addr_max();\n\tsrc_addr = (unsigned long)src;\n\tif (likely(src_addr < max_addr)) {\n\t\tunsigned long max = max_addr - src_addr;\n\t\tlong retval;\n\t\tkasan_check_write(dst, count);\n\t\tcheck_object_size(dst, count, false);\n\t\tif (user_access_begin(src, max)) {\n\t\t\tretval = do_strncpy_from_user(dst, src, count, max);\n\t\t\tuser_access_end();\n\t\t\treturn retval;\n\t\t}\n\t}\n\treturn -EFAULT;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 5
    },
    {
        "code": "int verify_iovec(struct msghdr *m, struct iovec *iov, struct sockaddr_storage *address, int mode)\n{\n\tint size, ct, err;\n\tif (m->msg_namelen) {\n\t\tif (mode == VERIFY_READ) {\n\t\t\tvoid __user *namep;\n\t\t\tnamep = (void __user __force *) m->msg_name;\n\t\t\terr = move_addr_to_kernel(namep, m->msg_namelen,\n\t\t\t\t\t\t  address);\n\t\t\tif (err < 0)\n\t\t\t\treturn err;\n\t\t}\n\t\tif (m->msg_name)\n\t\t\tm->msg_name = address;\n\t} else {\n\t\tm->msg_name = NULL;\n\t}\n\tsize = m->msg_iovlen * sizeof(struct iovec);\n\tif (copy_from_user(iov, (void __user __force *) m->msg_iov, size))\n\t\treturn -EFAULT;\n\tm->msg_iov = iov;\n\terr = 0;\n\tfor (ct = 0; ct < m->msg_iovlen; ct++) {\n\t\tsize_t len = iov[ct].iov_len;\n\t\tif (len > INT_MAX - err) {\n\t\t\tlen = INT_MAX - err;\n\t\t\tiov[ct].iov_len = len;\n\t\t}\n\t\terr += len;\n\t}\n\treturn err;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 7
    },
    {
        "code": "int bt_sock_recvmsg(struct kiocb *iocb, struct socket *sock,\n\t\t\t\tstruct msghdr *msg, size_t len, int flags)\n{\n\tint noblock = flags & MSG_DONTWAIT;\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tsize_t copied;\n\tint err;\n\tBT_DBG(\"sock %p sk %p len %zu\", sock, sk, len);\n\tif (flags & (MSG_OOB))\n\t\treturn -EOPNOTSUPP;\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb) {\n\t\tif (sk->sk_shutdown & RCV_SHUTDOWN)\n\t\t\treturn 0;\n\t\treturn err;\n\t}\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\tskb_reset_transport_header(skb);\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err == 0) {\n\t\tsock_recv_ts_and_drops(msg, sk, skb);\n\t\tif (bt_sk(sk)->skb_msg_name)\n\t\t\tbt_sk(sk)->skb_msg_name(skb, msg->msg_name,\n\t\t\t\t\t\t&msg->msg_namelen);\n\t}\n\tskb_free_datagram(sk, skb);\n\treturn err ? : copied;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 9
    },
    {
        "code": "static int ax25_recvmsg(struct kiocb *iocb, struct socket *sock,\n\tstruct msghdr *msg, size_t size, int flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct sk_buff *skb;\n\tint copied;\n\tint err = 0;\n\tlock_sock(sk);\n\t/*\n\t * \tThis works for seqpacket too. The receiver has ordered the\n\t *\tqueue for us! We do one quick check first though\n\t */\n\tif (sk->sk_type == SOCK_SEQPACKET && sk->sk_state != TCP_ESTABLISHED) {\n\t\terr =  -ENOTCONN;\n\t\tgoto out;\n\t}\n\t/* Now we can treat all alike */\n\tskb = skb_recv_datagram(sk, flags & ~MSG_DONTWAIT,\n\t\t\t\tflags & MSG_DONTWAIT, &err);\n\tif (skb == NULL)\n\t\tgoto out;\n\tif (!ax25_sk(sk)->pidincl)\n\t\tskb_pull(skb, 1);\t\t/* Remove PID */\n\tskb_reset_transport_header(skb);\n\tcopied = skb->len;\n\tif (copied > size) {\n\t\tcopied = size;\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t}\n\tskb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (msg->msg_name) {\n\t\tax25_digi digi;\n\t\tax25_address src;\n\t\tconst unsigned char *mac = skb_mac_header(skb);\n\t\tstruct sockaddr_ax25 *sax = msg->msg_name;\n\t\tmemset(sax, 0, sizeof(struct full_sockaddr_ax25));\n\t\tax25_addr_parse(mac + 1, skb->data - mac - 1, &src, NULL,\n\t\t\t\t&digi, NULL, NULL);\n\t\tsax->sax25_family = AF_AX25;\n\t\t/* We set this correctly, even though we may not let the\n\t\t   application know the digi calls further down (because it\n\t\t   did NOT ask to know them).  This could get political... **/\n\t\tsax->sax25_ndigis = digi.ndigi;\n\t\tsax->sax25_call   = src;\n\t\tif (sax->sax25_ndigis != 0) {\n\t\t\tint ct;\n\t\t\tstruct full_sockaddr_ax25 *fsa = (struct full_sockaddr_ax25 *)sax;\n\t\t\tfor (ct = 0; ct < digi.ndigi; ct++)\n\t\t\t\tfsa->fsa_digipeater[ct] = digi.calls[ct];\n\t\t}\n\t\tmsg->msg_namelen = sizeof(struct full_sockaddr_ax25);\n\t}\n\tskb_free_datagram(sk, skb);\n\terr = copied;\nout:\n\trelease_sock(sk);\n\treturn err;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 11
    },
    {
        "code": "int rds_recvmsg(struct kiocb *iocb, struct socket *sock, struct msghdr *msg,\n\t\tsize_t size, int msg_flags)\n{\n\tstruct sock *sk = sock->sk;\n\tstruct rds_sock *rs = rds_sk_to_rs(sk);\n\tlong timeo;\n\tint ret = 0, nonblock = msg_flags & MSG_DONTWAIT;\n\tstruct sockaddr_in *sin;\n\tstruct rds_incoming *inc = NULL;\n\t/* udp_recvmsg()->sock_recvtimeo() gets away without locking too.. */\n\ttimeo = sock_rcvtimeo(sk, nonblock);\n\trdsdebug(\"size %zu flags 0x%x timeo %ld\\n\", size, msg_flags, timeo);\n\tif (msg_flags & MSG_OOB)\n\t\tgoto out;\n\twhile (1) {\n\t\t/* If there are pending notifications, do those - and nothing else */\n\t\tif (!list_empty(&rs->rs_notify_queue)) {\n\t\t\tret = rds_notify_queue_get(rs, msg);\n\t\t\tbreak;\n\t\t}\n\t\tif (rs->rs_cong_notify) {\n\t\t\tret = rds_notify_cong(rs, msg);\n\t\t\tbreak;\n\t\t}\n\t\tif (!rds_next_incoming(rs, &inc)) {\n\t\t\tif (nonblock) {\n\t\t\t\tret = -EAGAIN;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ttimeo = wait_event_interruptible_timeout(*sk_sleep(sk),\n\t\t\t\t\t(!list_empty(&rs->rs_notify_queue) ||\n\t\t\t\t\t rs->rs_cong_notify ||\n\t\t\t\t\t rds_next_incoming(rs, &inc)), timeo);\n\t\t\trdsdebug(\"recvmsg woke inc %p timeo %ld\\n\", inc,\n\t\t\t\t timeo);\n\t\t\tif (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)\n\t\t\t\tcontinue;\n\t\t\tret = timeo;\n\t\t\tif (ret == 0)\n\t\t\t\tret = -ETIMEDOUT;\n\t\t\tbreak;\n\t\t}\n\t\trdsdebug(\"copying inc %p from %pI4:%u to user\\n\", inc,\n\t\t\t &inc->i_conn->c_faddr,\n\t\t\t ntohs(inc->i_hdr.h_sport));\n\t\tret = inc->i_conn->c_trans->inc_copy_to_user(inc, msg->msg_iov,\n\t\t\t\t\t\t\t     size);\n\t\tif (ret < 0)\n\t\t\tbreak;\n\t\t/*\n\t\t * if the message we just copied isn't at the head of the\n\t\t * recv queue then someone else raced us to return it, try\n\t\t * to get the next message.\n\t\t */\n\t\tif (!rds_still_queued(rs, inc, !(msg_flags & MSG_PEEK))) {\n\t\t\trds_inc_put(inc);\n\t\t\tinc = NULL;\n\t\t\trds_stats_inc(s_recv_deliver_raced);\n\t\t\tcontinue;\n\t\t}\n\t\tif (ret < be32_to_cpu(inc->i_hdr.h_len)) {\n\t\t\tif (msg_flags & MSG_TRUNC)\n\t\t\t\tret = be32_to_cpu(inc->i_hdr.h_len);\n\t\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\t}\n\t\tif (rds_cmsg_recv(inc, msg)) {\n\t\t\tret = -EFAULT;\n\t\t\tgoto out;\n\t\t}\n\t\trds_stats_inc(s_recv_delivered);\n\t\tsin = (struct sockaddr_in *)msg->msg_name;\n\t\tif (sin) {\n\t\t\tsin->sin_family = AF_INET;\n\t\t\tsin->sin_port = inc->i_hdr.h_sport;\n\t\t\tsin->sin_addr.s_addr = inc->i_saddr;\n\t\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t\tmsg->msg_namelen = sizeof(*sin);\n\t\t}\n\t\tbreak;\n\t}\n\tif (inc)\n\t\trds_inc_put(inc);\nout:\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 13
    },
    {
        "code": "static int cma_req_handler(struct ib_cm_id *cm_id, struct ib_cm_event *ib_event)\n{\n\tstruct rdma_id_private *listen_id, *conn_id;\n\tstruct rdma_cm_event event;\n\tint offset, ret;\n\tlisten_id = cm_id->context;\n\tif (!cma_check_req_qp_type(&listen_id->id, ib_event))\n\t\treturn -EINVAL;\n\tif (cma_disable_callback(listen_id, RDMA_CM_LISTEN))\n\t\treturn -ECONNABORTED;\n\tmemset(&event, 0, sizeof event);\n\toffset = cma_user_data_offset(listen_id);\n\tevent.event = RDMA_CM_EVENT_CONNECT_REQUEST;\n\tif (ib_event->event == IB_CM_SIDR_REQ_RECEIVED) {\n\t\tconn_id = cma_new_udp_id(&listen_id->id, ib_event);\n\t\tevent.param.ud.private_data = ib_event->private_data + offset;\n\t\tevent.param.ud.private_data_len =\n\t\t\t\tIB_CM_SIDR_REQ_PRIVATE_DATA_SIZE - offset;\n\t} else {\n\t\tconn_id = cma_new_conn_id(&listen_id->id, ib_event);\n\t\tcma_set_req_event_data(&event, &ib_event->param.req_rcvd,\n\t\t\t\t       ib_event->private_data, offset);\n\t}\n\tif (!conn_id) {\n\t\tret = -ENOMEM;\n\t\tgoto err1;\n\t}\n\tmutex_lock_nested(&conn_id->handler_mutex, SINGLE_DEPTH_NESTING);\n\tret = cma_acquire_dev(conn_id, listen_id);\n\tif (ret)\n\t\tgoto err2;\n\tconn_id->cm_id.ib = cm_id;\n\tcm_id->context = conn_id;\n\tcm_id->cm_handler = cma_ib_handler;\n\t/*\n\t * Protect against the user destroying conn_id from another thread\n\t * until we're done accessing it.\n\t */\n\tatomic_inc(&conn_id->refcount);\n\tret = conn_id->id.event_handler(&conn_id->id, &event);\n\tif (ret)\n\t\tgoto err3;\n\t/*\n\t * Acquire mutex to prevent user executing rdma_destroy_id()\n\t * while we're accessing the cm_id.\n\t */\n\tmutex_lock(&lock);\n\tif (cma_comp(conn_id, RDMA_CM_CONNECT) &&\n\t    (conn_id->id.qp_type != IB_QPT_UD))\n\t\tib_send_cm_mra(cm_id, CMA_CM_MRA_SETTING, NULL, 0);\n\tmutex_unlock(&lock);\n\tmutex_unlock(&conn_id->handler_mutex);\n\tmutex_unlock(&listen_id->handler_mutex);\n\tcma_deref_id(conn_id);\n\treturn 0;\nerr3:\n\tcma_deref_id(conn_id);\n\t/* Destroy the CM ID by returning a non-zero value. */\n\tconn_id->cm_id.ib = NULL;\nerr2:\n\tcma_exch(conn_id, RDMA_CM_DESTROYING);\n\tmutex_unlock(&conn_id->handler_mutex);\nerr1:\n\tmutex_unlock(&listen_id->handler_mutex);\n\tif (conn_id)\n\t\trdma_destroy_id(&conn_id->id);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 15
    },
    {
        "code": "static long restore_tm_user_regs(struct pt_regs *regs,\n\t\t\t\t struct mcontext __user *sr,\n\t\t\t\t struct mcontext __user *tm_sr)\n{\n\tlong err;\n\tunsigned long msr, msr_hi;\n#ifdef CONFIG_VSX\n\tint i;\n#endif\n\t/*\n\t * restore general registers but not including MSR or SOFTE. Also\n\t * take care of keeping r2 (TLS) intact if not a signal.\n\t * See comment in signal_64.c:restore_tm_sigcontexts();\n\t * TFHAR is restored from the checkpointed NIP; TEXASR and TFIAR\n\t * were set by the signal delivery.\n\t */\n\terr = restore_general_regs(regs, tm_sr);\n\terr |= restore_general_regs(&current->thread.ckpt_regs, sr);\n\terr |= __get_user(current->thread.tm_tfhar, &sr->mc_gregs[PT_NIP]);\n\terr |= __get_user(msr, &sr->mc_gregs[PT_MSR]);\n\tif (err)\n\t\treturn 1;\n\t/* Restore the previous little-endian mode */\n\tregs->msr = (regs->msr & ~MSR_LE) | (msr & MSR_LE);\n\t/*\n\t * Do this before updating the thread state in\n\t * current->thread.fpr/vr/evr.  That way, if we get preempted\n\t * and another task grabs the FPU/Altivec/SPE, it won't be\n\t * tempted to save the current CPU state into the thread_struct\n\t * and corrupt what we are writing there.\n\t */\n\tdiscard_lazy_cpu_state();\n#ifdef CONFIG_ALTIVEC\n\tregs->msr &= ~MSR_VEC;\n\tif (msr & MSR_VEC) {\n\t\t/* restore altivec registers from the stack */\n\t\tif (__copy_from_user(&current->thread.vr_state, &sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)) ||\n\t\t    __copy_from_user(&current->thread.transact_vr,\n\t\t\t\t     &tm_sr->mc_vregs,\n\t\t\t\t     sizeof(sr->mc_vregs)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vr) {\n\t\tmemset(&current->thread.vr_state, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t\tmemset(&current->thread.transact_vr, 0,\n\t\t       ELF_NVRREG * sizeof(vector128));\n\t}\n\t/* Always get VRSAVE back */\n\tif (__get_user(current->thread.vrsave,\n\t\t       (u32 __user *)&sr->mc_vregs[32]) ||\n\t    __get_user(current->thread.transact_vrsave,\n\t\t       (u32 __user *)&tm_sr->mc_vregs[32]))\n\t\treturn 1;\n\tif (cpu_has_feature(CPU_FTR_ALTIVEC))\n\t\tmtspr(SPRN_VRSAVE, current->thread.vrsave);\n#endif /* CONFIG_ALTIVEC */\n\tregs->msr &= ~(MSR_FP | MSR_FE0 | MSR_FE1);\n\tif (copy_fpr_from_user(current, &sr->mc_fregs) ||\n\t    copy_transact_fpr_from_user(current, &tm_sr->mc_fregs))\n\t\treturn 1;\n#ifdef CONFIG_VSX\n\tregs->msr &= ~MSR_VSX;\n\tif (msr & MSR_VSX) {\n\t\t/*\n\t\t * Restore altivec registers from the stack to a local\n\t\t * buffer, then write this out to the thread_struct\n\t\t */\n\t\tif (copy_vsx_from_user(current, &sr->mc_vsregs) ||\n\t\t    copy_transact_vsx_from_user(current, &tm_sr->mc_vsregs))\n\t\t\treturn 1;\n\t} else if (current->thread.used_vsr)\n\t\tfor (i = 0; i < 32 ; i++) {\n\t\t\tcurrent->thread.fp_state.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t\tcurrent->thread.transact_fp.fpr[i][TS_VSRLOWOFFSET] = 0;\n\t\t}\n#endif /* CONFIG_VSX */\n#ifdef CONFIG_SPE\n\t/* SPE regs are not checkpointed with TM, so this section is\n\t * simply the same as in restore_user_regs().\n\t */\n\tregs->msr &= ~MSR_SPE;\n\tif (msr & MSR_SPE) {\n\t\tif (__copy_from_user(current->thread.evr, &sr->mc_vregs,\n\t\t\t\t     ELF_NEVRREG * sizeof(u32)))\n\t\t\treturn 1;\n\t} else if (current->thread.used_spe)\n\t\tmemset(current->thread.evr, 0, ELF_NEVRREG * sizeof(u32));\n\t/* Always get SPEFSCR back */\n\tif (__get_user(current->thread.spefscr, (u32 __user *)&sr->mc_vregs\n\t\t       + ELF_NEVRREG))\n\t\treturn 1;\n#endif /* CONFIG_SPE */\n\t/* Get the top half of the MSR from the user context */\n\tif (__get_user(msr_hi, &tm_sr->mc_gregs[PT_MSR]))\n\t\treturn 1;\n\tmsr_hi <<= 32;\n\t/* If TM bits are set to the reserved value, it's an invalid context */\n\tif (MSR_TM_RESV(msr_hi))\n\t\treturn 1;\n\t/* Pull in the MSR TM bits from the user context */\n\tregs->msr = (regs->msr & ~MSR_TS_MASK) | (msr_hi & MSR_TS_MASK);\n\t/* Now, recheckpoint.  This loads up all of the checkpointed (older)\n\t * registers, including FP and V[S]Rs.  After recheckpointing, the\n\t * transactional versions should be loaded.\n\t */\n\ttm_enable();",
        "bug_line_number": [],
        "vul": 0,
        "id": 17
    },
    {
        "code": "static inline int nvme_reset_subsystem(struct nvme_ctrl *ctrl)\n{\n\tint ret;\n\tif (!ctrl->subsystem)\n\t\treturn -ENOTTY;\n\tif (!nvme_wait_reset(ctrl))\n\t\treturn -EBUSY;\n\tret = ctrl->ops->reg_write32(ctrl, NVME_REG_NSSR, 0x4E564D65);\n\tif (ret)\n\t\treturn ret;\n\treturn nvme_try_sched_reset(ctrl);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 19
    },
    {
        "code": "\t\tif (!irqchip_in_kernel(vcpu->kvm))\n\t\t\tgoto out;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&va, argp, sizeof va))\n\t\t\tgoto out;\n\t\tr = kvm_lapic_set_vapic_addr(vcpu, va.vapic_addr);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SETUP_MCE: {\n\t\tu64 mcg_cap;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mcg_cap, argp, sizeof mcg_cap))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_setup_mce(vcpu, mcg_cap);\n\t\tbreak;\n\t}\n\tcase KVM_X86_SET_MCE: {\n\t\tstruct kvm_x86_mce mce;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&mce, argp, sizeof mce))\n\t\t\tgoto out;\n\t\tr = kvm_vcpu_ioctl_x86_set_mce(vcpu, &mce);\n\t\tbreak;\n\t}\n\tcase KVM_GET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\t\tkvm_vcpu_ioctl_x86_get_vcpu_events(vcpu, &events);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &events, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_VCPU_EVENTS: {\n\t\tstruct kvm_vcpu_events events;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&events, argp, sizeof(struct kvm_vcpu_events)))\n\t\t\tbreak;\n\t\tr = kvm_vcpu_ioctl_x86_set_vcpu_events(vcpu, &events);\n\t\tbreak;\n\t}\n\tcase KVM_GET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\t\tkvm_vcpu_ioctl_x86_get_debugregs(vcpu, &dbgregs);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, &dbgregs,\n\t\t\t\t sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_DEBUGREGS: {\n\t\tstruct kvm_debugregs dbgregs;\n\t\tr = -EFAULT;\n\t\tif (copy_from_user(&dbgregs, argp,\n\t\t\t\t   sizeof(struct kvm_debugregs)))\n\t\t\tbreak;\n\t\tr = kvm_vcpu_ioctl_x86_set_debugregs(vcpu, &dbgregs);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XSAVE: {\n\t\tu.xsave = kzalloc(sizeof(struct kvm_xsave), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xsave)\n\t\t\tbreak;\n\t\tkvm_vcpu_ioctl_x86_get_xsave(vcpu, u.xsave);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xsave, sizeof(struct kvm_xsave)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XSAVE: {\n\t\tu.xsave = memdup_user(argp, sizeof(*u.xsave));\n\t\tif (IS_ERR(u.xsave))\n\t\t\treturn PTR_ERR(u.xsave);\n\t\tr = kvm_vcpu_ioctl_x86_set_xsave(vcpu, u.xsave);\n\t\tbreak;\n\t}\n\tcase KVM_GET_XCRS: {\n\t\tu.xcrs = kzalloc(sizeof(struct kvm_xcrs), GFP_KERNEL);\n\t\tr = -ENOMEM;\n\t\tif (!u.xcrs)\n\t\t\tbreak;\n\t\tkvm_vcpu_ioctl_x86_get_xcrs(vcpu, u.xcrs);\n\t\tr = -EFAULT;\n\t\tif (copy_to_user(argp, u.xcrs,\n\t\t\t\t sizeof(struct kvm_xcrs)))\n\t\t\tbreak;\n\t\tr = 0;\n\t\tbreak;\n\t}\n\tcase KVM_SET_XCRS: {\n\t\tu.xcrs = memdup_user(argp, sizeof(*u.xcrs));\n\t\tif (IS_ERR(u.xcrs))\n\t\t\treturn PTR_ERR(u.xcrs);\n\t\tr = kvm_vcpu_ioctl_x86_set_xcrs(vcpu, u.xcrs);\n\t\tbreak;\n\t}\n\tcase KVM_SET_TSC_KHZ: {\n\t\tu32 user_tsc_khz;\n\t\tr = -EINVAL;\n\t\tuser_tsc_khz = (u32)arg;",
        "bug_line_number": [],
        "vul": 0,
        "id": 21
    },
    {
        "code": "int kvm_lapic_set_vapic_addr(struct kvm_vcpu *vcpu, gpa_t vapic_addr)\n{\n\tif (vapic_addr) {\n\t\tif (kvm_gfn_to_hva_cache_init(vcpu->kvm,\n\t\t\t\t\t&vcpu->arch.apic->vapic_cache,\n\t\t\t\t\tvapic_addr, sizeof(u32)))\n\t\t\treturn -EINVAL;\n\t\t__set_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t} else {\n\t\t__clear_bit(KVM_APIC_CHECK_VAPIC, &vcpu->arch.apic_attention);\n\t}\n\tvcpu->arch.apic->vapic_addr = vapic_addr;\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 23
    },
    {
        "code": "static int __vcpu_run(struct kvm_vcpu *vcpu)\n{\n\tint r;\n\tstruct kvm *kvm = vcpu->kvm;\n\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\tr = 1;\n\twhile (r > 0) {\n\t\tif (vcpu->arch.mp_state == KVM_MP_STATE_RUNNABLE &&\n\t\t    !vcpu->arch.apf.halted)\n\t\t\tr = vcpu_enter_guest(vcpu);\n\t\telse {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_vcpu_block(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t\tif (kvm_check_request(KVM_REQ_UNHALT, vcpu)) {\n\t\t\t\tkvm_apic_accept_events(vcpu);\n\t\t\t\tswitch(vcpu->arch.mp_state) {\n\t\t\t\tcase KVM_MP_STATE_HALTED:\n\t\t\t\t\tvcpu->arch.pv.pv_unhalted = false;\n\t\t\t\t\tvcpu->arch.mp_state =\n\t\t\t\t\t\tKVM_MP_STATE_RUNNABLE;\n\t\t\t\tcase KVM_MP_STATE_RUNNABLE:\n\t\t\t\t\tvcpu->arch.apf.halted = false;\n\t\t\t\t\tbreak;\n\t\t\t\tcase KVM_MP_STATE_INIT_RECEIVED:\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tr = -EINTR;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif (r <= 0)\n\t\t\tbreak;\n\t\tclear_bit(KVM_REQ_PENDING_TIMER, &vcpu->requests);\n\t\tif (kvm_cpu_has_pending_timer(vcpu))\n\t\t\tkvm_inject_pending_timer_irqs(vcpu);\n\t\tif (dm_request_for_irq_injection(vcpu)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.request_irq_exits;\n\t\t}\n\t\tkvm_check_async_pf_completion(vcpu);\n\t\tif (signal_pending(current)) {\n\t\t\tr = -EINTR;\n\t\t\tvcpu->run->exit_reason = KVM_EXIT_INTR;\n\t\t\t++vcpu->stat.signal_exits;\n\t\t}\n\t\tif (need_resched()) {\n\t\t\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\t\t\tkvm_resched(vcpu);\n\t\t\tvcpu->srcu_idx = srcu_read_lock(&kvm->srcu);\n\t\t}\n\t}\n\tsrcu_read_unlock(&kvm->srcu, vcpu->srcu_idx);\n\treturn r;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 25
    },
    {
        "code": "static bool generic_new(struct nf_conn *ct, const struct sk_buff *skb,\n\t\t\tunsigned int dataoff, unsigned int *timeouts)\n{\n\treturn nf_generic_should_process(nf_ct_protonum(ct));\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 27
    },
    {
        "code": "static struct dst_entry *ip6_sk_dst_check(struct sock *sk,\n\t\t\t\t\t  struct dst_entry *dst,\n\t\t\t\t\t  const struct flowi6 *fl6)\n{\n\tstruct ipv6_pinfo *np = inet6_sk(sk);\n\tstruct rt6_info *rt;\n\tif (!dst)\n\t\tgoto out;\n\tif (dst->ops->family != AF_INET6) {\n\t\tdst_release(dst);\n\t\treturn NULL;\n\t}\n\trt = (struct rt6_info *)dst;\n\t/* Yes, checking route validity in not connected\n\t * case is not very simple. Take into account,\n\t * that we do not support routing by source, TOS,\n\t * and MSG_DONTROUTE \t\t--ANK (980726)\n\t *\n\t * 1. ip6_rt_check(): If route was host route,\n\t *    check that cached destination is current.\n\t *    If it is network route, we still may\n\t *    check its validity using saved pointer\n\t *    to the last used address: daddr_cache.\n\t *    We do not want to save whole address now,\n\t *    (because main consumer of this service\n\t *    is tcp, which has not this problem),\n\t *    so that the last trick works only on connected\n\t *    sockets.\n\t * 2. oif also should be the same.\n\t */\n\tif (ip6_rt_check(&rt->rt6i_dst, &fl6->daddr, np->daddr_cache) ||\n#ifdef CONFIG_IPV6_SUBTREES\n\t    ip6_rt_check(&rt->rt6i_src, &fl6->saddr, np->saddr_cache) ||\n#endif\n\t    (fl6->flowi6_oif && fl6->flowi6_oif != dst->dev->ifindex)) {\n\t\tdst_release(dst);\n\t\tdst = NULL;\n\t}\nout:\n\treturn dst;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 29
    },
    {
        "code": "static void aead_release(void *private)\n{\n\tstruct aead_tfm *tfm = private;\n\tcrypto_free_aead(tfm->aead);\n\tcrypto_put_default_null_skcipher2();\n\tkfree(tfm);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 31
    },
    {
        "code": "static int kvm_create_vm_debugfs(struct kvm *kvm, int fd)\n{\n\tchar dir_name[ITOA_MAX_LEN * 2];\n\tstruct kvm_stat_data *stat_data;\n\tstruct kvm_stats_debugfs_item *p;\n\tif (!debugfs_initialized())\n\t\treturn 0;\n\tsnprintf(dir_name, sizeof(dir_name), \"%d-%d\", task_pid_nr(current), fd);\n\tkvm->debugfs_dentry = debugfs_create_dir(dir_name, kvm_debugfs_dir);\n\tkvm->debugfs_stat_data = kcalloc(kvm_debugfs_num_entries,\n\t\t\t\t\t sizeof(*kvm->debugfs_stat_data),\n\t\t\t\t\t GFP_KERNEL_ACCOUNT);\n\tif (!kvm->debugfs_stat_data)\n\t\treturn -ENOMEM;\n\tfor (p = debugfs_entries; p->name; p++) {\n\t\tstat_data = kzalloc(sizeof(*stat_data), GFP_KERNEL_ACCOUNT);\n\t\tif (!stat_data)\n\t\t\treturn -ENOMEM;\n\t\tstat_data->kvm = kvm;\n\t\tstat_data->offset = p->offset;\n\t\tstat_data->mode = p->mode ? p->mode : 0644;\n\t\tkvm->debugfs_stat_data[p - debugfs_entries] = stat_data;\n\t\tdebugfs_create_file(p->name, stat_data->mode, kvm->debugfs_dentry,\n\t\t\t\t    stat_data, stat_fops_per_vm[p->kind]);\n\t}\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 33
    },
    {
        "code": "static bool sctp_v4_from_addr_param(union sctp_addr *addr,\n\t\t\t\t    union sctp_addr_param *param,\n\t\t\t\t    __be16 port, int iif)\n{\n\tif (ntohs(param->v4.param_hdr.length) < sizeof(struct sctp_ipv4addr_param))\n\t\treturn false;\n\taddr->v4.sin_family = AF_INET;\n\taddr->v4.sin_port = port;\n\taddr->v4.sin_addr.s_addr = param->v4.addr.s_addr;\n\tmemset(addr->v4.sin_zero, 0, sizeof(addr->v4.sin_zero));\n\treturn true;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 35
    },
    {
        "code": "static struct sctp_association *__sctp_rcv_asconf_lookup(\n\t\t\t\t\tstruct net *net,\n\t\t\t\t\tstruct sctp_chunkhdr *ch,\n\t\t\t\t\tconst union sctp_addr *laddr,\n\t\t\t\t\t__be16 peer_port,\n\t\t\t\t\tstruct sctp_transport **transportp)\n{\n\tstruct sctp_addip_chunk *asconf = (struct sctp_addip_chunk *)ch;\n\tstruct sctp_af *af;\n\tunion sctp_addr_param *param;\n\tunion sctp_addr paddr;\n\t/* Skip over the ADDIP header and find the Address parameter */\n\tparam = (union sctp_addr_param *)(asconf + 1);\n\taf = sctp_get_af_specific(param_type2af(param->p.type));\n\tif (unlikely(!af))\n\t\treturn NULL;\n\tif (af->from_addr_param(&paddr, param, peer_port, 0))\n\t\treturn NULL;\n\treturn __sctp_lookup_association(net, laddr, &paddr, transportp);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 37
    },
    {
        "code": "static int i40e_vc_config_queues_msg(struct i40e_vf *vf, u8 *msg)\n{\n\tstruct virtchnl_vsi_queue_config_info *qci =\n\t    (struct virtchnl_vsi_queue_config_info *)msg;\n\tstruct virtchnl_queue_pair_info *qpi;\n\tstruct i40e_pf *pf = vf->pf;\n\tu16 vsi_id, vsi_queue_id = 0;\n\tu16 num_qps_all = 0;\n\ti40e_status aq_ret = 0;\n\tint i, j = 0, idx = 0;\n\tif (!test_bit(I40E_VF_STATE_ACTIVE, &vf->vf_states)) {\n\t\taq_ret = I40E_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\tif (!i40e_vc_isvalid_vsi_id(vf, qci->vsi_id)) {\n\t\taq_ret = I40E_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\tif (qci->num_queue_pairs > I40E_MAX_VF_QUEUES) {\n\t\taq_ret = I40E_ERR_PARAM;\n\t\tgoto error_param;\n\t}\n\tif (vf->adq_enabled) {\n\t\tfor (i = 0; i < I40E_MAX_VF_VSI; i++)\n\t\t\tnum_qps_all += vf->ch[i].num_qps;\n\t\tif (num_qps_all != qci->num_queue_pairs) {\n\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\t}\n\tvsi_id = qci->vsi_id;\n\tfor (i = 0; i < qci->num_queue_pairs; i++) {\n\t\tqpi = &qci->qpair[i];\n\t\tif (!vf->adq_enabled) {\n\t\t\tif (!i40e_vc_isvalid_queue_id(vf, vsi_id,\n\t\t\t\t\t\t      qpi->txq.queue_id)) {\n\t\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t\tvsi_queue_id = qpi->txq.queue_id;\n\t\t\tif (qpi->txq.vsi_id != qci->vsi_id ||\n\t\t\t    qpi->rxq.vsi_id != qci->vsi_id ||\n\t\t\t    qpi->rxq.queue_id != vsi_queue_id) {\n\t\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t}\n\t\tif (vf->adq_enabled) {\n\t\t\tif (idx >= ARRAY_SIZE(vf->ch)) {\n\t\t\t\taq_ret = I40E_ERR_NO_AVAILABLE_VSI;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t\tvsi_id = vf->ch[idx].vsi_id;\n\t\t}\n\t\tif (i40e_config_vsi_rx_queue(vf, vsi_id, vsi_queue_id,\n\t\t\t\t\t     &qpi->rxq) ||\n\t\t    i40e_config_vsi_tx_queue(vf, vsi_id, vsi_queue_id,\n\t\t\t\t\t     &qpi->txq)) {\n\t\t\taq_ret = I40E_ERR_PARAM;\n\t\t\tgoto error_param;\n\t\t}\n\t\t/* For ADq there can be up to 4 VSIs with max 4 queues each.\n\t\t * VF does not know about these additional VSIs and all\n\t\t * it cares is about its own queues. PF configures these queues\n\t\t * to its appropriate VSIs based on TC mapping\n\t\t **/\n\t\tif (vf->adq_enabled) {\n\t\t\tif (idx >= ARRAY_SIZE(vf->ch)) {\n\t\t\t\taq_ret = I40E_ERR_NO_AVAILABLE_VSI;\n\t\t\t\tgoto error_param;\n\t\t\t}\n\t\t\tif (j == (vf->ch[idx].num_qps - 1)) {\n\t\t\t\tidx++;\n\t\t\t\tj = 0; /* resetting the queue count */\n\t\t\t\tvsi_queue_id = 0;\n\t\t\t} else {\n\t\t\t\tj++;\n\t\t\t\tvsi_queue_id++;\n\t\t\t}\n\t\t}\n\t}\n\t/* set vsi num_queue_pairs in use to num configured by VF */\n\tif (!vf->adq_enabled) {\n\t\tpf->vsi[vf->lan_vsi_idx]->num_queue_pairs =\n\t\t\tqci->num_queue_pairs;\n\t} else {\n\t\tfor (i = 0; i < vf->num_tc; i++)\n\t\t\tpf->vsi[vf->ch[i].vsi_idx]->num_queue_pairs =\n\t\t\t       vf->ch[i].num_qps;\n\t}\nerror_param:\n\t/* send the response to the VF */\n\treturn i40e_vc_send_resp_to_vf(vf, VIRTCHNL_OP_CONFIG_VSI_QUEUES,\n\t\t\t\t       aq_ret);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 39
    },
    {
        "code": "SYSCALL_DEFINE6(io_uring_enter, unsigned int, fd, u32, to_submit,\n\t\tu32, min_complete, u32, flags, const sigset_t __user *, sig,\n\t\tsize_t, sigsz)\n{\n\tstruct io_ring_ctx *ctx;\n\tlong ret = -EBADF;\n\tint submitted = 0;\n\tstruct fd f;\n\tio_run_task_work();\n\tif (flags & ~(IORING_ENTER_GETEVENTS | IORING_ENTER_SQ_WAKEUP))\n\t\treturn -EINVAL;\n\tf = fdget(fd);\n\tif (!f.file)\n\t\treturn -EBADF;\n\tret = -EOPNOTSUPP;\n\tif (f.file->f_op != &io_uring_fops)\n\t\tgoto out_fput;\n\tret = -ENXIO;\n\tctx = f.file->private_data;\n\tif (!percpu_ref_tryget(&ctx->refs))\n\t\tgoto out_fput;\n\t/*\n\t * For SQ polling, the thread will do all submissions and completions.\n\t * Just return the requested submit count, and wake the thread if\n\t * we were asked to.\n\t */\n\tret = 0;\n\tif (ctx->flags & IORING_SETUP_SQPOLL) {\n\t\tif (!list_empty_careful(&ctx->cq_overflow_list))\n\t\t\tio_cqring_overflow_flush(ctx, false, NULL, NULL);\n\t\tif (flags & IORING_ENTER_SQ_WAKEUP)\n\t\t\twake_up(&ctx->sqo_wait);\n\t\tsubmitted = to_submit;\n\t} else if (to_submit) {\n\t\tret = io_uring_add_task_file(f.file);\n\t\tif (unlikely(ret))\n\t\t\tgoto out;\n\t\tmutex_lock(&ctx->uring_lock);\n\t\tsubmitted = io_submit_sqes(ctx, to_submit);\n\t\tmutex_unlock(&ctx->uring_lock);\n\t\tif (submitted != to_submit)\n\t\t\tgoto out;\n\t}\n\tif (flags & IORING_ENTER_GETEVENTS) {\n\t\tmin_complete = min(min_complete, ctx->cq_entries);\n\t\t/*\n\t\t * When SETUP_IOPOLL and SETUP_SQPOLL are both enabled, user\n\t\t * space applications don't need to do io completion events\n\t\t * polling again, they can rely on io_sq_thread to do polling\n\t\t * work, which can reduce cpu usage and uring_lock contention.\n\t\t */\n\t\tif (ctx->flags & IORING_SETUP_IOPOLL &&\n\t\t    !(ctx->flags & IORING_SETUP_SQPOLL)) {\n\t\t\tret = io_iopoll_check(ctx, min_complete);\n\t\t} else {\n\t\t\tret = io_cqring_wait(ctx, min_complete, sig, sigsz);\n\t\t}\n\t}\nout:\n\tpercpu_ref_put(&ctx->refs);\nout_fput:\n\tfdput(f);\n\treturn submitted ? submitted : ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 41
    },
    {
        "code": "int arch_dup_task_struct(struct task_struct *dst, struct task_struct *src)\n{\n\tflush_fp_to_thread(src);\n\tflush_altivec_to_thread(src);\n\tflush_vsx_to_thread(src);\n\tflush_spe_to_thread(src);\n\t/*\n\t * Flush TM state out so we can copy it.  __switch_to_tm() does this\n\t * flush but it removes the checkpointed state from the current CPU and\n\t * transitions the CPU out of TM mode.  Hence we need to call\n\t * tm_recheckpoint_new_task() (on the same task) to restore the\n\t * checkpointed state back and the TM mode.\n\t */\n\t__switch_to_tm(src);\n\ttm_recheckpoint_new_task(src);\n\t*dst = *src;\n\tclear_task_ebb(dst);\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 43
    },
    {
        "code": "int ip6_mroute_getsockopt(struct sock *sk, int optname, char __user *optval,\n\t\t\t  int __user *optlen)\n{\n\tint olr;\n\tint val;\n\tstruct net *net = sock_net(sk);\n\tstruct mr6_table *mrt;\n\tif (sk->sk_type != SOCK_RAW ||\n\t    inet_sk(sk)->inet_num != IPPROTO_ICMPV6)\n\t\treturn -EOPNOTSUPP;\n\tmrt = ip6mr_get_table(net, raw6_sk(sk)->ip6mr_table ? : RT6_TABLE_DFLT);\n\tif (!mrt)\n\t\treturn -ENOENT;\n\tswitch (optname) {\n\tcase MRT6_VERSION:\n\t\tval = 0x0305;\n\t\tbreak;\n#ifdef CONFIG_IPV6_PIMSM_V2\n\tcase MRT6_PIM:\n\t\tval = mrt->mroute_do_pim;\n\t\tbreak;\n#endif\n\tcase MRT6_ASSERT:\n\t\tval = mrt->mroute_do_assert;\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (get_user(olr, optlen))\n\t\treturn -EFAULT;\n\tolr = min_t(int, olr, sizeof(int));\n\tif (olr < 0)\n\t\treturn -EINVAL;\n\tif (put_user(olr, optlen))\n\t\treturn -EFAULT;\n\tif (copy_to_user(optval, &val, olr))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 45
    },
    {
        "code": "static int kvm_vm_ioctl_create_vcpu(struct kvm *kvm, u32 id)\n{\n\tint r;\n\tstruct kvm_vcpu *vcpu, *v;\n\tif (id >= KVM_MAX_VCPUS)\n\t\treturn -EINVAL;\n\tvcpu = kvm_arch_vcpu_create(kvm, id);\n\tif (IS_ERR(vcpu))\n\t\treturn PTR_ERR(vcpu);\n\tpreempt_notifier_init(&vcpu->preempt_notifier, &kvm_preempt_ops);\n\tr = kvm_arch_vcpu_setup(vcpu);\n\tif (r)\n\t\tgoto vcpu_destroy;\n\tmutex_lock(&kvm->lock);\n\tif (!kvm_vcpu_compatible(vcpu)) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tif (atomic_read(&kvm->online_vcpus) == KVM_MAX_VCPUS) {\n\t\tr = -EINVAL;\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm_for_each_vcpu(r, v, kvm)\n\t\tif (v->vcpu_id == id) {\n\t\t\tr = -EEXIST;\n\t\t\tgoto unlock_vcpu_destroy;\n\t\t}\n\tBUG_ON(kvm->vcpus[atomic_read(&kvm->online_vcpus)]);\n\t/* Now it's all set up, let userspace reach it */\n\tkvm_get_kvm(kvm);\n\tr = create_vcpu_fd(vcpu);\n\tif (r < 0) {\n\t\tkvm_put_kvm(kvm);\n\t\tgoto unlock_vcpu_destroy;\n\t}\n\tkvm->vcpus[atomic_read(&kvm->online_vcpus)] = vcpu;\n\tsmp_wmb();\n\tatomic_inc(&kvm->online_vcpus);\n\tmutex_unlock(&kvm->lock);\n\tkvm_arch_vcpu_postcreate(vcpu);\n\treturn r;\nunlock_vcpu_destroy:\n\tmutex_unlock(&kvm->lock);\nvcpu_destroy:\n\tkvm_arch_vcpu_destroy(vcpu);\n\treturn r;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 47
    },
    {
        "code": "static int hid_parser_global(struct hid_parser *parser, struct hid_item *item)\n{\n\t__u32 raw_value;\n\tswitch (item->tag) {\n\tcase HID_GLOBAL_ITEM_TAG_PUSH:\n\t\tif (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {\n\t\t\thid_err(parser->device, \"global environment stack overflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(parser->global_stack + parser->global_stack_ptr++,\n\t\t\t&parser->global, sizeof(struct hid_global));\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_POP:\n\t\tif (!parser->global_stack_ptr) {\n\t\t\thid_err(parser->device, \"global environment stack underflow\\n\");\n\t\t\treturn -1;\n\t\t}\n\t\tmemcpy(&parser->global, parser->global_stack +\n\t\t\t--parser->global_stack_ptr, sizeof(struct hid_global));\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_USAGE_PAGE:\n\t\tparser->global.usage_page = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:\n\t\tparser->global.logical_minimum = item_sdata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:\n\t\tif (parser->global.logical_minimum < 0)\n\t\t\tparser->global.logical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.logical_maximum = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:\n\t\tparser->global.physical_minimum = item_sdata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:\n\t\tif (parser->global.physical_minimum < 0)\n\t\t\tparser->global.physical_maximum = item_sdata(item);\n\t\telse\n\t\t\tparser->global.physical_maximum = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:\n\t\t/* Units exponent negative numbers are given through a\n\t\t * two's complement.\n\t\t * See \"6.2.2.7 Global Items\" for more information. */\n\t\traw_value = item_udata(item);\n\t\tif (!(raw_value & 0xfffffff0))\n\t\t\tparser->global.unit_exponent = hid_snto32(raw_value, 4);\n\t\telse\n\t\t\tparser->global.unit_exponent = raw_value;\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_UNIT:\n\t\tparser->global.unit = item_udata(item);\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_SIZE:\n\t\tparser->global.report_size = item_udata(item);\n\t\tif (parser->global.report_size > 128) {\n\t\t\thid_err(parser->device, \"invalid report_size %d\\n\",\n\t\t\t\t\tparser->global.report_size);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_COUNT:\n\t\tparser->global.report_count = item_udata(item);\n\t\tif (parser->global.report_count > HID_MAX_USAGES) {\n\t\t\thid_err(parser->device, \"invalid report_count %d\\n\",\n\t\t\t\t\tparser->global.report_count);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tcase HID_GLOBAL_ITEM_TAG_REPORT_ID:\n\t\tparser->global.report_id = item_udata(item);\n\t\tif (parser->global.report_id == 0 ||\n\t\t    parser->global.report_id >= HID_MAX_IDS) {\n\t\t\thid_err(parser->device, \"report_id %u is invalid\\n\",\n\t\t\t\tparser->global.report_id);\n\t\t\treturn -1;\n\t\t}\n\t\treturn 0;\n\tdefault:\n\t\thid_err(parser->device, \"unknown global tag 0x%x\\n\", item->tag);\n\t\treturn -1;\n\t}\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 49
    },
    {
        "code": "static void hid_close_report(struct hid_device *device)\n{\n\tunsigned i, j;\n\tfor (i = 0; i < HID_REPORT_TYPES; i++) {\n\t\tstruct hid_report_enum *report_enum = device->report_enum + i;\n\t\tfor (j = 0; j < HID_MAX_IDS; j++) {\n\t\t\tstruct hid_report *report = report_enum->report_id_hash[j];\n\t\t\tif (report)\n\t\t\t\thid_free_report(report);\n\t\t}\n\t\tmemset(report_enum, 0, sizeof(*report_enum));\n\t\tINIT_LIST_HEAD(&report_enum->report_list);\n\t}\n\tkfree(device->rdesc);\n\tdevice->rdesc = NULL;\n\tdevice->rsize = 0;\n\tkfree(device->collection);\n\tdevice->collection = NULL;\n\tdevice->collection_size = 0;\n\tdevice->maxcollection = 0;\n\tdevice->maxapplication = 0;\n\tdevice->status &= ~HID_STAT_PARSED;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 51
    },
    {
        "code": "static int raw_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\t       size_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tsize_t copied = 0;\n\tint err = -EOPNOTSUPP;\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tif (flags & MSG_OOB)\n\t\tgoto out;\n\tif (flags & MSG_ERRQUEUE) {\n\t\terr = ip_recv_error(sk, msg, len);\n\t\tgoto out;\n\t}\n\tskb = skb_recv_datagram(sk, flags, noblock, &err);\n\tif (!skb)\n\t\tgoto out;\n\tcopied = skb->len;\n\tif (len < copied) {\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t\tcopied = len;\n\t}\n\terr = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copied);\n\tif (err)\n\t\tgoto done;\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tsin->sin_port = 0;\n\t\tmemset(&sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\tif (flags & MSG_TRUNC)\n\t\tcopied = skb->len;\ndone:\n\tskb_free_datagram(sk, skb);\nout:\n\tif (err)\n\t\treturn err;\n\treturn copied;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 53
    },
    {
        "code": "int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,\n\t\tsize_t len, int noblock, int flags, int *addr_len)\n{\n\tstruct inet_sock *inet = inet_sk(sk);\n\tstruct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;\n\tstruct sk_buff *skb;\n\tunsigned int ulen, copied;\n\tint peeked, off = 0;\n\tint err;\n\tint is_udplite = IS_UDPLITE(sk);\n\tbool slow;\n\tif (flags & MSG_ERRQUEUE)\n\t\treturn ip_recv_error(sk, msg, len);\ntry_again:\n\tskb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),\n\t\t\t\t  &peeked, &off, &err);\n\tif (!skb)\n\t\tgoto out;\n\tulen = skb->len - sizeof(struct udphdr);\n\tcopied = len;\n\tif (copied > ulen)\n\t\tcopied = ulen;\n\telse if (copied < ulen)\n\t\tmsg->msg_flags |= MSG_TRUNC;\n\t/*\n\t * If checksum is needed at all, try to do it while copying the\n\t * data.  If the data is truncated, or if we only want a partial\n\t * coverage checksum (UDP-Lite), do it before the copy.\n\t */\n\tif (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {\n\t\tif (udp_lib_checksum_complete(skb))\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (skb_csum_unnecessary(skb))\n\t\terr = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),\n\t\t\t\t\t      msg->msg_iov, copied);\n\telse {\n\t\terr = skb_copy_and_csum_datagram_iovec(skb,\n\t\t\t\t\t\t       sizeof(struct udphdr),\n\t\t\t\t\t\t       msg->msg_iov);\n\t\tif (err == -EINVAL)\n\t\t\tgoto csum_copy_err;\n\t}\n\tif (unlikely(err)) {\n\t\ttrace_kfree_skb(skb, udp_recvmsg);\n\t\tif (!peeked) {\n\t\t\tatomic_inc(&sk->sk_drops);\n\t\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\t\t   UDP_MIB_INERRORS, is_udplite);\n\t\t}\n\t\tgoto out_free;\n\t}\n\tif (!peeked)\n\t\tUDP_INC_STATS_USER(sock_net(sk),\n\t\t\t\tUDP_MIB_INDATAGRAMS, is_udplite);\n\tsock_recv_ts_and_drops(msg, sk, skb);\n\t/* Copy the address. */\n\tif (sin) {\n\t\tsin->sin_family = AF_INET;\n\t\tsin->sin_port = udp_hdr(skb)->source;\n\t\tsin->sin_addr.s_addr = ip_hdr(skb)->saddr;\n\t\tmemset(sin->sin_zero, 0, sizeof(sin->sin_zero));\n\t\t*addr_len = sizeof(*sin);\n\t}\n\tif (inet->cmsg_flags)\n\t\tip_cmsg_recv(msg, skb);\n\terr = copied;\n\tif (flags & MSG_TRUNC)\n\t\terr = ulen;\nout_free:\n\tskb_free_datagram_locked(sk, skb);\nout:\n\treturn err;\ncsum_copy_err:\n\tslow = lock_sock_fast(sk);\n\tif (!skb_kill_datagram(sk, skb, flags)) {\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);\n\t\tUDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);\n\t}\n\tunlock_sock_fast(sk, slow);\n\tif (noblock)\n\t\treturn -EAGAIN;\n\t/* starting over for a new packet */\n\tmsg->msg_flags &= ~MSG_TRUNC;\n\tgoto try_again;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 55
    },
    {
        "code": "static int set_core_reg(struct kvm_vcpu *vcpu, const struct kvm_one_reg *reg)\n{\n\t__u32 __user *uaddr = (__u32 __user *)(unsigned long)reg->addr;\n\tstruct kvm_regs *regs = vcpu_gp_regs(vcpu);\n\tint nr_regs = sizeof(*regs) / sizeof(__u32);\n\t__uint128_t tmp;\n\tvoid *valp = &tmp;\n\tu64 off;\n\tint err = 0;\n\t/* Our ID is an index into the kvm_regs struct. */\n\toff = core_reg_offset_from_id(reg->id);\n\tif (off >= nr_regs ||\n\t    (off + (KVM_REG_SIZE(reg->id) / sizeof(__u32))) >= nr_regs)\n\t\treturn -ENOENT;\n\tif (validate_core_offset(reg))\n\t\treturn -EINVAL;\n\tif (KVM_REG_SIZE(reg->id) > sizeof(tmp))\n\t\treturn -EINVAL;\n\tif (copy_from_user(valp, uaddr, KVM_REG_SIZE(reg->id))) {\n\t\terr = -EFAULT;\n\t\tgoto out;\n\t}\n\tif (off == KVM_REG_ARM_CORE_REG(regs.pstate)) {\n\t\tu32 mode = (*(u32 *)valp) & PSR_AA32_MODE_MASK;\n\t\tswitch (mode) {\n\t\tcase PSR_AA32_MODE_USR:\n\t\tcase PSR_AA32_MODE_FIQ:\n\t\tcase PSR_AA32_MODE_IRQ:\n\t\tcase PSR_AA32_MODE_SVC:\n\t\tcase PSR_AA32_MODE_ABT:\n\t\tcase PSR_AA32_MODE_UND:\n\t\tcase PSR_MODE_EL0t:\n\t\tcase PSR_MODE_EL1t:\n\t\tcase PSR_MODE_EL1h:\n\t\t\tbreak;\n\t\tdefault:\n\t\t\terr = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\tmemcpy((u32 *)regs + off, valp, KVM_REG_SIZE(reg->id));\nout:\n\treturn err;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 57
    },
    {
        "code": "int f2fs_trim_fs(struct f2fs_sb_info *sbi, struct fstrim_range *range)\n{\n\t__u64 start = F2FS_BYTES_TO_BLK(range->start);\n\t__u64 end = start + F2FS_BYTES_TO_BLK(range->len) - 1;\n\tunsigned int start_segno, end_segno;\n\tstruct cp_control cpc;\n\tint err = 0;\n\tif (start >= MAX_BLKADDR(sbi) || range->len < sbi->blocksize)\n\t\treturn -EINVAL;\n\tcpc.trimmed = 0;\n\tif (end <= MAIN_BLKADDR(sbi))\n\t\tgoto out;\n\tif (is_sbi_flag_set(sbi, SBI_NEED_FSCK)) {\n\t\tf2fs_msg(sbi->sb, KERN_WARNING,\n\t\t\t\"Found FS corruption, run fsck to fix.\");\n\t\tgoto out;\n\t}\n\t/* start/end segment number in main_area */\n\tstart_segno = (start <= MAIN_BLKADDR(sbi)) ? 0 : GET_SEGNO(sbi, start);\n\tend_segno = (end >= MAX_BLKADDR(sbi)) ? MAIN_SEGS(sbi) - 1 :\n\t\t\t\t\t\tGET_SEGNO(sbi, end);\n\tcpc.reason = CP_DISCARD;\n\tcpc.trim_minlen = max_t(__u64, 1, F2FS_BYTES_TO_BLK(range->minlen));\n\t/* do checkpoint to issue discard commands safely */\n\tfor (; start_segno <= end_segno; start_segno = cpc.trim_end + 1) {\n\t\tcpc.trim_start = start_segno;\n\t\tif (sbi->discard_blks == 0)\n\t\t\tbreak;\n\t\telse if (sbi->discard_blks < BATCHED_TRIM_BLOCKS(sbi))\n\t\t\tcpc.trim_end = end_segno;\n\t\telse\n\t\t\tcpc.trim_end = min_t(unsigned int,\n\t\t\t\trounddown(start_segno +\n\t\t\t\tBATCHED_TRIM_SEGMENTS(sbi),\n\t\t\t\tsbi->segs_per_sec) - 1, end_segno);\n\t\tmutex_lock(&sbi->gc_mutex);\n\t\terr = write_checkpoint(sbi, &cpc);\n\t\tmutex_unlock(&sbi->gc_mutex);\n\t\tif (err)\n\t\t\tbreak;\n\t\tschedule();\n\t}\n\t/* It's time to issue all the filed discards */\n\tmark_discard_range_all(sbi);\n\tf2fs_wait_discard_bios(sbi, false);\nout:\n\trange->len = F2FS_BLK_TO_BYTES(cpc.trimmed);\n\treturn err;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 59
    },
    {
        "code": "static inline int xsave_state_booting(struct xsave_struct *fx, u64 mask)\n{\n\tu32 lmask = mask;\n\tu32 hmask = mask >> 32;\n\tint err = 0;\n\tWARN_ON(system_state != SYSTEM_BOOTING);\n\tif (boot_cpu_has(X86_FEATURE_XSAVES))\n\t\tasm volatile(\"1:\"XSAVES\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t     xstate_fault\n\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\telse\n\t\tasm volatile(\"1:\"XSAVE\"\\n\\t\"\n\t\t\t\"2:\\n\\t\"\n\t\t\t     xstate_fault\n\t\t\t: \"D\" (fx), \"m\" (*fx), \"a\" (lmask), \"d\" (hmask)\n\t\t\t:   \"memory\");\n\treturn err;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 61
    },
    {
        "code": "static int lme2510_identify_state(struct dvb_usb_device *d, const char **name)\n{\n\tstruct lme2510_state *st = d->priv;\n\tint status;\n\tusb_reset_configuration(d->udev);\n\tusb_set_interface(d->udev,\n\t\td->props->bInterfaceNumber, 1);\n\tst->dvb_usb_lme2510_firmware = dvb_usb_lme2510_firmware;\n\tstatus = lme2510_return_status(d);\n\tif (status == 0x44) {\n\t\t*name = lme_firmware_switch(d, 0);\n\t\treturn COLD;\n\t}\n\tif (status != 0x47)\n\t\treturn -EINVAL;\n\treturn WARM;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 63
    },
    {
        "code": "int kvm_read_guest_page(struct kvm *kvm, gfn_t gfn, void *data, int offset,\n\t\t\tint len)\n{\n\tint r;\n\tunsigned long addr;\n\taddr = gfn_to_hva(kvm, gfn);\n\tif (kvm_is_error_hva(addr))\n\t\treturn -EFAULT;\n\tr = __copy_from_user(data, (void __user *)addr + offset, len);\n\tif (r)\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 65
    },
    {
        "code": "static int FNAME(walk_addr_generic)(struct guest_walker *walker,\n\t\t\t\t    struct kvm_vcpu *vcpu, struct kvm_mmu *mmu,\n\t\t\t\t    gva_t addr, u32 access)\n{\n\tpt_element_t pte;\n\tpt_element_t __user *ptep_user;\n\tgfn_t table_gfn;\n\tunsigned index, pt_access, uninitialized_var(pte_access);\n\tgpa_t pte_gpa;\n\tbool eperm, present, rsvd_fault;\n\tint offset, write_fault, user_fault, fetch_fault;\n\twrite_fault = access & PFERR_WRITE_MASK;\n\tuser_fault = access & PFERR_USER_MASK;\n\tfetch_fault = access & PFERR_FETCH_MASK;\n\ttrace_kvm_mmu_pagetable_walk(addr, write_fault, user_fault,\n\t\t\t\t     fetch_fault);\nwalk:\n\tpresent = true;\n\teperm = rsvd_fault = false;\n\twalker->level = mmu->root_level;\n\tpte           = mmu->get_cr3(vcpu);\n#if PTTYPE == 64\n\tif (walker->level == PT32E_ROOT_LEVEL) {\n\t\tpte = kvm_pdptr_read_mmu(vcpu, mmu, (addr >> 30) & 3);\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (!is_present_gpte(pte)) {\n\t\t\tpresent = false;\n\t\t\tgoto error;\n\t\t}\n\t\t--walker->level;\n\t}\n#endif\n\tASSERT((!is_long_mode(vcpu) && is_pae(vcpu)) ||\n\t       (mmu->get_cr3(vcpu) & CR3_NONPAE_RESERVED_BITS) == 0);\n\tpt_access = ACC_ALL;\n\tfor (;;) {\n\t\tgfn_t real_gfn;\n\t\tunsigned long host_addr;\n\t\tindex = PT_INDEX(addr, walker->level);\n\t\ttable_gfn = gpte_to_gfn(pte);\n\t\toffset    = index * sizeof(pt_element_t);\n\t\tpte_gpa   = gfn_to_gpa(table_gfn) + offset;\n\t\twalker->table_gfn[walker->level - 1] = table_gfn;\n\t\twalker->pte_gpa[walker->level - 1] = pte_gpa;\n\t\treal_gfn = mmu->translate_gpa(vcpu, gfn_to_gpa(table_gfn),\n\t\t\t\t\t      PFERR_USER_MASK|PFERR_WRITE_MASK);\n\t\tif (unlikely(real_gfn == UNMAPPED_GVA)) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\treal_gfn = gpa_to_gfn(real_gfn);\n\t\thost_addr = gfn_to_hva(vcpu->kvm, real_gfn);\n\t\tif (unlikely(kvm_is_error_hva(host_addr))) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\tptep_user = (pt_element_t __user *)((void *)host_addr + offset);\n\t\tif (unlikely(__copy_from_user(&pte, ptep_user, sizeof(pte)))) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\ttrace_kvm_mmu_paging_element(pte, walker->level);\n\t\tif (unlikely(!is_present_gpte(pte))) {\n\t\t\tpresent = false;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(is_rsvd_bits_set(&vcpu->arch.mmu, pte,\n\t\t\t\t\t      walker->level))) {\n\t\t\trsvd_fault = true;\n\t\t\tbreak;\n\t\t}\n\t\tif (unlikely(write_fault && !is_writable_pte(pte)\n\t\t\t     && (user_fault || is_write_protection(vcpu))))\n\t\t\teperm = true;\n\t\tif (unlikely(user_fault && !(pte & PT_USER_MASK)))\n\t\t\teperm = true;\n#if PTTYPE == 64\n\t\tif (unlikely(fetch_fault && (pte & PT64_NX_MASK)))\n\t\t\teperm = true;\n#endif\n\t\tif (!eperm && !rsvd_fault\n\t\t    && unlikely(!(pte & PT_ACCESSED_MASK))) {\n\t\t\tint ret;\n\t\t\ttrace_kvm_mmu_set_accessed_bit(table_gfn, index,\n\t\t\t\t\t\t       sizeof(pte));\n\t\t\tret = FNAME(cmpxchg_gpte)(vcpu, mmu, table_gfn,\n\t\t\t\t\tindex, pte, pte|PT_ACCESSED_MASK);\n\t\t\tif (ret < 0) {\n\t\t\t\tpresent = false;\n\t\t\t\tbreak;\n\t\t\t} else if (ret)\n\t\t\t\tgoto walk;\n\t\t\tmark_page_dirty(vcpu->kvm, table_gfn);\n\t\t\tpte |= PT_ACCESSED_MASK;\n\t\t}\n\t\tpte_access = pt_access & FNAME(gpte_access)(vcpu, pte);\n\t\twalker->ptes[walker->level - 1] = pte;\n\t\tif ((walker->level == PT_PAGE_TABLE_LEVEL) ||\n\t\t    ((walker->level == PT_DIRECTORY_LEVEL) &&",
        "bug_line_number": [],
        "vul": 0,
        "id": 67
    },
    {
        "code": "int intel_uc_fw_fetch(struct intel_uc_fw *uc_fw)\n{\n\tstruct drm_i915_private *i915 = __uc_fw_to_gt(uc_fw)->i915;\n\tstruct device *dev = i915->drm.dev;\n\tstruct drm_i915_gem_object *obj;\n\tconst struct firmware *fw = NULL;\n\tstruct uc_css_header *css;\n\tsize_t size;\n\tint err;\n\tGEM_BUG_ON(!i915->wopcm.size);\n\tGEM_BUG_ON(!intel_uc_fw_is_enabled(uc_fw));\n\terr = i915_inject_probe_error(i915, -ENXIO);\n\tif (err)\n\t\tgoto fail;\n\t__force_fw_fetch_failures(uc_fw, -EINVAL);\n\t__force_fw_fetch_failures(uc_fw, -ESTALE);\n\terr = request_firmware(&fw, uc_fw->path, dev);\n\tif (err)\n\t\tgoto fail;\n\t/* Check the size of the blob before examining buffer contents */\n\tif (unlikely(fw->size < sizeof(struct uc_css_header))) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: invalid size: %zu < %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t fw->size, sizeof(struct uc_css_header));\n\t\terr = -ENODATA;\n\t\tgoto fail;\n\t}\n\tcss = (struct uc_css_header *)fw->data;\n\t/* Check integrity of size values inside CSS header */\n\tsize = (css->header_size_dw - css->key_size_dw - css->modulus_size_dw -\n\t\tcss->exponent_size_dw) * sizeof(u32);\n\tif (unlikely(size != sizeof(struct uc_css_header))) {\n\t\tdrm_warn(&i915->drm,\n\t\t\t \"%s firmware %s: unexpected header size: %zu != %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t fw->size, sizeof(struct uc_css_header));\n\t\terr = -EPROTO;\n\t\tgoto fail;\n\t}\n\t/* uCode size must calculated from other sizes */\n\tuc_fw->ucode_size = (css->size_dw - css->header_size_dw) * sizeof(u32);\n\t/* now RSA */\n\tif (unlikely(css->key_size_dw != UOS_RSA_SCRATCH_COUNT)) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: unexpected key size: %u != %u\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t css->key_size_dw, UOS_RSA_SCRATCH_COUNT);\n\t\terr = -EPROTO;\n\t\tgoto fail;\n\t}\n\tuc_fw->rsa_size = css->key_size_dw * sizeof(u32);\n\t/* At least, it should have header, uCode and RSA. Size of all three. */\n\tsize = sizeof(struct uc_css_header) + uc_fw->ucode_size + uc_fw->rsa_size;\n\tif (unlikely(fw->size < size)) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: invalid size: %zu < %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t fw->size, size);\n\t\terr = -ENOEXEC;\n\t\tgoto fail;\n\t}\n\t/* Sanity check whether this fw is not larger than whole WOPCM memory */\n\tsize = __intel_uc_fw_get_upload_size(uc_fw);\n\tif (unlikely(size >= i915->wopcm.size)) {\n\t\tdrm_warn(&i915->drm, \"%s firmware %s: invalid size: %zu > %zu\\n\",\n\t\t\t intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t size, (size_t)i915->wopcm.size);\n\t\terr = -E2BIG;\n\t\tgoto fail;\n\t}\n\t/* Get version numbers from the CSS header */\n\tuc_fw->major_ver_found = FIELD_GET(CSS_SW_VERSION_UC_MAJOR,\n\t\t\t\t\t   css->sw_version);\n\tuc_fw->minor_ver_found = FIELD_GET(CSS_SW_VERSION_UC_MINOR,\n\t\t\t\t\t   css->sw_version);\n\tif (uc_fw->major_ver_found != uc_fw->major_ver_wanted ||\n\t    uc_fw->minor_ver_found < uc_fw->minor_ver_wanted) {\n\t\tdrm_notice(&i915->drm, \"%s firmware %s: unexpected version: %u.%u != %u.%u\\n\",\n\t\t\t   intel_uc_fw_type_repr(uc_fw->type), uc_fw->path,\n\t\t\t   uc_fw->major_ver_found, uc_fw->minor_ver_found,\n\t\t\t   uc_fw->major_ver_wanted, uc_fw->minor_ver_wanted);\n\t\tif (!intel_uc_fw_is_overridden(uc_fw)) {\n\t\t\terr = -ENOEXEC;\n\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (uc_fw->type == INTEL_UC_FW_TYPE_GUC)\n\t\tuc_fw->private_data_size = css->private_data_size;\n\tobj = i915_gem_object_create_shmem_from_data(i915, fw->data, fw->size);\n\tif (IS_ERR(obj)) {\n\t\terr = PTR_ERR(obj);\n\t\tgoto fail;\n\t}\n\tuc_fw->obj = obj;\n\tuc_fw->size = fw->size;\n\tintel_uc_fw_change_status(uc_fw, INTEL_UC_FIRMWARE_AVAILABLE);\n\trelease_firmware(fw);\n\treturn 0;\nfail:\n\tintel_uc_fw_change_status(uc_fw, err == -ENOENT ?\n\t\t\t\t  INTEL_UC_FIRMWARE_MISSING :\n\t\t\t\t  INTEL_UC_FIRMWARE_ERROR);\n\tdrm_notice(&i915->drm, \"%s firmware %s: fetch failed with error %d\\n\",",
        "bug_line_number": [],
        "vul": 0,
        "id": 69
    },
    {
        "code": "static int aac_send_raw_srb(struct aac_dev* dev, void __user * arg)\n{\n\tstruct fib* srbfib;\n\tint status;\n\tstruct aac_srb *srbcmd = NULL;\n\tstruct user_aac_srb *user_srbcmd = NULL;\n\tstruct user_aac_srb __user *user_srb = arg;\n\tstruct aac_srb_reply __user *user_reply;\n\tstruct aac_srb_reply* reply;\n\tu32 fibsize = 0;\n\tu32 flags = 0;\n\ts32 rcode = 0;\n\tu32 data_dir;\n\tvoid __user *sg_user[32];\n\tvoid *sg_list[32];\n\tu32 sg_indx = 0;\n\tu32 byte_count = 0;\n\tu32 actual_fibsize64, actual_fibsize = 0;\n\tint i;\n\tif (dev->in_reset) {\n\t\tdprintk((KERN_DEBUG\"aacraid: send raw srb -EBUSY\\n\"));\n\t\treturn -EBUSY;\n\t}\n\tif (!capable(CAP_SYS_ADMIN)){\n\t\tdprintk((KERN_DEBUG\"aacraid: No permission to send raw srb\\n\"));\n\t\treturn -EPERM;\n\t}\n\t/*\n\t *\tAllocate and initialize a Fib then setup a SRB command\n\t */\n\tif (!(srbfib = aac_fib_alloc(dev))) {\n\t\treturn -ENOMEM;\n\t}\n\taac_fib_init(srbfib);\n\t/* raw_srb FIB is not FastResponseCapable */\n\tsrbfib->hw_fib_va->header.XferState &= ~cpu_to_le32(FastResponseCapable);\n\tsrbcmd = (struct aac_srb*) fib_data(srbfib);\n\tmemset(sg_list, 0, sizeof(sg_list)); /* cleanup may take issue */\n\tif(copy_from_user(&fibsize, &user_srb->count,sizeof(u32))){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy data size from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\tif ((fibsize < (sizeof(struct user_aac_srb) - sizeof(struct user_sgentry))) ||\n\t    (fibsize > (dev->max_fib_size - sizeof(struct aac_fibhdr)))) {\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tuser_srbcmd = kmalloc(fibsize, GFP_KERNEL);\n\tif (!user_srbcmd) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not make a copy of the srb\\n\"));\n\t\trcode = -ENOMEM;\n\t\tgoto cleanup;\n\t}\n\tif(copy_from_user(user_srbcmd, user_srb,fibsize)){\n\t\tdprintk((KERN_DEBUG\"aacraid: Could not copy srb from user\\n\"));\n\t\trcode = -EFAULT;\n\t\tgoto cleanup;\n\t}\n\tuser_reply = arg+fibsize;\n\tflags = user_srbcmd->flags; /* from user in cpu order */\n\t// Fix up srb for endian and force some values\n\tsrbcmd->function = cpu_to_le32(SRBF_ExecuteScsi);\t// Force this\n\tsrbcmd->channel\t = cpu_to_le32(user_srbcmd->channel);\n\tsrbcmd->id\t = cpu_to_le32(user_srbcmd->id);\n\tsrbcmd->lun\t = cpu_to_le32(user_srbcmd->lun);\n\tsrbcmd->timeout\t = cpu_to_le32(user_srbcmd->timeout);\n\tsrbcmd->flags\t = cpu_to_le32(flags);\n\tsrbcmd->retry_limit = 0; // Obsolete parameter\n\tsrbcmd->cdb_size = cpu_to_le32(user_srbcmd->cdb_size);\n\tmemcpy(srbcmd->cdb, user_srbcmd->cdb, sizeof(srbcmd->cdb));\n\tswitch (flags & (SRB_DataIn | SRB_DataOut)) {\n\tcase SRB_DataOut:\n\t\tdata_dir = DMA_TO_DEVICE;\n\t\tbreak;\n\tcase (SRB_DataIn | SRB_DataOut):\n\t\tdata_dir = DMA_BIDIRECTIONAL;\n\t\tbreak;\n\tcase SRB_DataIn:\n\t\tdata_dir = DMA_FROM_DEVICE;\n\t\tbreak;\n\tdefault:\n\t\tdata_dir = DMA_NONE;\n\t}\n\tif (user_srbcmd->sg.count > ARRAY_SIZE(sg_list)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: too many sg entries %d\\n\",\n\t\t  le32_to_cpu(srbcmd->sg.count)));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tactual_fibsize = sizeof(struct aac_srb) - sizeof(struct sgentry) +\n\t\t((user_srbcmd->sg.count & 0xff) * sizeof(struct sgentry));\n\tactual_fibsize64 = actual_fibsize + (user_srbcmd->sg.count & 0xff) *\n\t  (sizeof(struct sgentry64) - sizeof(struct sgentry));\n\t/* User made a mistake - should not continue */\n\tif ((actual_fibsize != fibsize) && (actual_fibsize64 != fibsize)) {\n\t\tdprintk((KERN_DEBUG\"aacraid: Bad Size specified in \"\n\t\t  \"Raw SRB command calculated fibsize=%lu;%lu \"\n\t\t  \"user_srbcmd->sg.count=%d aac_srb=%lu sgentry=%lu;%lu \"\n\t\t  \"issued fibsize=%d\\n\",\n\t\t  actual_fibsize, actual_fibsize64, user_srbcmd->sg.count,\n\t\t  sizeof(struct aac_srb), sizeof(struct sgentry),\n\t\t  sizeof(struct sgentry64), fibsize));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;\n\t}\n\tif ((data_dir == DMA_NONE) && user_srbcmd->sg.count) {\n\t\tdprintk((KERN_DEBUG\"aacraid: SG with no direction specified in Raw SRB command\\n\"));\n\t\trcode = -EINVAL;\n\t\tgoto cleanup;",
        "bug_line_number": [],
        "vul": 0,
        "id": 71
    },
    {
        "code": "static inline pgd_t *pgd_alloc(struct mm_struct *mm)\n{\n\tunsigned long *table = crst_table_alloc(mm);\n\tif (!table)\n\t\treturn NULL;\n\tif (mm->context.asce_limit == (1UL << 31)) {\n\t\t/* Forking a compat process with 2 page table levels */\n\t\tif (!pgtable_pmd_page_ctor(virt_to_page(table))) {\n\t\t\tcrst_table_free(mm, table);\n\t\t\treturn NULL;\n\t\t}\n\t}\n\treturn (pgd_t *) table;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 73
    },
    {
        "code": "static unsigned long ioapic_read_indirect(struct kvm_ioapic *ioapic,\n\t\t\t\t\t  unsigned long addr,\n\t\t\t\t\t  unsigned long length)\n{\n\tunsigned long result = 0;\n\tswitch (ioapic->ioregsel) {\n\tcase IOAPIC_REG_VERSION:\n\t\tresult = ((((IOAPIC_NUM_PINS - 1) & 0xff) << 16)\n\t\t\t  | (IOAPIC_VERSION_ID & 0xff));\n\t\tbreak;\n\tcase IOAPIC_REG_APIC_ID:\n\tcase IOAPIC_REG_ARB_ID:\n\t\tresult = ((ioapic->id & 0xf) << 24);\n\t\tbreak;\n\tdefault:\n\t\t{\n\t\t\tu32 redir_index = (ioapic->ioregsel - 0x10) >> 1;\n\t\t\tu64 redir_content;\n\t\t\tif (redir_index < IOAPIC_NUM_PINS)\n\t\t\t\tredir_content =\n\t\t\t\t\tioapic->redirtbl[redir_index].bits;\n\t\t\telse\n\t\t\t\tredir_content = ~0ULL;\n\t\t\tresult = (ioapic->ioregsel & 0x1) ?\n\t\t\t    (redir_content >> 32) & 0xffffffff :\n\t\t\t    redir_content & 0xffffffff;\n\t\t\tbreak;\n\t\t}\n\t}\n\treturn result;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 75
    },
    {
        "code": "static int do_fault(struct mm_struct *mm, struct vm_area_struct *vma,\n\t\tunsigned long address, pte_t *page_table, pmd_t *pmd,\n\t\tunsigned int flags, pte_t orig_pte)\n{\n\tpgoff_t pgoff = (((address & PAGE_MASK)\n\t\t\t- vma->vm_start) >> PAGE_SHIFT) + vma->vm_pgoff;\n\tpte_unmap(page_table);\n\t/* The VMA was not fully populated on mmap() or missing VM_DONTEXPAND */\n\tif (!vma->vm_ops->fault)\n\t\treturn VM_FAULT_SIGBUS;\n\tif (!(flags & FAULT_FLAG_WRITE))\n\t\treturn do_read_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\tif (!(vma->vm_flags & VM_SHARED))\n\t\treturn do_cow_fault(mm, vma, address, pmd, pgoff, flags,\n\t\t\t\torig_pte);\n\treturn do_shared_fault(mm, vma, address, pmd, pgoff, flags, orig_pte);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 77
    },
    {
        "code": "static int adjust_insn_aux_data(struct bpf_verifier_env *env, u32 prog_len,\n\t\t\t\tu32 off, u32 cnt)\n{\n\tstruct bpf_insn_aux_data *new_data, *old_data = env->insn_aux_data;\n\tint i;\n\tif (cnt == 1)\n\t\treturn 0;\n\tnew_data = vzalloc(sizeof(struct bpf_insn_aux_data) * prog_len);\n\tif (!new_data)\n\t\treturn -ENOMEM;\n\tmemcpy(new_data, old_data, sizeof(struct bpf_insn_aux_data) * off);\n\tmemcpy(new_data + off + cnt - 1, old_data + off,\n\t       sizeof(struct bpf_insn_aux_data) * (prog_len - off - cnt + 1));\n\tfor (i = off; i < off + cnt - 1; i++)\n\t\tnew_data[i].seen = true;\n\tenv->insn_aux_data = new_data;\n\tvfree(old_data);\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 79
    },
    {
        "code": "struct sctp_packet *sctp_packet_config(struct sctp_packet *packet,\n\t\t\t\t       __u32 vtag, int ecn_capable)\n{\n\tstruct sctp_chunk *chunk = NULL;\n\tSCTP_DEBUG_PRINTK(\"%s: packet:%p vtag:0x%x\\n\", __func__,\n\t\t\t  packet, vtag);\n\tpacket->vtag = vtag;\n\tif (ecn_capable && sctp_packet_empty(packet)) {\n\t\tchunk = sctp_get_ecne_prepend(packet->transport->asoc);\n\t\t/* If there a is a prepend chunk stick it on the list before\n\t\t * any other chunks get appended.\n\t\t */\n\t\tif (chunk)\n\t\t\tsctp_packet_append_chunk(packet, chunk);\n\t}\n\treturn packet;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 81
    },
    {
        "code": "struct tc_action *tcf_action_init_1(struct net *net, struct nlattr *nla,\n\t\t\t\t    struct nlattr *est, char *name, int ovr,\n\t\t\t\t    int bind)\n{\n\tstruct tc_action *a;\n\tstruct tc_action_ops *a_o;\n\tstruct tc_cookie *cookie = NULL;\n\tchar act_name[IFNAMSIZ];\n\tstruct nlattr *tb[TCA_ACT_MAX + 1];\n\tstruct nlattr *kind;\n\tint err;\n\tif (name == NULL) {\n\t\terr = nla_parse_nested(tb, TCA_ACT_MAX, nla, NULL);\n\t\tif (err < 0)\n\t\t\tgoto err_out;\n\t\terr = -EINVAL;\n\t\tkind = tb[TCA_ACT_KIND];\n\t\tif (kind == NULL)\n\t\t\tgoto err_out;\n\t\tif (nla_strlcpy(act_name, kind, IFNAMSIZ) >= IFNAMSIZ)\n\t\t\tgoto err_out;\n\t\tif (tb[TCA_ACT_COOKIE]) {\n\t\t\tint cklen = nla_len(tb[TCA_ACT_COOKIE]);\n\t\t\tif (cklen > TC_COOKIE_MAX_SIZE)\n\t\t\t\tgoto err_out;\n\t\t\tcookie = nla_memdup_cookie(tb);\n\t\t\tif (!cookie) {\n\t\t\t\terr = -ENOMEM;\n\t\t\t\tgoto err_out;\n\t\t\t}\n\t\t}\n\t} else {\n\t\terr = -EINVAL;\n\t\tif (strlcpy(act_name, name, IFNAMSIZ) >= IFNAMSIZ)\n\t\t\tgoto err_out;\n\t}\n\ta_o = tc_lookup_action_n(act_name);\n\tif (a_o == NULL) {\n#ifdef CONFIG_MODULES\n\t\trtnl_unlock();\n\t\trequest_module(\"act_%s\", act_name);\n\t\trtnl_lock();\n\t\ta_o = tc_lookup_action_n(act_name);\n\t\t/* We dropped the RTNL semaphore in order to\n\t\t * perform the module load.  So, even if we\n\t\t * succeeded in loading the module we have to\n\t\t * tell the caller to replay the request.  We\n\t\t * indicate this using -EAGAIN.\n\t\t */\n\t\tif (a_o != NULL) {\n\t\t\terr = -EAGAIN;\n\t\t\tgoto err_mod;\n\t\t}\n#endif\n\t\terr = -ENOENT;\n\t\tgoto err_out;\n\t}\n\t/* backward compatibility for policer */\n\tif (name == NULL)\n\t\terr = a_o->init(net, tb[TCA_ACT_OPTIONS], est, &a, ovr, bind);\n\telse\n\t\terr = a_o->init(net, nla, est, &a, ovr, bind);\n\tif (err < 0)\n\t\tgoto err_mod;\n\tif (name == NULL && tb[TCA_ACT_COOKIE]) {\n\t\tif (a->act_cookie) {\n\t\t\tkfree(a->act_cookie->data);\n\t\t\tkfree(a->act_cookie);\n\t\t}\n\t\ta->act_cookie = cookie;\n\t}\n\t/* module count goes up only when brand new policy is created\n\t * if it exists and is only bound to in a_o->init() then\n\t * ACT_P_CREATED is not returned (a zero is).\n\t */\n\tif (err != ACT_P_CREATED)\n\t\tmodule_put(a_o->owner);\n\treturn a;\nerr_mod:\n\tmodule_put(a_o->owner);\nerr_out:\n\tif (cookie) {\n\t\tkfree(cookie->data);\n\t\tkfree(cookie);\n\t}\n\treturn ERR_PTR(err);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 83
    },
    {
        "code": "int\nnfsd_dispatch(struct svc_rqst *rqstp, __be32 *statp)\n{\n\tstruct svc_procedure\t*proc;\n\tkxdrproc_t\t\txdr;\n\t__be32\t\t\tnfserr;\n\t__be32\t\t\t*nfserrp;\n\tdprintk(\"nfsd_dispatch: vers %d proc %d\\n\",\n\t\t\t\trqstp->rq_vers, rqstp->rq_proc);\n\tproc = rqstp->rq_procinfo;\n\tif (nfs_request_too_big(rqstp, proc)) {\n\t\tdprintk(\"nfsd: NFSv%d argument too large\\n\", rqstp->rq_vers);\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\t/*\n\t * Give the xdr decoder a chance to change this if it wants\n\t * (necessary in the NFSv4.0 compound case)\n\t */\n\trqstp->rq_cachetype = proc->pc_cachetype;\n\t/* Decode arguments */\n\txdr = proc->pc_decode;\n\tif (xdr && !xdr(rqstp, (__be32*)rqstp->rq_arg.head[0].iov_base,\n\t\t\trqstp->rq_argp)) {\n\t\tdprintk(\"nfsd: failed to decode arguments!\\n\");\n\t\t*statp = rpc_garbage_args;\n\t\treturn 1;\n\t}\n\t/* Check whether we have this call in the cache. */\n\tswitch (nfsd_cache_lookup(rqstp)) {\n\tcase RC_DROPIT:\n\t\treturn 0;\n\tcase RC_REPLY:\n\t\treturn 1;\n\tcase RC_DOIT:;\n\t\t/* do it */\n\t}\n\t/* need to grab the location to store the status, as\n\t * nfsv4 does some encoding while processing \n\t */\n\tnfserrp = rqstp->rq_res.head[0].iov_base\n\t\t+ rqstp->rq_res.head[0].iov_len;\n\trqstp->rq_res.head[0].iov_len += sizeof(__be32);\n\t/* Now call the procedure handler, and encode NFS status. */\n\tnfserr = proc->pc_func(rqstp, rqstp->rq_argp, rqstp->rq_resp);\n\tnfserr = map_new_errors(rqstp->rq_vers, nfserr);\n\tif (nfserr == nfserr_dropit || test_bit(RQ_DROPME, &rqstp->rq_flags)) {\n\t\tdprintk(\"nfsd: Dropping request; may be revisited later\\n\");\n\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\treturn 0;\n\t}\n\tif (rqstp->rq_proc != 0)\n\t\t*nfserrp++ = nfserr;\n\t/* Encode result.\n\t * For NFSv2, additional info is never returned in case of an error.\n\t */\n\tif (!(nfserr && rqstp->rq_vers == 2)) {\n\t\txdr = proc->pc_encode;\n\t\tif (xdr && !xdr(rqstp, nfserrp,\n\t\t\t\trqstp->rq_resp)) {\n\t\t\t/* Failed to encode result. Release cache entry */\n\t\t\tdprintk(\"nfsd: failed to encode result!\\n\");\n\t\t\tnfsd_cache_update(rqstp, RC_NOCACHE, NULL);\n\t\t\t*statp = rpc_system_err;\n\t\t\treturn 1;\n\t\t}\n\t}\n\t/* Store reply in cache. */\n\tnfsd_cache_update(rqstp, rqstp->rq_cachetype, statp + 1);\n\treturn 1;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 85
    },
    {
        "code": "static ext3_fsblk_t get_sb_block(void **data, struct super_block *sb)\n{\n\text3_fsblk_t\tsb_block;\n\tchar\t\t*options = (char *) *data;\n\tif (!options || strncmp(options, \"sb=\", 3) != 0)\n\t\treturn 1;\t/* Default location */\n\toptions += 3;\n\t/*todo: use simple_strtoll with >32bit ext3 */\n\tsb_block = simple_strtoul(options, &options, 0);\n\tif (*options && *options != ',') {\n\t\text3_msg(sb, KERN_ERR, \"error: invalid sb specification: %s\",\n\t\t       (char *) *data);\n\t\treturn 1;\n\t}\n\tif (*options == ',')\n\t\toptions++;\n\t*data = (void *) options;\n\treturn sb_block;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 87
    },
    {
        "code": "static int dccp_error(struct net *net, struct nf_conn *tmpl,\n\t\t      struct sk_buff *skb, unsigned int dataoff,\n\t\t      enum ip_conntrack_info *ctinfo,\n\t\t      u_int8_t pf, unsigned int hooknum)\n{\n\tstruct dccp_hdr _dh, *dh;\n\tunsigned int dccp_len = skb->len - dataoff;\n\tunsigned int cscov;\n\tconst char *msg;\n\tdh = skb_header_pointer(skb, dataoff, sizeof(_dh), &_dh);\n\tif (dh == NULL) {\n\t\tmsg = \"nf_ct_dccp: short packet \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_doff * 4 < sizeof(struct dccp_hdr) ||\n\t    dh->dccph_doff * 4 > dccp_len) {\n\t\tmsg = \"nf_ct_dccp: truncated/malformed packet \";\n\t\tgoto out_invalid;\n\t}\n\tcscov = dccp_len;\n\tif (dh->dccph_cscov) {\n\t\tcscov = (dh->dccph_cscov - 1) * 4;\n\t\tif (cscov > dccp_len) {\n\t\t\tmsg = \"nf_ct_dccp: bad checksum coverage \";\n\t\t\tgoto out_invalid;\n\t\t}\n\t}\n\tif (net->ct.sysctl_checksum && hooknum == NF_INET_PRE_ROUTING &&\n\t    nf_checksum_partial(skb, hooknum, dataoff, cscov, IPPROTO_DCCP,\n\t\t\t\tpf)) {\n\t\tmsg = \"nf_ct_dccp: bad checksum \";\n\t\tgoto out_invalid;\n\t}\n\tif (dh->dccph_type >= DCCP_PKT_INVALID) {\n\t\tmsg = \"nf_ct_dccp: reserved packet type \";\n\t\tgoto out_invalid;\n\t}\n\treturn NF_ACCEPT;\nout_invalid:\n\tif (LOG_INVALID(net, IPPROTO_DCCP))\n\t\tnf_log_packet(net, pf, 0, skb, NULL, NULL, NULL, \"%s\", msg);\n\treturn -NF_ACCEPT;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 89
    },
    {
        "code": "static int security_context_to_sid_core(const char *scontext, u32 scontext_len,\n\t\t\t\t\tu32 *sid, u32 def_sid, gfp_t gfp_flags,\n\t\t\t\t\tint force)\n{\n\tchar *scontext2, *str = NULL;\n\tstruct context context;\n\tint rc = 0;\n\t/* An empty security context is never valid. */\n\tif (!scontext_len)\n\t\treturn -EINVAL;\n\tif (!ss_initialized) {\n\t\tint i;\n\t\tfor (i = 1; i < SECINITSID_NUM; i++) {\n\t\t\tif (!strcmp(initial_sid_to_string[i], scontext)) {\n\t\t\t\t*sid = i;\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\t*sid = SECINITSID_KERNEL;\n\t\treturn 0;\n\t}\n\t*sid = SECSID_NULL;\n\t/* Copy the string so that we can modify the copy as we parse it. */\n\tscontext2 = kmalloc(scontext_len + 1, gfp_flags);\n\tif (!scontext2)\n\t\treturn -ENOMEM;\n\tmemcpy(scontext2, scontext, scontext_len);\n\tscontext2[scontext_len] = 0;\n\tif (force) {\n\t\t/* Save another copy for storing in uninterpreted form */\n\t\trc = -ENOMEM;\n\t\tstr = kstrdup(scontext2, gfp_flags);\n\t\tif (!str)\n\t\t\tgoto out;\n\t}\n\tread_lock(&policy_rwlock);\n\trc = string_to_context_struct(&policydb, &sidtab, scontext2,\n\t\t\t\t      scontext_len, &context, def_sid);\n\tif (rc == -EINVAL && force) {\n\t\tcontext.str = str;\n\t\tcontext.len = scontext_len;\n\t\tstr = NULL;\n\t} else if (rc)\n\t\tgoto out_unlock;\n\trc = sidtab_context_to_sid(&sidtab, &context, sid);\n\tcontext_destroy(&context);\nout_unlock:\n\tread_unlock(&policy_rwlock);\nout:\n\tkfree(scontext2);\n\tkfree(str);\n\treturn rc;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 91
    }
]