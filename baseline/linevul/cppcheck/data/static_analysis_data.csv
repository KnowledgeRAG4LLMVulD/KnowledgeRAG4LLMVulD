,source,flaw_line_indices,flaw_lines
0,"xmlXPathNextPrecedingInternal(xmlXPathParserContextPtr ctxt,
xmlNodePtr cur)
{
if ((ctxt == NULL) || (ctxt->context == NULL)) return(NULL);
    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||
	(ctxt->context->node->type == XML_NAMESPACE_DECL))
	return(NULL);
if (cur == NULL) {
cur = ctxt->context->node;
if (cur == NULL)
return (NULL);
ctxt->ancestor = cur->parent;
}
if ((cur->prev != NULL) && (cur->prev->type == XML_DTD_NODE))
cur = cur->prev;
while (cur->prev == NULL) {
cur = cur->parent;
if (cur == NULL)
return (NULL);
if (cur == ctxt->context->doc->children)
return (NULL);
if (cur != ctxt->ancestor)
return (cur);
ctxt->ancestor = cur->parent;
}
cur = cur->prev;
while (cur->last != NULL)
cur = cur->last;
return (cur);
}
","[4, 5, 6, 10, 18, 20]",    if ((ctxt->context->node->type == XML_ATTRIBUTE_NODE) ||/~/	(ctxt->context->node->type == XML_NAMESPACE_DECL))/~/	return(NULL);
1,"PHP_FUNCTION(imageconvolution)
{
zval *SIM, *hash_matrix;
zval **var = NULL, **var2 = NULL;
gdImagePtr im_src = NULL;
double div, offset;
int nelem, i, j, res;
float matrix[3][3] = {{0,0,0}, {0,0,0}, {0,0,0}};

if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""radd"", &SIM, &hash_matrix, &div, &offset) == FAILURE) {
RETURN_FALSE;
}

ZEND_FETCH_RESOURCE(im_src, gdImagePtr, &SIM, -1, ""Image"", le_gd);

nelem = zend_hash_num_elements(Z_ARRVAL_P(hash_matrix));
if (nelem != 3) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
RETURN_FALSE;
}

for (i=0; i<3; i++) {
if (zend_hash_index_find(Z_ARRVAL_P(hash_matrix), (i), (void **) &var) == SUCCESS && Z_TYPE_PP(var) == IS_ARRAY) {
if (Z_TYPE_PP(var) != IS_ARRAY || zend_hash_num_elements(Z_ARRVAL_PP(var)) != 3 ) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have 3x3 array"");
RETURN_FALSE;
}

for (j=0; j<3; j++) {
if (zend_hash_index_find(Z_ARRVAL_PP(var), (j), (void **) &var2) == SUCCESS) {
					SEPARATE_ZVAL(var2);
					convert_to_double(*var2);
					matrix[i][j] = (float)Z_DVAL_PP(var2);
} else {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""You must have a 3x3 matrix"");
RETURN_FALSE;
}
}
}
}
res = gdImageConvolution(im_src, matrix, (float)div, (float)offset);

if (res) {
RETURN_TRUE;
} else {
RETURN_FALSE;
}
}
","[25, 26]",					SEPARATE_ZVAL(var2);/~/					convert_to_double(*var2);/~/					matrix[i][j] = (float)Z_DVAL_PP(var2);
2,"void ExtensionTtsController::Stop() {
  if (current_utterance_ && !current_utterance_->extension_id().empty()) {
    current_utterance_->profile()->GetExtensionEventRouter()->
        DispatchEventToExtension(
            current_utterance_->extension_id(),
            events::kOnStop,
            ""[]"",
            current_utterance_->profile(),
            GURL());
  } else {
    GetPlatformImpl()->clear_error();
    GetPlatformImpl()->StopSpeaking();
}

  if (current_utterance_)
    current_utterance_->set_error(kSpeechInterruptedError);
  FinishCurrentUtterance();
  ClearUtteranceQueue();
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]","  if (current_utterance_ && !current_utterance_->extension_id().empty()) {/~/    current_utterance_->profile()->GetExtensionEventRouter()->/~/        DispatchEventToExtension(/~/            current_utterance_->extension_id(),/~/            events::kOnStop,/~/            ""[]"",/~/            current_utterance_->profile(),/~/            GURL());/~/  } else {/~/    GetPlatformImpl()->clear_error();/~/    GetPlatformImpl()->StopSpeaking();/~/  if (current_utterance_)/~/    current_utterance_->set_error(kSpeechInterruptedError);/~/  FinishCurrentUtterance();/~/  ClearUtteranceQueue();/~/}"
3,"SYSCALL_DEFINE5(waitid, int, which, pid_t, upid, struct siginfo __user *,
infop, int, options, struct rusage __user *, ru)
{
struct rusage r;
struct waitid_info info = {.status = 0};
long err = kernel_waitid(which, upid, &info, options, ru ? &r : NULL);
int signo = 0;
if (err > 0) {
signo = SIGCHLD;
err = 0;
	}
	if (!err) {
if (ru && copy_to_user(ru, &r, sizeof(struct rusage)))
return -EFAULT;
}
if (!infop)
return err;

user_access_begin();
unsafe_put_user(signo, &infop->si_signo, Efault);
unsafe_put_user(0, &infop->si_errno, Efault);
unsafe_put_user(info.cause, &infop->si_code, Efault);
unsafe_put_user(info.pid, &infop->si_pid, Efault);
unsafe_put_user(info.uid, &infop->si_uid, Efault);
unsafe_put_user(info.status, &infop->si_status, Efault);
user_access_end();
return err;
Efault:
user_access_end();
return -EFAULT;
}
","[10, 11, 14, 29]",	}/~/	if (!err) {
4,"void *arm_dma_alloc(struct device *dev, size_t size, dma_addr_t *handle,
gfp_t gfp, struct dma_attrs *attrs)
{
	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);
void *memory;

if (dma_alloc_from_coherent(dev, size, handle, &memory))
return memory;

return __dma_alloc(dev, size, handle, gfp, prot, false,
__builtin_return_address(0));
}
",[3],"	pgprot_t prot = __get_dma_pgprot(attrs, pgprot_kernel);"
5,"gray_render_span( int             y,
int             count,
const FT_Span*  spans,
PWorker         worker )
{
unsigned char*  p;
FT_Bitmap*      map = &worker->target;


/* first of all, compute the scanline offset */
p = (unsigned char*)map->buffer - y * map->pitch;
if ( map->pitch >= 0 )
      p += ( map->rows - 1 ) * map->pitch;

for ( ; count > 0; count--, spans++ )
{
unsigned char  coverage = spans->coverage;


if ( coverage )
{
/* For small-spans it is faster to do it by ourselves than
* calling `memset'.  This is mainly due to the cost of the
* function call.
*/
if ( spans->len >= 8 )
FT_MEM_SET( p + spans->x, (unsigned char)coverage, spans->len );
else
{
unsigned char*  q = p + spans->x;


switch ( spans->len )
{
case 7: *q++ = (unsigned char)coverage;
case 6: *q++ = (unsigned char)coverage;
case 5: *q++ = (unsigned char)coverage;
case 4: *q++ = (unsigned char)coverage;
case 3: *q++ = (unsigned char)coverage;
case 2: *q++ = (unsigned char)coverage;
case 1: *q   = (unsigned char)coverage;
default:
;
}
}
}
}
}
",[10],      p += ( map->rows - 1 ) * map->pitch;
6,"static int compile_search(struct Context *ctx, const struct Pattern *pat, struct Buffer *buf)
{
if (do_search(pat, 0) == 0)
return 0;

if (pat->not)
mutt_buffer_addstr(buf, ""NOT "");

if (pat->child)
{
int clauses;

clauses = do_search(pat->child, 1);
if (clauses > 0)
{
const struct Pattern *clause = pat->child;

mutt_buffer_addch(buf, '(');

while (clauses)
{
if (do_search(clause, 0))
{
if (pat->op == MUTT_OR && clauses > 1)
mutt_buffer_addstr(buf, ""OR "");
clauses--;

if (compile_search(ctx, clause, buf) < 0)
return -1;

if (clauses)
mutt_buffer_addch(buf, ' ');
}
clause = clause->next;
}

mutt_buffer_addch(buf, ')');
}
}
else
{
char term[STRING];
char *delim = NULL;

switch (pat->op)
{
case MUTT_HEADER:
mutt_buffer_addstr(buf, ""HEADER "");

/* extract header name */
delim = strchr(pat->p.str, ':');
if (!delim)
{
mutt_error(_(""Header search without header name: %s""), pat->p.str);
return -1;
}
*delim = '\0';
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
mutt_buffer_addch(buf, ' ');

/* and field */
*delim = ':';
delim++;
SKIPWS(delim);
        imap_quote_string(term, sizeof(term), delim);
mutt_buffer_addstr(buf, term);
break;
case MUTT_BODY:
mutt_buffer_addstr(buf, ""BODY "");
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
break;
case MUTT_WHOLE_MSG:
mutt_buffer_addstr(buf, ""TEXT "");
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
break;
case MUTT_SERVERSEARCH:
{
struct ImapData *idata = ctx->data;
if (!mutt_bit_isset(idata->capabilities, X_GM_EXT1))
{
mutt_error(_(""Server-side custom search not supported: %s""), pat->p.str);
return -1;
}
}
mutt_buffer_addstr(buf, ""X-GM-RAW "");
        imap_quote_string(term, sizeof(term), pat->p.str);
mutt_buffer_addstr(buf, term);
break;
}
}

return 0;
}
","[47, 54]","        imap_quote_string(term, sizeof(term), pat->p.str);/~/        imap_quote_string(term, sizeof(term), delim);/~/        imap_quote_string(term, sizeof(term), pat->p.str);/~/        imap_quote_string(term, sizeof(term), pat->p.str);/~/        imap_quote_string(term, sizeof(term), pat->p.str);"
7,"bool UnprivilegedProcessDelegate::CreateConnectedIpcChannel(
    const std::string& channel_name,
    IPC::Listener* delegate,
    ScopedHandle* client_out,
    scoped_ptr<IPC::ChannelProxy>* server_out) {
  // Create the server end of the channel.
  scoped_ptr<IPC::ChannelProxy> server;
  if (!CreateIpcChannel(channel_name, kDaemonIpcSecurityDescriptor,
                        io_task_runner_, delegate, &server)) {
    return false;
  }
  // Convert the channel name to the pipe name.
  std::string pipe_name(kChromePipeNamePrefix);
  pipe_name.append(channel_name);
  SECURITY_ATTRIBUTES security_attributes;
  security_attributes.nLength = sizeof(security_attributes);
  security_attributes.lpSecurityDescriptor = NULL;
  security_attributes.bInheritHandle = TRUE;
  // Create the client end of the channel. This code should match the code in
  // IPC::Channel.
  ScopedHandle client;
  client.Set(CreateFile(UTF8ToUTF16(pipe_name).c_str(),
                        GENERIC_READ | GENERIC_WRITE,
                        0,
                        &security_attributes,
                        OPEN_EXISTING,
                        SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION |
                            FILE_FLAG_OVERLAPPED,
                        NULL));
  if (!client.IsValid())
    return false;
  *client_out = client.Pass();
  *server_out = server.Pass();
  return true;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26]","    const std::string& channel_name,/~/    IPC::Listener* delegate,/~/    ScopedHandle* client_out,/~/    scoped_ptr<IPC::ChannelProxy>* server_out) {/~/  // Create the server end of the channel./~/  scoped_ptr<IPC::ChannelProxy> server;/~/  if (!CreateIpcChannel(channel_name, kDaemonIpcSecurityDescriptor,/~/                        io_task_runner_, delegate, &server)) {/~/    return false;/~/  }/~/  // Convert the channel name to the pipe name./~/  std::string pipe_name(kChromePipeNamePrefix);/~/  pipe_name.append(channel_name);/~/  SECURITY_ATTRIBUTES security_attributes;/~/  security_attributes.nLength = sizeof(security_attributes);/~/  security_attributes.lpSecurityDescriptor = NULL;/~/  security_attributes.bInheritHandle = TRUE;/~/  // Create the client end of the channel. This code should match the code in/~/  // IPC::Channel./~/  ScopedHandle client;/~/  client.Set(CreateFile(UTF8ToUTF16(pipe_name).c_str(),/~/                        GENERIC_READ | GENERIC_WRITE,/~/                        0,/~/                        &security_attributes,/~/                        OPEN_EXISTING,/~/                        SECURITY_SQOS_PRESENT | SECURITY_IDENTIFICATION |/~/                            FILE_FLAG_OVERLAPPED,/~/                        NULL));/~/  if (!client.IsValid())/~/    return false;/~/  *client_out = client.Pass();/~/  *server_out = server.Pass();/~/  return true;/~/}"
8,"static MagickBooleanType ReadDXT5(Image *image, DDSInfo *dds_info,
ExceptionInfo *exception)
{
DDSColors
colors;

ssize_t
j,
y;

MagickSizeType
alpha_bits;

PixelPacket
*q;

register ssize_t
i,
x;

unsigned char
a0,
a1;

size_t
alpha,
bits,
code,
alpha_code;

unsigned short
c0,
c1;

for (y = 0; y < (ssize_t) dds_info->height; y += 4)
{
for (x = 0; x < (ssize_t) dds_info->width; x += 4)
{
/* Get 4x4 patch of pixels to write on */
      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),
                         Min(4, dds_info->height - y),exception);

if (q == (PixelPacket *) NULL)
return MagickFalse;

/* Read alpha values (8 bytes) */
a0 = (unsigned char) ReadBlobByte(image);
a1 = (unsigned char) ReadBlobByte(image);

alpha_bits = (MagickSizeType)ReadBlobLSBLong(image);
alpha_bits = alpha_bits | ((MagickSizeType)ReadBlobLSBShort(image) << 32);

/* Read 8 bytes of data from the image */
c0 = ReadBlobLSBShort(image);
c1 = ReadBlobLSBShort(image);
bits = ReadBlobLSBLong(image);

CalculateColors(c0, c1, &colors, MagickTrue);

/* Write the pixels */
for (j = 0; j < 4; j++)
{
for (i = 0; i < 4; i++)
{
if ((x + i) < (ssize_t) dds_info->width && (y + j) < (ssize_t) dds_info->height)
{
code = (bits >> ((4*j+i)*2)) & 0x3;
SetPixelRed(q,ScaleCharToQuantum(colors.r[code]));
SetPixelGreen(q,ScaleCharToQuantum(colors.g[code]));
SetPixelBlue(q,ScaleCharToQuantum(colors.b[code]));
/* Extract alpha value */
alpha_code = (size_t) (alpha_bits >> (3*(4*j+i))) & 0x7;
if (alpha_code == 0)
alpha = a0;
else if (alpha_code == 1)
alpha = a1;
else if (a0 > a1)
alpha = ((8-alpha_code) * a0 + (alpha_code-1) * a1) / 7;
else if (alpha_code == 6)
alpha = 0;
else if (alpha_code == 7)
alpha = 255;
else
alpha = (((6-alpha_code) * a0 + (alpha_code-1) * a1) / 5);
SetPixelAlpha(q,ScaleCharToQuantum((unsigned char)
alpha));
q++;
}
}
}

if (SyncAuthenticPixels(image,exception) == MagickFalse)
return MagickFalse;
}
}

  SkipDXTMipmaps(image, dds_info, 16);
  return MagickTrue;
}
","[31, 32]","      q = QueueAuthenticPixels(image, x, y, Min(4, dds_info->width - x),/~/                         Min(4, dds_info->height - y),exception);/~/  SkipDXTMipmaps(image, dds_info, 16);/~/  return MagickTrue;"
9,"SchedulerObject::_continue(std::string key, std::string &/*reason*/, std::string &text)
{
PROC_ID id = getProcByString(key.c_str());
       if (id.cluster < 0 || id.proc < 0) {
dprintf(D_FULLDEBUG, ""Remove: Failed to parse id: %s\n"", key.c_str());
text = ""Invalid Id"";
return false;
}

scheduler.enqueueActOnJobMyself(id,JA_CONTINUE_JOBS,true);

return true;
}
",[3],       if (id.cluster < 0 || id.proc < 0) {
10,"make_error(png_store* volatile psIn, png_byte PNG_CONST colour_type,
png_byte bit_depth, int interlace_type, int test, png_const_charp name)
{
   png_store * volatile ps = psIn;
context(ps, fault);

check_interlace_type(interlace_type);

Try
{
      png_structp pp;
png_infop pi;
      pp = set_store_for_write(ps, &pi, name);

if (pp == NULL)
Throw ps;

      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),
         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,
         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

if (colour_type == 3) /* palette */
init_standard_palette(ps, pp, pi, 1U << bit_depth, 0/*do tRNS*/);

/* Time for a few errors; these are in various optional chunks, the
* standard tests test the standard chunks pretty well.
*/
#     define exception__prev exception_prev_1

#     define exception__env exception_env_1
Try
{
/* Expect this to throw: */
ps->expect_error = !error_test[test].warning;
ps->expect_warning = error_test[test].warning;
ps->saw_warning = 0;
error_test[test].fn(pp, pi);

/* Normally the error is only detected here: */
png_write_info(pp, pi);

/* And handle the case where it was only a warning: */
if (ps->expect_warning && ps->saw_warning)
Throw ps;

/* If we get here there is a problem, we have success - no error or
* no warning - when we shouldn't have success.  Log an error.
*/
store_log(ps, pp, error_test[test].msg, 1 /*error*/);

}

Catch (fault)
         ps = fault; /* expected exit, make sure ps is not clobbered *
#undef exception__prev
#undef exception__env

/* And clear these flags */
ps->expect_error = 0;
ps->expect_warning = 0;

/* Now write the whole image, just to make sure that the detected, or
* undetected, errro has not created problems inside libpng.
*/
if (png_get_rowbytes(pp, pi) !=
transform_rowsize(pp, colour_type, bit_depth))
png_error(pp, ""row size incorrect"");


else
{
         png_uint_32 h = transform_height(pp, colour_type, bit_depth);
         int npasses = png_set_interlace_handling(pp);
int pass;

if (npasses != npasses_from_interlace_type(pp, interlace_type))
png_error(pp, ""write: png_set_interlace_handling failed"");

for (pass=0; pass<npasses; ++pass)
{
png_uint_32 y;

for (y=0; y<h; ++y)
{

png_byte buffer[TRANSFORM_ROWMAX];

transform_row(pp, buffer, colour_type, bit_depth, y);
png_write_row(pp, buffer);
}
}
}

png_write_end(pp, pi);

/* The following deletes the file that was just written. */
store_write_reset(ps);
}

Catch(fault)
{
store_write_reset(fault);
}

}
","[3, 8, 10, 13, 14, 15]","   png_store * volatile ps = psIn;/~/      png_structp pp;/~/      pp = set_store_for_write(ps, &pi, name);/~/      png_set_IHDR(pp, pi, transform_width(pp, colour_type, bit_depth),/~/         transform_height(pp, colour_type, bit_depth), bit_depth, colour_type,/~/         interlace_type, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);/~/         ps = fault; /* expected exit, make sure ps is not clobbered */~/         png_uint_32 h = transform_height(pp, colour_type, bit_depth);/~/         int npasses = png_set_interlace_handling(pp);"
11,"isoent_gen_joliet_identifier(struct archive_write *a, struct isoent *isoent,
struct idr *idr)
{
struct iso9660 *iso9660;
struct isoent *np;
unsigned char *p;
size_t l;
int r;
	int ffmax, parent_len;
static const struct archive_rb_tree_ops rb_ops = {
isoent_cmp_node_joliet, isoent_cmp_key_joliet
};

if (isoent->children.cnt == 0)
return (0);

iso9660 = a->format_data;
if (iso9660->opt.joliet == OPT_JOLIET_LONGNAME)
ffmax = 206;
else
ffmax = 128;

	r = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);
if (r < 0)
return (r);

parent_len = 1;
for (np = isoent; np->parent != np; np = np->parent)
parent_len += np->mb_len + 1;

for (np = isoent->children.first; np != NULL; np = np->chnext) {
unsigned char *dot;
int ext_off, noff, weight;
size_t lt;

		if ((int)(l = np->file->basename_utf16.length) > ffmax)
l = ffmax;

p = malloc((l+1)*2);
if (p == NULL) {
archive_set_error(&a->archive, ENOMEM,
""Can't allocate memory"");
return (ARCHIVE_FATAL);
}
memcpy(p, np->file->basename_utf16.s, l);
p[l] = 0;
p[l+1] = 0;

np->identifier = (char *)p;
lt = l;
dot = p + l;
weight = 0;
while (lt > 0) {
if (!joliet_allowed_char(p[0], p[1]))
archive_be16enc(p, 0x005F); /* '_' */
else if (p[0] == 0 && p[1] == 0x2E) /* '.' */
dot = p;
p += 2;
lt -= 2;
}
ext_off = (int)(dot - (unsigned char *)np->identifier);
np->ext_off = ext_off;
np->ext_len = (int)l - ext_off;
np->id_len = (int)l;

/*
* Get a length of MBS of a full-pathname.
*/
		if ((int)np->file->basename_utf16.length > ffmax) {
if (archive_strncpy_l(&iso9660->mbs,
(const char *)np->identifier, l,
iso9660->sconv_from_utf16be) != 0 &&
errno == ENOMEM) {
archive_set_error(&a->archive, errno,
""No memory"");
return (ARCHIVE_FATAL);
}
np->mb_len = (int)iso9660->mbs.length;
if (np->mb_len != (int)np->file->basename.length)
weight = np->mb_len;
} else
np->mb_len = (int)np->file->basename.length;

/* If a length of full-pathname is longer than 240 bytes,
* it violates Joliet extensions regulation. */
		if (parent_len + np->mb_len > 240) {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
""The regulation of Joliet extensions;""
"" A length of a full-pathname of `%s' is ""
""longer than 240 bytes, (p=%d, b=%d)"",
archive_entry_pathname(np->file->entry),
(int)parent_len, (int)np->mb_len);
return (ARCHIVE_FATAL);
}

/* Make an offset of the number which is used to be set
* hexadecimal number to avoid duplicate identifier. */
		if ((int)l == ffmax)
noff = ext_off - 6;
		else if ((int)l == ffmax-2)
noff = ext_off - 4;
		else if ((int)l == ffmax-4)
noff = ext_off - 2;
else
noff = ext_off;
/* Register entry to the identifier resolver. */
idr_register(idr, np, weight, noff);
}

/* Resolve duplicate identifier with Joliet Volume. */
idr_resolve(idr, idr_set_num_beutf16);

return (ARCHIVE_OK);
}
","[8, 19, 29]","	int ffmax, parent_len;/~/	r = idr_start(a, idr, isoent->children.cnt, ffmax, 6, 2, &rb_ops);/~/		if ((int)(l = np->file->basename_utf16.length) > ffmax)/~/		if ((int)np->file->basename_utf16.length > ffmax) {/~/		if (parent_len + np->mb_len > 240) {/~/		if ((int)l == ffmax)/~/		else if ((int)l == ffmax-2)/~/		else if ((int)l == ffmax-4)"
12,"key_ref_t key_create_or_update(key_ref_t keyring_ref,
const char *type,
const char *description,
const void *payload,
size_t plen,
key_perm_t perm,
unsigned long flags)
{
struct keyring_index_key index_key = {
.description	= description,
};
struct key_preparsed_payload prep;
struct assoc_array_edit *edit;
const struct cred *cred = current_cred();
struct key *keyring, *key = NULL;
key_ref_t key_ref;
int ret;

/* look up the key type to see if it's one of the registered kernel
* types */
index_key.type = key_type_lookup(type);
if (IS_ERR(index_key.type)) {
key_ref = ERR_PTR(-ENODEV);
goto error;
}

key_ref = ERR_PTR(-EINVAL);
	if (!index_key.type->match || !index_key.type->instantiate ||
(!index_key.description && !index_key.type->preparse))
goto error_put_type;

keyring = key_ref_to_ptr(keyring_ref);

key_check(keyring);

key_ref = ERR_PTR(-ENOTDIR);
if (keyring->type != &key_type_keyring)
goto error_put_type;

memset(&prep, 0, sizeof(prep));
prep.data = payload;
prep.datalen = plen;
prep.quotalen = index_key.type->def_datalen;
prep.trusted = flags & KEY_ALLOC_TRUSTED;
prep.expiry = TIME_T_MAX;
if (index_key.type->preparse) {
ret = index_key.type->preparse(&prep);
if (ret < 0) {
key_ref = ERR_PTR(ret);
goto error_free_prep;
}
if (!index_key.description)
index_key.description = prep.description;
key_ref = ERR_PTR(-EINVAL);
if (!index_key.description)
goto error_free_prep;
}
index_key.desc_len = strlen(index_key.description);

key_ref = ERR_PTR(-EPERM);
if (!prep.trusted && test_bit(KEY_FLAG_TRUSTED_ONLY, &keyring->flags))
goto error_free_prep;
flags |= prep.trusted ? KEY_ALLOC_TRUSTED : 0;

ret = __key_link_begin(keyring, &index_key, &edit);
if (ret < 0) {
key_ref = ERR_PTR(ret);
goto error_free_prep;
}

/* if we're going to allocate a new key, we're going to have
* to modify the keyring */
ret = key_permission(keyring_ref, KEY_NEED_WRITE);
if (ret < 0) {
key_ref = ERR_PTR(ret);
goto error_link_end;
}

/* if it's possible to update this type of key, search for an existing
* key of the same type and description in the destination keyring and
* update that instead if possible
*/
if (index_key.type->update) {
key_ref = find_key_to_update(keyring_ref, &index_key);
if (key_ref)
goto found_matching_key;
}

/* if the client doesn't provide, decide on the permissions we want */
if (perm == KEY_PERM_UNDEF) {
perm = KEY_POS_VIEW | KEY_POS_SEARCH | KEY_POS_LINK | KEY_POS_SETATTR;
perm |= KEY_USR_VIEW;

if (index_key.type->read)
perm |= KEY_POS_READ;

if (index_key.type == &key_type_keyring ||
index_key.type->update)
perm |= KEY_POS_WRITE;
}

/* allocate a new key */
key = key_alloc(index_key.type, index_key.description,
cred->fsuid, cred->fsgid, cred, perm, flags);
if (IS_ERR(key)) {
key_ref = ERR_CAST(key);
goto error_link_end;
}

/* instantiate it and link it into the target keyring */
ret = __key_instantiate_and_link(key, &prep, keyring, NULL, &edit);
if (ret < 0) {
key_put(key);
key_ref = ERR_PTR(ret);
goto error_link_end;
}

key_ref = make_key_ref(key, is_key_possessed(keyring_ref));

error_link_end:
__key_link_end(keyring, &index_key, edit);
error_free_prep:
if (index_key.type->preparse)
index_key.type->free_preparse(&prep);
error_put_type:
key_type_put(index_key.type);
error:
return key_ref;

found_matching_key:
/* we found a matching key, so we're going to try to update it
* - we can drop the locks first as we have the key pinned
*/
__key_link_end(keyring, &index_key, edit);

key_ref = __key_update(key_ref, &prep);
goto error_free_prep;
}
",[26],	if (!index_key.type->match || !index_key.type->instantiate ||
13,"IDNConversionResult IDNToUnicodeWithAdjustmentsImpl(
base::StringPiece host,
base::OffsetAdjuster::Adjustments* adjustments,
bool enable_spoof_checks) {
if (adjustments)
adjustments->clear();
// Convert the ASCII input to a base::string16 for ICU.
base::string16 input16;
input16.reserve(host.length());
input16.insert(input16.end(), host.begin(), host.end());

  bool is_tld_ascii = true;
size_t last_dot = host.rfind('.');
  if (last_dot != base::StringPiece::npos &&
      host.substr(last_dot).starts_with("".xn--"")) {
    is_tld_ascii = false;
}

IDNConversionResult result;
// Do each component of the host separately, since we enforce script matching
// on a per-component basis.
base::string16 out16;
for (size_t component_start = 0, component_end;
component_start < input16.length();
component_start = component_end + 1) {
// Find the end of the component.
component_end = input16.find('.', component_start);
if (component_end == base::string16::npos)
component_end = input16.length();  // For getting the last component.
size_t component_length = component_end - component_start;
size_t new_component_start = out16.length();
bool converted_idn = false;
if (component_end > component_start) {
// Add the substring that we just found.
bool has_idn_component = false;
converted_idn = IDNToUnicodeOneComponent(
          input16.data() + component_start, component_length, is_tld_ascii,
enable_spoof_checks, &out16, &has_idn_component);
result.has_idn_component |= has_idn_component;
}
size_t new_component_length = out16.length() - new_component_start;

if (converted_idn && adjustments) {
adjustments->push_back(base::OffsetAdjuster::Adjustment(
component_start, component_length, new_component_length));
}

// Need to add the dot we just found (if we found one).
if (component_end < input16.length())
out16.push_back('.');
}

result.result = out16;

// Leave as punycode any inputs that spoof top domains.
if (result.has_idn_component) {
result.matching_top_domain =
g_idn_spoof_checker.Get().GetSimilarTopDomain(out16);
if (enable_spoof_checks && !result.matching_top_domain.domain.empty()) {
if (adjustments)
adjustments->clear();
result.result = input16;
}
}

return result;
}
","[10, 12, 13, 14, 34]","  bool is_tld_ascii = true;/~/  if (last_dot != base::StringPiece::npos &&/~/      host.substr(last_dot).starts_with("".xn--"")) {/~/    is_tld_ascii = false;/~/          input16.data() + component_start, component_length, is_tld_ascii,"
14,"static int hns_xgmac_get_sset_count(int stringset)
{
	if (stringset == ETH_SS_STATS)
return ARRAY_SIZE(g_xgmac_stats_string);

return 0;
}
",[2],	if (stringset == ETH_SS_STATS)
15,"static ssize_t snd_timer_user_read(struct file *file, char __user *buffer,
size_t count, loff_t *offset)
{
struct snd_timer_user *tu;
long result = 0, unit;
int qhead;
int err = 0;

tu = file->private_data;
unit = tu->tread ? sizeof(struct snd_timer_tread) : sizeof(struct snd_timer_read);
spin_lock_irq(&tu->qlock);
while ((long)count - result >= unit) {
while (!tu->qused) {
wait_queue_t wait;

if ((file->f_flags & O_NONBLOCK) != 0 || result > 0) {
err = -EAGAIN;
goto _error;
}

set_current_state(TASK_INTERRUPTIBLE);
init_waitqueue_entry(&wait, current);
add_wait_queue(&tu->qchange_sleep, &wait);

spin_unlock_irq(&tu->qlock);
schedule();
spin_lock_irq(&tu->qlock);

remove_wait_queue(&tu->qchange_sleep, &wait);

if (tu->disconnected) {
err = -ENODEV;
goto _error;
}
if (signal_pending(current)) {
err = -ERESTARTSYS;
goto _error;
}
}

qhead = tu->qhead++;
tu->qhead %= tu->queue_size;
tu->qused--;
spin_unlock_irq(&tu->qlock);

		mutex_lock(&tu->ioctl_lock);
if (tu->tread) {
if (copy_to_user(buffer, &tu->tqueue[qhead],
sizeof(struct snd_timer_tread)))
err = -EFAULT;
} else {
if (copy_to_user(buffer, &tu->queue[qhead],
sizeof(struct snd_timer_read)))
err = -EFAULT;
}
		mutex_unlock(&tu->ioctl_lock);

spin_lock_irq(&tu->qlock);
if (err < 0)
goto _error;
result += unit;
buffer += unit;
}
_error:
spin_unlock_irq(&tu->qlock);
return result > 0 ? result : err;
}
",[37],		mutex_lock(&tu->ioctl_lock);/~/		mutex_unlock(&tu->ioctl_lock);
16,"void GoBackCrossSite() {
NavigationEntry* entry = contents()->controller().GetEntryAtOffset(-1);
ASSERT_TRUE(entry);
contents()->controller().GoBack();

    // The navigation should commit in the pending RVH.
    contents()->TestDidNavigate(
        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),
        content::PAGE_TRANSITION_TYPED);
}
","[4, 5, 6, 7]","    // The navigation should commit in the pending RVH./~/    contents()->TestDidNavigate(/~/        contents()->pending_rvh(), entry->page_id(), GURL(entry->url()),/~/        content::PAGE_TRANSITION_TYPED);"
17,"static void ext2_put_super (struct super_block * sb)
{
int db_count;
int i;
struct ext2_sb_info *sbi = EXT2_SB(sb);

dquot_disable(sb, -1, DQUOT_USAGE_ENABLED | DQUOT_LIMITS_ENABLED);

	ext2_xattr_put_super(sb);
if (!(sb->s_flags & MS_RDONLY)) {
struct ext2_super_block *es = sbi->s_es;

spin_lock(&sbi->s_lock);
es->s_state = cpu_to_le16(sbi->s_mount_state);
spin_unlock(&sbi->s_lock);
ext2_sync_super(sb, es, 1);
}
db_count = sbi->s_gdb_count;
for (i = 0; i < db_count; i++)
if (sbi->s_group_desc[i])
brelse (sbi->s_group_desc[i]);
kfree(sbi->s_group_desc);
kfree(sbi->s_debts);
percpu_counter_destroy(&sbi->s_freeblocks_counter);
percpu_counter_destroy(&sbi->s_freeinodes_counter);
percpu_counter_destroy(&sbi->s_dirs_counter);
brelse (sbi->s_sbh);
sb->s_fs_info = NULL;
kfree(sbi->s_blockgroup_lock);
kfree(sbi);
}
",[6],	ext2_xattr_put_super(sb);
18,"long long BlockGroup::GetPrevTimeCode() const
{
    return m_prev;
}
","[1, 2, 3]",{/~/    return m_prev;/~/}
19,"xmlParseAttValueComplex(xmlParserCtxtPtr ctxt, int *attlen, int normalize) {
xmlChar limit = 0;
xmlChar *buf = NULL;
xmlChar *rep = NULL;
int len = 0;
int buf_size = 0;
int c, l, in_space = 0;
xmlChar *current = NULL;
xmlEntityPtr ent;

if (NXT(0) == '""') {
ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
limit = '""';
NEXT;
} else if (NXT(0) == '\'') {
limit = '\'';
ctxt->instate = XML_PARSER_ATTRIBUTE_VALUE;
NEXT;
} else {
xmlFatalErr(ctxt, XML_ERR_ATTRIBUTE_NOT_STARTED, NULL);
return(NULL);
}

/*
* allocate a translation buffer.
*/
buf_size = XML_PARSER_BUFFER_SIZE;
buf = (xmlChar *) xmlMallocAtomic(buf_size * sizeof(xmlChar));
if (buf == NULL) goto mem_error;

/*
* OK loop until we reach one of the ending char or a size limit.
*/
c = CUR_CHAR(l);
    while ((NXT(0) != limit) && /* checked *
           (IS_CHAR(c)) && (c != '<')) {
if (c == 0) break;
if (c == '&') {
in_space = 0;
if (NXT(1) == '#') {
int val = xmlParseCharRef(ctxt);

if (val == '&') {
if (ctxt->replaceEntities) {
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
buf[len++] = '&';
} else {
/*
* The reparsing will be done in xmlStringGetNodeList()
* called by the attribute() function in SAX.c
*/
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
buf[len++] = '&';
buf[len++] = '#';
buf[len++] = '3';
buf[len++] = '8';
buf[len++] = ';';
}
} else if (val != 0) {
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
len += xmlCopyChar(0, &buf[len], val);
}
} else {
ent = xmlParseEntityRef(ctxt);
ctxt->nbentities++;
if (ent != NULL)
ctxt->nbentities += ent->owner;
if ((ent != NULL) &&
(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
if ((ctxt->replaceEntities == 0) &&
(ent->content[0] == '&')) {
buf[len++] = '&';
buf[len++] = '#';
buf[len++] = '3';
buf[len++] = '8';
buf[len++] = ';';
} else {
buf[len++] = ent->content[0];
}
} else if ((ent != NULL) &&
(ctxt->replaceEntities != 0)) {
if (ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) {
rep = xmlStringDecodeEntities(ctxt, ent->content,
XML_SUBSTITUTE_REF,
0, 0, 0);
if (rep != NULL) {
current = rep;
while (*current != 0) { /* non input consuming */
if ((*current == 0xD) || (*current == 0xA) ||
(*current == 0x9)) {
buf[len++] = 0x20;
current++;
} else
buf[len++] = *current++;
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
}
xmlFree(rep);
rep = NULL;
}
} else {
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
if (ent->content != NULL)
buf[len++] = ent->content[0];
}
} else if (ent != NULL) {
int i = xmlStrlen(ent->name);
const xmlChar *cur = ent->name;

/*
* This may look absurd but is needed to detect
* entities problems
*/
if ((ent->etype != XML_INTERNAL_PREDEFINED_ENTITY) &&
(ent->content != NULL)) {
rep = xmlStringDecodeEntities(ctxt, ent->content,
XML_SUBSTITUTE_REF, 0, 0, 0);
if (rep != NULL) {
xmlFree(rep);
rep = NULL;
}
}

/*
* Just output the reference
*/
buf[len++] = '&';
while (len > buf_size - i - 10) {
growBuffer(buf, i + 10);
}
for (;i > 0;i--)
buf[len++] = *cur++;
buf[len++] = ';';
}
}
} else {
if ((c == 0x20) || (c == 0xD) || (c == 0xA) || (c == 0x9)) {
if ((len != 0) || (!normalize)) {
if ((!normalize) || (!in_space)) {
COPY_BUF(l,buf,len,0x20);
while (len > buf_size - 10) {
growBuffer(buf, 10);
}
}
in_space = 1;
}
} else {
in_space = 0;
COPY_BUF(l,buf,len,c);
if (len > buf_size - 10) {
growBuffer(buf, 10);
}
}
NEXTL(l);
}
GROW;
c = CUR_CHAR(l);
}
if ((in_space) && (normalize)) {
while ((len > 0) && (buf[len - 1] == 0x20)) len--;
}
buf[len] = 0;
if (RAW == '<') {
xmlFatalErr(ctxt, XML_ERR_LT_IN_ATTRIBUTE, NULL);
} else if (RAW != limit) {
if ((c != 0) && (!IS_CHAR(c))) {
xmlFatalErrMsg(ctxt, XML_ERR_INVALID_CHAR,
""invalid character in attribute value\n"");
} else {
xmlFatalErrMsg(ctxt, XML_ERR_ATTRIBUTE_NOT_FINISHED,
""AttValue: ' expected\n"");
}
} else
NEXT;
if (attlen != NULL) *attlen = len;
return(buf);

mem_error:
xmlErrMemory(ctxt, NULL);
if (buf != NULL)
xmlFree(buf);
if (rep != NULL)
xmlFree(rep);
return(NULL);
}
","[31, 32]",    while ((NXT(0) != limit) && /* checked */~/           (IS_CHAR(c)) && (c != '<')) {
20,"rs_filter_graph(RSFilter *filter)
{
g_return_if_fail(RS_IS_FILTER(filter));
GString *str = g_string_new(""digraph G {\n"");

rs_filter_graph_helper(str, filter);

g_string_append_printf(str, ""}\n"");
	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);

	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))
g_warning(""Calling dot failed"");
	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))
g_warning(""Calling gnome-open failed."");

g_string_free(str, TRUE);
}
","[6, 7, 9]","	g_file_set_contents(""/tmp/rs-filter-graph"", str->str, str->len, NULL);/~/	if (0 != system(""dot -Tpng >/tmp/rs-filter-graph.png </tmp/rs-filter-graph""))/~/	if (0 != system(""gnome-open /tmp/rs-filter-graph.png""))"
21,"WebPluginResourceClient* WebPluginDelegateImpl::CreateResourceClient(
    unsigned long resource_id, const GURL& url, bool notify_needed,
    intptr_t notify_data, intptr_t existing_stream) {
  // Stream already exists. This typically happens for range requests
  // initiated via NPN_RequestRead.
  if (existing_stream) {
    NPAPI::PluginStream* plugin_stream =
        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);
    return plugin_stream->AsResourceClient();
  }

  std::string mime_type;
  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(
      resource_id, url, mime_type, notify_needed,
      reinterpret_cast<void*>(notify_data));
  return stream;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]","    unsigned long resource_id, const GURL& url, bool notify_needed,/~/    intptr_t notify_data, intptr_t existing_stream) {/~/  // Stream already exists. This typically happens for range requests/~/  // initiated via NPN_RequestRead./~/  if (existing_stream) {/~/    NPAPI::PluginStream* plugin_stream =/~/        reinterpret_cast<NPAPI::PluginStream*>(existing_stream);/~/    return plugin_stream->AsResourceClient();/~/  }/~/  std::string mime_type;/~/  NPAPI::PluginStreamUrl *stream = instance()->CreateStream(/~/      resource_id, url, mime_type, notify_needed,/~/      reinterpret_cast<void*>(notify_data));/~/  return stream;"
22,"void GLSurfaceOzoneSurfacelessSurfaceImpl::Destroy() {
if (!context_)
return;
scoped_refptr<gfx::GLContext> previous_context = gfx::GLContext::GetCurrent();
scoped_refptr<gfx::GLSurface> previous_surface;

bool was_current = previous_context && previous_context->IsCurrent(nullptr) &&
gfx::GLSurface::GetCurrent() == this;
if (!was_current) {
// Only take a reference to previous surface if it's not |this|
// because otherwise we can take a self reference from our own dtor.
previous_surface = gfx::GLSurface::GetCurrent();
context_->MakeCurrent(this);
}

glBindFramebufferEXT(GL_FRAMEBUFFER, 0);
if (fbo_) {
glDeleteTextures(arraysize(textures_), textures_);
for (auto& texture : textures_)
texture = 0;
glDeleteFramebuffersEXT(1, &fbo_);
fbo_ = 0;
}
for (auto image : images_) {
if (image)
image->Destroy(true);
}

if (!was_current) {
    previous_context->MakeCurrent(previous_surface.get());
  } else {
    context_->ReleaseCurrent(this);
}
}
","[26, 27, 28]",    previous_context->MakeCurrent(previous_surface.get());/~/  } else {/~/    context_->ReleaseCurrent(this);
23,"void gdImageLine (gdImagePtr im, int x1, int y1, int x2, int y2, int color)
{
int dx, dy, incr1, incr2, d, x, y, xend, yend, xdirflag, ydirflag;
int wid;
int w, wstart;
int thick = im->thick;

if (color == gdAntiAliased) {
		/* 
gdAntiAliased passed as color: use the much faster, much cheaper
and equally attractive gdImageAALine implementation. That
clips too, so don't clip twice.
*/
		gdImageAALine(im, x1, y1, x2, y2, im->AA_color); 
return;
}

/* 2.0.10: Nick Atty: clip to edges of drawing rectangle, return if no points need to be drawn */
if (!clip_1d(&x1,&y1,&x2,&y2,gdImageSX(im)) || !clip_1d(&y1,&x1,&y2,&x2,gdImageSY(im))) {
return;
}

dx = abs (x2 - x1);
dy = abs (y2 - y1);

if (dx == 0) {
gdImageVLine(im, x1, y1, y2, color);
return;
} else if (dy == 0) {
gdImageHLine(im, y1, x1, x2, color);
return;
}

if (dy <= dx) {
/* More-or-less horizontal. use wid for vertical stroke */
/* Doug Claar: watch out for NaN in atan2 (2.0.5) */
if ((dx == 0) && (dy == 0)) {
wid = 1;
} else {
/* 2.0.12: Michael Schwartz: divide rather than multiply;
TBB: but watch out for /0! */
double ac = cos (atan2 (dy, dx));
if (ac != 0) {
wid = thick / ac;
} else {
wid = 1;
}
if (wid == 0) {
wid = 1;
}
}
d = 2 * dy - dx;
incr1 = 2 * dy;
incr2 = 2 * (dy - dx);
if (x1 > x2) {
x = x2;
y = y2;
ydirflag = (-1);
xend = x1;
} else {
x = x1;
y = y1;
ydirflag = 1;
xend = x2;
}

/* Set up line thickness */
wstart = y - wid / 2;
for (w = wstart; w < wstart + wid; w++) {
gdImageSetPixel(im, x, w, color);
}

if (((y2 - y1) * ydirflag) > 0) {
while (x < xend) {
x++;
if (d < 0) {
d += incr1;
} else {
y++;
d += incr2;
}
wstart = y - wid / 2;
for (w = wstart; w < wstart + wid; w++) {
gdImageSetPixel (im, x, w, color);
}
}
} else {
while (x < xend) {
x++;
if (d < 0) {
d += incr1;
} else {
y--;
d += incr2;
}
wstart = y - wid / 2;
for (w = wstart; w < wstart + wid; w++) {
gdImageSetPixel (im, x, w, color);
}
}
}
} else {
/* More-or-less vertical. use wid for horizontal stroke */
/* 2.0.12: Michael Schwartz: divide rather than multiply;
TBB: but watch out for /0! */
double as = sin (atan2 (dy, dx));
if (as != 0) {
wid = thick / as;
} else {
wid = 1;
}
if (wid == 0) {
wid = 1;
}

d = 2 * dx - dy;
incr1 = 2 * dx;
incr2 = 2 * (dx - dy);
if (y1 > y2) {
y = y2;
x = x2;
yend = y1;
xdirflag = (-1);
} else {
y = y1;
x = x1;
yend = y2;
xdirflag = 1;
}

/* Set up line thickness */
wstart = x - wid / 2;
for (w = wstart; w < wstart + wid; w++) {
gdImageSetPixel (im, w, y, color);
}

if (((x2 - x1) * xdirflag) > 0) {
while (y < yend) {
y++;
if (d < 0) {
d += incr1;
} else {
x++;
d += incr2;
}
wstart = x - wid / 2;
for (w = wstart; w < wstart + wid; w++) {
gdImageSetPixel (im, w, y, color);
}
}
} else {
while (y < yend) {
y++;
if (d < 0) {
d += incr1;
} else {
x--;
d += incr2;
}
wstart = x - wid / 2;
for (w = wstart; w < wstart + wid; w++) {
gdImageSetPixel (im, w, y, color);
}
}
}
}
}
","[7, 12]","		/* /~/		gdImageAALine(im, x1, y1, x2, y2, im->AA_color); "
24,"static int cypress_open(struct tty_struct *tty, struct usb_serial_port *port)
{
struct cypress_private *priv = usb_get_serial_port_data(port);
struct usb_serial *serial = port->serial;
unsigned long flags;
int result = 0;

if (!priv->comm_is_ok)
return -EIO;

/* clear halts before open */
usb_clear_halt(serial->dev, 0x81);
usb_clear_halt(serial->dev, 0x02);

spin_lock_irqsave(&priv->lock, flags);
/* reset read/write statistics */
priv->bytes_in = 0;
priv->bytes_out = 0;
priv->cmd_count = 0;
priv->rx_flags = 0;
spin_unlock_irqrestore(&priv->lock, flags);

/* Set termios */
cypress_send(port);

if (tty)
cypress_set_termios(tty, port, &priv->tmp_termios);

/* setup the port and start reading from the device */
	if (!port->interrupt_in_urb) {
		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",
			__func__);
		return -1;
	}
usb_fill_int_urb(port->interrupt_in_urb, serial->dev,
usb_rcvintpipe(serial->dev, port->interrupt_in_endpointAddress),
port->interrupt_in_urb->transfer_buffer,
port->interrupt_in_urb->transfer_buffer_length,
cypress_read_int_callback, port, priv->read_urb_interval);
result = usb_submit_urb(port->interrupt_in_urb, GFP_KERNEL);

if (result) {
dev_err(&port->dev,
""%s - failed submitting read urb, error %d\n"",
__func__, result);
cypress_set_dead(port);
}

return result;
} /* cypress_open */
","[23, 24, 25, 26, 27, 39]","	if (!port->interrupt_in_urb) {/~/		dev_err(&port->dev, ""%s - interrupt_in_urb is empty!\n"",/~/			__func__);/~/		return -1;/~/	}"
25,"my_object_dict_of_dicts (MyObject *obj, GHashTable *in,
                                GHashTable **out, GError **error)
{
  *out = g_hash_table_new_full (g_str_hash, g_str_equal,
				(GDestroyNotify) g_free,
                                (GDestroyNotify) g_hash_table_destroy);
  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);
  return TRUE;
}
","[1, 2, 3, 4, 5, 6, 7, 8]","                                GHashTable **out, GError **error)/~/{/~/  *out = g_hash_table_new_full (g_str_hash, g_str_equal,/~/				(GDestroyNotify) g_free,/~/                                (GDestroyNotify) g_hash_table_destroy);/~/  g_hash_table_foreach (in, hash_foreach_mangle_dict_of_strings, *out);/~/  return TRUE;/~/}"
26,"int user_update(struct key *key, struct key_preparsed_payload *prep)
{
struct user_key_payload *upayload, *zap;
size_t datalen = prep->datalen;
int ret;

ret = -EINVAL;
if (datalen <= 0 || datalen > 32767 || !prep->data)
goto error;

/* construct a replacement payload */
ret = -ENOMEM;
upayload = kmalloc(sizeof(*upayload) + datalen, GFP_KERNEL);
if (!upayload)
goto error;

upayload->datalen = datalen;
memcpy(upayload->data, prep->data, datalen);

/* check the quota and attach the new data */
zap = upayload;

ret = key_payload_reserve(key, datalen);

if (ret == 0) {
/* attach the new data, displacing the old */
		zap = key->payload.data[0];
rcu_assign_keypointer(key, upayload);
key->expiry = 0;
}

if (zap)
kfree_rcu(zap, rcu);

error:
return ret;
}
",[20],		zap = key->payload.data[0];
27,"int BN_hex2bn(BIGNUM **bn, const char *a)
{
BIGNUM *ret = NULL;
BN_ULONG l = 0;
int neg = 0, h, m, i, j, k, c;
int num;

if ((a == NULL) || (*a == '\0'))
return (0);

if (*a == '-') {
neg = 1;
a++;
a++;
}

    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;

num = i + neg;
if (bn == NULL)
return (0);
} else {
ret = *bn;
BN_zero(ret);
}
",[13],    for (i = 0; isxdigit((unsigned char)a[i]); i++) ;
28,"void EnableHighDPISupport() {
if (IsHighDPIEnabled() &&
      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {
    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {
      SetProcessDPIAwareWrapper();
    }
}
}
","[2, 3, 4, 5, 6, 7]",      (base::win::GetVersion() < base::win::VERSION_WIN8_1)) {/~/    if (!SetProcessDpiAwarenessWrapper(PROCESS_SYSTEM_DPI_AWARE)) {/~/      SetProcessDPIAwareWrapper();/~/    }
29,"void Segment::PreloadCluster(Cluster* pCluster, ptrdiff_t idx)
{
    assert(pCluster);
    assert(pCluster->m_index < 0);
    assert(idx >= m_clusterCount);
    const long count = m_clusterCount + m_clusterPreloadCount;
    long& size = m_clusterSize;
    assert(size >= count);
    if (count >= size)
    {
        const long n = (size <= 0) ? 2048 : 2*size;
        Cluster** const qq = new Cluster*[n];
        Cluster** q = qq;
        Cluster** p = m_clusters;
        Cluster** const pp = p + count;
        while (p != pp)
            *q++ = *p++;
        delete[] m_clusters;
        m_clusters = qq;
        size = n;
    }
assert(m_clusters);

    Cluster** const p = m_clusters + idx;

    Cluster** q = m_clusters + count;
    assert(q >= p);
assert(q < (m_clusters + size));

    while (q > p)
    {
        Cluster** const qq = q - 1;
        assert((*qq)->m_index < 0);

        *q = *qq;
        q = qq;
}

    m_clusters[idx] = pCluster;
    ++m_clusterPreloadCount;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 22, 23, 24, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]",{/~/    assert(pCluster);/~/    assert(pCluster->m_index < 0);/~/    assert(idx >= m_clusterCount);/~/    const long count = m_clusterCount + m_clusterPreloadCount;/~/    long& size = m_clusterSize;/~/    assert(size >= count);/~/    if (count >= size)/~/    {/~/        const long n = (size <= 0) ? 2048 : 2*size;/~/        Cluster** const qq = new Cluster*[n];/~/        Cluster** q = qq;/~/        Cluster** p = m_clusters;/~/        Cluster** const pp = p + count;/~/        while (p != pp)/~/            *q++ = *p++;/~/        delete[] m_clusters;/~/        m_clusters = qq;/~/        size = n;/~/    }/~/    Cluster** const p = m_clusters + idx;/~/    Cluster** q = m_clusters + count;/~/    assert(q >= p);/~/    while (q > p)/~/    {/~/        Cluster** const qq = q - 1;/~/        assert((*qq)->m_index < 0);/~/        *q = *qq;/~/        q = qq;/~/    m_clusters[idx] = pCluster;/~/    ++m_clusterPreloadCount;
30,"SPL_METHOD(SplFileObject, seek)
{
spl_filesystem_object *intern = (spl_filesystem_object*)zend_object_store_get_object(getThis() TSRMLS_CC);
long line_pos;
	
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""l"", &line_pos) == FAILURE) {
return;
}
if (line_pos < 0) {
zend_throw_exception_ex(spl_ce_LogicException, 0 TSRMLS_CC, ""Can't seek file %s to negative line %ld"", intern->file_name, line_pos);
		RETURN_FALSE;		
}
	
spl_filesystem_file_rewind(getThis(), intern TSRMLS_CC);
	
while(intern->u.file.current_line_num < line_pos) {
if (spl_filesystem_file_read_line(getThis(), intern, 1 TSRMLS_CC) == FAILURE) {
break;
}
}
} /* }}} */

/* {{{ Function/Class/Method definitions */
",[9],	/~/		RETURN_FALSE;		/~/	/~/	
31,"void WallpaperManager::OnWallpaperDecoded(
const AccountId& account_id,
const wallpaper::WallpaperInfo& info,
bool update_wallpaper,
MovableOnDestroyCallbackHolder on_finish,
std::unique_ptr<user_manager::UserImage> user_image) {
DCHECK_CURRENTLY_ON(BrowserThread::UI);
TRACE_EVENT_ASYNC_END0(""ui"", ""LoadAndDecodeWallpaper"", this);

// If decoded wallpaper is empty, we have probably failed to decode the file.
// Use default wallpaper in this case.
if (user_image->image().isNull()) {
// Updates user pref to default wallpaper.
wallpaper::WallpaperInfo default_info(
"""", wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED, wallpaper::DEFAULT,
base::Time::Now().LocalMidnight());
SetUserWallpaperInfo(account_id, default_info, true);
    if (update_wallpaper)
      DoSetDefaultWallpaper(account_id, std::move(on_finish));
return;
}

// Update the image, but keep the path which was set earlier.
wallpaper_cache_[account_id].second = user_image->image();

if (update_wallpaper)
SetWallpaper(user_image->image(), info);
}
","[16, 17, 22]","    if (update_wallpaper)/~/      DoSetDefaultWallpaper(account_id, std::move(on_finish));"
32,"FT_Bitmap_Embolden( FT_Library  library,
FT_Bitmap*  bitmap,
FT_Pos      xStrength,
FT_Pos      yStrength )
{
FT_Error        error;
unsigned char*  p;
    FT_Int          i, x, y, pitch;
FT_Int          xstr, ystr;


return FT_THROW( Invalid_Library_Handle );

if ( !bitmap || !bitmap->buffer )
return FT_THROW( Invalid_Argument );

if ( ( ( FT_PIX_ROUND( xStrength ) >> 6 ) > FT_INT_MAX ) ||
( ( FT_PIX_ROUND( yStrength ) >> 6 ) > FT_INT_MAX ) )
return FT_THROW( Invalid_Argument );

xstr = (FT_Int)FT_PIX_ROUND( xStrength ) >> 6;
ystr = (FT_Int)FT_PIX_ROUND( yStrength ) >> 6;

if ( xstr == 0 && ystr == 0 )
return FT_Err_Ok;
else if ( xstr < 0 || ystr < 0 )
return FT_THROW( Invalid_Argument );

switch ( bitmap->pixel_mode )
{
case FT_PIXEL_MODE_GRAY2:
case FT_PIXEL_MODE_GRAY4:
{
FT_Bitmap  tmp;


/* convert to 8bpp */
FT_Bitmap_New( &tmp );
error = FT_Bitmap_Convert( library, bitmap, &tmp, 1 );
if ( error )
return error;

FT_Bitmap_Done( library, bitmap );
*bitmap = tmp;
}
break;

case FT_PIXEL_MODE_MONO:
if ( xstr > 8 )
xstr = 8;
break;

case FT_PIXEL_MODE_LCD:
xstr *= 3;
break;

case FT_PIXEL_MODE_LCD_V:
ystr *= 3;
break;

case FT_PIXEL_MODE_BGRA:
/* We don't embolden color glyphs. */
return FT_Err_Ok;
}

error = ft_bitmap_assure_buffer( library->memory, bitmap, xstr, ystr );
if ( error )
return error;

/* take care of bitmap flow */
pitch = bitmap->pitch;
if ( pitch > 0 )
p = bitmap->buffer + pitch * ystr;
else
{
pitch = -pitch;
p = bitmap->buffer + pitch * ( bitmap->rows - 1 );
}

/* for each row */
for ( y = 0; y < bitmap->rows ; y++ )
{
/*
* Horizontally:
*
* From the last pixel on, make each pixel or'ed with the
* `xstr' pixels before it.
*/
for ( x = pitch - 1; x >= 0; x-- )
{
unsigned char  tmp;


tmp = p[x];
for ( i = 1; i <= xstr; i++ )
{
if ( bitmap->pixel_mode == FT_PIXEL_MODE_MONO )
{
p[x] |= tmp >> i;

/* the maximum value of 8 for `xstr' comes from here */
if ( x > 0 )
p[x] |= p[x - 1] << ( 8 - i );

#if 0
if ( p[x] == 0xff )
break;
#endif
}
else
{
if ( x - i >= 0 )
{
if ( p[x] + p[x - i] > bitmap->num_grays - 1 )
{
p[x] = (unsigned char)( bitmap->num_grays - 1 );
break;
}
else
{
p[x] = (unsigned char)( p[x] + p[x - i] );
if ( p[x] == bitmap->num_grays - 1 )
break;
}
}
else
break;
}
}
}

/*
* Vertically:
*
* Make the above `ystr' rows or'ed with it.
*/
for ( x = 1; x <= ystr; x++ )
{
unsigned char*  q;


q = p - bitmap->pitch * x;
for ( i = 0; i < pitch; i++ )
q[i] |= p[i];
}

p += bitmap->pitch;
}

bitmap->width += xstr;
bitmap->rows += ystr;

return FT_Err_Ok;
}
",[7],"    FT_Int          i, x, y, pitch;"
33,"StateBase* writeBlob(v8::Handle<v8::Value> value, StateBase* next)
{
Blob* blob = V8Blob::toNative(value.As<v8::Object>());
if (!blob)
return 0;
if (blob->hasBeenClosed())
return handleError(DataCloneError, ""A Blob object has been closed, and could therefore not be cloned."", next);
int blobIndex = -1;
        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());
if (appendBlobInfo(blob->uuid(), blob->type(), blob->size(), &blobIndex))
m_writer.writeBlobIndex(blobIndex);
else
m_writer.writeBlob(blob->uuid(), blob->type(), blob->size());
return 0;
}
",[8],"        m_blobDataHandles.add(blob->uuid(), blob->blobDataHandle());"
34,"standard_row_validate(standard_display *dp, png_const_structp pp,
int iImage, int iDisplay, png_uint_32 y)
{
int where;
png_byte std[STANDARD_ROWMAX];

/* The row must be pre-initialized to the magic number here for the size
* tests to pass:
*/
memset(std, 178, sizeof std);
standard_row(pp, std, dp->id, y);

/* At the end both the 'row' and 'display' arrays should end up identical.

* In earlier passes 'row' will be partially filled in, with only the pixels
* that have been read so far, but 'display' will have those pixels
* replicated to fill the unread pixels while reading an interlaced image.
#if PNG_LIBPNG_VER < 10506
    * The side effect inside the libpng sequential reader is that the 'row'
    * array retains the correct values for unwritten pixels within the row
    * bytes, while the 'display' array gets bits off the end of the image (in
    * the last byte) trashed.  Unfortunately in the progressive reader the
    * row bytes are always trashed, so we always do a pixel_cmp here even though
    * a memcmp of all cbRow bytes will succeed for the sequential reader.
#endif
*/
if (iImage >= 0 &&
(where = pixel_cmp(std, store_image_row(dp->ps, pp, iImage, y),
dp->bit_width)) != 0)
{
char msg[64];
sprintf(msg, ""PNG image row[%lu][%d] changed from %.2x to %.2x"",
(unsigned long)y, where-1, std[where-1],
store_image_row(dp->ps, pp, iImage, y)[where-1]);

png_error(pp, msg);
}

#if PNG_LIBPNG_VER < 10506
   /* In this case use pixel_cmp because we need to compare a partial
    * byte at the end of the row if the row is not an exact multiple
    * of 8 bits wide.  (This is fixed in libpng-1.5.6 and pixel_cmp is
    * changed to match!)
    *
#endif
if (iDisplay >= 0 &&
(where = pixel_cmp(std, store_image_row(dp->ps, pp, iDisplay, y),
dp->bit_width)) != 0)
{
char msg[64];
      sprintf(msg, ""display  row[%lu][%d] changed from %.2x to %.2x"",
(unsigned long)y, where-1, std[where-1],
store_image_row(dp->ps, pp, iDisplay, y)[where-1]);
png_error(pp, msg);
}
}
","[14, 15, 16, 17, 18, 19, 20, 21, 33, 34]","#if PNG_LIBPNG_VER < 10506/~/    * The side effect inside the libpng sequential reader is that the 'row'/~/    * array retains the correct values for unwritten pixels within the row/~/    * bytes, while the 'display' array gets bits off the end of the image (in/~/    * the last byte) trashed.  Unfortunately in the progressive reader the/~/    * row bytes are always trashed, so we always do a pixel_cmp here even though/~/    * a memcmp of all cbRow bytes will succeed for the sequential reader./~/#endif/~/#if PNG_LIBPNG_VER < 10506/~/   /* In this case use pixel_cmp because we need to compare a partial/~/    * byte at the end of the row if the row is not an exact multiple/~/    * of 8 bits wide.  (This is fixed in libpng-1.5.6 and pixel_cmp is/~/    * changed to match!)/~/    */~/#endif/~/      sprintf(msg, ""display  row[%lu][%d] changed from %.2x to %.2x"","
35,"bool Plugin::LoadNaClModuleCommon(nacl::DescWrapper* wrapper,
NaClSubprocess* subprocess,
const Manifest* manifest,
bool should_report_uma,
ErrorInfo* error_info,
pp::CompletionCallback init_done_cb,
pp::CompletionCallback crash_cb) {
ServiceRuntime* new_service_runtime =
new ServiceRuntime(this, manifest, should_report_uma, init_done_cb,
crash_cb);
subprocess->set_service_runtime(new_service_runtime);
PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime=%p)\n"",
static_cast<void*>(new_service_runtime)));
if (NULL == new_service_runtime) {
error_info->SetReport(ERROR_SEL_LDR_INIT,
""sel_ldr init failure "" + subprocess->description());
return false;
}

bool service_runtime_started =
      new_service_runtime->Start(wrapper,
                                 error_info,
                                 manifest_base_url());
PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon (service_runtime_started=%d)\n"",
service_runtime_started));
if (!service_runtime_started) {
return false;
}
  // Try to start the Chrome IPC-based proxy.
  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();
  if (ppb_nacl->StartPpapiProxy(pp_instance())) {
    using_ipc_proxy_ = true;
    // We need to explicitly schedule this here. It is normally called in
    // response to starting the SRPC proxy.
    CHECK(init_done_cb.pp_completion_callback().func != NULL);
    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));
    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);
  }
return true;
}
","[17, 19, 20, 21, 26, 27, 28, 29, 30, 31, 32, 33]","      new_service_runtime->Start(wrapper,/~/                                 error_info,/~/                                 manifest_base_url());/~/  // Try to start the Chrome IPC-based proxy./~/  const PPB_NaCl_Private* ppb_nacl = GetNaclInterface();/~/  if (ppb_nacl->StartPpapiProxy(pp_instance())) {/~/    using_ipc_proxy_ = true;/~/    // We need to explicitly schedule this here. It is normally called in/~/    // response to starting the SRPC proxy./~/    CHECK(init_done_cb.pp_completion_callback().func != NULL);/~/    PLUGIN_PRINTF((""Plugin::LoadNaClModuleCommon, started ipc proxy.\n""));/~/    pp::Module::Get()->core()->CallOnMainThread(0, init_done_cb, PP_OK);/~/  }"
36,"void SSLManager::OnSSLCertificateError(
    base::WeakPtr<SSLErrorHandler::Delegate> delegate,
const content::GlobalRequestID& id,
const ResourceType::Type resource_type,
const GURL& url,
int render_process_id,
int render_view_id,
const net::SSLInfo& ssl_info,
bool fatal) {
DCHECK(delegate);
DVLOG(1) << ""OnSSLCertificateError() cert_error: ""
<< net::MapCertStatusToNetError(ssl_info.cert_status)
<< "" id: "" << id.child_id << "","" << id.request_id
<< "" resource_type: "" << resource_type
<< "" url: "" << url.spec()
<< "" render_process_id: "" << render_process_id
<< "" render_view_id: "" << render_view_id
<< "" cert_status: "" << std::hex << ssl_info.cert_status;

// A certificate error occurred.  Construct a SSLCertErrorHandler object and
// hand it over to the UI thread for processing.
BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
base::Bind(&SSLCertErrorHandler::Dispatch,
new SSLCertErrorHandler(delegate,
id,
resource_type,
url,
render_process_id,
render_view_id,
ssl_info,
fatal)));
}
",[1],"    base::WeakPtr<SSLErrorHandler::Delegate> delegate,"
37,"void RunScrollbarThumbDragLatencyTest() {
    // See above comment in RunScrollbarButtonLatencyTest for why this test
    // doesn't run on Android.
#if !defined(OS_ANDROID)
    // Click on the scrollbar thumb and drag it twice to induce a compositor
    // thread scrollbar ScrollBegin and ScrollUpdate.
    blink::WebFloatPoint scrollbar_thumb(795, 30);
    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,
        0);
    mouse_down.button = blink::WebMouseEvent::Button::kLeft;
    mouse_down.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_down);
    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,
        scrollbar_thumb.y + 10, 0);
    mouse_move.button = blink::WebMouseEvent::Button::kLeft;
    mouse_move.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    RunUntilInputProcessed(GetWidgetHost());
    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);
    GetWidgetHost()->ForwardMouseEvent(mouse_move);
    RunUntilInputProcessed(GetWidgetHost());
    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(
        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,
        scrollbar_thumb.y + 20, 0);
    mouse_up.button = blink::WebMouseEvent::Button::kLeft;
    mouse_up.SetTimeStamp(base::TimeTicks::Now());
    GetWidgetHost()->ForwardMouseEvent(mouse_up);
    RunUntilInputProcessed(GetWidgetHost());
    FetchHistogramsFromChildProcesses();
    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};
    for (const std::string& scroll_type : scroll_types) {
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.RendererSwapToBrowserNotified2""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));
      std::string thread_name =
          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +
                 thread_name));
      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(
          1, ""Event.Latency."" + scroll_type +
                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));
    }
#endif  // !defined(OS_ANDROID)
  }
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]","    // See above comment in RunScrollbarButtonLatencyTest for why this test/~/    // doesn't run on Android./~/#if !defined(OS_ANDROID)/~/    // Click on the scrollbar thumb and drag it twice to induce a compositor/~/    // thread scrollbar ScrollBegin and ScrollUpdate./~/    blink::WebFloatPoint scrollbar_thumb(795, 30);/~/    blink::WebMouseEvent mouse_down = SyntheticWebMouseEventBuilder::Build(/~/        blink::WebInputEvent::kMouseDown, scrollbar_thumb.x, scrollbar_thumb.y,/~/        0);/~/    mouse_down.button = blink::WebMouseEvent::Button::kLeft;/~/    mouse_down.SetTimeStamp(base::TimeTicks::Now());/~/    GetWidgetHost()->ForwardMouseEvent(mouse_down);/~/    blink::WebMouseEvent mouse_move = SyntheticWebMouseEventBuilder::Build(/~/        blink::WebInputEvent::kMouseMove, scrollbar_thumb.x,/~/        scrollbar_thumb.y + 10, 0);/~/    mouse_move.button = blink::WebMouseEvent::Button::kLeft;/~/    mouse_move.SetTimeStamp(base::TimeTicks::Now());/~/    GetWidgetHost()->ForwardMouseEvent(mouse_move);/~/    RunUntilInputProcessed(GetWidgetHost());/~/    mouse_move.SetPositionInWidget(scrollbar_thumb.x, scrollbar_thumb.y + 20);/~/    mouse_move.SetPositionInScreen(scrollbar_thumb.x, scrollbar_thumb.y + 20);/~/    GetWidgetHost()->ForwardMouseEvent(mouse_move);/~/    RunUntilInputProcessed(GetWidgetHost());/~/    blink::WebMouseEvent mouse_up = SyntheticWebMouseEventBuilder::Build(/~/        blink::WebInputEvent::kMouseUp, scrollbar_thumb.x,/~/        scrollbar_thumb.y + 20, 0);/~/    mouse_up.button = blink::WebMouseEvent::Button::kLeft;/~/    mouse_up.SetTimeStamp(base::TimeTicks::Now());/~/    GetWidgetHost()->ForwardMouseEvent(mouse_up);/~/    RunUntilInputProcessed(GetWidgetHost());/~/    FetchHistogramsFromChildProcesses();/~/    const std::string scroll_types[] = {""ScrollBegin"", ""ScrollUpdate""};/~/    for (const std::string& scroll_type : scroll_types) {/~/      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(/~/          1, ""Event.Latency."" + scroll_type +/~/                 "".Scrollbar.TimeToScrollUpdateSwapBegin4""));/~/      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(/~/          1, ""Event.Latency."" + scroll_type +/~/                 "".Scrollbar.RendererSwapToBrowserNotified2""));/~/      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(/~/          1, ""Event.Latency."" + scroll_type +/~/                 "".Scrollbar.BrowserNotifiedToBeforeGpuSwap2""));/~/      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(/~/          1, ""Event.Latency."" + scroll_type + "".Scrollbar.GpuSwap2""));/~/      std::string thread_name =/~/          DoesScrollbarScrollOnMainThread() ? ""Main"" : ""Impl"";/~/      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(/~/          1, ""Event.Latency."" + scroll_type + "".Scrollbar.TimeToHandled2_"" +/~/                 thread_name));/~/      EXPECT_TRUE(VerifyRecordedSamplesForHistogram(/~/          1, ""Event.Latency."" + scroll_type +/~/                 "".Scrollbar.HandledToRendererSwap2_"" + thread_name));/~/    }/~/#endif  // !defined(OS_ANDROID)/~/  }"
38,"GpuChannelHost* RenderThreadImpl::EstablishGpuChannelSync(
content::CauseForGpuLaunch cause_for_gpu_launch) {
if (gpu_channel_.get()) {
// Do nothing if we already have a GPU channel or are already
// establishing one.
if (gpu_channel_->state() == GpuChannelHost::kUnconnected ||
gpu_channel_->state() == GpuChannelHost::kConnected)
return GetGpuChannel();

// Recreate the channel if it has been lost.
gpu_channel_ = NULL;
}

// Ask the browser for the channel name.
int client_id = 0;
IPC::ChannelHandle channel_handle;
  base::ProcessHandle renderer_process_for_gpu;
content::GPUInfo gpu_info;
if (!Send(new GpuHostMsg_EstablishGpuChannel(cause_for_gpu_launch,
&client_id,
&channel_handle,
                                               &renderer_process_for_gpu,
&gpu_info)) ||
      channel_handle.name.empty() ||
#if defined(OS_POSIX)
channel_handle.socket.fd == -1 ||
#endif
      renderer_process_for_gpu == base::kNullProcessHandle) {
// Otherwise cancel the connection.
gpu_channel_ = NULL;
return NULL;
}

gpu_channel_ = new GpuChannelHost(this, 0, client_id);
gpu_channel_->set_gpu_info(gpu_info);
content::GetContentClient()->SetGpuInfo(gpu_info);

// Connect to the GPU process if a channel name was received.
  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);

return GetGpuChannel();
}
","[14, 19, 21, 25, 34]","  base::ProcessHandle renderer_process_for_gpu;/~/                                               &renderer_process_for_gpu,/~/      channel_handle.name.empty() ||/~/      renderer_process_for_gpu == base::kNullProcessHandle) {/~/  gpu_channel_->Connect(channel_handle, renderer_process_for_gpu);"
39,"static int fanout_add(struct sock *sk, u16 id, u16 type_flags)
{
struct packet_sock *po = pkt_sk(sk);
struct packet_fanout *f, *match;
u8 type = type_flags & 0xff;
u8 flags = type_flags >> 8;
int err;

switch (type) {
case PACKET_FANOUT_ROLLOVER:
if (type_flags & PACKET_FANOUT_FLAG_ROLLOVER)
return -EINVAL;
case PACKET_FANOUT_HASH:
case PACKET_FANOUT_LB:
case PACKET_FANOUT_CPU:
case PACKET_FANOUT_RND:
case PACKET_FANOUT_QM:
case PACKET_FANOUT_CBPF:
case PACKET_FANOUT_EBPF:
break;
default:
return -EINVAL;
}

if (!po->running)
		return -EINVAL;

if (po->fanout)
		return -EALREADY;

if (type == PACKET_FANOUT_ROLLOVER ||
(type_flags & PACKET_FANOUT_FLAG_ROLLOVER)) {
		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);
		if (!po->rollover)
			return -ENOMEM;
		atomic_long_set(&po->rollover->num, 0);
		atomic_long_set(&po->rollover->num_huge, 0);
		atomic_long_set(&po->rollover->num_failed, 0);
}

	mutex_lock(&fanout_mutex);
match = NULL;
list_for_each_entry(f, &fanout_list, list) {
if (f->id == id &&
read_pnet(&f->net) == sock_net(sk)) {
match = f;
break;
}
}
err = -EINVAL;
if (match && match->flags != flags)
goto out;
if (!match) {
err = -ENOMEM;
match = kzalloc(sizeof(*match), GFP_KERNEL);
if (!match)
goto out;
write_pnet(&match->net, sock_net(sk));
match->id = id;
match->type = type;
match->flags = flags;
INIT_LIST_HEAD(&match->list);
spin_lock_init(&match->lock);
atomic_set(&match->sk_ref, 0);
fanout_init_data(match);
match->prot_hook.type = po->prot_hook.type;
match->prot_hook.dev = po->prot_hook.dev;
match->prot_hook.func = packet_rcv_fanout;
match->prot_hook.af_packet_priv = match;
match->prot_hook.id_match = match_fanout_group;
dev_add_pack(&match->prot_hook);
list_add(&match->list, &fanout_list);
}
err = -EINVAL;
if (match->type == type &&
match->prot_hook.type == po->prot_hook.type &&
match->prot_hook.dev == po->prot_hook.dev) {
err = -ENOSPC;
if (atomic_read(&match->sk_ref) < PACKET_FANOUT_MAX) {
__dev_remove_pack(&po->prot_hook);
po->fanout = match;
atomic_inc(&match->sk_ref);
__fanout_link(sk, po);
err = 0;
}
}
out:
	mutex_unlock(&fanout_mutex);
	if (err) {
		kfree(po->rollover);
po->rollover = NULL;
}
return err;
}
","[10, 20, 23, 25, 28, 29, 30, 31, 32, 33, 35]","		return -EINVAL;/~/		return -EALREADY;/~/		po->rollover = kzalloc(sizeof(*po->rollover), GFP_KERNEL);/~/		if (!po->rollover)/~/			return -ENOMEM;/~/		atomic_long_set(&po->rollover->num, 0);/~/		atomic_long_set(&po->rollover->num_huge, 0);/~/		atomic_long_set(&po->rollover->num_failed, 0);/~/	mutex_lock(&fanout_mutex);/~/	mutex_unlock(&fanout_mutex);/~/	if (err) {/~/		kfree(po->rollover);"
40,"png_write_destroy(png_structp png_ptr)
{
#ifdef PNG_SETJMP_SUPPORTED
jmp_buf tmp_jmp; /* Save jump buffer */
#endif
png_error_ptr error_fn;
png_error_ptr warning_fn;
png_voidp error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
png_free_ptr free_fn;
#endif

png_debug(1, ""in png_write_destroy"");

/* Free any memory zlib uses */
deflateEnd(&png_ptr->zstream);

/* Free our memory.  png_free checks NULL for us. */
png_free(png_ptr, png_ptr->zbuf);
png_free(png_ptr, png_ptr->row_buf);
#ifdef PNG_WRITE_FILTER_SUPPORTED
png_free(png_ptr, png_ptr->prev_row);
png_free(png_ptr, png_ptr->sub_row);
png_free(png_ptr, png_ptr->up_row);
png_free(png_ptr, png_ptr->avg_row);
png_free(png_ptr, png_ptr->paeth_row);
#endif

#ifdef PNG_TIME_RFC1123_SUPPORTED
png_free(png_ptr, png_ptr->time_buffer);
#endif

#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED
   png_free(png_ptr, png_ptr->prev_filters);
   png_free(png_ptr, png_ptr->filter_weights);
   png_free(png_ptr, png_ptr->inv_filter_weights);
   png_free(png_ptr, png_ptr->filter_costs);
   png_free(png_ptr, png_ptr->inv_filter_costs);
#endif
#ifdef PNG_SETJMP_SUPPORTED
/* Reset structure */
png_memcpy(tmp_jmp, png_ptr->jmpbuf, png_sizeof(jmp_buf));
#endif

error_fn = png_ptr->error_fn;
warning_fn = png_ptr->warning_fn;
error_ptr = png_ptr->error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
free_fn = png_ptr->free_fn;
#endif

png_memset(png_ptr, 0, png_sizeof(png_struct));

png_ptr->error_fn = error_fn;
png_ptr->warning_fn = warning_fn;
png_ptr->error_ptr = error_ptr;
#ifdef PNG_USER_MEM_SUPPORTED
png_ptr->free_fn = free_fn;
#endif

#ifdef PNG_SETJMP_SUPPORTED
png_memcpy(png_ptr->jmpbuf, tmp_jmp, png_sizeof(jmp_buf));
#endif
}
","[4, 10, 23, 26, 27, 28, 29, 30, 31, 32, 33]","#ifdef PNG_WRITE_WEIGHTED_FILTER_SUPPORTED/~/   png_free(png_ptr, png_ptr->prev_filters);/~/   png_free(png_ptr, png_ptr->filter_weights);/~/   png_free(png_ptr, png_ptr->inv_filter_weights);/~/   png_free(png_ptr, png_ptr->filter_costs);/~/   png_free(png_ptr, png_ptr->inv_filter_costs);/~/#endif"
41,"XFixesFetchRegionAndBounds (Display	    *dpy,
XserverRegion   region,
int		    *nrectanglesRet,
XRectangle	    *bounds)
{
XFixesExtDisplayInfo	*info = XFixesFindDisplay (dpy);
xXFixesFetchRegionReq	*req;
xXFixesFetchRegionReply	rep;
XRectangle			*rects;
int    			nrects;
long    			nbytes;
long			nread;

XFixesCheckExtension (dpy, info, NULL);
LockDisplay (dpy);
GetReq (XFixesFetchRegion, req);
req->reqType = info->codes->major_opcode;
req->xfixesReqType = X_XFixesFetchRegion;
req->region = region;
*nrectanglesRet = 0;
if (!_XReply (dpy, (xReply *) &rep, 0, xFalse))
{
UnlockDisplay (dpy);
SyncHandle ();
return NULL;
}
bounds->x = rep.x;
bounds->y = rep.y;
bounds->y = rep.y;
bounds->width = rep.width;
bounds->height = rep.height;
    nbytes = (long) rep.length << 2;
    nrects = rep.length >> 1;
    rects = Xmalloc (nrects * sizeof (XRectangle));
if (!rects)
{
_XEatDataWords(dpy, rep.length);
_XEatData (dpy, (unsigned long) (nbytes - nread));
}
UnlockDisplay (dpy);
SyncHandle();
*nrectanglesRet = nrects;
return rects;
}
","[40, 41, 42]",    nbytes = (long) rep.length << 2;/~/    nrects = rep.length >> 1;/~/    rects = Xmalloc (nrects * sizeof (XRectangle));
42,"static void sycc422_to_rgb(opj_image_t *img)
{
int *d0, *d1, *d2, *r, *g, *b;
const int *y, *cb, *cr;
	unsigned int maxw, maxh, max;
int offset, upb;
	unsigned int i, j;

upb = (int)img->comps[0].prec;
offset = 1<<(upb - 1); upb = (1<<upb)-1;

	maxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;
max = maxw * maxh;

y = img->comps[0].data;
cb = img->comps[1].data;
cr = img->comps[2].data;

	d0 = r = (int*)malloc(sizeof(int) * (size_t)max);
	d1 = g = (int*)malloc(sizeof(int) * (size_t)max);
	d2 = b = (int*)malloc(sizeof(int) * (size_t)max);

if(r == NULL || g == NULL || b == NULL) goto fails;

for(i=0U; i < maxh; ++i)
{
		for(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)
{
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y; ++r; ++g; ++b;
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y; ++r; ++g; ++b; ++cb; ++cr;
}
		if (j < maxw) {
sycc_to_rgb(offset, upb, *y, *cb, *cr, r, g, b);
++y; ++r; ++g; ++b; ++cb; ++cr;
}
}
free(img->comps[0].data); img->comps[0].data = d0;
free(img->comps[1].data); img->comps[1].data = d1;
free(img->comps[2].data); img->comps[2].data = d2;

#if defined(USE_JPWL) || defined(USE_MJ2)
	img->comps[1].w = maxw; img->comps[1].h = maxh;
	img->comps[2].w = maxw; img->comps[2].h = maxh;
#else
	img->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;
	img->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;
#endif
	img->comps[1].dx = img->comps[0].dx;
	img->comps[2].dx = img->comps[0].dx;
	img->comps[1].dy = img->comps[0].dy;
	img->comps[2].dy = img->comps[0].dy;
return;

fails:
	if(r) free(r);
	if(g) free(g);
	if(b) free(b);
}/* sycc422_to_rgb() */
","[4, 6, 9, 14, 15, 16, 20, 27]","	unsigned int maxw, maxh, max;/~/	unsigned int i, j;/~/	maxw = (unsigned int)img->comps[0].w; maxh = (unsigned int)img->comps[0].h;/~/	d0 = r = (int*)malloc(sizeof(int) * (size_t)max);/~/	d1 = g = (int*)malloc(sizeof(int) * (size_t)max);/~/	d2 = b = (int*)malloc(sizeof(int) * (size_t)max);/~/		for(j=0U; j < (maxw & ~(unsigned int)1U); j += 2U)/~/		if (j < maxw) {/~/#if defined(USE_JPWL) || defined(USE_MJ2)/~/	img->comps[1].w = maxw; img->comps[1].h = maxh;/~/	img->comps[2].w = maxw; img->comps[2].h = maxh;/~/#else/~/	img->comps[1].w = (OPJ_UINT32)maxw; img->comps[1].h = (OPJ_UINT32)maxh;/~/	img->comps[2].w = (OPJ_UINT32)maxw; img->comps[2].h = (OPJ_UINT32)maxh;/~/#endif/~/	img->comps[1].dx = img->comps[0].dx;/~/	img->comps[2].dx = img->comps[0].dx;/~/	img->comps[1].dy = img->comps[0].dy;/~/	img->comps[2].dy = img->comps[0].dy;/~/	if(r) free(r);/~/	if(g) free(g);/~/	if(b) free(b);"
43,"static int tight_fill_palette(VncState *vs, int x, int y,
size_t count, uint32_t *bg, uint32_t *fg,
VncPalette **palette)
{
int max;

max = count / tight_conf[vs->tight.compression].idx_max_colors_divisor;
if (max < 2 &&
count >= tight_conf[vs->tight.compression].mono_min_rect_size) {
max = 2;
}
if (max >= 256) {
max = 256;
}

    switch(vs->clientds.pf.bytes_per_pixel) {
case 4:
return tight_fill_palette32(vs, x, y, max, count, bg, fg, palette);
case 2:
return tight_fill_palette16(vs, x, y, max, count, bg, fg, palette);
default:
max = 2;
return tight_fill_palette8(vs, x, y, max, count, bg, fg, palette);
}
return 0;
}
",[13],    switch(vs->clientds.pf.bytes_per_pixel) {
44,"queue_unlock(struct futex_q *q, struct futex_hash_bucket *hb)
{
spin_unlock(&hb->lock);
	drop_futex_key_refs(&q->key);
}
",[3],	drop_futex_key_refs(&q->key);
45,"FileStream::FileStream(base::File file,
const scoped_refptr<base::TaskRunner>& task_runner)
    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}
",[2],"    : context_(base::MakeUnique<Context>(std::move(file), task_runner)) {}"
46,"bool WebPagePrivate::dispatchTouchPointAsMouseEventToFullScreenPlugin(PluginView* pluginView, const Platform::TouchPoint& point)
{
NPEvent npEvent;
NPMouseEvent mouse;

    switch (point.m_state) {
case Platform::TouchPoint::TouchPressed:
mouse.type = MOUSE_BUTTON_DOWN;
break;
case Platform::TouchPoint::TouchReleased:
mouse.type = MOUSE_BUTTON_UP;
break;
case Platform::TouchPoint::TouchMoved:
mouse.type = MOUSE_MOTION;
break;
case Platform::TouchPoint::TouchStationary:
return true;
}

    mouse.x = point.m_screenPos.x();
    mouse.y = point.m_screenPos.y();
mouse.button = mouse.type != MOUSE_BUTTON_UP;
mouse.flags = 0;
npEvent.type = NP_MouseEvent;
npEvent.data = &mouse;

pluginView->dispatchFullScreenNPEvent(npEvent);
return true;
}
","[4, 17, 18]",    switch (point.m_state) {/~/    mouse.x = point.m_screenPos.x();/~/    mouse.y = point.m_screenPos.y();
47,"static int ohci_bus_start(OHCIState *ohci)
{
    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,
                    ohci_frame_boundary,
                    ohci);
    if (ohci->eof_timer == NULL) {
        trace_usb_ohci_bus_eof_timer_failed(ohci->name);
        ohci_die(ohci);
        return 0;
    }
trace_usb_ohci_start(ohci->name);

/* Delay the first SOF event by one frame time as

if (ohci->eof_timer == NULL) {
trace_usb_ohci_bus_eof_timer_failed(ohci->name);
ohci_die(ohci);
return 0;
}

trace_usb_ohci_start(ohci->name);

/* Delay the first SOF event by one frame time as
static void ohci_bus_stop(OHCIState *ohci)
{
trace_usb_ohci_stop(ohci->name);
    if (ohci->eof_timer) {
        timer_del(ohci->eof_timer);
        timer_free(ohci->eof_timer);
    }
    ohci->eof_timer = NULL;
}

/* Sets a flag in a port status register but only set it if the port is
}
","[2, 3, 4, 5, 6, 7, 8, 9, 12, 13, 14, 15, 16, 22, 23, 24, 25, 26, 27, 29]","    ohci->eof_timer = timer_new_ns(QEMU_CLOCK_VIRTUAL,/~/                    ohci_frame_boundary,/~/                    ohci);/~/    if (ohci->eof_timer == NULL) {/~/        trace_usb_ohci_bus_eof_timer_failed(ohci->name);/~/        ohci_die(ohci);/~/        return 0;/~/    }/~/    if (ohci->eof_timer) {/~/        timer_del(ohci->eof_timer);/~/        timer_free(ohci->eof_timer);/~/    }/~/    ohci->eof_timer = NULL;"
48,"static void LongOrNullAttributeAttributeSetter(
v8::Local<v8::Value> v8_value, const v8::FunctionCallbackInfo<v8::Value>& info) {
v8::Isolate* isolate = info.GetIsolate();
ALLOW_UNUSED_LOCAL(isolate);

v8::Local<v8::Object> holder = info.Holder();
ALLOW_UNUSED_LOCAL(holder);

TestObject* impl = V8TestObject::ToImpl(holder);

ExceptionState exception_state(isolate, ExceptionState::kSetterContext, ""TestObject"", ""longOrNullAttribute"");

// Prepare the value to be set.
  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);
if (exception_state.HadException())
return;

  bool is_null = IsUndefinedOrNull(v8_value);
impl->setLongOrNullAttribute(cpp_value, is_null);
}
","[9, 12]","  int32_t cpp_value = NativeValueTraits<IDLLong>::NativeValue(info.GetIsolate(), v8_value, exception_state);/~/  bool is_null = IsUndefinedOrNull(v8_value);"
49,"void DataReductionProxySettings::InitDataReductionProxySettings(
PrefService* prefs,
DataReductionProxyIOData* io_data,
std::unique_ptr<DataReductionProxyService> data_reduction_proxy_service) {
DCHECK(thread_checker_.CalledOnValidThread());
DCHECK(prefs);
DCHECK(io_data);
DCHECK(io_data->config());
DCHECK(data_reduction_proxy_service);
prefs_ = prefs;
config_ = io_data->config();
data_reduction_proxy_service_ = std::move(data_reduction_proxy_service);
data_reduction_proxy_service_->AddObserver(this);
  InitPrefMembers();
RecordDataReductionInit();

#if defined(OS_ANDROID)
  if (spdy_proxy_auth_enabled_.GetValue()) {
data_reduction_proxy_service_->compression_stats()
->SetDataUsageReportingEnabled(true);
}
#endif  // defined(OS_ANDROID)

for (auto& observer : observers_)
observer.OnSettingsInitialized();
}
","[13, 16]",  InitPrefMembers();/~/  if (spdy_proxy_auth_enabled_.GetValue()) {
50,"static SharedMemorySupport DoQuerySharedMemorySupport(Display* dpy) {
int dummy;
Bool pixmaps_supported;
// Query the server's support for XSHM.
if (!XShmQueryVersion(dpy, &dummy, &dummy, &pixmaps_supported))
return SHARED_MEMORY_NONE;

#if defined(OS_FREEBSD)
// On FreeBSD we can't access the shared memory after it was marked for
// deletion, unless this behaviour is explicitly enabled by the user.
// In case it's not enabled disable shared memory support.
int allow_removed;
size_t length = sizeof(allow_removed);

if ((sysctlbyname(""kern.ipc.shm_allow_removed"", &allow_removed, &length,
NULL, 0) < 0) || allow_removed < 1) {
return SHARED_MEMORY_NONE;
}
#endif

// Next we probe to see if shared memory will really work
  int shmkey = shmget(IPC_PRIVATE, 1, 0666);
  if (shmkey == -1)
return SHARED_MEMORY_NONE;
void* address = shmat(shmkey, NULL, 0);
// Mark the shared memory region for deletion
shmctl(shmkey, IPC_RMID, NULL);

XShmSegmentInfo shminfo;
memset(&shminfo, 0, sizeof(shminfo));
shminfo.shmid = shmkey;

gdk_error_trap_push();
bool result = XShmAttach(dpy, &shminfo);
XSync(dpy, False);
if (gdk_error_trap_pop())
result = false;
shmdt(address);
  if (!result)
return SHARED_MEMORY_NONE;

XShmDetach(dpy, &shminfo);
return pixmaps_supported ? SHARED_MEMORY_PIXMAP : SHARED_MEMORY_PUTIMAGE;
}
","[18, 19, 33]","  int shmkey = shmget(IPC_PRIVATE, 1, 0666);/~/  if (shmkey == -1)/~/  if (!result)"
51,"static int jpeg_size(unsigned char* data, unsigned int data_size,
int *width, int *height)
{
int i = 0;
if (i + 3 < data_size && data[i] == 0xFF && data[i+1] == 0xD8 &&
data[i+2] == 0xFF && data[i+3] == 0xE0) {
i += 4;
if(i + 6 < data_size &&
data[i+2] == 'J' && data[i+3] == 'F' && data[i+4] == 'I' &&
data[i+5] == 'F' && data[i+6] == 0x00) {
unsigned short block_length = data[i] * 256 + data[i+1];
while(i<data_size) {
i+=block_length;
if((i + 1) >= data_size)
return -1;
if(data[i] != 0xFF)
return -1;
if(data[i+1] == 0xC0) {
*height = data[i+5]*256 + data[i+6];
*width = data[i+7]*256 + data[i+8];
return 0;
}
i+=2;
                block_length = data[i] * 256 + data[i+1];
}
}
}

return -1;
}
",[23],                block_length = data[i] * 256 + data[i+1];
52,"bool ParseRequestInfo(const struct mg_request_info* const request_info,
std::string* method,
std::vector<std::string>* path_segments,
DictionaryValue** parameters,
Response* const response) {
*method = request_info->request_method;
if (*method == ""HEAD"")
*method = ""GET"";
else if (*method == ""PUT"")
*method = ""POST"";

std::string uri(request_info->uri);
SessionManager* manager = SessionManager::GetInstance();
uri = uri.substr(manager->url_base().length());

base::SplitString(uri, '/', path_segments);

if (*method == ""POST"" && request_info->post_data_len > 0) {
    VLOG(1) << ""...parsing request body"";
std::string json(request_info->post_data, request_info->post_data_len);
    std::string error;
    if (!ParseJSONDictionary(json, parameters, &error)) {
response->SetError(new Error(
kBadRequest,
          ""Failed to parse command data: "" + error + ""\n  Data: "" + json));
return false;
}
}
  VLOG(1) << ""Parsed "" << method << "" "" << uri
        << std::string(request_info->post_data, request_info->post_data_len);
return true;
}
","[15, 17, 18, 21, 25, 26]","    VLOG(1) << ""...parsing request body"";/~/    std::string error;/~/    if (!ParseJSONDictionary(json, parameters, &error)) {/~/          ""Failed to parse command data: "" + error + ""\n  Data: "" + json));/~/  VLOG(1) << ""Parsed "" << method << "" "" << uri/~/        << std::string(request_info->post_data, request_info->post_data_len);"
53,"void InspectorOverlay::update()
{
if (isEmpty()) {
m_client->hideHighlight();
return;
}

FrameView* view = m_page->mainFrame()->view();
if (!view)
return;
IntRect viewRect = view->visibleContentRect();
FrameView* overlayView = overlayPage()->mainFrame()->view();

// Include scrollbars to avoid masking them by the gutter.
IntSize frameViewFullSize = view->visibleContentRect(ScrollableArea::IncludeScrollbars).size();
IntSize size = m_size.isEmpty() ? frameViewFullSize : m_size;
size.scale(m_page->pageScaleFactor());
overlayView->resize(size);

// Clear canvas and paint things.
reset(size, m_size.isEmpty() ? IntSize() : frameViewFullSize, viewRect.x(), viewRect.y());

drawGutter();
drawNodeHighlight();
drawQuadHighlight();
if (!m_inspectModeEnabled)
drawPausedInDebuggerMessage();
drawViewSize();
    drawOverridesMessage();

// Position DOM elements.
overlayPage()->mainFrame()->document()->recalcStyle(Force);
if (overlayView->needsLayout())
overlayView->layout();

// Kick paint.
m_client->highlight();
}
",[24],    drawOverridesMessage();
54,"void StoreAccumulatedContentLength(int received_content_length,
                                   int original_content_length,
                                   bool data_reduction_proxy_was_used) {
BrowserThread::PostTask(BrowserThread::UI, FROM_HERE,
base::Bind(&UpdateContentLengthPrefs,
received_content_length, original_content_length,
                 data_reduction_proxy_was_used));
}
","[1, 2, 6]","                                   int original_content_length,/~/                                   bool data_reduction_proxy_was_used) {/~/                 data_reduction_proxy_was_used));"
55,"void CCLayerTreeHostTest::endTest()
{
// If we are called from the CCThread, re-call endTest on the main thread.
if (!isMainThread())
        CCMainThread::postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));
else {
// For the case where we endTest during beginTest(), set a flag to indicate that
// the test should end the second beginTest regains control.
if (m_beginning)
m_endWhenBeginReturns = true;
else
onEndTest(static_cast<void*>(this));
}
}
",[4],"        CCMainThread::postTask(createMainThreadTask(this, &CCLayerTreeHostTest::endTest));"
56,"long Chapters::Parse()
{
    IMkvReader* const pReader = m_pSegment->m_pReader;
    long long pos = m_start;  // payload start
    const long long stop = pos + m_size;  // payload stop
    while (pos < stop)
    {
        long long id, size;
        long status = ParseElementHeader(
                        pReader,
                        pos,
                        stop,
                        id,
                        size);
        if (status < 0)  // error
            return status;
        if (size == 0)  // weird
            continue;
        if (id == 0x05B9)  // EditionEntry ID
        {
            status = ParseEdition(pos, size);
            if (status < 0)  // error
                return status;
        }
        pos += size;
        assert(pos <= stop);
}

    assert(pos == stop);
    return 0;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]","{/~/    IMkvReader* const pReader = m_pSegment->m_pReader;/~/    long long pos = m_start;  // payload start/~/    const long long stop = pos + m_size;  // payload stop/~/    while (pos < stop)/~/    {/~/        long long id, size;/~/        long status = ParseElementHeader(/~/                        pReader,/~/                        pos,/~/                        stop,/~/                        id,/~/                        size);/~/        if (status < 0)  // error/~/            return status;/~/        if (size == 0)  // weird/~/            continue;/~/        if (id == 0x05B9)  // EditionEntry ID/~/        {/~/            status = ParseEdition(pos, size);/~/            if (status < 0)  // error/~/                return status;/~/        }/~/        pos += size;/~/        assert(pos <= stop);/~/    assert(pos == stop);/~/    return 0;"
57,"static int __ptrace_may_access(struct task_struct *task, unsigned int mode)
{
const struct cred *cred = current_cred(), *tcred;

/* May we inspect the given task?
* This check is used both for attaching with ptrace
* and for allowing access to sensitive information in /proc.
*
* ptrace_attach denies several cases that /proc allows
* because setting up the necessary parent/child relationship
* or halting the specified task is impossible.
*/
int dumpable = 0;
/* Don't let security modules deny introspection */
if (same_thread_group(task, current))
return 0;
rcu_read_lock();
tcred = __task_cred(task);
if (uid_eq(cred->uid, tcred->euid) &&
uid_eq(cred->uid, tcred->suid) &&
uid_eq(cred->uid, tcred->uid)  &&
gid_eq(cred->gid, tcred->egid) &&
gid_eq(cred->gid, tcred->sgid) &&
gid_eq(cred->gid, tcred->gid))
goto ok;
if (ptrace_has_cap(tcred->user_ns, mode))
goto ok;
rcu_read_unlock();
return -EPERM;
ok:
rcu_read_unlock();
smp_rmb();
if (task->mm)
dumpable = get_dumpable(task->mm);
rcu_read_lock();
	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {
rcu_read_unlock();
return -EPERM;
}
rcu_read_unlock();

return security_ptrace_access_check(task, mode);
}
",[34],"	if (!dumpable && !ptrace_has_cap(__task_cred(task)->user_ns, mode)) {"
58,"struct import_t* MACH0_(get_imports)(struct MACH0_(obj_t)* bin) {
struct import_t *imports;
int i, j, idx, stridx;
const char *symstr;

	if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)
return NULL;
if (bin->dysymtab.nundefsym < 1 || bin->dysymtab.nundefsym > 0xfffff) {
return NULL;
}
if (!(imports = malloc ((bin->dysymtab.nundefsym + 1) * sizeof (struct import_t)))) {
return NULL;
}
for (i = j = 0; i < bin->dysymtab.nundefsym; i++) {
idx = bin->dysymtab.iundefsym + i;
if (idx < 0 || idx >= bin->nsymtab) {
bprintf (""WARNING: Imports index out of bounds. Ignoring relocs\n"");
free (imports);
return NULL;
}
stridx = bin->symtab[idx].n_strx;
if (stridx >= 0 && stridx < bin->symstrlen) {
symstr = (char *)bin->symstr + stridx;
} else {
symstr = """";
}
if (!*symstr) {
continue;
}
{
int i = 0;
int len = 0;
char *symstr_dup = NULL;
len = bin->symstrlen - stridx;
imports[j].name[0] = 0;
if (len > 0) {
for (i = 0; i < len; i++) {
if ((unsigned char)symstr[i] == 0xff || !symstr[i]) {
len = i;
break;
}
}
symstr_dup = r_str_ndup (symstr, len);
if (symstr_dup) {
r_str_ncpy (imports[j].name, symstr_dup, R_BIN_MACH0_STRING_LENGTH);
r_str_filter (imports[j].name, - 1);
imports[j].name[R_BIN_MACH0_STRING_LENGTH - 2] = 0;
free (symstr_dup);
}
}
}
imports[j].ord = i;
imports[j++].last = 0;
}
imports[j].last = 1;

if (!bin->imports_by_ord_size) {
if (j > 0) {
bin->imports_by_ord_size = j;
bin->imports_by_ord = (RBinImport**)calloc (j, sizeof (RBinImport*));
} else {
bin->imports_by_ord_size = 0;
bin->imports_by_ord = NULL;
}
}

return imports;
}
",[4],	if (!bin->symtab || !bin->symstr || !bin->sects || !bin->indirectsyms)
59,"NetworkThrottleManagerImpl::NetworkThrottleManagerImpl()
: lifetime_median_estimate_(PercentileEstimator::kMedianPercentile,
kInitialMedianInMs),
outstanding_recomputation_timer_(
          base::MakeUnique<base::Timer>(false /* retain_user_task */,
false /* is_repeating */)),
tick_clock_(new base::DefaultTickClock()),
weak_ptr_factory_(this) {}
",[4],"          base::MakeUnique<base::Timer>(false /* retain_user_task */,"
60,"long Segment::ParseCues(long long off, long long& pos, long& len) {
if (m_pCues)
return 0;  // success

if (off < 0)
return -1;

long long total, avail;

const int status = m_pReader->Length(&total, &avail);

if (status < 0) // error
return status;

assert((total < 0) || (avail <= total));

pos = m_start + off;

if ((total < 0) || (pos >= total))
return 1; // don't bother parsing cues

const long long element_start = pos;
const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;

if ((pos + 1) > avail) {
len = 1;
return E_BUFFER_NOT_FULL;
}

long long result = GetUIntLength(m_pReader, pos, len);

if (result < 0) // error
return static_cast<long>(result);

if (result > 0) // underflow (weird)
{
len = 1;
return E_BUFFER_NOT_FULL;
}

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;


const long long idpos = pos;

  const long long id = ReadUInt(m_pReader, idpos, len);

if (id != 0x0C53BB6B)  // Cues ID
return E_FILE_FORMAT_INVALID;

pos += len; // consume ID
assert((segment_stop < 0) || (pos <= segment_stop));

// Read Size

if ((pos + 1) > avail) {
len = 1;
return E_BUFFER_NOT_FULL;
}

result = GetUIntLength(m_pReader, pos, len);

if (result < 0) // error
return static_cast<long>(result);

if (result > 0) // underflow (weird)
{
len = 1;
return E_BUFFER_NOT_FULL;
}

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;

const long long size = ReadUInt(m_pReader, pos, len);

if (size < 0) // error
return static_cast<long>(size);

if (size == 0) // weird, although technically not illegal
return 1; // done

pos += len; // consume length of size of element
assert((segment_stop < 0) || (pos <= segment_stop));

// Pos now points to start of payload

const long long element_stop = pos + size;

if ((segment_stop >= 0) && (element_stop > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((total >= 0) && (element_stop > total))
return 1; // don't bother parsing anymore

len = static_cast<long>(size);

if (element_stop > avail)
return E_BUFFER_NOT_FULL;

const long long element_size = element_stop - element_start;


m_pCues =
new (std::nothrow) Cues(this, pos, size, element_start, element_size);
  assert(m_pCues);  // TODO

return 0;  // success
}
",[32],"  const long long id = ReadUInt(m_pReader, idpos, len);/~/  assert(m_pCues);  // TODO"
61,"Chapters::Chapters(
    Segment* pSegment,
    long long payload_start,
    long long payload_size,
    long long element_start,
    long long element_size) :
    m_pSegment(pSegment),
    m_start(payload_start),
    m_size(payload_size),
    m_element_start(element_start),
    m_element_size(element_size),
    m_editions(NULL),
    m_editions_size(0),
    m_editions_count(0)
{
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]","    Segment* pSegment,/~/    long long payload_start,/~/    long long payload_size,/~/    long long element_start,/~/    long long element_size) :/~/    m_pSegment(pSegment),/~/    m_start(payload_start),/~/    m_size(payload_size),/~/    m_element_start(element_start),/~/    m_element_size(element_size),/~/    m_editions(NULL),/~/    m_editions_size(0),/~/    m_editions_count(0)/~/{/~/}"
62,"void Initialize(ChannelLayout channel_layout, int bits_per_channel) {
AudioParameters params(
media::AudioParameters::AUDIO_PCM_LINEAR, channel_layout,
        kSamplesPerSecond, bits_per_channel, kRawDataSize);

algorithm_.Initialize(1, params, base::Bind(
&AudioRendererAlgorithmTest::EnqueueData, base::Unretained(this)));
EnqueueData();
}
",[3],"        kSamplesPerSecond, bits_per_channel, kRawDataSize);"
63,"frag6_print(netdissect_options *ndo, register const u_char *bp, register const u_char *bp2)
{
register const struct ip6_frag *dp;
register const struct ip6_hdr *ip6;

dp = (const struct ip6_frag *)bp;
ip6 = (const struct ip6_hdr *)bp2;

	ND_TCHECK(dp->ip6f_offlg);

if (ndo->ndo_vflag) {
ND_PRINT((ndo, ""frag (0x%08x:%d|%ld)"",
EXTRACT_32BITS(&dp->ip6f_ident),
EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
(long)(bp - bp2) - sizeof(struct ip6_frag)));
} else {
ND_PRINT((ndo, ""frag (%d|%ld)"",
EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK,
sizeof(struct ip6_hdr) + EXTRACT_16BITS(&ip6->ip6_plen) -
(long)(bp - bp2) - sizeof(struct ip6_frag)));
}

/* it is meaningless to decode non-first fragment */
if ((EXTRACT_16BITS(&dp->ip6f_offlg) & IP6F_OFF_MASK) != 0)
return -1;
else
{
ND_PRINT((ndo, "" ""));
return sizeof(struct ip6_frag);
}
trunc:
ND_PRINT((ndo, ""[|frag]""));
return -1;
}
",[6],	ND_TCHECK(dp->ip6f_offlg);
64,"void UserSelectionScreen::OnBeforeUserRemoved(const AccountId& account_id) {
  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();
       ++it) {
if ((*it)->GetAccountId() == account_id) {
users_.erase(it);
break;
}
}
}
","[1, 2]",  for (user_manager::UserList::iterator it = users_.begin(); it != users_.end();/~/       ++it) {
65,"bool MediaElementAudioSourceHandler::WouldTaintOrigin() {
  // If we're cross-origin and allowed access vie CORS, we're not tainted.
  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {
    return false;
  }
  // Handles the case where the url is a redirect to another site that we're not
  // allowed to access.
  if (!MediaElement()->HasSingleSecurityOrigin()) {
    return true;
  }
  // Test to see if the current media URL taint the origin of the audio context?
  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]","  // If we're cross-origin and allowed access vie CORS, we're not tainted./~/  if (MediaElement()->GetWebMediaPlayer()->DidPassCORSAccessCheck()) {/~/    return false;/~/  }/~/  // Handles the case where the url is a redirect to another site that we're not/~/  // allowed to access./~/  if (!MediaElement()->HasSingleSecurityOrigin()) {/~/    return true;/~/  }/~/  // Test to see if the current media URL taint the origin of the audio context?/~/  return Context()->WouldTaintOrigin(MediaElement()->currentSrc());"
66,"string16 ExtensionInstallUI::Prompt::GetHeading(std::string extension_name)
    const {
if (type_ == INLINE_INSTALL_PROMPT) {
return UTF8ToUTF16(extension_name);
} else {
return l10n_util::GetStringFUTF16(
kHeadingIds[type_], UTF8ToUTF16(extension_name));
}
}
",[1],    const {
67,"static v8::Handle<v8::Value> methodWithCallbackArgCallback(const v8::Arguments& args)
{
INC_STATS(""DOM.TestObj.methodWithCallbackArg"");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
if (args.Length() <= 0 || !args[0]->IsFunction())
return throwError(TYPE_MISMATCH_ERR, args.GetIsolate());
RefPtr<TestCallback> callback = V8TestCallback::create(args[0], getScriptExecutionContext());
imp->methodWithCallbackArg(callback);
return v8::Handle<v8::Value>();
}
",[4],        return V8Proxy::throwNotEnoughArgumentsError();
68,"int socket_create(uint16_t port)
{
int sfd = -1;
int yes = 1;
#ifdef WIN32
WSADATA wsa_data;
if (!wsa_init) {
if (WSAStartup(MAKEWORD(2,2), &wsa_data) != ERROR_SUCCESS) {
fprintf(stderr, ""WSAStartup failed!\n"");
ExitProcess(-1);
}
wsa_init = 1;
}
#endif
struct sockaddr_in saddr;

if (0 > (sfd = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP))) {
perror(""socket()"");
return -1;
}

if (setsockopt(sfd, SOL_SOCKET, SO_REUSEADDR, (void*)&yes, sizeof(int)) == -1) {
perror(""setsockopt()"");
socket_close(sfd);
return -1;
}

memset((void *) &saddr, 0, sizeof(saddr));
saddr.sin_family = AF_INET;
	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
saddr.sin_port = htons(port);

if (0 > bind(sfd, (struct sockaddr *) &saddr, sizeof(saddr))) {
perror(""bind()"");
socket_close(sfd);
return -1;
}

if (listen(sfd, 1) == -1) {
perror(""listen()"");
socket_close(sfd);
return -1;
}

return sfd;
}
",[26],	saddr.sin_addr.s_addr = htonl(INADDR_ANY);
69,"R_API RConfigNode* r_config_set(RConfig *cfg, const char *name, const char *value) {
RConfigNode *node = NULL;
char *ov = NULL;
ut64 oi;
if (!cfg || STRNULL (name)) {
return NULL;
}
node = r_config_node_get (cfg, name);
if (node) {
if (node->flags & CN_RO) {
eprintf (""(error: '%s' config key is read only)\n"", name);
return node;
}
oi = node->i_value;
if (node->value) {
ov = strdup (node->value);
if (!ov) {
goto beach;
}
} else {
free (node->value);
node->value = strdup ("""");
}
if (node->flags & CN_BOOL) {
bool b = is_true (value);
node->i_value = (ut64) b? 1: 0;
char *value = strdup (r_str_bool (b));
if (value) {
free (node->value);
node->value = value;
}
} else {
if (!value) {
free (node->value);
node->value = strdup ("""");
node->i_value = 0;
} else {
if (node->value == value) {
goto beach;
}
				free (node->value);
node->value = strdup (value);
if (IS_DIGIT (*value)) {
if (strchr (value, '/')) {
node->i_value = r_num_get (cfg->num, value);
} else {
node->i_value = r_num_math (cfg->num, value);
}
} else {
node->i_value = 0;
}
node->flags |= CN_INT;
}
}
} else { // Create a new RConfigNode
oi = UT64_MAX;
if (!cfg->lock) {
node = r_config_node_new (name, value);
if (node) {
if (value && is_bool (value)) {
node->flags |= CN_BOOL;
node->i_value = is_true (value)? 1: 0;
}
if (cfg->ht) {
ht_insert (cfg->ht, node->name, node);
r_list_append (cfg->nodes, node);
cfg->n_nodes++;
}
} else {
eprintf (""r_config_set: unable to create a new RConfigNode\n"");
}
} else {
eprintf (""r_config_set: variable '%s' not found\n"", name);
}
}

if (node && node->setter) {
int ret = node->setter (cfg->user, node);
if (ret == false) {
if (oi != UT64_MAX) {
node->i_value = oi;
}
free (node->value);
node->value = strdup (ov? ov: """");
}
}
beach:
free (ov);
return node;
}
","[20, 28, 33, 40]",				free (node->value);
70,"size_t CancelableFileOperation(Function operation,
HANDLE file,
BufferType* buffer,
size_t length,
WaitableEvent* io_event,
WaitableEvent* cancel_event,
CancelableSyncSocket* socket,
DWORD timeout_in_ms) {
ThreadRestrictions::AssertIOAllowed();
// The buffer must be byte size or the length check won't make much sense.
COMPILE_ASSERT(sizeof(buffer[0]) == sizeof(char), incorrect_buffer_type);
DCHECK_GT(length, 0u);
DCHECK_LE(length, kMaxMessageLength);
DCHECK_NE(file, SyncSocket::kInvalidHandle);

// Track the finish time so we can calculate the timeout as data is read.
TimeTicks current_time, finish_time;
if (timeout_in_ms != INFINITE) {
current_time = TimeTicks::Now();
finish_time =
current_time + base::TimeDelta::FromMilliseconds(timeout_in_ms);
}

size_t count = 0;
do {
// The OVERLAPPED structure will be modified by ReadFile or WriteFile.
OVERLAPPED ol = { 0 };
ol.hEvent = io_event->handle();

const DWORD chunk = GetNextChunkSize(count, length);
// This is either the ReadFile or WriteFile call depending on whether
// we're receiving or sending data.
DWORD len = 0;
const BOOL operation_ok = operation(
file, static_cast<BufferType*>(buffer) + count, chunk, &len, &ol);
if (!operation_ok) {
if (::GetLastError() == ERROR_IO_PENDING) {
HANDLE events[] = { io_event->handle(), cancel_event->handle() };
const int wait_result = WaitForMultipleObjects(
            ARRAYSIZE_UNSAFE(events), events, FALSE,
timeout_in_ms == INFINITE ?
timeout_in_ms :
static_cast<DWORD>(
(finish_time - current_time).InMilliseconds()));
if (wait_result != WAIT_OBJECT_0 + 0) {
// CancelIo() doesn't synchronously cancel outstanding IO, only marks
// outstanding IO for cancellation. We must call GetOverlappedResult()
// below to ensure in flight writes complete before returning.
CancelIo(file);
}

// We set the |bWait| parameter to TRUE for GetOverlappedResult() to
// ensure writes are complete before returning.
if (!GetOverlappedResult(file, &ol, &len, TRUE))
len = 0;

if (wait_result == WAIT_OBJECT_0 + 1) {
DVLOG(1) << ""Shutdown was signaled. Closing socket."";
socket->Close();
return count;
}

// Timeouts will be handled by the while() condition below since
// GetOverlappedResult() may complete successfully after CancelIo().
DCHECK(wait_result == WAIT_OBJECT_0 + 0 || wait_result == WAIT_TIMEOUT);
} else {
break;
}
}

count += len;

// Quit the operation if we can't write/read anymore.
if (len != chunk)
break;

// Since TimeTicks::Now() is expensive, only bother updating the time if we
// have more work to do.
if (timeout_in_ms != INFINITE && count < length)
current_time = base::TimeTicks::Now();
} while (count < length &&
(timeout_in_ms == INFINITE || current_time < finish_time));

return count;
}
",[36],"            ARRAYSIZE_UNSAFE(events), events, FALSE,"
71,"void MediaInterfaceProxy::CreateCdm(
media::mojom::ContentDecryptionModuleRequest request) {
DCHECK(thread_checker_.CalledOnValidThread());
  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
}
",[3],  GetMediaInterfaceFactory()->CreateCdm(std::move(request));
72,"void TranslateInfoBarBase::Layout() {
// Layout the close button.
  InfoBar::Layout();

// Layout the icon on left of bar.
gfx::Size icon_ps = icon_->GetPreferredSize();
  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),
      icon_ps.width(), icon_ps.height());
}
","[2, 5, 6]","  InfoBar::Layout();/~/  icon_->SetBounds(InfoBar::kHorizontalPadding, InfoBar::OffsetY(this, icon_ps),/~/      icon_ps.width(), icon_ps.height());"
73,"cleanup_pathname(struct archive_write_disk *a)
{
char *dest, *src;
char separator = '\0';

dest = src = a->name;
if (*src == '\0') {
archive_set_error(&a->archive, ARCHIVE_ERRNO_MISC,
""Invalid empty pathname"");
return (ARCHIVE_FAILED);
}

#if defined(__CYGWIN__)
cleanup_pathname_win(a);
#endif
/* Skip leading '/'. */
	if (*src == '/')
separator = *src++;

/* Scan the pathname one element at a time. */
for (;;) {
/* src points to first char after '/' */
if (src[0] == '\0') {
break;
} else if (src[0] == '/') {
/* Found '//', ignore second one. */
src++;
continue;
} else if (src[0] == '.') {
if (src[1] == '\0') {
/* Ignore trailing '.' */
break;
} else if (src[1] == '/') {
/* Skip './'. */
src += 2;
continue;
} else if (src[1] == '.') {
if (src[2] == '/' || src[2] == '\0') {
/* Conditionally warn about '..' */
if (a->flags & ARCHIVE_EXTRACT_SECURE_NODOTDOT) {
archive_set_error(&a->archive,
ARCHIVE_ERRNO_MISC,
""Path contains '..'"");
return (ARCHIVE_FAILED);
}
}
/*
* Note: Under no circumstances do we
* remove '..' elements.  In
* particular, restoring
* '/foo/../bar/' should create the
* 'foo' dir as a side-effect.
*/
}
}

/* Copy current element, including leading '/'. */
if (separator)
*dest++ = '/';
while (*src != '\0' && *src != '/') {
*dest++ = *src++;
}

if (*src == '\0')
break;

/* Skip '/' separator. */
separator = *src++;
}
/*
* We've just copied zero or more path elements, not including the
* final '/'.
*/
if (dest == a->name) {
/*
* Nothing got copied.  The path must have been something
* like '.' or '/' or './' or '/././././/./'.
*/
if (separator)
*dest++ = '/';
else
*dest++ = '.';
}
/* Terminate the result. */
*dest = '\0';
return (ARCHIVE_OK);
}
",[14],	if (*src == '/')
74,"void DOMStorageContextWrapper::Shutdown() {
  DCHECK(context_.get());
  mojo_task_runner_->PostTask(
      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,
                                base::Unretained(mojo_state_)));
  mojo_state_ = nullptr;
if (mojo_session_state_) {
mojo_task_runner_->PostTask(
FROM_HERE, base::BindOnce(&SessionStorageContextMojo::ShutdownAndDelete,
base::Unretained(mojo_session_state_)));
mojo_session_state_ = nullptr;
}
memory_pressure_listener_.reset();
  context_->task_runner()->PostShutdownBlockingTask(
      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,
      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));
}
","[1, 2, 3, 4, 5, 7, 13, 14, 15]","  DCHECK(context_.get());/~/  mojo_task_runner_->PostTask(/~/      FROM_HERE, base::BindOnce(&LocalStorageContextMojo::ShutdownAndDelete,/~/                                base::Unretained(mojo_state_)));/~/  mojo_state_ = nullptr;/~/  context_->task_runner()->PostShutdownBlockingTask(/~/      FROM_HERE, DOMStorageTaskRunner::PRIMARY_SEQUENCE,/~/      base::BindOnce(&DOMStorageContextImpl::Shutdown, context_));"
75,"void WebPluginImpl::didFinishLoadingFrameRequest(
const WebURL& url, void* notify_data) {
if (delegate_) {
delegate_->DidFinishLoadWithReason(
        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));
}
}
",[4],"        url, NPRES_DONE, reinterpret_cast<intptr_t>(notify_data));"
76,"void V8LazyEventListener::prepareListenerObject(ExecutionContext* executionContext)
{
if (!executionContext)
return;

// A ScriptState used by the event listener needs to be calculated based on
// the ExecutionContext that fired the the event listener and the world
// that installed the event listener.
v8::HandleScope handleScope(toIsolate(executionContext));
v8::Local<v8::Context> v8Context = toV8Context(executionContext, world());
if (v8Context.IsEmpty())
return;
ScriptState* scriptState = ScriptState::from(v8Context);
if (!scriptState->contextIsValid())
return;

    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {
clearListenerObject();
return;
}

if (hasExistingListenerObject())
return;

    ASSERT(executionContext->isDocument());
ScriptState::Scope scope(scriptState);
String listenerSource =  InspectorInstrumentation::preprocessEventListener(toDocument(executionContext)->frame(), m_code, m_sourceURL, m_functionName);

// FIXME: Remove the following 'with' hack.
//
// Nodes other than the document object, when executing inline event
// handlers push document, form owner, and the target node on the scope chain.
// We do this by using 'with' statement.
// See chrome/fast/forms/form-action.html
//     chrome/fast/forms/selected-index-value.html
//     base/fast/overflow/onscroll-layer-self-destruct.html
//
// Don't use new lines so that lines in the modified handler
// have the same numbers as in the original code.
// FIXME: V8 does not allow us to programmatically create object environments so
//        we have to do this hack! What if m_code escapes to run arbitrary script?
//
// Call with 4 arguments instead of 3, pass additional null as the last parameter.
// By calling the function with 4 arguments, we create a setter on arguments object
// which would shadow property ""3"" on the prototype.
String code = ""(function() {""
""with (this[2]) {""
""with (this[1]) {""
""with (this[0]) {""
""return function("" + m_eventParameterName + "") {"" +
listenerSource + ""\n"" // Insert '\n' otherwise //-style comments could break the handler.
""};""
""}}}})"";

v8::Handle<v8::String> codeExternalString = v8String(isolate(), code);

v8::Local<v8::Value> result = V8ScriptRunner::compileAndRunInternalScript(codeExternalString, isolate(), m_sourceURL, m_position);
if (result.IsEmpty())
return;

// Call the outer function to get the inner function.
    ASSERT(result->IsFunction());
v8::Local<v8::Function> intermediateFunction = result.As<v8::Function>();

HTMLFormElement* formElement = 0;
if (m_node && m_node->isHTMLElement())
formElement = toHTMLElement(m_node)->formOwner();

v8::Handle<v8::Object> nodeWrapper = toObjectWrapper<Node>(m_node, scriptState);
v8::Handle<v8::Object> formWrapper = toObjectWrapper<HTMLFormElement>(formElement, scriptState);
v8::Handle<v8::Object> documentWrapper = toObjectWrapper<Document>(m_node ? m_node->ownerDocument() : 0, scriptState);

v8::Local<v8::Object> thisObject = v8::Object::New(isolate());
if (thisObject.IsEmpty())
return;
if (!thisObject->ForceSet(v8::Integer::New(isolate(), 0), nodeWrapper))
return;
if (!thisObject->ForceSet(v8::Integer::New(isolate(), 1), formWrapper))
return;
if (!thisObject->ForceSet(v8::Integer::New(isolate(), 2), documentWrapper))
return;

// FIXME: Remove this code when we stop doing the 'with' hack above.
v8::Local<v8::Value> innerValue = V8ScriptRunner::callInternalFunction(intermediateFunction, thisObject, 0, 0, isolate());
if (innerValue.IsEmpty() || !innerValue->IsFunction())
return;

v8::Local<v8::Function> wrappedFunction = innerValue.As<v8::Function>();

// Change the toString function on the wrapper function to avoid it
// returning the source for the actual wrapper function. Instead it
// returns source for a clean wrapper function with the event
// argument wrapping the event source code. The reason for this is
// that some web sites use toString on event functions and eval the
// source returned (sometimes a RegExp is applied as well) for some
// other use. That fails miserably if the actual wrapper source is
// returned.
v8::Local<v8::Function> toStringFunction = v8::Function::New(isolate(), V8LazyEventListenerToString);
ASSERT(!toStringFunction.IsEmpty());
String toStringString = ""function "" + m_functionName + ""("" + m_eventParameterName + "") {\n  "" + m_code + ""\n}"";
V8HiddenValue::setHiddenValue(isolate(), wrappedFunction, V8HiddenValue::toStringString(isolate()), v8String(isolate(), toStringString));
wrappedFunction->Set(v8AtomicString(isolate(), ""toString""), toStringFunction);
wrappedFunction->SetName(v8String(isolate(), m_functionName));

// FIXME: Remove the following comment-outs.
// See https://bugs.webkit.org/show_bug.cgi?id=85152 for more details.
//
// For the time being, we comment out the following code since the
// second parsing can happen.
// // Since we only parse once, there's no need to keep data used for parsing around anymore.
// m_functionName = String();
// m_code = String();
// m_eventParameterName = String();
// m_sourceURL = String();

setListenerObject(wrappedFunction);
}
","[14, 20]","    if (executionContext->isDocument() && !toDocument(executionContext)->allowInlineEventHandlers(m_node, this, m_sourceURL, m_position.m_line)) {/~/    ASSERT(executionContext->isDocument());/~/    ASSERT(result->IsFunction());"
77,"static ssize_t driver_override_show(struct device *dev,
struct device_attribute *attr, char *buf)
{
struct platform_device *pdev = to_platform_device(dev);

	return sprintf(buf, ""%s\n"", pdev->driver_override);
}
",[4],"	return sprintf(buf, ""%s\n"", pdev->driver_override);"
78,"DefragReverseSimpleTest(void)
{
Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
Packet *reassembled = NULL;
int id = 12;
int i;
int ret = 0;

DefragInit();

    p1 = BuildTestPacket(id, 0, 1, 'A', 8);
if (p1 == NULL)
goto end;
    p2 = BuildTestPacket(id, 1, 1, 'B', 8);
if (p2 == NULL)
goto end;
    p3 = BuildTestPacket(id, 2, 0, 'C', 3);
if (p3 == NULL)
goto end;

if (Defrag(NULL, NULL, p3, NULL) != NULL)
goto end;
if (Defrag(NULL, NULL, p2, NULL) != NULL)
goto end;

reassembled = Defrag(NULL, NULL, p1, NULL);
if (reassembled == NULL)
goto end;

if (IPV4_GET_HLEN(reassembled) != 20)
goto end;
if (IPV4_GET_IPLEN(reassembled) != 39)
goto end;

/* 20 bytes in we should find 8 bytes of A. */
for (i = 20; i < 20 + 8; i++) {
if (GET_PKT_DATA(reassembled)[i] != 'A')
goto end;
}

/* 28 bytes in we should find 8 bytes of B. */
for (i = 28; i < 28 + 8; i++) {
if (GET_PKT_DATA(reassembled)[i] != 'B')
goto end;
}

/* And 36 bytes in we should find 3 bytes of C. */
for (i = 36; i < 36 + 3; i++) {
if (GET_PKT_DATA(reassembled)[i] != 'C')
goto end;
}

ret = 1;
end:
if (p1 != NULL)
SCFree(p1);
if (p2 != NULL)
SCFree(p2);
if (p3 != NULL)
SCFree(p3);
if (reassembled != NULL)
SCFree(reassembled);

DefragDestroy();
return ret;
}
","[8, 11, 14]","    p1 = BuildTestPacket(id, 0, 1, 'A', 8);/~/    p2 = BuildTestPacket(id, 1, 1, 'B', 8);/~/    p3 = BuildTestPacket(id, 2, 0, 'C', 3);"
79,"accept_ice_connection (GIOChannel           *source,
GIOCondition          condition,
GsmIceConnectionData *data)
{
        IceListenObj    listener;
IceConn         ice_conn;
IceAcceptStatus status;
        GsmClient      *client;
        GsmXsmpServer  *server;
        listener = data->listener;
        server = data->server;

g_debug (""GsmXsmpServer: accept_ice_connection()"");

        ice_conn = IceAcceptConnection (listener, &status);
if (status != IceAcceptSuccess) {
g_debug (""GsmXsmpServer: IceAcceptConnection returned %d"", status);
return TRUE;
}

        client = gsm_xsmp_client_new (ice_conn);
        ice_conn->context = client;
        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));
        /* the store will own the ref *
        g_object_unref (client);

return TRUE;
}
","[4, 7, 8, 9, 10, 12, 17, 18, 19, 20, 21]","        IceListenObj    listener;/~/        GsmClient      *client;/~/        GsmXsmpServer  *server;/~/        listener = data->listener;/~/        server = data->server;/~/        ice_conn = IceAcceptConnection (listener, &status);/~/        client = gsm_xsmp_client_new (ice_conn);/~/        ice_conn->context = client;/~/        gsm_store_add (server->priv->client_store, gsm_client_peek_id (client), G_OBJECT (client));/~/        /* the store will own the ref */~/        g_object_unref (client);"
80,"void FrameSelection::MoveRangeSelectionExtent(const IntPoint& contents_point) {
if (ComputeVisibleSelectionInDOMTree().IsNone())
return;

SetSelection(
SelectionInDOMTree::Builder(
GetGranularityStrategy()->UpdateExtent(contents_point, frame_))
          .SetIsHandleVisible(true)
.Build(),
SetSelectionData::Builder()
.SetShouldCloseTyping(true)
.SetShouldClearTypingStyle(true)
.SetDoNotClearStrategy(true)
.SetSetSelectionBy(SetSelectionBy::kUser)
.Build());
}
",[6],          .SetIsHandleVisible(true)
81,"bool Block::IsInvisible() const
{
    return bool(int(m_flags & 0x08) != 0);
}
","[1, 2]",{/~/    return bool(int(m_flags & 0x08) != 0);
82,"status_t SampleTable::setTimeToSampleParams(
off64_t data_offset, size_t data_size) {
    if (!mTimeToSample.empty() || data_size < 8) {
return ERROR_MALFORMED;
}

uint8_t header[8];
if (mDataSource->readAt(
data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
return ERROR_IO;
}

if (U32_AT(header) != 0) {
// Expected version = 0, flags = 0.
return ERROR_MALFORMED;
}

mTimeToSampleCount = U32_AT(&header[4]);
if ((uint64_t)mTimeToSampleCount >
(uint64_t)UINT32_MAX / (2 * sizeof(uint32_t))) {
// Choose this bound because
// 1) 2 * sizeof(uint32_t) is the amount of memory needed for one
//    time-to-sample entry in the time-to-sample table.
// 2) mTimeToSampleCount is the number of entries of the time-to-sample
//    table.
// 3) We hope that the table size does not exceed UINT32_MAX.
ALOGE(""  Error: Time-to-sample table size too large."");

return ERROR_OUT_OF_RANGE;
}

// Note: At this point, we know that mTimeToSampleCount * 2 will not
// overflow because of the above condition.
if (!mDataSource->getVector(data_offset + 8, &mTimeToSample,
mTimeToSampleCount * 2)) {
ALOGE(""  Error: Incomplete data read for time-to-sample table."");
return ERROR_IO;
}


for (size_t i = 0; i < mTimeToSample.size(); ++i) {
mTimeToSample.editItemAt(i) = ntohl(mTimeToSample[i]);
}
return OK;
}
",[2],    if (!mTimeToSample.empty() || data_size < 8) {
83,"static int init_nss_hash(struct crypto_instance *instance)
{
PK11SlotInfo*	hash_slot = NULL;
SECItem		hash_param;

if (!hash_to_nss[instance->crypto_hash_type]) {
return 0;
}

hash_param.type = siBuffer;
	hash_param.data = 0;
	hash_param.len = 0;

hash_slot = PK11_GetBestSlot(hash_to_nss[instance->crypto_hash_type], NULL);
if (hash_slot == NULL) {
log_printf(instance->log_level_security, ""Unable to find security slot (err %d)"",
PR_GetError());
return -1;
}

instance->nss_sym_key_sign = PK11_ImportSymKey(hash_slot,
hash_to_nss[instance->crypto_hash_type],
PK11_OriginUnwrap, CKA_SIGN,
&hash_param, NULL);
if (instance->nss_sym_key_sign == NULL) {
log_printf(instance->log_level_security, ""Failure to import key into NSS (err %d)"",
PR_GetError());
return -1;
}

PK11_FreeSlot(hash_slot);

return 0;
}
","[10, 11]",	hash_param.data = 0;/~/	hash_param.len = 0;
84,"void MockWebRTCPeerConnectionHandler::setRemoteDescription(const WebRTCVoidRequest& request, const WebRTCSessionDescriptionDescriptor& remoteDescription)
{
    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {
        m_remoteDescription = remoteDescription;
        postTask(new RTCVoidRequestTask(this, request, true));
} else
        postTask(new RTCVoidRequestTask(this, request, false));
}
","[1, 2, 3, 4, 6, 7]","{/~/    if (!remoteDescription.isNull() && remoteDescription.type() == ""answer"") {/~/        m_remoteDescription = remoteDescription;/~/        postTask(new RTCVoidRequestTask(this, request, true));/~/        postTask(new RTCVoidRequestTask(this, request, false));/~/}"
85,"ptaReadStream(FILE  *fp)
{
char       typestr[128];
l_int32    i, n, ix, iy, type, version;
l_float32  x, y;
PTA       *pta;

PROCNAME(""ptaReadStream"");

if (!fp)
return (PTA *)ERROR_PTR(""stream not defined"", procName, NULL);

if (fscanf(fp, ""\n Pta Version %d\n"", &version) != 1)
return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
if (version != PTA_VERSION_NUMBER)
return (PTA *)ERROR_PTR(""invalid pta version"", procName, NULL);
    if (fscanf(fp, "" Number of pts = %d; format = %s\n"", &n, typestr) != 2)
return (PTA *)ERROR_PTR(""not a pta file"", procName, NULL);
if (!strcmp(typestr, ""float""))
type = 0;
else  /* typestr is ""integer"" */
type = 1;

if ((pta = ptaCreate(n)) == NULL)
return (PTA *)ERROR_PTR(""pta not made"", procName, NULL);
for (i = 0; i < n; i++) {
if (type == 0) {  /* data is float */
if (fscanf(fp, ""   (%f, %f)\n"", &x, &y) != 2) {
ptaDestroy(&pta);
return (PTA *)ERROR_PTR(""error reading floats"", procName, NULL);
}
ptaAddPt(pta, x, y);
} else {   /* data is integer */
if (fscanf(fp, ""   (%d, %d)\n"", &ix, &iy) != 2) {
ptaDestroy(&pta);
return (PTA *)ERROR_PTR(""error reading ints"", procName, NULL);
}
ptaAddPt(pta, ix, iy);
}
}

return pta;
}
","[2, 13]","char       typestr[128];/~/    if (fscanf(fp, "" Number of pts = %d; format = %s\n"", &n, typestr) != 2)"
86,"static void sctp_sock_migrate(struct sock *oldsk, struct sock *newsk,
struct sctp_association *assoc,
sctp_socket_type_t type)
{
struct sctp_sock *oldsp = sctp_sk(oldsk);
struct sctp_sock *newsp = sctp_sk(newsk);
struct sctp_bind_bucket *pp; /* hash list port iterator */
struct sctp_endpoint *newep = newsp->ep;
struct sk_buff *skb, *tmp;
struct sctp_ulpevent *event;
struct sctp_bind_hashbucket *head;
	struct list_head tmplist;

/* Migrate socket buffer sizes and all the socket level options to the
* new socket.
*/
newsk->sk_sndbuf = oldsk->sk_sndbuf;
newsk->sk_rcvbuf = oldsk->sk_rcvbuf;
/* Brute force copy old sctp opt. */
	if (oldsp->do_auto_asconf) {
		memcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));
		inet_sk_copy_descendant(newsk, oldsk);
		memcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));
	} else
		inet_sk_copy_descendant(newsk, oldsk);

/* Restore the ep value that was overwritten with the above structure
* copy.
*/
newsp->ep = newep;
newsp->hmac = NULL;

/* Hook this new socket in to the bind_hash list. */
head = &sctp_port_hashtable[sctp_phashfn(sock_net(oldsk),
inet_sk(oldsk)->inet_num)];
local_bh_disable();
spin_lock(&head->lock);
pp = sctp_sk(oldsk)->bind_hash;
sk_add_bind_node(newsk, &pp->owner);
sctp_sk(newsk)->bind_hash = pp;
inet_sk(newsk)->inet_num = inet_sk(oldsk)->inet_num;
spin_unlock(&head->lock);
local_bh_enable();

/* Copy the bind_addr list from the original endpoint to the new
* endpoint so that we can handle restarts properly
*/
sctp_bind_addr_dup(&newsp->ep->base.bind_addr,
&oldsp->ep->base.bind_addr, GFP_KERNEL);

/* Move any messages in the old socket's receive queue that are for the
* peeled off association to the new socket's receive queue.
*/
sctp_skb_for_each(skb, &oldsk->sk_receive_queue, tmp) {
event = sctp_skb2event(skb);
if (event->asoc == assoc) {
__skb_unlink(skb, &oldsk->sk_receive_queue);
__skb_queue_tail(&newsk->sk_receive_queue, skb);
sctp_skb_set_owner_r_frag(skb, newsk);
}
}

/* Clean up any messages pending delivery due to partial
* delivery.   Three cases:
* 1) No partial deliver;  no work.
* 2) Peeling off partial delivery; keep pd_lobby in new pd_lobby.
* 3) Peeling off non-partial delivery; move pd_lobby to receive_queue.
*/
skb_queue_head_init(&newsp->pd_lobby);
atomic_set(&sctp_sk(newsk)->pd_mode, assoc->ulpq.pd_mode);

if (atomic_read(&sctp_sk(oldsk)->pd_mode)) {
struct sk_buff_head *queue;

/* Decide which queue to move pd_lobby skbs to. */
if (assoc->ulpq.pd_mode) {
queue = &newsp->pd_lobby;
} else
queue = &newsk->sk_receive_queue;

/* Walk through the pd_lobby, looking for skbs that
* need moved to the new socket.
*/
sctp_skb_for_each(skb, &oldsp->pd_lobby, tmp) {
event = sctp_skb2event(skb);
if (event->asoc == assoc) {
__skb_unlink(skb, &oldsp->pd_lobby);
__skb_queue_tail(queue, skb);
sctp_skb_set_owner_r_frag(skb, newsk);
}
}

/* Clear up any skbs waiting for the partial
* delivery to finish.
*/
if (assoc->ulpq.pd_mode)
sctp_clear_pd(oldsk, NULL);

}

sctp_skb_for_each(skb, &assoc->ulpq.reasm, tmp)
sctp_skb_set_owner_r_frag(skb, newsk);

sctp_skb_for_each(skb, &assoc->ulpq.lobby, tmp)
sctp_skb_set_owner_r_frag(skb, newsk);

/* Set the type of socket to indicate that it is peeled off from the
* original UDP-style socket or created with the accept() call on a
* TCP-style socket..
*/
newsp->type = type;

/* Mark the new socket ""in-use"" by the user so that any packets
* that may arrive on the association after we've moved it are
* queued to the backlog.  This prevents a potential race between
* backlog processing on the old socket and new-packet processing
* on the new socket.
*
* The caller has just allocated newsk so we can guarantee that other
* paths won't try to lock it and then oldsk.
*/
lock_sock_nested(newsk, SINGLE_DEPTH_NESTING);
sctp_assoc_migrate(assoc, newsk);

/* If the association on the newsk is already closed before accept()
* is called, set RCV_SHUTDOWN flag.
*/
if (sctp_state(assoc, CLOSED) && sctp_style(newsk, TCP))
newsk->sk_shutdown |= RCV_SHUTDOWN;

newsk->sk_state = SCTP_SS_ESTABLISHED;
release_sock(newsk);
}
","[11, 18, 19, 20, 21, 22, 23]","	struct list_head tmplist;/~/	if (oldsp->do_auto_asconf) {/~/		memcpy(&tmplist, &newsp->auto_asconf_list, sizeof(tmplist));/~/		inet_sk_copy_descendant(newsk, oldsk);/~/		memcpy(&newsp->auto_asconf_list, &tmplist, sizeof(tmplist));/~/	} else/~/		inet_sk_copy_descendant(newsk, oldsk);"
87,"static struct page *alloc_huge_page(struct vm_area_struct *vma,
unsigned long addr, int avoid_reserve)
{
struct hstate *h = hstate_vma(vma);
struct page *page;
	struct address_space *mapping = vma->vm_file->f_mapping;
	struct inode *inode = mapping->host;
long chg;

/*
	 * Processes that did not create the mapping will have no reserves and
	 * will not have accounted against quota. Check that the quota can be
	 * made before satisfying the allocation
	 * MAP_NORESERVE mappings may also need pages and quota allocated
	 * if no reserve mapping overlaps.
*/
chg = vma_needs_reservation(h, vma, addr);
if (chg < 0)
return ERR_PTR(-VM_FAULT_OOM);
if (chg)
		if (hugetlb_get_quota(inode->i_mapping, chg))
return ERR_PTR(-VM_FAULT_SIGBUS);

spin_lock(&hugetlb_lock);
page = dequeue_huge_page_vma(h, vma, addr, avoid_reserve);
spin_unlock(&hugetlb_lock);

if (!page) {
page = alloc_buddy_huge_page(h, NUMA_NO_NODE);
if (!page) {
			hugetlb_put_quota(inode->i_mapping, chg);
return ERR_PTR(-VM_FAULT_SIGBUS);
}
}

	set_page_private(page, (unsigned long) mapping);

vma_commit_reservation(h, vma, addr);

return page;
}
","[5, 6, 9, 10, 11, 12, 13, 19, 27, 31]","	struct address_space *mapping = vma->vm_file->f_mapping;/~/	struct inode *inode = mapping->host;/~/	 * Processes that did not create the mapping will have no reserves and/~/	 * will not have accounted against quota. Check that the quota can be/~/	 * made before satisfying the allocation/~/	 * MAP_NORESERVE mappings may also need pages and quota allocated/~/	 * if no reserve mapping overlaps./~/		if (hugetlb_get_quota(inode->i_mapping, chg))/~/			hugetlb_put_quota(inode->i_mapping, chg);/~/	set_page_private(page, (unsigned long) mapping);"
88,"int ext4_orphan_del(handle_t *handle, struct inode *inode)
{
struct list_head *prev;
struct ext4_inode_info *ei = EXT4_I(inode);
struct ext4_sb_info *sbi;
__u32 ino_next;
struct ext4_iloc iloc;
int err = 0;

	if (!EXT4_SB(inode->i_sb)->s_journal)
return 0;

mutex_lock(&EXT4_SB(inode->i_sb)->s_orphan_lock);
if (list_empty(&ei->i_orphan))
goto out;

ino_next = NEXT_ORPHAN(inode);
prev = ei->i_orphan.prev;
sbi = EXT4_SB(inode->i_sb);

jbd_debug(4, ""remove inode %lu from orphan list\n"", inode->i_ino);

list_del_init(&ei->i_orphan);

/* If we're on an error path, we may not have a valid
* transaction handle with which to update the orphan list on
* disk, but we still need to remove the inode from the linked
* list in memory. */
if (!handle)
goto out;

err = ext4_reserve_inode_write(handle, inode, &iloc);
if (err)
goto out_err;

if (prev == &sbi->s_orphan) {
jbd_debug(4, ""superblock will point to %u\n"", ino_next);
BUFFER_TRACE(sbi->s_sbh, ""get_write_access"");
err = ext4_journal_get_write_access(handle, sbi->s_sbh);
if (err)
goto out_brelse;
sbi->s_es->s_last_orphan = cpu_to_le32(ino_next);
err = ext4_handle_dirty_super(handle, inode->i_sb);
} else {
struct ext4_iloc iloc2;
struct inode *i_prev =
&list_entry(prev, struct ext4_inode_info, i_orphan)->vfs_inode;

jbd_debug(4, ""orphan inode %lu will point to %u\n"",
i_prev->i_ino, ino_next);
err = ext4_reserve_inode_write(handle, i_prev, &iloc2);
if (err)
goto out_brelse;
NEXT_ORPHAN(i_prev) = ino_next;
err = ext4_mark_iloc_dirty(handle, i_prev, &iloc2);
}
if (err)
goto out_brelse;
NEXT_ORPHAN(inode) = 0;
err = ext4_mark_iloc_dirty(handle, inode, &iloc);

out_err:
ext4_std_error(inode->i_sb, err);
out:
mutex_unlock(&EXT4_SB(inode->i_sb)->s_orphan_lock);
return err;

out_brelse:
brelse(iloc.bh);
goto out_err;
}
",[8],	if (!EXT4_SB(inode->i_sb)->s_journal)
89,"static int mptsas_process_scsi_io_request(MPTSASState *s,
MPIMsgSCSIIORequest *scsi_io,
hwaddr addr)
{
MPTSASRequest *req;
MPIMsgSCSIIOReply reply;
SCSIDevice *sdev;
int status;

mptsas_fix_scsi_io_endianness(scsi_io);

trace_mptsas_process_scsi_io_request(s, scsi_io->Bus, scsi_io->TargetID,
scsi_io->LUN[1], scsi_io->DataLength);

status = mptsas_scsi_device_find(s, scsi_io->Bus, scsi_io->TargetID,
scsi_io->LUN, &sdev);
if (status) {
goto bad;
}

    req = g_new(MPTSASRequest, 1);
QTAILQ_INSERT_TAIL(&s->pending, req, next);
req->scsi_io = *scsi_io;
req->dev = s;

status = mptsas_build_sgl(s, req, addr);
if (status) {
goto free_bad;
}

if (req->qsg.size < scsi_io->DataLength) {
trace_mptsas_sgl_overflow(s, scsi_io->MsgContext, scsi_io->DataLength,
req->qsg.size);
status = MPI_IOCSTATUS_INVALID_SGL;
goto free_bad;
}

req->sreq = scsi_req_new(sdev, scsi_io->MsgContext,
scsi_io->LUN[1], scsi_io->CDB, req);

if (req->sreq->cmd.xfer > scsi_io->DataLength) {
goto overrun;
}
switch (scsi_io->Control & MPI_SCSIIO_CONTROL_DATADIRECTION_MASK) {
case MPI_SCSIIO_CONTROL_NODATATRANSFER:
if (req->sreq->cmd.mode != SCSI_XFER_NONE) {
goto overrun;
}
break;

case MPI_SCSIIO_CONTROL_WRITE:
if (req->sreq->cmd.mode != SCSI_XFER_TO_DEV) {
goto overrun;
}
break;

case MPI_SCSIIO_CONTROL_READ:
if (req->sreq->cmd.mode != SCSI_XFER_FROM_DEV) {
goto overrun;
}
break;
}

if (scsi_req_enqueue(req->sreq)) {
scsi_req_continue(req->sreq);
}
return 0;

overrun:
trace_mptsas_scsi_overflow(s, scsi_io->MsgContext, req->sreq->cmd.xfer,
scsi_io->DataLength);
status = MPI_IOCSTATUS_SCSI_DATA_OVERRUN;
free_bad:
mptsas_free_request(req);
bad:
memset(&reply, 0, sizeof(reply));
reply.TargetID          = scsi_io->TargetID;
reply.Bus               = scsi_io->Bus;
reply.MsgLength         = sizeof(reply) / 4;
reply.Function          = scsi_io->Function;
reply.CDBLength         = scsi_io->CDBLength;
reply.SenseBufferLength = scsi_io->SenseBufferLength;
reply.MsgContext        = scsi_io->MsgContext;
reply.SCSIState         = MPI_SCSI_STATE_NO_SCSI_STATUS;
reply.IOCStatus         = status;

mptsas_fix_scsi_io_reply_endianness(&reply);
mptsas_reply(s, (MPIDefaultReply *)&reply);

return 0;
}
",[16],"    req = g_new(MPTSASRequest, 1);"
90,"static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,
unsigned int *rsize)
{
	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
hid_info(hdev, ""fixing up Cherry Cymotion report descriptor\n"");
rdesc[11] = rdesc[16] = 0xff;
rdesc[12] = rdesc[17] = 0x03;
}
return rdesc;
}
",[3],	if (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {
91,"int git_delta_apply(
void **out,
size_t *out_len,
const unsigned char *base,
size_t base_len,
const unsigned char *delta,
size_t delta_len)
{
const unsigned char *delta_end = delta + delta_len;
size_t base_sz, res_sz, alloc_sz;
unsigned char *res_dp;

*out = NULL;
*out_len = 0;

/*
* Check that the base size matches the data we were given;
* if not we would underflow while accessing data from the
* base object, resulting in data corruption or segfault.
*/
if ((hdr_sz(&base_sz, &delta, delta_end) < 0) || (base_sz != base_len)) {
giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
return -1;
}

if (hdr_sz(&res_sz, &delta, delta_end) < 0) {
giterr_set(GITERR_INVALID, ""failed to apply delta: base size does not match given data"");
return -1;
}

GITERR_CHECK_ALLOC_ADD(&alloc_sz, res_sz, 1);
res_dp = git__malloc(alloc_sz);
GITERR_CHECK_ALLOC(res_dp);

res_dp[res_sz] = '\0';
*out = res_dp;
*out_len = res_sz;

while (delta < delta_end) {
unsigned char cmd = *delta++;
if (cmd & 0x80) {
/* cmd is a copy instruction; copy from the base. */
size_t off = 0, len = 0;

			if (cmd & 0x01) off = *delta++;
			if (cmd & 0x02) off |= *delta++ << 8UL;
			if (cmd & 0x04) off |= *delta++ << 16UL;
			if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);
			if (cmd & 0x10) len = *delta++;
			if (cmd & 0x20) len |= *delta++ << 8UL;
			if (cmd & 0x40) len |= *delta++ << 16UL;
if (!len)       len = 0x10000;

if (base_len < off + len || res_sz < len)
goto fail;
memcpy(res_dp, base + off, len);
res_dp += len;
res_sz -= len;

} else if (cmd) {
/*
* cmd is a literal insert instruction; copy from
* the delta stream itself.
*/
if (delta_end - delta < cmd || res_sz < cmd)
goto fail;
memcpy(res_dp, delta, cmd);
delta += cmd;
res_dp += cmd;
res_sz -= cmd;

} else {
/* cmd == 0 is reserved for future encodings. */
goto fail;
}
}

if (delta != delta_end || res_sz)
goto fail;
return 0;

fail:
git__free(*out);

*out = NULL;
*out_len = 0;

giterr_set(GITERR_INVALID, ""failed to apply delta"");
return -1;
}
","[37, 38, 39]",			if (cmd & 0x01) off = *delta++;/~/			if (cmd & 0x02) off |= *delta++ << 8UL;/~/			if (cmd & 0x04) off |= *delta++ << 16UL;/~/			if (cmd & 0x08) off |= ((unsigned) *delta++ << 24UL);/~/			if (cmd & 0x10) len = *delta++;/~/			if (cmd & 0x20) len |= *delta++ << 8UL;/~/			if (cmd & 0x40) len |= *delta++ << 16UL;
92,"void RenderFrameDevToolsAgentHost::DestroyOnRenderFrameGone() {
scoped_refptr<RenderFrameDevToolsAgentHost> protect(this);
if (IsAttached())
RevokePolicy();
  ForceDetachAllClients();
frame_host_ = nullptr;
agent_ptr_.reset();
SetFrameTreeNode(nullptr);
Release();
}
",[4],  ForceDetachAllClients();
93,"asmlinkage void do_sparc_fault(struct pt_regs *regs, int text_fault, int write,
unsigned long address)
{
struct vm_area_struct *vma;
struct task_struct *tsk = current;
struct mm_struct *mm = tsk->mm;
unsigned int fixup;
unsigned long g2;
int from_user = !(regs->psr & PSR_PS);
int fault, code;

if(text_fault)
address = regs->pc;

/*
* We fault-in kernel-space virtual memory on-demand. The
* 'reference' page table is init_mm.pgd.
*
* NOTE! We MUST NOT take any locks for this case. We may
* be in an interrupt or a critical region, and should
* only copy the information from the master page table,
* nothing more.
*/
code = SEGV_MAPERR;
if (!ARCH_SUN4C && address >= TASK_SIZE)
goto vmalloc_fault;

/*
* If we're in an interrupt or have no user
* context, we must not take the fault..
*/
if (in_atomic() || !mm)
goto no_context;

	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);

down_read(&mm->mmap_sem);

/*
* The kernel referencing a bad kernel pointer can lock up
* a sun4c machine completely, so we must attempt recovery.
*/
if(!from_user && address >= PAGE_OFFSET)
goto bad_area;

vma = find_vma(mm, address);
if(!vma)
goto bad_area;
if(vma->vm_start <= address)
goto good_area;
if(!(vma->vm_flags & VM_GROWSDOWN))
goto bad_area;
if(expand_stack(vma, address))
goto bad_area;
/*
* Ok, we have a good vm_area for this memory access, so
* we can handle it..
*/
good_area:
code = SEGV_ACCERR;
if(write) {
if(!(vma->vm_flags & VM_WRITE))
goto bad_area;
} else {
/* Allow reads even for write-only mappings */
if(!(vma->vm_flags & (VM_READ | VM_EXEC)))
goto bad_area;
}

/*
* If for any reason at all we couldn't handle the fault,
* make sure we exit gracefully rather than endlessly redo
* the fault.
*/
fault = handle_mm_fault(mm, vma, address, write ? FAULT_FLAG_WRITE : 0);
if (unlikely(fault & VM_FAULT_ERROR)) {
if (fault & VM_FAULT_OOM)
goto out_of_memory;
else if (fault & VM_FAULT_SIGBUS)
goto do_sigbus;
BUG();
}
if (fault & VM_FAULT_MAJOR) {
current->maj_flt++;
		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,
			      regs, address);
} else {
current->min_flt++;
		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,
			      regs, address);
}
up_read(&mm->mmap_sem);
return;

/*
* Something tried to access memory that isn't in our memory map..
* Fix it, but check if it's kernel or user first..
*/
bad_area:
up_read(&mm->mmap_sem);

bad_area_nosemaphore:
/* User mode accesses just cause a SIGSEGV */
if (from_user) {
do_fault_siginfo(code, SIGSEGV, regs, text_fault);
return;
}

/* Is this in ex_table? */
no_context:
g2 = regs->u_regs[UREG_G2];
if (!from_user) {
fixup = search_extables_range(regs->pc, &g2);
if (fixup > 10) { /* Values below are reserved for other things */
extern const unsigned __memset_start[];
extern const unsigned __memset_end[];
extern const unsigned __csum_partial_copy_start[];
extern const unsigned __csum_partial_copy_end[];

#ifdef DEBUG_EXCEPTIONS
printk(""Exception: PC<%08lx> faddr<%08lx>\n"", regs->pc, address);
printk(""EX_TABLE: insn<%08lx> fixup<%08x> g2<%08lx>\n"",
regs->pc, fixup, g2);
#endif
if ((regs->pc >= (unsigned long)__memset_start &&
regs->pc < (unsigned long)__memset_end) ||
(regs->pc >= (unsigned long)__csum_partial_copy_start &&
regs->pc < (unsigned long)__csum_partial_copy_end)) {
regs->u_regs[UREG_I4] = address;
regs->u_regs[UREG_I5] = regs->pc;
}
regs->u_regs[UREG_G2] = g2;
regs->pc = fixup;
regs->npc = regs->pc + 4;
return;
}
}

unhandled_fault (address, tsk, regs);
do_exit(SIGKILL);

/*
* We ran out of memory, or some other thing happened to us that made
* us unable to handle the page fault gracefully.
*/
out_of_memory:
up_read(&mm->mmap_sem);
if (from_user) {
pagefault_out_of_memory();
return;
}
goto no_context;

do_sigbus:
up_read(&mm->mmap_sem);
do_fault_siginfo(BUS_ADRERR, SIGBUS, regs, text_fault);
if (!from_user)
goto no_context;

vmalloc_fault:
{
/*
* Synchronize this task's top level page-table
* with the 'reference' page table.
*/
int offset = pgd_index(address);
pgd_t *pgd, *pgd_k;
pmd_t *pmd, *pmd_k;

pgd = tsk->active_mm->pgd + offset;
pgd_k = init_mm.pgd + offset;

if (!pgd_present(*pgd)) {
if (!pgd_present(*pgd_k))
goto bad_area_nosemaphore;
pgd_val(*pgd) = pgd_val(*pgd_k);
return;
}

pmd = pmd_offset(pgd, address);
pmd_k = pmd_offset(pgd_k, address);

if (pmd_present(*pmd) || !pmd_present(*pmd_k))
goto bad_area_nosemaphore;
*pmd = *pmd_k;
return;
}
}
",[30],"	perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS, 1, 0, regs, address);/~/		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MAJ, 1, 0,/~/			      regs, address);/~/		perf_sw_event(PERF_COUNT_SW_PAGE_FAULTS_MIN, 1, 0,/~/			      regs, address);"
94,"void bdt_enable(void)
{
bdt_log(""ENABLE BT"");
if (bt_enabled) {

bdt_log(""Bluetooth is already enabled"");
return;
}
    status = sBtInterface->enable();

check_return_status(status);
}
",[7],    status = sBtInterface->enable();
95,"void GpuVideoDecodeAccelerator::Initialize(
const media::VideoCodecProfile profile,
    IPC::Message* init_done_msg,
    base::ProcessHandle renderer_process) {
DCHECK(!video_decode_accelerator_.get());
DCHECK(!init_done_msg_);
DCHECK(init_done_msg);
init_done_msg_ = init_done_msg;

#if (defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)) || defined(OS_WIN)
DCHECK(stub_ && stub_->decoder());
#if defined(OS_WIN)
if (base::win::GetVersion() < base::win::VERSION_WIN7) {
NOTIMPLEMENTED() << ""HW video decode acceleration not available."";
NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);
return;
}
DLOG(INFO) << ""Initializing DXVA HW decoder for windows."";
DXVAVideoDecodeAccelerator* video_decoder =
      new DXVAVideoDecodeAccelerator(this, renderer_process);
#else  // OS_WIN
OmxVideoDecodeAccelerator* video_decoder =
new OmxVideoDecodeAccelerator(this);
video_decoder->SetEglState(
gfx::GLSurfaceEGL::GetHardwareDisplay(),
stub_->decoder()->GetGLContext()->GetHandle());
#endif  // OS_WIN
video_decode_accelerator_ = video_decoder;
if (!video_decode_accelerator_->Initialize(profile))
NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);
#else  // Update RenderViewImpl::createMediaPlayer when adding clauses.
NOTIMPLEMENTED() << ""HW video decode acceleration not available."";
NotifyError(media::VideoDecodeAccelerator::PLATFORM_FAILURE);
#endif  // defined(OS_CHROMEOS) && defined(ARCH_CPU_ARMEL)
}
","[2, 3, 18]","    IPC::Message* init_done_msg,/~/    base::ProcessHandle renderer_process) {/~/      new DXVAVideoDecodeAccelerator(this, renderer_process);"
96,"void OffscreenCanvasFrameReceiverImpl::SubmitCompositorFrame(
const cc::SurfaceId& surface_id,
cc::CompositorFrame frame) {
    cc::Surface* surface = GetSurfaceManager()->GetSurfaceForId(surface_id);
    if (surface) {
        surface->QueueFrame(std::move(frame), base::Closure());
}
    // If surface doet not exist, drop the frame.
}
","[3, 4, 5, 7]","    cc::Surface* surface = GetSurfaceManager()->GetSurfaceForId(surface_id);/~/    if (surface) {/~/        surface->QueueFrame(std::move(frame), base::Closure());/~/    // If surface doet not exist, drop the frame."
97,"bool isUserInteractionEventForSlider(Event* event, LayoutObject* layoutObject) {
// It is unclear if this can be converted to isUserInteractionEvent(), since
// mouse* events seem to be eaten during a drag anyway.  crbug.com/516416 .
if (isUserInteractionEvent(event))
return true;

// Some events are only captured during a slider drag.
LayoutSliderItem slider = LayoutSliderItem(toLayoutSlider(layoutObject));
if (!slider.isNull() && !slider.inDragMode())
return false;

const AtomicString& type = event->type();
return type == EventTypeNames::mouseover ||
         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
}
",[11],         type == EventTypeNames::mouseout || type == EventTypeNames::mousemove;
98,"long Cluster::ParseSimpleBlock(long long block_size, long long& pos,
long& len) {
const long long block_start = pos;
const long long block_stop = pos + block_size;

IMkvReader* const pReader = m_pSegment->m_pReader;

long long total, avail;

long status = pReader->Length(&total, &avail);

if (status < 0) // error
return status;

assert((total < 0) || (avail <= total));

// parse track number

if ((pos + 1) > avail) {
len = 1;
return E_BUFFER_NOT_FULL;
}

long long result = GetUIntLength(pReader, pos, len);

if (result < 0) // error
return static_cast<long>(result);

if (result > 0) // weird
return E_BUFFER_NOT_FULL;

if ((pos + len) > block_stop)
return E_FILE_FORMAT_INVALID;

if ((pos + len) > avail)
return E_BUFFER_NOT_FULL;

const long long track = ReadUInt(pReader, pos, len);

if (track < 0) // error
return static_cast<long>(track);


if (track == 0)
return E_FILE_FORMAT_INVALID;

#if 0
    //TODO(matthewjheaney)
    //This turned out to be too conservative.  The problem is that
    //if we see a track header in the tracks element with an unsupported
    //track type, we throw that track header away, so it is not present
    //in the track map.  But even though we don't understand the track
    //header, there are still blocks in the cluster with that track
    //number.  It was our decision to ignore that track header, so it's
    //up to us to deal with blocks associated with that track -- we
    //cannot simply report an error since technically there's nothing
    //wrong with the file.
    
    //For now we go ahead and finish the parse, creating a block entry
    //for this block.  This is somewhat wasteful, because without a
    //track header there's nothing you can do with the block. What
    //we really need here is a special return value that indicates to
    //the caller that he should ignore this particular block, and
    //continue parsing.
    const Tracks* const pTracks = m_pSegment->GetTracks();
    assert(pTracks);
    const long tn = static_cast<long>(track);
    const Track* const pTrack = pTracks->GetTrackByNumber(tn);
    if (pTrack == NULL)
        return E_FILE_FORMAT_INVALID;
#endif
pos += len;  // consume track number

if ((pos + 2) > block_stop)
return E_FILE_FORMAT_INVALID;

if ((pos + 2) > avail) {
len = 2;
return E_BUFFER_NOT_FULL;
}

pos += 2; // consume timecode

if ((pos + 1) > block_stop)
return E_FILE_FORMAT_INVALID;

if ((pos + 1) > avail) {
len = 1;
return E_BUFFER_NOT_FULL;
}

unsigned char flags;

status = pReader->Read(pos, 1, &flags);

if (status < 0) { // error or underflow
len = 1;
return status;
}

++pos; // consume flags byte
assert(pos <= avail);

if (pos >= block_stop)
return E_FILE_FORMAT_INVALID;

const int lacing = int(flags & 0x06) >> 1;

if ((lacing != 0) && (block_stop > avail)) {
len = static_cast<long>(block_stop - pos);
return E_BUFFER_NOT_FULL;
}

status = CreateBlock(0x23, // simple block id
block_start, block_size,
0); // DiscardPadding

if (status != 0)
return status;

m_pos = block_stop;

return 0; // success
}
","[21, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40]","#if 0/~/    //TODO(matthewjheaney)/~/    //This turned out to be too conservative.  The problem is that/~/    //if we see a track header in the tracks element with an unsupported/~/    //track type, we throw that track header away, so it is not present/~/    //in the track map.  But even though we don't understand the track/~/    //header, there are still blocks in the cluster with that track/~/    //number.  It was our decision to ignore that track header, so it's/~/    //up to us to deal with blocks associated with that track -- we/~/    //cannot simply report an error since technically there's nothing/~/    //wrong with the file./~/    /~/    //For now we go ahead and finish the parse, creating a block entry/~/    //for this block.  This is somewhat wasteful, because without a/~/    //track header there's nothing you can do with the block. What/~/    //we really need here is a special return value that indicates to/~/    //the caller that he should ignore this particular block, and/~/    //continue parsing./~/    const Tracks* const pTracks = m_pSegment->GetTracks();/~/    assert(pTracks);/~/    const long tn = static_cast<long>(track);/~/    const Track* const pTrack = pTracks->GetTrackByNumber(tn);/~/    if (pTrack == NULL)/~/        return E_FILE_FORMAT_INVALID;/~/#endif"
99,"DOMHandler::DOMHandler()
: DevToolsDomainHandler(DOM::Metainfo::domainName),
      host_(nullptr) {
}
","[2, 3]",      host_(nullptr) {/~/}
100,"int send_event (int fd, uint16_t type, uint16_t code, int32_t value)
{
struct uinput_event event;
BTIF_TRACE_DEBUG(""%s type:%u code:%u value:%d"", __FUNCTION__,
type, code, value);
memset(&event, 0, sizeof(event));
event.type  = type;

event.code  = code;
event.value = value;

    return write(fd, &event, sizeof(event));
}
",[9],"    return write(fd, &event, sizeof(event));"
101,"ProcEstablishConnection(ClientPtr client)
{
const char *reason;
char *auth_proto, *auth_string;
xConnClientPrefix *prefix;

REQUEST(xReq);

prefix = (xConnClientPrefix *) ((char *) stuff + sz_xReq);
auth_proto = (char *) prefix + sz_xConnClientPrefix;
auth_string = auth_proto + pad_to_int32(prefix->nbytesAuthProto);
    if ((prefix->majorVersion != X_PROTOCOL) ||
(prefix->minorVersion != X_PROTOCOL_REVISION))
reason = ""Protocol version mismatch"";
else

return (SendConnSetup(client, reason));
}
",[9],    if ((prefix->majorVersion != X_PROTOCOL) ||
102,"long Track::GetNumber() const
{
    return m_info.number;
}
","[1, 2, 3]",{/~/    return m_info.number;/~/}
103,"static void sas_scsi_clear_queue_lu(struct list_head *error_q, struct scsi_cmnd *my_cmd)
{
struct scsi_cmnd *cmd, *n;

list_for_each_entry_safe(cmd, n, error_q, eh_entry) {
if (cmd->device->sdev_target == my_cmd->device->sdev_target &&
cmd->device->lun == my_cmd->device->lun)
			sas_eh_defer_cmd(cmd);
}
}
",[6],			sas_eh_defer_cmd(cmd);
104,"static struct svc_serv *nfs_callback_create_svc(int minorversion)
{
struct nfs_callback_data *cb_info = &nfs_callback_info[minorversion];
struct svc_serv *serv;
struct svc_serv_ops *sv_ops;

/*
* Check whether we're already up and running.
*/
if (cb_info->serv) {
/*
* Note: increase service usage, because later in case of error
* svc_destroy() will be called.
*/
svc_get(cb_info->serv);
return cb_info->serv;
}

switch (minorversion) {
case 0:
sv_ops = nfs4_cb_sv_ops[0];
break;
default:
sv_ops = nfs4_cb_sv_ops[1];
}

if (sv_ops == NULL)
return ERR_PTR(-ENOTSUPP);

/*
* Sanity check: if there's no task,
* we should be the first user ...
*/
if (cb_info->users)
printk(KERN_WARNING ""nfs_callback_create_svc: no kthread, %d users??\n"",
cb_info->users);

	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);
if (!serv) {
printk(KERN_ERR ""nfs_callback_create_svc: create service failed\n"");
return ERR_PTR(-ENOMEM);
}
cb_info->serv = serv;
/* As there is only one thread we need to over-ride the
* default maximum of 80 connections
*/
serv->sv_maxconn = 1024;
dprintk(""nfs_callback_create_svc: service created\n"");
return serv;
}
",[32],"	serv = svc_create(&nfs4_callback_program, NFS4_CALLBACK_BUFSIZE, sv_ops);"
105,"_exsltDateAdd (exsltDateValPtr dt, exsltDateValPtr dur)
{
exsltDateValPtr ret;
long carry, tempdays, temp;
exsltDateValDatePtr r, d;
exsltDateValDurationPtr u;

if ((dt == NULL) || (dur == NULL))
return NULL;

ret = exsltDateCreateDate(dt->type);
if (ret == NULL)
return NULL;

r = &(ret->value.date);
d = &(dt->value.date);
u = &(dur->value.dur);

    /* normalization *
    if (d->mon == 0)
        d->mon = 1;
/* normalize for time zone offset */
u->sec -= (d->tzo * 60);	/* changed from + to - (bug 153000) */
d->tzo = 0;

    /* normalization *
    if (d->day == 0)
        d->day = 1;
/* month */
carry  = d->mon + u->mon;
r->mon = (unsigned int)MODULO_RANGE(carry, 1, 13);
carry  = (long)FQUOTIENT_RANGE(carry, 1, 13);

/* year (may be modified later) */
r->year = d->year + carry;
if (r->year == 0) {
if (d->year > 0)
r->year--;
else
r->year++;
}

/* time zone */
r->tzo     = d->tzo;
r->tz_flag = d->tz_flag;

/* seconds */
r->sec = d->sec + u->sec;
carry  = (long)FQUOTIENT((long)r->sec, 60);
if (r->sec != 0.0) {
r->sec = MODULO(r->sec, 60.0);
}

/* minute */
carry += d->min;
r->min = (unsigned int)MODULO(carry, 60);
carry  = (long)FQUOTIENT(carry, 60);

/* hours */
carry  += d->hour;
r->hour = (unsigned int)MODULO(carry, 24);
carry   = (long)FQUOTIENT(carry, 24);

/*
* days
* Note we use tempdays because the temporary values may need more
* than 5 bits
*/
if ((VALID_YEAR(r->year)) && (VALID_MONTH(r->mon)) &&
(d->day > MAX_DAYINMONTH(r->year, r->mon)))
tempdays = MAX_DAYINMONTH(r->year, r->mon);
else if (d->day < 1)
tempdays = 1;
else
tempdays = d->day;

tempdays += u->day + carry;

while (1) {
if (tempdays < 1) {
long tmon = (long)MODULO_RANGE((int)r->mon-1, 1, 13);
long tyr  = r->year + (long)FQUOTIENT_RANGE((int)r->mon-1, 1, 13);
if (tyr == 0)
tyr--;
/*
* Coverity detected an overrun in daysInMonth
* of size 12 at position 12 with index variable ""((r)->mon - 1)""
*/
if (tmon < 0)
tmon = 0;
if (tmon > 12)
tmon = 12;
tempdays += MAX_DAYINMONTH(tyr, tmon);
carry = -1;
} else if (tempdays > (long)MAX_DAYINMONTH(r->year, r->mon)) {
tempdays = tempdays - MAX_DAYINMONTH(r->year, r->mon);
carry = 1;
} else
break;

temp = r->mon + carry;
r->mon = (unsigned int)MODULO_RANGE(temp, 1, 13);
r->year = r->year + (long)FQUOTIENT_RANGE(temp, 1, 13);
if (r->year == 0) {
if (temp < 1)
r->year--;
else
r->year++;
}
}

r->day = tempdays;

/*
* adjust the date/time type to the date values
*/
if (ret->type != XS_DATETIME) {
if ((r->hour) || (r->min) || (r->sec))
ret->type = XS_DATETIME;
else if (ret->type != XS_DATE) {
if (r->day != 1)
ret->type = XS_DATE;
else if ((ret->type != XS_GYEARMONTH) && (r->mon != 1))
ret->type = XS_GYEARMONTH;
}
}

return ret;
}
","[14, 15, 16, 21, 22, 23]",    /* normalization */~/    if (d->mon == 0)/~/        d->mon = 1;/~/    /* normalization */~/    if (d->day == 0)/~/        d->day = 1;
106,"WORD32 ih264d_cavlc_4x4res_block_totalcoeff_2to10(UWORD32 u4_isdc,
UWORD32 u4_total_coeff_trail_one, /*!<TotalCoefficients<<16+trailingones*/
dec_bit_stream_t *ps_bitstrm)
{
UWORD32 u4_total_zeroes;
WORD32 i;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;

UWORD32 u4_bitstream_offset = ps_bitstrm->u4_ofst;
UWORD32 u4_trailing_ones = u4_total_coeff_trail_one & 0xFFFF;
UWORD32 u4_total_coeff = u4_total_coeff_trail_one >> 16;
    WORD16 i2_level_arr[16];

tu_sblk4x4_coeff_data_t *ps_tu_4x4;
WORD16 *pi2_coeff_data;
dec_struct_t *ps_dec = (dec_struct_t *)ps_bitstrm->pv_codec_handle;

ps_tu_4x4 = (tu_sblk4x4_coeff_data_t *)ps_dec->pv_parse_tu_coeff_data;
ps_tu_4x4->u2_sig_coeff_map = 0;
pi2_coeff_data = &ps_tu_4x4->ai2_level[0];

i = u4_total_coeff - 1;

if(u4_trailing_ones)
{
/*********************************************************************/
/* Decode Trailing Ones                                              */
/* read the sign of T1's and put them in level array                 */
/*********************************************************************/
UWORD32 u4_signs, u4_cnt = u4_trailing_ones;
WORD16 (*ppi2_trlone_lkup)[3] =
(WORD16 (*)[3])gai2_ih264d_trailing_one_level;
WORD16 *pi2_trlone_lkup;

GETBITS(u4_signs, u4_bitstream_offset, pu4_bitstrm_buf, u4_cnt);

pi2_trlone_lkup = ppi2_trlone_lkup[(1 << u4_cnt) - 2 + u4_signs];

while(u4_cnt--)
i2_level_arr[i--] = *pi2_trlone_lkup++;
}

/****************************************************************/
/* Decoding Levels Begins                                       */
/****************************************************************/
if(i >= 0)
{
/****************************************************************/
/* First level is decoded outside the loop as it has lot of     */
/* special cases.                                               */
/****************************************************************/
UWORD32 u4_lev_suffix, u4_suffix_len, u4_lev_suffix_size;
WORD32 u2_lev_code, u2_abs_value;
UWORD32 u4_lev_prefix;

/***************************************************************/
/* u4_suffix_len = 0,  Find leading zeros in next 32 bits      */
/***************************************************************/
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);

/*********************************************************/
/* Special decoding case when trailing ones are 3        */
/*********************************************************/
u2_lev_code = MIN(15, u4_lev_prefix);

u2_lev_code += (3 == u4_trailing_ones) ? 0 : 2;

if(14 == u4_lev_prefix)
u4_lev_suffix_size = 4;
else if(15 <= u4_lev_prefix)
{
u2_lev_code += 15;
u4_lev_suffix_size = u4_lev_prefix - 3;
}
else
u4_lev_suffix_size = 0;

//HP_LEVEL_PREFIX
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
if(u4_lev_suffix_size)
{
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code += u4_lev_suffix;
}

u2_abs_value = (u2_lev_code + 2) >> 1;
/*********************************************************/
/* If Level code is odd, level is negative else positive */
/*********************************************************/
i2_level_arr[i--] = (u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

u4_suffix_len = (u2_abs_value > 3) ? 2 : 1;

/*********************************************************/
/* Now loop over the remaining levels                    */
/*********************************************************/
while(i >= 0)
{

/***************************************************************/
/* Find leading zeros in next 32 bits                          */
/***************************************************************/
FIND_ONE_IN_STREAM_32(u4_lev_prefix, u4_bitstream_offset,
pu4_bitstrm_buf);

u4_lev_suffix_size =
(15 <= u4_lev_prefix) ?
(u4_lev_prefix - 3) : u4_suffix_len;

/*********************************************************/
/* Compute level code using prefix and suffix            */
/*********************************************************/
GETBITS(u4_lev_suffix, u4_bitstream_offset, pu4_bitstrm_buf,
u4_lev_suffix_size);
u2_lev_code = (MIN(15,u4_lev_prefix) << u4_suffix_len)
+ u4_lev_suffix;

//HP_LEVEL_PREFIX
if(16 <= u4_lev_prefix)
{
u2_lev_code += ((1 << (u4_lev_prefix - 3)) - 4096);
}
u2_abs_value = (u2_lev_code + 2) >> 1;

/*********************************************************/
/* If Level code is odd, level is negative else positive */
/*********************************************************/
i2_level_arr[i--] =
(u2_lev_code & 1) ? -u2_abs_value : u2_abs_value;

/*********************************************************/
/* Increment suffix length if required                   */
/*********************************************************/
u4_suffix_len +=
(u4_suffix_len < 6) ?
(u2_abs_value
> (3
<< (u4_suffix_len
- 1))) :
0;
}

/****************************************************************/
/* Decoding Levels Ends                                         */
/****************************************************************/
}

/****************************************************************/
/* Decoding total zeros as in section 9.2.3, table 9.7          */
/****************************************************************/
{
UWORD32 u4_index;
const UWORD8 (*ppu1_total_zero_lkup)[64] =
(const UWORD8 (*)[64])gau1_ih264d_table_total_zero_2to10;

NEXTBITS(u4_index, u4_bitstream_offset, pu4_bitstrm_buf, 6);
u4_total_zeroes = ppu1_total_zero_lkup[u4_total_coeff - 2][u4_index];

FLUSHBITS(u4_bitstream_offset, (u4_total_zeroes >> 4));
u4_total_zeroes &= 0xf;
}

/**************************************************************/
/* Decode the runs and form the coefficient buffer            */
/**************************************************************/
{
const UWORD8 *pu1_table_runbefore;
UWORD32 u4_run;
WORD32 k;
UWORD32 u4_scan_pos = u4_total_coeff + u4_total_zeroes - 1 + u4_isdc;
WORD32 u4_zeroes_left = u4_total_zeroes;
k = u4_total_coeff - 1;

/**************************************************************/
/* Decoding Runs Begin for zeros left > 6                     */
/**************************************************************/
while((u4_zeroes_left > 6) && k)
{
UWORD32 u4_code;

NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);

if(u4_code != 0)
{
FLUSHBITS(u4_bitstream_offset, 3);
u4_run = (7 - u4_code);
}
else
{

FIND_ONE_IN_STREAM_LEN(u4_code, u4_bitstream_offset,
pu4_bitstrm_buf, 11);
u4_run = (4 + u4_code);
}

SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_zeroes_left -= u4_run;
u4_scan_pos -= (u4_run + 1);
}

/**************************************************************/
/* Decoding Runs for 0 < zeros left <=6                       */
/**************************************************************/
pu1_table_runbefore = (UWORD8 *)gau1_ih264d_table_run_before;
while((u4_zeroes_left > 0) && k)
{
UWORD32 u4_code;
NEXTBITS(u4_code, u4_bitstream_offset, pu4_bitstrm_buf, 3);

u4_code = pu1_table_runbefore[u4_code + (u4_zeroes_left << 3)];
u4_run = u4_code >> 2;

FLUSHBITS(u4_bitstream_offset, (u4_code & 0x03));

SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_zeroes_left -= u4_run;
u4_scan_pos -= (u4_run + 1);
}
/**************************************************************/
/* Decoding Runs End                                          */
/**************************************************************/

/**************************************************************/
/* Copy the remaining coefficients                            */
/**************************************************************/
if(u4_zeroes_left < 0)
return -1;
while(k >= 0)
{

SET_BIT(ps_tu_4x4->u2_sig_coeff_map, u4_scan_pos);
*pi2_coeff_data++ = i2_level_arr[k--];
u4_scan_pos--;
}
}

{
WORD32 offset;
offset = (UWORD8 *)pi2_coeff_data - (UWORD8 *)ps_tu_4x4;
offset = ALIGN4(offset);
ps_dec->pv_parse_tu_coeff_data = (void *)((UWORD8 *)ps_dec->pv_parse_tu_coeff_data + offset);
}

ps_bitstrm->u4_ofst = u4_bitstream_offset;
return 0;
}
",[10],    WORD16 i2_level_arr[16];
107,"String InspectorPageAgent::CachedResourceTypeJson(
const Resource& cached_resource) {
  return ResourceTypeJson(CachedResourceType(cached_resource));
}
",[2],  return ResourceTypeJson(CachedResourceType(cached_resource));
108,"XGetModifierMapping(register Display *dpy)
{
xGetModifierMappingReply rep;
register xReq *req;
unsigned long nbytes;
XModifierKeymap *res;

LockDisplay(dpy);
GetEmptyReq(GetModifierMapping, req);
(void) _XReply (dpy, (xReply *)&rep, 0, xFalse);

    if (rep.length < (INT_MAX >> 2)) {
nbytes = (unsigned long)rep.length << 2;
res = Xmalloc(sizeof (XModifierKeymap));
if (res)
} else
res = NULL;
if ((! res) || (! res->modifiermap)) {
Xfree(res);
res = (XModifierKeymap *) NULL;
_XEatDataWords(dpy, rep.length);
} else {
_XReadPad(dpy, (char *) res->modifiermap, (long) nbytes);
res->max_keypermod = rep.numKeyPerModifier;
}

UnlockDisplay(dpy);
SyncHandle();
return (res);
}
",[9],    if (rep.length < (INT_MAX >> 2)) {
109,"static void addDataToStreamTask(void* context)
{
OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);
}
",[3],"    blobRegistry().addDataToStream(blobRegistryContext->url, blobRegistryContext->streamData);"
110,"static sk_sp<SkImage> unPremulSkImageToPremul(SkImage* input) {
SkImageInfo info = SkImageInfo::Make(input->width(), input->height(),
kN32_SkColorType, kPremul_SkAlphaType);
RefPtr<Uint8Array> dstPixels = copySkImageData(input, info);
if (!dstPixels)
return nullptr;
return newSkImageFromRaster(
info, std::move(dstPixels),
      static_cast<size_t>(input->width()) * info.bytesPerPixel());
}
",[8],      static_cast<size_t>(input->width()) * info.bytesPerPixel());
111,"static int complete_emulated_mmio(struct kvm_vcpu *vcpu)
{
struct kvm_run *run = vcpu->run;
struct kvm_mmio_fragment *frag;
unsigned len;

BUG_ON(!vcpu->mmio_needed);

/* Complete previous fragment */
frag = &vcpu->mmio_fragments[vcpu->mmio_cur_fragment];
len = min(8u, frag->len);
if (!vcpu->mmio_is_write)
memcpy(frag->data, run->mmio.data, len);

if (frag->len <= 8) {
/* Switch to the next fragment. */
frag++;
vcpu->mmio_cur_fragment++;
} else {
/* Go forward to the next mmio piece. */
frag->data += len;
frag->gpa += len;
frag->len -= len;
}

	if (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {
vcpu->mmio_needed = 0;

/* FIXME: return into emulator if single-stepping.  */
if (vcpu->mmio_is_write)
return 1;
vcpu->mmio_read_completed = 1;
return complete_emulated_io(vcpu);
}

run->exit_reason = KVM_EXIT_MMIO;
run->mmio.phys_addr = frag->gpa;
if (vcpu->mmio_is_write)
memcpy(run->mmio.data, frag->data, min(8u, frag->len));
run->mmio.len = min(8u, frag->len);
run->mmio.is_write = vcpu->mmio_is_write;
vcpu->arch.complete_userspace_io = complete_emulated_mmio;
return 0;
}
",[21],	if (vcpu->mmio_cur_fragment == vcpu->mmio_nr_fragments) {
112,"int udp_recvmsg(struct kiocb *iocb, struct sock *sk, struct msghdr *msg,
size_t len, int noblock, int flags, int *addr_len)
{
struct inet_sock *inet = inet_sk(sk);
struct sockaddr_in *sin = (struct sockaddr_in *)msg->msg_name;
struct sk_buff *skb;
unsigned int ulen, copied;
int peeked, off = 0;
int err;
int is_udplite = IS_UDPLITE(sk);
bool slow;

	/*
	 *	Check any passed addresses
	 *
	if (addr_len)
		*addr_len = sizeof(*sin);
if (flags & MSG_ERRQUEUE)
return ip_recv_error(sk, msg, len);

try_again:
skb = __skb_recv_datagram(sk, flags | (noblock ? MSG_DONTWAIT : 0),
&peeked, &off, &err);
if (!skb)
goto out;

ulen = skb->len - sizeof(struct udphdr);
copied = len;
if (copied > ulen)
copied = ulen;
else if (copied < ulen)
msg->msg_flags |= MSG_TRUNC;

/*
* If checksum is needed at all, try to do it while copying the
* data.  If the data is truncated, or if we only want a partial
* coverage checksum (UDP-Lite), do it before the copy.
*/

if (copied < ulen || UDP_SKB_CB(skb)->partial_cov) {
if (udp_lib_checksum_complete(skb))
goto csum_copy_err;
}

if (skb_csum_unnecessary(skb))
err = skb_copy_datagram_iovec(skb, sizeof(struct udphdr),
msg->msg_iov, copied);
else {
err = skb_copy_and_csum_datagram_iovec(skb,
sizeof(struct udphdr),
msg->msg_iov);

if (err == -EINVAL)
goto csum_copy_err;
}

if (unlikely(err)) {
trace_kfree_skb(skb, udp_recvmsg);
if (!peeked) {
atomic_inc(&sk->sk_drops);
UDP_INC_STATS_USER(sock_net(sk),
UDP_MIB_INERRORS, is_udplite);
}
goto out_free;
}

if (!peeked)
UDP_INC_STATS_USER(sock_net(sk),
UDP_MIB_INDATAGRAMS, is_udplite);

sock_recv_ts_and_drops(msg, sk, skb);

/* Copy the address. */
if (sin) {
sin->sin_family = AF_INET;
sin->sin_port = udp_hdr(skb)->source;
sin->sin_addr.s_addr = ip_hdr(skb)->saddr;
memset(sin->sin_zero, 0, sizeof(sin->sin_zero));
}
if (inet->cmsg_flags)
ip_cmsg_recv(msg, skb);

err = copied;
if (flags & MSG_TRUNC)
err = ulen;

out_free:
skb_free_datagram_locked(sk, skb);
out:
return err;

csum_copy_err:
slow = lock_sock_fast(sk);
if (!skb_kill_datagram(sk, skb, flags)) {
UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_CSUMERRORS, is_udplite);
UDP_INC_STATS_USER(sock_net(sk), UDP_MIB_INERRORS, is_udplite);
}
unlock_sock_fast(sk, slow);

if (noblock)
return -EAGAIN;

/* starting over for a new packet */
msg->msg_flags &= ~MSG_TRUNC;
goto try_again;
}
","[11, 12, 14, 15, 16, 30]",	/*/~/	 *	Check any passed addresses/~/	 */~/	if (addr_len)/~/		*addr_len = sizeof(*sin);
113,"bool WebstoreStandaloneInstaller::EnsureUniqueInstall(
webstore_install::Result* reason,
std::string* error) {
InstallTracker* tracker = InstallTracker::Get(profile_);
DCHECK(tracker);

const ActiveInstallData* existing_install_data =
tracker->GetActiveInstall(id_);
if (existing_install_data) {
*reason = webstore_install::INSTALL_IN_PROGRESS;
    *error = kInstallInProgressError;
return false;
}

ActiveInstallData install_data(id_);
InitInstallData(&install_data);
scoped_active_install_.reset(new ScopedActiveInstall(tracker, install_data));
return true;
}
",[9],    *error = kInstallInProgressError;
114,"vips_foreign_load_gif_scan_image( VipsForeignLoadGif *gif )
{
VipsObjectClass *class = VIPS_OBJECT_GET_CLASS( gif );
GifFileType *file = gif->file;
	ColorMapObject *map = file->Image.ColorMap ?
		file->Image.ColorMap : file->SColorMap;

GifByteType *extension;

if( DGifGetImageDesc( gif->file ) == GIF_ERROR ) {
vips_foreign_load_gif_error( gif );
return( -1 );
}

/* Check that the frame looks sane. Perhaps giflib checks
* this for us.
*/
if( file->Image.Left < 0 ||
file->Image.Width < 1 ||
file->Image.Width > 10000 ||
file->Image.Left + file->Image.Width > file->SWidth ||
file->Image.Top < 0 ||
file->Image.Height < 1 ||
file->Image.Height > 10000 ||
file->Image.Top + file->Image.Height > file->SHeight ) {
vips_error( class->nickname, ""%s"", _( ""bad frame size"" ) );
return( -1 );
}

/* Test for a non-greyscale colourmap for this frame.
*/
if( !gif->has_colour &&
map ) {
int i;

for( i = 0; i < map->ColorCount; i++ )
if( map->Colors[i].Red != map->Colors[i].Green ||
map->Colors[i].Green != map->Colors[i].Blue ) {
gif->has_colour = TRUE;
break;
}
}

/* Step over compressed image data.
*/
do {
if( vips_foreign_load_gif_code_next( gif, &extension ) )
return( -1 );
} while( extension != NULL );

return( 0 );
}
","[4, 5]",	ColorMapObject *map = file->Image.ColorMap ?/~/		file->Image.ColorMap : file->SColorMap;
115,"void Vp9Parser::ReadSegmentationMap() {
for (size_t i = 0; i < Vp9Segmentation::kNumTreeProbs; i++) {
    segmentation_.tree_probs[i] =
reader_.ReadBool() ? reader_.ReadLiteral(8) : kVp9MaxProb;
}

for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++)
    segmentation_.pred_probs[i] = kVp9MaxProb;

  segmentation_.temporal_update = reader_.ReadBool();
  if (segmentation_.temporal_update) {
for (size_t i = 0; i < Vp9Segmentation::kNumPredictionProbs; i++) {
if (reader_.ReadBool())
        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
}
}
}
","[2, 6, 7, 8, 11]",    segmentation_.tree_probs[i] =/~/    segmentation_.pred_probs[i] = kVp9MaxProb;/~/  segmentation_.temporal_update = reader_.ReadBool();/~/  if (segmentation_.temporal_update) {/~/        segmentation_.pred_probs[i] = reader_.ReadLiteral(8);
116,"void WallpaperManager::SetDefaultWallpaperPath(
const base::FilePath& default_small_wallpaper_file,
std::unique_ptr<gfx::ImageSkia> small_wallpaper_image,
const base::FilePath& default_large_wallpaper_file,
std::unique_ptr<gfx::ImageSkia> large_wallpaper_image) {
default_small_wallpaper_file_ = default_small_wallpaper_file;
default_large_wallpaper_file_ = default_large_wallpaper_file;

ash::WallpaperController* controller =
ash::Shell::Get()->wallpaper_controller();

// |need_update_screen| is true if the previous default wallpaper is visible
// now, so we need to update wallpaper on the screen.
//
// Layout is ignored here, so wallpaper::WALLPAPER_LAYOUT_CENTER is used
// as a placeholder only.
const bool need_update_screen =
default_wallpaper_image_.get() &&
controller->WallpaperIsAlreadyLoaded(default_wallpaper_image_->image(),
false /* compare_layouts */,
wallpaper::WALLPAPER_LAYOUT_CENTER);

default_wallpaper_image_.reset();
if (GetAppropriateResolution() == WALLPAPER_RESOLUTION_SMALL) {
if (small_wallpaper_image) {
default_wallpaper_image_.reset(
new user_manager::UserImage(*small_wallpaper_image));
default_wallpaper_image_->set_file_path(default_small_wallpaper_file);
}
} else {
if (large_wallpaper_image) {
default_wallpaper_image_.reset(
new user_manager::UserImage(*large_wallpaper_image));
default_wallpaper_image_->set_file_path(default_large_wallpaper_file);
}
}

  if (need_update_screen)
    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());
}
","[33, 34]","  if (need_update_screen)/~/    DoSetDefaultWallpaper(EmptyAccountId(), MovableOnDestroyCallbackHolder());"
117,"int orangefs_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
struct orangefs_inode_s *orangefs_inode = ORANGEFS_I(inode);
int error = 0;
void *value = NULL;
size_t size = 0;
const char *name = NULL;

switch (type) {
case ACL_TYPE_ACCESS:
name = XATTR_NAME_POSIX_ACL_ACCESS;
if (acl) {
			umode_t mode = inode->i_mode;
			/*
			 * can we represent this with the traditional file
			 * mode permission bits?
			 *
			error = posix_acl_equiv_mode(acl, &mode);
			if (error < 0) {
				gossip_err(""%s: posix_acl_equiv_mode err: %d\n"",
__func__,
error);
return error;
}

if (inode->i_mode != mode)
SetModeFlag(orangefs_inode);
inode->i_mode = mode;
mark_inode_dirty_sync(inode);
			if (error == 0)
				acl = NULL;
}
break;
case ACL_TYPE_DEFAULT:
name = XATTR_NAME_POSIX_ACL_DEFAULT;
break;
default:
gossip_err(""%s: invalid type %d!\n"", __func__, type);
return -EINVAL;
}

gossip_debug(GOSSIP_ACL_DEBUG,
""%s: inode %pU, key %s type %d\n"",
__func__, get_khandle_from_ino(inode),
name,
type);

if (acl) {
size = posix_acl_xattr_size(acl->a_count);
value = kmalloc(size, GFP_KERNEL);
if (!value)
return -ENOMEM;

error = posix_acl_to_xattr(&init_user_ns, acl, value, size);
if (error < 0)
goto out;
}

gossip_debug(GOSSIP_ACL_DEBUG,
""%s: name %s, value %p, size %zd, acl %p\n"",
__func__, name, value, size, acl);
/*
* Go ahead and set the extended attribute now. NOTE: Suppose acl
* was NULL, then value will be NULL and size will be 0 and that
* will xlate to a removexattr. However, we don't want removexattr
* complain if attributes does not exist.
*/
error = orangefs_inode_setxattr(inode, name, value, size, 0);

out:
kfree(value);
if (!error)
set_cached_acl(inode, type, acl);
return error;
}
","[11, 12, 13, 14, 15, 16, 17, 18, 27, 28]","			umode_t mode = inode->i_mode;/~/			/*/~/			 * can we represent this with the traditional file/~/			 * mode permission bits?/~/			 */~/			error = posix_acl_equiv_mode(acl, &mode);/~/			if (error < 0) {/~/				gossip_err(""%s: posix_acl_equiv_mode err: %d\n"",/~/			if (error == 0)/~/				acl = NULL;"
118,"WebsiteSettingsPopupAndroid::WebsiteSettingsPopupAndroid(
JNIEnv* env,
jobject java_website_settings_pop,
content::WebContents* web_contents) {
// Important to use GetVisibleEntry to match what's showing in the omnibox.
content::NavigationEntry* nav_entry =
web_contents->GetController().GetVisibleEntry();
if (nav_entry == NULL)
return;

url_ = nav_entry->GetURL();

popup_jobject_.Reset(env, java_website_settings_pop);

presenter_.reset(new WebsiteSettings(
this,
Profile::FromBrowserContext(web_contents->GetBrowserContext()),
TabSpecificContentSettings::FromWebContents(web_contents),
      InfoBarService::FromWebContents(web_contents),
nav_entry->GetURL(),
nav_entry->GetSSL(),
content::CertStore::GetInstance()));
}
",[15],"      InfoBarService::FromWebContents(web_contents),"
119,"static void calc_coeff(double mu[4], const int index[4], int prefilter, double r2, double mul)
{
double mul2 = mul * mul, mul3 = mul2 * mul;
double kernel[] = {
(5204 + 2520 * mul + 1092 * mul2 + 3280 * mul3) / 12096,
(2943 -  210 * mul -  273 * mul2 - 2460 * mul3) / 12096,
( 486 -  924 * mul -  546 * mul2 +  984 * mul3) / 12096,
(  17 -  126 * mul +  273 * mul2 -  164 * mul3) / 12096,
};

    double mat_freq[13];
memcpy(mat_freq, kernel, sizeof(kernel));
memset(mat_freq + 4, 0, sizeof(mat_freq) - sizeof(kernel));
int n = 6;
coeff_filter(mat_freq, n, kernel);
for (int k = 0; k < 2 * prefilter; ++k)
coeff_blur121(mat_freq, ++n);

double vec_freq[13];
n = index[3] + prefilter + 3;
calc_gauss(vec_freq, n, r2);
memset(vec_freq + n + 1, 0, sizeof(vec_freq) - (n + 1) * sizeof(vec_freq[0]));
n -= 3;
coeff_filter(vec_freq, n, kernel);
for (int k = 0; k < prefilter; ++k)
coeff_blur121(vec_freq, --n);

double mat[4][4];
calc_matrix(mat, mat_freq, index);

double vec[4];
for (int i = 0; i < 4; ++i)
vec[i] = mat_freq[0] - mat_freq[index[i]] - vec_freq[0] + vec_freq[index[i]];

for (int i = 0; i < 4; ++i) {
double res = 0;
for (int j = 0; j < 4; ++j)
res += mat[i][j] * vec[j];
mu[i] = FFMAX(0, res);
}
}
",[9],    double mat_freq[13];
120,"static v8::Handle<v8::Value> enabledAtRuntimeMethod2Callback(const v8::Arguments& args)
{
INC_STATS(""DOM.TestObj.enabledAtRuntimeMethod2"");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, intArg, V8int::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8int::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
imp->enabledAtRuntimeMethod2(intArg);
return v8::Handle<v8::Value>();
}
",[4],        return V8Proxy::throwNotEnoughArgumentsError();
121,"void Vp9Parser::ReadSegmentation() {
  segmentation_.update_map = false;
  segmentation_.update_data = false;

  segmentation_.enabled = reader_.ReadBool();
  if (!segmentation_.enabled)
return;

  segmentation_.update_map = reader_.ReadBool();
  if (segmentation_.update_map)
    ReadSegmentationMap();

  segmentation_.update_data = reader_.ReadBool();
  if (segmentation_.update_data)
    ReadSegmentationData();
}
","[1, 2, 3, 4, 6, 7, 8, 9, 10, 11]",  segmentation_.update_map = false;/~/  segmentation_.update_data = false;/~/  segmentation_.enabled = reader_.ReadBool();/~/  if (!segmentation_.enabled)/~/  segmentation_.update_map = reader_.ReadBool();/~/  if (segmentation_.update_map)/~/    ReadSegmentationMap();/~/  segmentation_.update_data = reader_.ReadBool();/~/  if (segmentation_.update_data)/~/    ReadSegmentationData();
122,"PHP_FUNCTION(grapheme_strpos)
{
unsigned char *haystack, *needle;
int haystack_len, needle_len;
unsigned char *found;
long loffset = 0;
       int32_t offset = 0;
int ret_pos;

if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ss|l"", (char **)&haystack, &haystack_len, (char **)&needle, &needle_len, &loffset) == FAILURE) {

intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR,
""grapheme_strpos: unable to parse input param"", 0 TSRMLS_CC );

RETURN_FALSE;
}

if ( OUTSIDE_STRING(loffset, haystack_len) ) {

intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, ""grapheme_strpos: Offset not contained in string"", 1 TSRMLS_CC );

RETURN_FALSE;
}

/* we checked that it will fit: */
offset = (int32_t) loffset;

/* the offset is 'grapheme count offset' so it still might be invalid - we'll check it later */


intl_error_set( NULL, U_ILLEGAL_ARGUMENT_ERROR, ""grapheme_strpos: Empty delimiter"", 1 TSRMLS_CC );

RETURN_FALSE;
}
",[6],       int32_t offset = 0;
123,"void AddSimpleRectChunk(TestPaintArtifact& artifact) {
    artifact
        .Chunk(TransformPaintPropertyNode::Root(),
               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())
.RectDrawing(FloatRect(100, 100, 200, 100), Color::kBlack);
}
","[1, 2, 3]","    artifact/~/        .Chunk(TransformPaintPropertyNode::Root(),/~/               ClipPaintPropertyNode::Root(), EffectPaintPropertyNode::Root())"
124,"void RegisterProperties(IBusPropList* ibus_prop_list) {
    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");

ImePropertyList prop_list;  // our representation.
if (ibus_prop_list) {
// You can call
//   LOG(INFO) << ""\n"" << PrintPropList(ibus_prop_list, 0);
// here to dump |ibus_prop_list|.
if (!FlattenPropertyList(ibus_prop_list, &prop_list)) {
// Clear properties on errors.
        RegisterProperties(NULL);
return;
}
}
// Notify the change.
    register_ime_properties_(language_library_, prop_list);
  }
","[1, 9, 11, 12, 14, 15]","    DLOG(INFO) << ""RegisterProperties"" << (ibus_prop_list ? """" : "" (clear)"");/~/        RegisterProperties(NULL);/~/    register_ime_properties_(language_library_, prop_list);/~/  }"
125,"void ShelfWidget::DelegateView::UpdateOpaqueBackground() {
const gfx::Rect local_bounds = GetLocalBounds();
gfx::Rect opaque_background_bounds = local_bounds;

const Shelf* shelf = shelf_widget_->shelf();
const ShelfBackgroundType background_type =
shelf_widget_->GetBackgroundType();

// If the app list is showing in clamshell mode, we should hide the shelf.
// otherwise, we should show it again. This creates a 'blending' effect
// between the two
if (background_type == SHELF_BACKGROUND_APP_LIST) {
opaque_background_.SetVisible(false);
UpdateBackgroundBlur();
return;
}

if (!opaque_background_.visible())
opaque_background_.SetVisible(true);

// Extend the opaque layer a little bit to handle ""overshoot"" gestures
// gracefully (the user drags the shelf further than it can actually go).
// That way:
// 1) When the shelf has rounded corners, only two of them are visible,
// 2) Even when the shelf is squared, it doesn't tear off the screen edge
// when dragged away.
// To achieve this, we extend the layer in the same direction where the shelf
// is aligned (downwards for a bottom shelf, etc.).
const int radius = kShelfRoundedCornerRadius;
const int safety_margin = 3 * radius;
opaque_background_bounds.Inset(
-shelf->SelectValueForShelfAlignment(0, safety_margin, 0), 0,
-shelf->SelectValueForShelfAlignment(0, 0, safety_margin),
-shelf->SelectValueForShelfAlignment(safety_margin, 0, 0));

  // Show rounded corners except in maximized and split modes.
  if (background_type == SHELF_BACKGROUND_MAXIMIZED ||
      background_type == SHELF_BACKGROUND_SPLIT_VIEW) {
mask_ = nullptr;
opaque_background_.SetMaskLayer(nullptr);
} else {
if (!mask_) {
mask_ = views::Painter::CreatePaintedLayer(
views::Painter::CreateSolidRoundRectPainter(SK_ColorBLACK, radius));
mask_->layer()->SetFillsBoundsOpaquely(false);
opaque_background_.SetMaskLayer(mask_->layer());
}
if (mask_->layer()->bounds() != opaque_background_bounds)
mask_->layer()->SetBounds(opaque_background_bounds);
}
opaque_background_.SetBounds(opaque_background_bounds);
UpdateBackgroundBlur();
SchedulePaint();
}
","[30, 31, 32]",  // Show rounded corners except in maximized and split modes./~/  if (background_type == SHELF_BACKGROUND_MAXIMIZED ||/~/      background_type == SHELF_BACKGROUND_SPLIT_VIEW) {
126,"static int asymmetric_key_match(const struct key *key,
				const struct key_match_data *match_data)
{
const struct asymmetric_key_subtype *subtype = asymmetric_key_subtype(key);
const char *description = match_data->raw_data;
const char *spec = description;
const char *id;
ptrdiff_t speclen;

if (!subtype || !spec || !*spec)
return 0;

/* See if the full key description matches as is */
if (key->description && strcmp(key->description, description) == 0)
return 1;

/* All tests from here on break the criterion description into a
* specifier, a colon and then an identifier.
*/
id = strchr(spec, ':');
if (!id)
return 0;

speclen = id - spec;
id++;

if (speclen == 2 && memcmp(spec, ""id"", 2) == 0)
return asymmetric_keyid_match(asymmetric_key_id(key), id);

if (speclen == subtype->name_len &&
memcmp(spec, subtype->name, speclen) == 0)
return 1;

return 0;
}
",[1],				const struct key_match_data *match_data)
127,"write_message( RenderState  state )
{
ADisplay  adisplay = (ADisplay)state->display.disp;


if ( state->message == NULL )
{
FontFace  face = &state->faces[state->face_index];
int       idx, total;


idx   = face->index;
total = 1;
while ( total + state->face_index < state->num_faces &&
face[total].filepath == face[0].filepath     )
total++;

total += idx;

state->message = state->message0;
if ( total > 1 )
        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",
state->filename, idx + 1, total,
state->char_size );
else
        sprintf( state->message0, ""%s @ %5.1fpt"",
state->filename,
state->char_size );
}

grWriteCellString( adisplay->bitmap, 0, DIM_Y - 10, state->message,
adisplay->fore_color );

state->message = NULL;
}
","[15, 19]","        sprintf( state->message0, ""%s %d/%d @ %5.1fpt"",/~/        sprintf( state->message0, ""%s @ %5.1fpt"","
128,"void ObserverOnLogoAvailable(LogoObserver* observer,
                             bool from_cache,
                             LogoCallbackReason type,
                             const base::Optional<Logo>& logo) {
  switch (type) {
    case LogoCallbackReason::DISABLED:
    case LogoCallbackReason::CANCELED:
    case LogoCallbackReason::FAILED:
      break;
    case LogoCallbackReason::REVALIDATED:
      // TODO(sfiera): double-check whether we should inform the observer of the
      // fresh metadata.
      break;
    case LogoCallbackReason::DETERMINED:
      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);
      break;
  }
  if (!from_cache) {
    observer->OnObserverRemoved();
  }
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]","                             bool from_cache,/~/                             LogoCallbackReason type,/~/                             const base::Optional<Logo>& logo) {/~/  switch (type) {/~/    case LogoCallbackReason::DISABLED:/~/    case LogoCallbackReason::CANCELED:/~/    case LogoCallbackReason::FAILED:/~/      break;/~/    case LogoCallbackReason::REVALIDATED:/~/      // TODO(sfiera): double-check whether we should inform the observer of the/~/      // fresh metadata./~/      break;/~/    case LogoCallbackReason::DETERMINED:/~/      observer->OnLogoAvailable(logo ? &logo.value() : nullptr, from_cache);/~/      break;/~/  }/~/  if (!from_cache) {/~/    observer->OnObserverRemoved();/~/  }/~/}"
129,"static int get_default_root(pool *p, int allow_symlinks, char **root) {
config_rec *c = NULL;
char *dir = NULL;
int res;

c = find_config(main_server->conf, CONF_PARAM, ""DefaultRoot"", FALSE);
while (c) {
pr_signals_handle();

/* Check the groups acl */
if (c->argc < 2) {
dir = c->argv[0];
break;
}

res = pr_expr_eval_group_and(((char **) c->argv)+1);
if (res) {
dir = c->argv[0];
break;
}

c = find_config_next(c, c->next, CONF_PARAM, ""DefaultRoot"", FALSE);
}

if (dir) {
char *new_dir;

/* Check for any expandable variables. */
new_dir = path_subst_uservar(p, &dir);
if (new_dir != NULL) {
dir = new_dir;
}

if (strncmp(dir, ""/"", 2) == 0) {
dir = NULL;

} else {
char *realdir;
int xerrno = 0;

if (allow_symlinks == FALSE) {
char *path, target_path[PR_TUNABLE_PATH_MAX + 1];
        struct stat st;
size_t pathlen;

/* First, deal with any possible interpolation.  dir_realpath() will
* do this for us, but dir_realpath() ALSO automatically follows
* symlinks, which is what we do NOT want to do here.
*/

path = dir;
if (*path != '/') {
if (*path == '~') {
if (pr_fs_interpolate(dir, target_path,
sizeof(target_path)-1) < 0) {
return -1;
}

path = target_path;
}
}

/* Note: lstat(2) is sensitive to the presence of a trailing slash on
* the path, particularly in the case of a symlink to a directory.
* Thus to get the correct test, we need to remove any trailing slash
* that might be present.  Subtle.
*/
pathlen = strlen(path);
if (pathlen > 1 &&
path[pathlen-1] == '/') {
path[pathlen-1] = '\0';
}

        pr_fs_clear_cache();
        res = pr_fsio_lstat(path, &st);
if (res < 0) {
          xerrno = errno;
          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,
            strerror(xerrno));
          errno = xerrno;
          return -1;
        }

        if (S_ISLNK(st.st_mode)) {
          pr_log_pri(PR_LOG_WARNING,
            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""
            ""config)"", path);
errno = EPERM;
return -1;
}
}

/* We need to be the final user here so that if the user has their home
* directory with a mode the user proftpd is running (i.e. the User
* directive) as can not traverse down, we can still have the default
* root.
*/

PRIVS_USER
realdir = dir_realpath(p, dir);
xerrno = errno;
PRIVS_RELINQUISH

if (realdir) {
dir = realdir;

} else {
/* Try to provide a more informative message. */
char interp_dir[PR_TUNABLE_PATH_MAX + 1];

memset(interp_dir, '\0', sizeof(interp_dir));
(void) pr_fs_interpolate(dir, interp_dir, sizeof(interp_dir)-1);

pr_log_pri(PR_LOG_NOTICE,
""notice: unable to use DefaultRoot '%s' [resolved to '%s']: %s"",
dir, interp_dir, strerror(xerrno));

errno = xerrno;
}
}
}

*root = dir;
return 0;
}
","[11, 16, 18, 25, 33, 44, 45, 47, 48]","        struct stat st;/~/        pr_fs_clear_cache();/~/        res = pr_fsio_lstat(path, &st);/~/          xerrno = errno;/~/          pr_log_pri(PR_LOG_WARNING, ""error: unable to check %s: %s"", path,/~/            strerror(xerrno));/~/          errno = xerrno;/~/          return -1;/~/        }/~/        if (S_ISLNK(st.st_mode)) {/~/          pr_log_pri(PR_LOG_WARNING,/~/            ""error: DefaultRoot %s is a symlink (denied by AllowChrootSymlinks ""/~/            ""config)"", path);"
130,"void *load_device_tree(const char *filename_path, int *sizep)
{
int dt_size;
int dt_file_load_size;
int ret;
void *fdt = NULL;

*sizep = 0;
dt_size = get_image_size(filename_path);
if (dt_size < 0) {
error_report(""Unable to get size of device tree file '%s'"",
filename_path);
goto fail;
}

/* Expand to 2x size to give enough room for manipulation.  */
dt_size += 10000;
dt_size *= 2;
/* First allocate space in qemu for device tree */
fdt = g_malloc0(dt_size);

    dt_file_load_size = load_image(filename_path, fdt);
if (dt_file_load_size < 0) {
error_report(""Unable to open device tree file '%s'"",
filename_path);
goto fail;
}

ret = fdt_open_into(fdt, fdt, dt_size);
if (ret) {
error_report(""Unable to copy device tree in memory"");
goto fail;
}

/* Check sanity of device tree */
if (fdt_check_header(fdt)) {
error_report(""Device tree file loaded into memory is invalid: %s"",
filename_path);
goto fail;
}
*sizep = dt_size;
return fdt;

fail:
g_free(fdt);
return NULL;
}
",[18],"    dt_file_load_size = load_image(filename_path, fdt);"
131,"static int shmem_remount_fs(struct super_block *sb, int *flags, char *data)
{
struct shmem_sb_info *sbinfo = SHMEM_SB(sb);
struct shmem_sb_info config = *sbinfo;
unsigned long inodes;
int error = -EINVAL;

if (shmem_parse_options(data, &config, true))
return error;

spin_lock(&sbinfo->stat_lock);
inodes = sbinfo->max_inodes - sbinfo->free_inodes;
if (percpu_counter_compare(&sbinfo->used_blocks, config.max_blocks) > 0)
goto out;
if (config.max_inodes < inodes)
goto out;
/*
* Those tests disallow limited->unlimited while any are in use;
* but we must separately disallow unlimited->limited, because
* in that case we have no record of how much is already in use.
*/
if (config.max_blocks && !sbinfo->max_blocks)
goto out;
if (config.max_inodes && !sbinfo->max_inodes)
goto out;

error = 0;
sbinfo->max_blocks  = config.max_blocks;
sbinfo->max_inodes  = config.max_inodes;
sbinfo->free_inodes = config.max_inodes - inodes;

	mpol_put(sbinfo->mpol);
	sbinfo->mpol        = config.mpol;	/* transfers initial ref *
out:
spin_unlock(&sbinfo->stat_lock);
return error;
}
",[27],	mpol_put(sbinfo->mpol);/~/	sbinfo->mpol        = config.mpol;	/* transfers initial ref *
132,"int ipmi_destroy_user(struct ipmi_user *user)
{
_ipmi_destroy_user(user);

	cleanup_srcu_struct(&user->release_barrier);
kref_put(&user->refcount, free_user);

return 0;
}
",[3],	cleanup_srcu_struct(&user->release_barrier);
133,"void SkippedMBMotionComp(
VideoDecData *video
)
{
Vop *prev = video->prevVop;
Vop *comp;
int ypos, xpos;
PIXEL *c_comp, *c_prev;
PIXEL *cu_comp, *cu_prev;
PIXEL *cv_comp, *cv_prev;
int width, width_uv;
int32 offset;
#ifdef PV_POSTPROC_ON // 2/14/2001
int imv;
int32 size = (int32) video->nTotalMB << 8;
uint8 *pp_dec_y, *pp_dec_u;
uint8 *pp_prev1;
int mvwidth = video->nMBPerRow << 1;
#endif

width = video->width;
width_uv  = width >> 1;
ypos = video->mbnum_row << 4 ;
xpos = video->mbnum_col << 4 ;
offset = (int32)ypos * width + xpos;



/* zero motion compensation for previous frame */
/*mby*width + mbx;*/
    c_prev  = prev->yChan + offset;
/*by*width_uv + bx;*/
cu_prev = prev->uChan + (offset >> 2) + (xpos >> 2);
/*by*width_uv + bx;*/
cv_prev = prev->vChan + (offset >> 2) + (xpos >> 2);

comp = video->currVop;

c_comp  = comp->yChan + offset;
cu_comp = comp->uChan + (offset >> 2) + (xpos >> 2);
cv_comp = comp->vChan + (offset >> 2) + (xpos >> 2);


/* Copy previous reconstructed frame into the current frame */
PutSKIPPED_MB(c_comp,  c_prev, width);
PutSKIPPED_B(cu_comp, cu_prev, width_uv);
PutSKIPPED_B(cv_comp, cv_prev, width_uv);

/*  10/24/2000 post_processing semaphore generation */
#ifdef PV_POSTPROC_ON // 2/14/2001
if (video->postFilterType != PV_NO_POST_PROC)
{
imv = (offset >> 6) - (xpos >> 6) + (xpos >> 3);
/* Post-processing mode (copy previous MB) */
pp_prev1 = video->pstprcTypPrv + imv;
pp_dec_y = video->pstprcTypCur + imv;
*pp_dec_y = *pp_prev1;
*(pp_dec_y + 1) = *(pp_prev1 + 1);
*(pp_dec_y + mvwidth) = *(pp_prev1 + mvwidth);
*(pp_dec_y + mvwidth + 1) = *(pp_prev1 + mvwidth + 1);

/* chrominance */
/*4*MB_in_width*MB_in_height*/
pp_prev1 = video->pstprcTypPrv + (size >> 6) +
((imv + (xpos >> 3)) >> 2);
pp_dec_u = video->pstprcTypCur + (size >> 6) +
((imv + (xpos >> 3)) >> 2);
*pp_dec_u = *pp_prev1;
pp_dec_u[size>>8] = pp_prev1[size>>8];
}
#endif
/*----------------------------------------------------------------------------
; Return nothing or data or data pointer
----------------------------------------------------------------------------*/

return;
}
",[26],    c_prev  = prev->yChan + offset;
134,"static int do_new_mount(struct path *path, const char *fstype, int flags,
int mnt_flags, const char *name, void *data)
{
struct file_system_type *type;
struct user_namespace *user_ns = current->nsproxy->mnt_ns->user_ns;
struct vfsmount *mnt;
int err;

if (!fstype)
return -EINVAL;

type = get_fs_type(fstype);
if (!type)
return -ENODEV;

if (user_ns != &init_user_ns) {
if (!(type->fs_flags & FS_USERNS_MOUNT)) {
put_filesystem(type);
return -EPERM;
}
/* Only in special cases allow devices from mounts
* created outside the initial user namespace.
*/
if (!(type->fs_flags & FS_USERNS_DEV_MOUNT)) {
flags |= MS_NODEV;
			mnt_flags |= MNT_NODEV;
}
}

mnt = vfs_kern_mount(type, flags, name, data);
if (!IS_ERR(mnt) && (type->fs_flags & FS_HAS_SUBTYPE) &&
!mnt->mnt_sb->s_subtype)
mnt = fs_set_subtype(mnt, fstype);

put_filesystem(type);
if (IS_ERR(mnt))
return PTR_ERR(mnt);

err = do_add_mount(real_mount(mnt), path, mnt_flags);
if (err)
mntput(mnt);
return err;
}
",[22],			mnt_flags |= MNT_NODEV;
135,"kadm5_modify_principal(void *server_handle,
kadm5_principal_ent_t entry, long mask)
{
int                     ret, ret2, i;
kadm5_policy_ent_rec    pol;
krb5_boolean            have_pol = FALSE;
krb5_db_entry           *kdb;
krb5_tl_data            *tl_data_orig;
osa_princ_ent_rec       adb;
kadm5_server_handle_t handle = server_handle;

CHECK_HANDLE(server_handle);

krb5_clear_error_message(handle->context);

if((mask & KADM5_PRINCIPAL) || (mask & KADM5_LAST_PWD_CHANGE) ||
(mask & KADM5_MOD_TIME) || (mask & KADM5_MOD_NAME) ||
(mask & KADM5_MKVNO) || (mask & KADM5_AUX_ATTRIBUTES) ||
(mask & KADM5_KEY_DATA) || (mask & KADM5_LAST_SUCCESS) ||
(mask & KADM5_LAST_FAILED))
return KADM5_BAD_MASK;
if((mask & ~ALL_PRINC_MASK))
return KADM5_BAD_MASK;
if((mask & KADM5_POLICY) && (mask & KADM5_POLICY_CLR))
return KADM5_BAD_MASK;
    if(entry == (kadm5_principal_ent_t) NULL)
        return EINVAL;
if (mask & KADM5_TL_DATA) {
tl_data_orig = entry->tl_data;
while (tl_data_orig) {
if (tl_data_orig->tl_data_type < 256)
return KADM5_BAD_TL_TYPE;
tl_data_orig = tl_data_orig->tl_data_next;
}
}

ret = kdb_get_entry(handle, entry->principal, &kdb, &adb);
if (ret)
return(ret);

/*
* This is pretty much the same as create ...
*/

if ((mask & KADM5_POLICY)) {
ret = get_policy(handle, entry->policy, &pol, &have_pol);
if (ret)
goto done;

/* set us up to use the new policy */
adb.aux_attributes |= KADM5_POLICY;
if (adb.policy)
free(adb.policy);
adb.policy = strdup(entry->policy);
}
if (have_pol) {
/* set pw_max_life based on new policy */
if (pol.pw_max_life) {
ret = krb5_dbe_lookup_last_pwd_change(handle->context, kdb,
&(kdb->pw_expiration));
if (ret)
goto done;
kdb->pw_expiration += pol.pw_max_life;
} else {
kdb->pw_expiration = 0;
}
}

if ((mask & KADM5_POLICY_CLR) && (adb.aux_attributes & KADM5_POLICY)) {
free(adb.policy);
adb.policy = NULL;
adb.aux_attributes &= ~KADM5_POLICY;
kdb->pw_expiration = 0;
}

if ((mask & KADM5_ATTRIBUTES))
kdb->attributes = entry->attributes;
if ((mask & KADM5_MAX_LIFE))
kdb->max_life = entry->max_life;
if ((mask & KADM5_PRINC_EXPIRE_TIME))
kdb->expiration = entry->princ_expire_time;
if (mask & KADM5_PW_EXPIRATION)
kdb->pw_expiration = entry->pw_expiration;
if (mask & KADM5_MAX_RLIFE)
kdb->max_renewable_life = entry->max_renewable_life;

if((mask & KADM5_KVNO)) {
for (i = 0; i < kdb->n_key_data; i++)
kdb->key_data[i].key_data_kvno = entry->kvno;
}

if (mask & KADM5_TL_DATA) {
krb5_tl_data *tl;

/* may have to change the version number of the API. Updates the list with the given tl_data rather than over-writting */

for (tl = entry->tl_data; tl;
tl = tl->tl_data_next)
{
ret = krb5_dbe_update_tl_data(handle->context, kdb, tl);
if( ret )
{
goto done;
}
}
}

/*
* Setting entry->fail_auth_count to 0 can be used to manually unlock
* an account. It is not possible to set fail_auth_count to any other
* value using kadmin.
*/
if (mask & KADM5_FAIL_AUTH_COUNT) {
if (entry->fail_auth_count != 0) {
ret = KADM5_BAD_SERVER_PARAMS;
goto done;
}

kdb->fail_auth_count = 0;
}

/* let the mask propagate to the database provider */
kdb->mask = mask;

ret = k5_kadm5_hook_modify(handle->context, handle->hook_handles,
KADM5_HOOK_STAGE_PRECOMMIT, entry, mask);
if (ret)
goto done;

ret = kdb_put_entry(handle, kdb, &adb);
if (ret) goto done;
(void) k5_kadm5_hook_modify(handle->context, handle->hook_handles,
KADM5_HOOK_STAGE_POSTCOMMIT, entry, mask);

ret = KADM5_OK;
done:
if (have_pol) {
ret2 = kadm5_free_policy_ent(handle->lhandle, &pol);
ret = ret ? ret : ret2;
}
kdb_free_entry(handle, kdb, &adb);
return ret;
}
","[22, 23]",    if(entry == (kadm5_principal_ent_t) NULL)/~/        return EINVAL;
136,"static int setup_dev_console(const struct lxc_rootfs *rootfs,
const struct lxc_console *console)
{
char path[MAXPATHLEN];
struct stat s;
int ret;

ret = snprintf(path, sizeof(path), ""%s/dev/console"", rootfs->mount);
if (ret >= sizeof(path)) {
ERROR(""console path too long"");
return -1;
}

if (access(path, F_OK)) {
WARN(""rootfs specified but no console found at '%s'"", path);
return 0;
}

if (console->master < 0) {
INFO(""no console"");
return 0;
}

if (stat(path, &s)) {
SYSERROR(""failed to stat '%s'"", path);
return -1;
}

if (chmod(console->name, s.st_mode)) {
SYSERROR(""failed to set mode '0%o' to '%s'"",
s.st_mode, console->name);
return -1;
}

	if (mount(console->name, path, ""none"", MS_BIND, 0)) {
ERROR(""failed to mount '%s' on '%s'"", console->name, path);
return -1;
}

INFO(""console has been setup"");
return 0;
}
",[28],"	if (mount(console->name, path, ""none"", MS_BIND, 0)) {"
137,"bool Extension::HasAPIPermission(const std::string& function_name) const {
base::AutoLock auto_lock(runtime_data_lock_);
return runtime_data_.GetActivePermissions()->
      HasAccessToFunction(function_name);
}
",[3],      HasAccessToFunction(function_name);
138,"void HttpAuthFilterWhitelist::SetWhitelist(
const std::string& server_whitelist) {
  rules_.ParseFromString(server_whitelist);
}
",[2],  rules_.ParseFromString(server_whitelist);
139,"void BackgroundContentsService::Observe(
int type,
const content::NotificationSource& source,
const content::NotificationDetails& details) {
switch (type) {
case chrome::NOTIFICATION_EXTENSIONS_READY:
LoadBackgroundContentsFromManifests(
content::Source<Profile>(source).ptr());
LoadBackgroundContentsFromPrefs(content::Source<Profile>(source).ptr());
break;
case chrome::NOTIFICATION_BACKGROUND_CONTENTS_DELETED:
BackgroundContentsShutdown(
content::Details<BackgroundContents>(details).ptr());
break;
case chrome::NOTIFICATION_BACKGROUND_CONTENTS_CLOSED:
DCHECK(IsTracked(content::Details<BackgroundContents>(details).ptr()));
UnregisterBackgroundContents(
content::Details<BackgroundContents>(details).ptr());
break;
case chrome::NOTIFICATION_BACKGROUND_CONTENTS_NAVIGATED: {
DCHECK(IsTracked(content::Details<BackgroundContents>(details).ptr()));

// Do not register in the pref if the extension has a manifest-specified
// background page.
BackgroundContents* bgcontents =
content::Details<BackgroundContents>(details).ptr();
Profile* profile = content::Source<Profile>(source).ptr();
const string16& appid = GetParentApplicationId(bgcontents);
ExtensionService* extension_service = profile->GetExtensionService();
// extension_service can be NULL when running tests.
if (extension_service) {
const Extension* extension =
extension_service->GetExtensionById(UTF16ToUTF8(appid), false);
        if (extension && extension->background_url().is_valid())
break;
}
RegisterBackgroundContents(bgcontents);
break;
}
case chrome::NOTIFICATION_EXTENSION_LOADED: {
const Extension* extension =
content::Details<const Extension>(details).ptr();
Profile* profile = content::Source<Profile>(source).ptr();
if (extension->is_hosted_app() &&
          extension->background_url().is_valid()) {
// If there is a background page specified in the manifest for a hosted
// app, then blow away registered urls in the pref.
ShutdownAssociatedBackgroundContents(ASCIIToUTF16(extension->id()));

ExtensionService* service = profile->GetExtensionService();
if (service && service->is_ready()) {
// Now load the manifest-specified background page. If service isn't
// ready, then the background page will be loaded from the
// EXTENSIONS_READY callback.
          LoadBackgroundContents(profile, extension->background_url(),
ASCIIToUTF16(""background""), UTF8ToUTF16(extension->id()));
}
}

// Remove any ""This extension has crashed"" balloons.
ScheduleCloseBalloon(extension->id());
break;
}
case chrome::NOTIFICATION_EXTENSION_PROCESS_TERMINATED:
case chrome::NOTIFICATION_BACKGROUND_CONTENTS_TERMINATED: {
Profile* profile = content::Source<Profile>(source).ptr();
const Extension* extension = NULL;
if (type == chrome::NOTIFICATION_BACKGROUND_CONTENTS_TERMINATED) {
BackgroundContents* bg =
content::Details<BackgroundContents>(details).ptr();
std::string extension_id = UTF16ToASCII(
BackgroundContentsServiceFactory::GetForProfile(profile)->
GetParentApplicationId(bg));
extension =
profile->GetExtensionService()->GetExtensionById(extension_id, false);
} else {
ExtensionHost* extension_host =
content::Details<ExtensionHost>(details).ptr();
extension = extension_host->extension();
}
if (!extension)
break;

// When an extension crashes, EXTENSION_PROCESS_TERMINATED is followed by
// an EXTENSION_UNLOADED notification. This UNLOADED signal causes all the
// notifications for this extension to be cancelled by
// DesktopNotificationService. For this reason, instead of showing the
// balloon right now, we schedule it to show a little later.
MessageLoop::current()->PostTask(
FROM_HERE, base::Bind(&ShowBalloon, extension, profile));
break;
}
case chrome::NOTIFICATION_EXTENSION_UNLOADED:
switch (content::Details<UnloadedExtensionInfo>(details)->reason) {
case extension_misc::UNLOAD_REASON_DISABLE:    // Fall through.
case extension_misc::UNLOAD_REASON_TERMINATE:  // Fall through.
case extension_misc::UNLOAD_REASON_UNINSTALL:
ShutdownAssociatedBackgroundContents(
ASCIIToUTF16(content::Details<UnloadedExtensionInfo>(details)->
extension->id()));
break;
case extension_misc::UNLOAD_REASON_UPDATE: {
// If there is a manifest specified background page, then shut it down
// here, since if the updated extension still has the background page,
// then it will be loaded from LOADED callback. Otherwise, leave
// BackgroundContents in place.
const Extension* extension =
content::Details<UnloadedExtensionInfo>(details)->extension;
          if (extension->background_url().is_valid())
ShutdownAssociatedBackgroundContents(ASCIIToUTF16(extension->id()));
break;
}
default:
NOTREACHED();
ShutdownAssociatedBackgroundContents(
ASCIIToUTF16(content::Details<UnloadedExtensionInfo>(details)->
extension->id()));
break;
}
break;

case chrome::NOTIFICATION_EXTENSION_UNINSTALLED: {
// Remove any ""This extension has crashed"" balloons.
ScheduleCloseBalloon(*content::Details<const std::string>(details).ptr());
break;
}

default:
NOTREACHED();
break;
}
}
","[32, 43]","        if (extension && extension->background_url().is_valid())/~/          extension->background_url().is_valid()) {/~/          LoadBackgroundContents(profile, extension->background_url(),/~/          if (extension->background_url().is_valid())"
140,"int ip6_find_1stfragopt(struct sk_buff *skb, u8 **nexthdr)
{
u16 offset = sizeof(struct ipv6hdr);
	struct ipv6_opt_hdr *exthdr =
				(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);
unsigned int packet_len = skb_tail_pointer(skb) -
skb_network_header(skb);
int found_rhdr = 0;
*nexthdr = &ipv6_hdr(skb)->nexthdr;

	while (offset + 1 <= packet_len) {

switch (**nexthdr) {

case NEXTHDR_HOP:
break;
case NEXTHDR_ROUTING:
found_rhdr = 1;
break;
case NEXTHDR_DEST:
#if IS_ENABLED(CONFIG_IPV6_MIP6)
if (ipv6_find_tlv(skb, offset, IPV6_TLV_HAO) >= 0)
break;
#endif
if (found_rhdr)
return offset;
break;
default:
return offset;
}

		offset += ipv6_optlen(exthdr);
		*nexthdr = &exthdr->nexthdr;
exthdr = (struct ipv6_opt_hdr *)(skb_network_header(skb) +
offset);
}

	return offset;
}
","[3, 4, 9, 22, 25, 27, 28, 32]",	struct ipv6_opt_hdr *exthdr =/~/				(struct ipv6_opt_hdr *)(ipv6_hdr(skb) + 1);/~/	while (offset + 1 <= packet_len) {/~/		offset += ipv6_optlen(exthdr);/~/		*nexthdr = &exthdr->nexthdr;/~/	return offset;
141,"context_length_arg (char const *str, int *out)
{
  uintmax_t value;
  if (! (xstrtoumax (str, 0, 10, &value, """") == LONGINT_OK
         && 0 <= (*out = value)
         && *out == value))
{
error (EXIT_TROUBLE, 0, ""%s: %s"", str,
_(""invalid context length argument""));
}
page size, unless a read yields a partial page.  */

static char *buffer;		/* Base of buffer. */
static size_t bufalloc;		/* Allocated buffer size, counting slop. */
#define INITIAL_BUFSIZE 32768	/* Initial buffer size, not counting slop. */
static int bufdesc;		/* File descriptor. */
static char *bufbeg;		/* Beginning of user-visible stuff. */
static char *buflim;		/* Limit of user-visible stuff. */
static size_t pagesize;		/* alignment of memory pages */
static off_t bufoffset;		/* Read offset; defined on regular files.  */
static off_t after_last_match;	/* Pointer after last matching line that
would have been output if we were
outputting characters. */

/* Return VAL aligned to the next multiple of ALIGNMENT.  VAL can be
an integer or a pointer.  Both args must be free of side effects.  */
#define ALIGN_TO(val, alignment) \
((size_t) (val) % (alignment) == 0 \
? (val) \
: (val) + ((alignment) - (size_t) (val) % (alignment)))

/* Reset the buffer for a new file, returning zero if we should skip it.
Initialize on the first time through. */
static int
reset (int fd, char const *file, struct stats *stats)
{
if (! pagesize)
{
pagesize = getpagesize ();
if (pagesize == 0 || 2 * pagesize + 1 <= pagesize)
abort ();
bufalloc = ALIGN_TO (INITIAL_BUFSIZE, pagesize) + pagesize + 1;
buffer = xmalloc (bufalloc);
}

bufbeg = buflim = ALIGN_TO (buffer + 1, pagesize);
bufbeg[-1] = eolbyte;
bufdesc = fd;

if (S_ISREG (stats->stat.st_mode))
{
if (file)
bufoffset = 0;
else
{
bufoffset = lseek (fd, 0, SEEK_CUR);
if (bufoffset < 0)
{
suppressible_error (_(""lseek failed""), errno);
return 0;
}
}
}
return 1;
}

/* Read new stuff into the buffer, saving the specified
amount of old stuff.  When we're done, 'bufbeg' points
to the beginning of the buffer contents, and 'buflim'
points just after the end.  Return zero if there's an error.  */
static int
fillbuf (size_t save, struct stats const *stats)
{
size_t fillsize = 0;
int cc = 1;
char *readbuf;
size_t readsize;

/* Offset from start of buffer to start of old stuff
that we want to save.  */
size_t saved_offset = buflim - save - buffer;

if (pagesize <= buffer + bufalloc - buflim)
{
readbuf = buflim;
bufbeg = buflim - save;
}
else
{
size_t minsize = save + pagesize;
size_t newsize;
size_t newalloc;
char *newbuf;

/* Grow newsize until it is at least as great as minsize.  */
for (newsize = bufalloc - pagesize - 1; newsize < minsize; newsize *= 2)
if (newsize * 2 < newsize || newsize * 2 + pagesize + 1 < newsize * 2)
xalloc_die ();

/* Try not to allocate more memory than the file size indicates,
as that might cause unnecessary memory exhaustion if the file
is large.  However, do not use the original file size as a
heuristic if we've already read past the file end, as most
likely the file is growing.  */
if (S_ISREG (stats->stat.st_mode))
{
off_t to_be_read = stats->stat.st_size - bufoffset;
off_t maxsize_off = save + to_be_read;
if (0 <= to_be_read && to_be_read <= maxsize_off
&& maxsize_off == (size_t) maxsize_off
&& minsize <= (size_t) maxsize_off
&& (size_t) maxsize_off < newsize)
newsize = maxsize_off;
}

/* Add enough room so that the buffer is aligned and has room
for byte sentinels fore and aft.  */
newalloc = newsize + pagesize + 1;

newbuf = bufalloc < newalloc ? xmalloc (bufalloc = newalloc) : buffer;
readbuf = ALIGN_TO (newbuf + 1 + save, pagesize);
bufbeg = readbuf - save;
memmove (bufbeg, buffer + saved_offset, save);
bufbeg[-1] = eolbyte;
if (newbuf != buffer)
{
free (buffer);
buffer = newbuf;
}
}

readsize = buffer + bufalloc - readbuf;
readsize -= readsize % pagesize;

if (! fillsize)
{
ssize_t bytesread;
while ((bytesread = read (bufdesc, readbuf, readsize)) < 0
&& errno == EINTR)
continue;
if (bytesread < 0)
cc = 0;
else
fillsize = bytesread;
}

bufoffset += fillsize;
#if defined HAVE_DOS_FILE_CONTENTS
if (fillsize)
fillsize = undossify_input (readbuf, fillsize);
#endif
buflim = readbuf + fillsize;
return cc;
}

/* Flags controlling the style of output. */
static enum
{
BINARY_BINARY_FILES,
TEXT_BINARY_FILES,
WITHOUT_MATCH_BINARY_FILES
} binary_files;		/* How to handle binary files.  */

static int filename_mask;	/* If zero, output nulls after filenames.  */
static int out_quiet;		/* Suppress all normal output. */
static int out_invert;		/* Print nonmatching stuff. */
static int out_file;		/* Print filenames. */
static int out_line;		/* Print line numbers. */
static int out_byte;		/* Print byte offsets. */
static int out_before;		/* Lines of leading context. */
static int out_after;		/* Lines of trailing context. */
static int out_file;		/* Print filenames. */
static int out_line;		/* Print line numbers. */
static int out_byte;		/* Print byte offsets. */
static int out_before;		/* Lines of leading context. *
static int out_after;		/* Lines of trailing context. *
static int count_matches;	/* Count matching lines.  */
static int list_files;		/* List matching files.  */
static int no_filenames;	/* Suppress file names.  */
static off_t max_count;		/* Stop after outputting this many
lines from an input file.  */
static int line_buffered;       /* If nonzero, use line buffering, i.e.
fflush everyline out.  */
static char const *lastnl;	/* Pointer after last newline counted. */
static char const *lastout;	/* Pointer after last character output;
NULL if no character has been output
or if it's conceptually before bufbeg. */
static uintmax_t totalnl;	/* Total newline count before lastnl. */
static off_t outleft;		/* Maximum number of lines to be output.  */
static int pending;		/* Pending lines of output.
NULL if no character has been output
or if it's conceptually before bufbeg. */
static uintmax_t totalnl;	/* Total newline count before lastnl. */
static off_t outleft;		/* Maximum number of lines to be output.  *
static int pending;		/* Pending lines of output.
Always kept 0 if out_quiet is true.  */
static int done_on_match;	/* Stop scanning file on first match.  */
static int exit_on_match;	/* Exit on first match.  */
/* Add two numbers that count input bytes or lines, and report an
error if the addition overflows.  */
static uintmax_t
add_count (uintmax_t a, uintmax_t b)
{
uintmax_t sum = a + b;
if (sum < a)
error (EXIT_TROUBLE, 0, _(""input is too large to count""));
return sum;
}

static void
nlscan (char const *lim)
{
size_t newlines = 0;
char const *beg;
for (beg = lastnl; beg < lim; beg++)
{
beg = memchr (beg, eolbyte, lim - beg);
if (!beg)
break;
newlines++;
}
totalnl = add_count (totalnl, newlines);
lastnl = lim;
}

/* Print the current filename.  */
static void
print_filename (void)
{
pr_sgr_start_if (filename_color);
fputs (filename, stdout);
pr_sgr_end_if (filename_color);
}

/* Print a character separator.  */
static void
print_sep (char sep)
{
pr_sgr_start_if (sep_color);
fputc (sep, stdout);
pr_sgr_end_if (sep_color);
}

/* Print a line number or a byte offset.  */
static void
print_offset (uintmax_t pos, int min_width, const char *color)
{
/* Do not rely on printf to print pos, since uintmax_t may be longer
than long, and long long is not portable.  */

char buf[sizeof pos * CHAR_BIT];
char *p = buf + sizeof buf;

do
{
*--p = '0' + pos % 10;
--min_width;
}
while ((pos /= 10) != 0);

/* Do this to maximize the probability of alignment across lines.  */
if (align_tabs)
while (--min_width >= 0)
*--p = ' ';

pr_sgr_start_if (color);
fwrite (p, 1, buf + sizeof buf - p, stdout);
pr_sgr_end_if (color);
}

/* Print a whole line head (filename, line, byte).  */
static void
print_line_head (char const *beg, char const *lim, int sep)
{
int pending_sep = 0;

if (out_file)
{
print_filename ();
if (filename_mask)
pending_sep = 1;
else
fputc (0, stdout);
}

if (out_line)
{
if (lastnl < lim)
{
nlscan (beg);
totalnl = add_count (totalnl, 1);
lastnl = lim;
}
if (pending_sep)
print_sep (sep);
print_offset (totalnl, 4, line_num_color);
pending_sep = 1;
}

if (out_byte)
{
uintmax_t pos = add_count (totalcc, beg - bufbeg);
#if defined HAVE_DOS_FILE_CONTENTS
pos = dossified_pos (pos);
#endif
if (pending_sep)
print_sep (sep);
print_offset (pos, 6, byte_num_color);
pending_sep = 1;
}

if (pending_sep)
{
/* This assumes sep is one column wide.
Try doing this any other way with Unicode
(and its combining and wide characters)
filenames and you're wasting your efforts.  */
if (align_tabs)
fputs (""\t\b"", stdout);

print_sep (sep);
}
}

static const char *
print_line_middle (const char *beg, const char *lim,
const char *line_color, const char *match_color)
{
size_t match_size;
size_t match_offset;
const char *cur = beg;
const char *mid = NULL;

while (cur < lim
&& ((match_offset = execute (beg, lim - beg, &match_size,
beg + (cur - beg))) != (size_t) -1))
{
char const *b = beg + match_offset;

/* Avoid matching the empty line at the end of the buffer. */
if (b == lim)
break;

/* Avoid hanging on grep --color """" foo */
if (match_size == 0)
{
/* Make minimal progress; there may be further non-empty matches.  */
/* XXX - Could really advance by one whole multi-octet character.  */
match_size = 1;
if (!mid)
mid = cur;
}
else
{
/* This function is called on a matching line only,
but is it selected or rejected/context?  */
if (only_matching)
print_line_head (b, lim, (out_invert ? SEP_CHAR_REJECTED
: SEP_CHAR_SELECTED));
else
{
pr_sgr_start (line_color);
if (mid)
{
cur = mid;
mid = NULL;
}
fwrite (cur, sizeof (char), b - cur, stdout);
}

pr_sgr_start_if (match_color);
fwrite (b, sizeof (char), match_size, stdout);
pr_sgr_end_if (match_color);
if (only_matching)
fputs (""\n"", stdout);
}
cur = b + match_size;
}

if (only_matching)
cur = lim;
else if (mid)
cur = mid;

return cur;
}

static const char *
print_line_tail (const char *beg, const char *lim, const char *line_color)
{
size_t eol_size;
size_t tail_size;

eol_size   = (lim > beg && lim[-1] == eolbyte);
eol_size  += (lim - eol_size > beg && lim[-(1 + eol_size)] == '\r');
tail_size  =  lim - eol_size - beg;

if (tail_size > 0)
{
pr_sgr_start (line_color);
fwrite (beg, 1, tail_size, stdout);
beg += tail_size;
pr_sgr_end (line_color);
}

return beg;
}

static void
prline (char const *beg, char const *lim, int sep)
{
int matching;
const char *line_color;
const char *match_color;

if (!only_matching)
print_line_head (beg, lim, sep);

matching = (sep == SEP_CHAR_SELECTED) ^ !!out_invert;

if (color_option)
{
line_color = (((sep == SEP_CHAR_SELECTED)
^ (out_invert && (color_option < 0)))
? selected_line_color  : context_line_color);
match_color = (sep == SEP_CHAR_SELECTED
? selected_match_color : context_match_color);
}
else
line_color = match_color = NULL; /* Shouldn't be used.  */

if ((only_matching && matching)
|| (color_option  && (*line_color || *match_color)))
{
/* We already know that non-matching lines have no match (to colorize).  */
if (matching && (only_matching || *match_color))
beg = print_line_middle (beg, lim, line_color, match_color);

/* FIXME: this test may be removable.  */
if (!only_matching && *line_color)
beg = print_line_tail (beg, lim, line_color);
}

if (!only_matching && lim > beg)
fwrite (beg, 1, lim - beg, stdout);

if (ferror (stdout))
{
write_error_seen = 1;
error (EXIT_TROUBLE, 0, _(""write error""));
}

lastout = lim;

if (line_buffered)
fflush (stdout);
}

/* Print pending lines of trailing context prior to LIM. Trailing context ends
at the next matching line when OUTLEFT is 0.  */
static void
prpending (char const *lim)
{
if (!lastout)
lastout = bufbeg;
while (pending > 0 && lastout < lim)
{
char const *nl = memchr (lastout, eolbyte, lim - lastout);
size_t match_size;
--pending;
if (outleft
|| ((execute (lastout, nl + 1 - lastout,
&match_size, NULL) == (size_t) -1)
== !out_invert))
prline (lastout, nl + 1, SEP_CHAR_REJECTED);
else
pending = 0;
}
}

/* Print the lines between BEG and LIM.  Deal with context crap.
If NLINESP is non-null, store a count of lines between BEG and LIM.  */
static void
prtext (char const *beg, char const *lim, int *nlinesp)
{
/* Print the lines between BEG and LIM.  Deal with context crap.
If NLINESP is non-null, store a count of lines between BEG and LIM.  */
static void
prtext (char const *beg, char const *lim, int *nlinesp)
{
static int used;	/* avoid printing SEP_STR_GROUP before any output */
char const *bp, *p;
char eol = eolbyte;
  int i, n;

if (!out_quiet && pending > 0)
prpending (beg);
/* Deal with leading context crap. */

bp = lastout ? lastout : bufbeg;
for (i = 0; i < out_before; ++i)
if (p > bp)
do
--p;
while (p[-1] != eol);

/* We print the SEP_STR_GROUP separator only if our output is
discontiguous from the last output in the file. */
if ((out_before || out_after) && used && p != lastout && group_separator)
{
pr_sgr_start_if (sep_color);
fputs (group_separator, stdout);
pr_sgr_end_if (sep_color);
fputc ('\n', stdout);
}

while (p < beg)
{
char const *nl = memchr (p, eol, beg - p);
nl++;
prline (p, nl, SEP_CHAR_REJECTED);
p = nl;
}
}

if (nlinesp)
{
/* Caller wants a line count. */
for (n = 0; p < lim && n < outleft; n++)
{
char const *nl = memchr (p, eol, lim - p);
nl++;
if (!out_quiet)
prline (p, nl, SEP_CHAR_SELECTED);
p = nl;
}
*nlinesp = n;

/* relying on it that this function is never called when outleft = 0.  */
after_last_match = bufoffset - (buflim - p);
}
else if (!out_quiet)
prline (beg, lim, SEP_CHAR_SELECTED);

pending = out_quiet ? 0 : out_after;
used = 1;
}

static size_t
do_execute (char const *buf, size_t size, size_t *match_size, char const *start_ptr)
{
size_t result;
const char *line_next;

/* With the current implementation, using --ignore-case with a multi-byte
character set is very inefficient when applied to a large buffer
containing many matches.  We can avoid much of the wasted effort
by matching line-by-line.

FIXME: this is just an ugly workaround, and it doesn't really
belong here.  Also, PCRE is always using this same per-line
matching algorithm.  Either we fix -i, or we should refactor
this code---for example, we could add another function pointer
to struct matcher to split the buffer passed to execute.  It would
perform the memchr if line-by-line matching is necessary, or just
return buf + size otherwise.  */
if (MB_CUR_MAX == 1 || !match_icase)
return execute (buf, size, match_size, start_ptr);

for (line_next = buf; line_next < buf + size; )
{
const char *line_buf = line_next;
const char *line_end = memchr (line_buf, eolbyte, (buf + size) - line_buf);
if (line_end == NULL)
line_next = line_end = buf + size;
else
line_next = line_end + 1;

if (start_ptr && start_ptr >= line_end)
continue;

result = execute (line_buf, line_next - line_buf, match_size, start_ptr);
if (result != (size_t) -1)
return (line_buf - buf) + result;
}

return (size_t) -1;
}

/* Scan the specified portion of the buffer, matching lines (or
between matching lines if OUT_INVERT is true).  Return a count of
lines printed. */
static int
grepbuf (char const *beg, char const *lim)
/* Scan the specified portion of the buffer, matching lines (or
between matching lines if OUT_INVERT is true).  Return a count of
lines printed. */
static int
grepbuf (char const *beg, char const *lim)
{
  int nlines, n;
char const *p;
size_t match_offset;
size_t match_size;
{
char const *b = p + match_offset;
char const *endp = b + match_size;
/* Avoid matching the empty line at the end of the buffer. */
if (b == lim)
break;
if (!out_invert)
{
prtext (b, endp, (int *) 0);
nlines++;
break;
if (!out_invert)
{
          prtext (b, endp, (int *) 0);
nlines++;
outleft--;
if (!outleft || done_on_match)
}
}
else if (p < b)
{
prtext (p, b, &n);
nlines += n;
outleft -= n;
if (!outleft)
return nlines;
}
p = endp;
}
if (out_invert && p < lim)
{
prtext (p, lim, &n);
nlines += n;
outleft -= n;
}
return nlines;
}

/* Search a given file.  Normally, return a count of lines printed;
but if the file is a directory and we search it recursively, then
return -2 if there was a match, and -1 otherwise.  */
static int
grep (int fd, char const *file, struct stats *stats)
/* Search a given file.  Normally, return a count of lines printed;
but if the file is a directory and we search it recursively, then
return -2 if there was a match, and -1 otherwise.  */
static int
grep (int fd, char const *file, struct stats *stats)
{
  int nlines, i;
int not_text;
size_t residue, save;
char oldc;
return 0;

if (file && directories == RECURSE_DIRECTORIES
&& S_ISDIR (stats->stat.st_mode))
{
/* Close fd now, so that we don't open a lot of file descriptors
when we recurse deeply.  */
if (close (fd) != 0)
suppressible_error (file, errno);
return grepdir (file, stats) - 2;
}

totalcc = 0;
lastout = 0;
totalnl = 0;
outleft = max_count;
after_last_match = 0;
pending = 0;

nlines = 0;
residue = 0;
save = 0;

if (! fillbuf (save, stats))
{
suppressible_error (filename, errno);
return 0;
}

not_text = (((binary_files == BINARY_BINARY_FILES && !out_quiet)
|| binary_files == WITHOUT_MATCH_BINARY_FILES)
&& memchr (bufbeg, eol ? '\0' : '\200', buflim - bufbeg));
if (not_text && binary_files == WITHOUT_MATCH_BINARY_FILES)
return 0;
done_on_match += not_text;
out_quiet += not_text;

for (;;)
{
lastnl = bufbeg;
if (lastout)
lastout = bufbeg;

beg = bufbeg + save;

/* no more data to scan (eof) except for maybe a residue -> break */
if (beg == buflim)
break;

/* Determine new residue (the length of an incomplete line at the end of
the buffer, 0 means there is no incomplete last line).  */
oldc = beg[-1];
beg[-1] = eol;
for (lim = buflim; lim[-1] != eol; lim--)
continue;
beg[-1] = oldc;
if (lim == beg)
lim = beg - residue;
beg -= residue;
residue = buflim - lim;

if (beg < lim)
{
if (outleft)
nlines += grepbuf (beg, lim);
if (pending)
prpending (lim);
if ((!outleft && !pending) || (nlines && done_on_match && !out_invert))
goto finish_grep;
}

/* The last OUT_BEFORE lines at the end of the buffer will be needed as
leading context if there is a matching line at the begin of the
next data. Make beg point to their begin.  */
i = 0;
beg = lim;
while (i < out_before && beg > bufbeg && beg != lastout)
{
++i;
do
--beg;
while (beg[-1] != eol);
}

/* detect if leading context is discontinuous from last printed line.  */
if (beg != lastout)
lastout = 0;

/* Handle some details and read more data to scan.  */
save = residue + lim - beg;
if (out_byte)
totalcc = add_count (totalcc, buflim - bufbeg - save);
if (out_line)
nlscan (beg);
if (! fillbuf (save, stats))
{
suppressible_error (filename, errno);
goto finish_grep;
}
}
if (residue)
{
*buflim++ = eol;
if (outleft)
nlines += grepbuf (bufbeg + save - residue, buflim);
if (pending)
prpending (buflim);
}

finish_grep:
done_on_match -= not_text;
out_quiet -= not_text;
if ((not_text & ~out_quiet) && nlines != 0)
printf (_(""Binary file %s matches\n""), filename);
return nlines;
}

static int
grepfile (char const *file, struct stats *stats)
{
int desc;
int count;
int status;
grepfile (char const *file, struct stats *stats)
{
int desc;
  int count;
int status;

filename = (file ? file : label ? label : _(""(standard input)""));
/* Don't open yet, since that might have side effects on a device.  */
desc = -1;
}
else
{
/* When skipping directories, don't worry about directories
that can't be opened.  */
desc = open (file, O_RDONLY);
if (desc < 0 && directories != SKIP_DIRECTORIES)
{
suppressible_error (file, errno);
return 1;
}
}

if (desc < 0
? stat (file, &stats->stat) != 0
: fstat (desc, &stats->stat) != 0)
{
suppressible_error (filename, errno);
if (file)
close (desc);
return 1;
}

if ((directories == SKIP_DIRECTORIES && S_ISDIR (stats->stat.st_mode))
|| (devices == SKIP_DEVICES && (S_ISCHR (stats->stat.st_mode)
|| S_ISBLK (stats->stat.st_mode)
|| S_ISSOCK (stats->stat.st_mode)
|| S_ISFIFO (stats->stat.st_mode))))
{
if (file)
close (desc);
return 1;
}

/* If there is a regular file on stdout and the current file refers
to the same i-node, we have to report the problem and skip it.
Otherwise when matching lines from some other input reach the
disk before we open this file, we can end up reading and matching
those lines and appending them to the file from which we're reading.
Then we'd have what appears to be an infinite loop that'd terminate
only upon filling the output file system or reaching a quota.
However, there is no risk of an infinite loop if grep is generating
no output, i.e., with --silent, --quiet, -q.
Similarly, with any of these:
--max-count=N (-m) (for N >= 2)
--files-with-matches (-l)
--files-without-match (-L)
there is no risk of trouble.
For --max-count=1, grep stops after printing the first match,
so there is no risk of malfunction.  But even --max-count=2, with
input==output, while there is no risk of infloop, there is a race
condition that could result in ""alternate"" output.  */
if (!out_quiet && list_files == 0 && 1 < max_count
&& S_ISREG (out_stat.st_mode) && out_stat.st_ino
&& SAME_INODE (stats->stat, out_stat))
{
if (! suppress_errors)
error (0, 0, _(""input file %s is also the output""), quote (filename));
errseen = 1;
if (file)
close (desc);
return 1;
}

if (desc < 0)
{
desc = open (file, O_RDONLY);
if (desc < 0)
{
suppressible_error (file, errno);
return 1;
}
}

#if defined SET_BINARY
/* Set input to binary mode.  Pipes are simulated with files
on DOS, so this includes the case of ""foo | grep bar"".  */
if (!isatty (desc))
SET_BINARY (desc);
#endif

count = grep (desc, file, stats);
if (count < 0)
status = count + 2;
else
{
if (count_matches)
{
if (out_file)
{
print_filename ();
if (filename_mask)
print_sep (SEP_CHAR_SELECTED);
else
fputc (0, stdout);
}
printf (""%d\n"", count);
}
else
fputc (0, stdout);
}
          printf (""%d\n"", count);
}

status = !count;

if (! file)
{
off_t required_offset = outleft ? bufoffset : after_last_match;
if (required_offset != bufoffset
&& lseek (desc, required_offset, SEEK_SET) < 0
&& S_ISREG (stats->stat.st_mode))
suppressible_error (filename, errno);
}
else
while (close (desc) != 0)
if (errno != EINTR)
{
suppressible_error (file, errno);
break;
}
}
","[2, 3, 4, 5, 39]","  uintmax_t value;/~/  if (! (xstrtoumax (str, 0, 10, &value, """") == LONGINT_OK/~/         && 0 <= (*out = value)/~/         && *out == value))/~/static int out_before;		/* Lines of leading context. */~/static int out_after;		/* Lines of trailing context. */~/static off_t max_count;		/* Stop after outputting this many/~/static off_t outleft;		/* Maximum number of lines to be output.  */~/static int pending;		/* Pending lines of output./~/prtext (char const *beg, char const *lim, int *nlinesp)/~/  int i, n;/~/static int/~/  int nlines, n;/~/          prtext (b, endp, (int *) 0);/~/static int/~/  int nlines, i;/~/  int count;/~/          printf (""%d\n"", count);"
142,"void InputMethodBase::OnInputMethodChanged() const {
TextInputClient* client = GetTextInputClient();
  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)
client->OnInputMethodChanged();
}
",[2],  if (client && client->GetTextInputType() != TEXT_INPUT_TYPE_NONE)
143,"void CallbackAndDie(bool succeeded) {
    v8::Isolate* isolate = context_->isolate();
    v8::HandleScope handle_scope(isolate);
    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};
    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),
                           arraysize(args), args);
delete this;
}
","[1, 2, 3, 4, 5]","    v8::Isolate* isolate = context_->isolate();/~/    v8::HandleScope handle_scope(isolate);/~/    v8::Local<v8::Value> args[] = {v8::Boolean::New(isolate, succeeded)};/~/    context_->CallFunction(v8::Local<v8::Function>::New(isolate, callback_),/~/                           arraysize(args), args);"
144,"long ContentEncoding::ParseContentEncodingEntry(long long start,
                                                long long size,
IMkvReader* pReader) {
assert(pReader);

long long pos = start;
const long long stop = start + size;

// Count ContentCompression and ContentEncryption elements.
int compression_count = 0;
int encryption_count = 0;


while (pos < stop) {
long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
return status;

if (id == 0x1034)  // ContentCompression ID
++compression_count;


if (id == 0x1035)  // ContentEncryption ID
++encryption_count;

    pos += size;  //consume payload
assert(pos <= stop);
}

if (compression_count <= 0 && encryption_count <= 0)
return -1;


if (compression_count > 0) {
compression_entries_ =
        new (std::nothrow) ContentCompression*[compression_count];
if (!compression_entries_)
return -1;
compression_entries_end_ = compression_entries_;
}


if (encryption_count > 0) {
encryption_entries_ =
        new (std::nothrow) ContentEncryption*[encryption_count];
if (!encryption_entries_) {
      delete [] compression_entries_;
return -1;
}
encryption_entries_end_ = encryption_entries_;
}


pos = start;
while (pos < stop) {
long long id, size;
    long status = ParseElementHeader(pReader,
                                     pos,
                                     stop,
                                     id,
                                     size);
    if (status < 0)  //error
return status;

if (id == 0x1031) {
// ContentEncodingOrder
encoding_order_ = UnserializeUInt(pReader, pos, size);
} else if (id == 0x1032) {
// ContentEncodingScope
encoding_scope_ = UnserializeUInt(pReader, pos, size);
if (encoding_scope_ < 1)
return -1;
} else if (id == 0x1033) {
// ContentEncodingType
encoding_type_ = UnserializeUInt(pReader, pos, size);

} else if (id == 0x1034) {
// ContentCompression ID
ContentCompression* const compression =
        new (std::nothrow) ContentCompression();
if (!compression)
return -1;

status = ParseCompressionEntry(pos, size, pReader, compression);
if (status) {
delete compression;
return status;
}
*compression_entries_end_++ = compression;
} else if (id == 0x1035) {
// ContentEncryption ID
ContentEncryption* const encryption =
new (std::nothrow) ContentEncryption();
if (!encryption)
return -1;

status = ParseEncryptionEntry(pos, size, pReader, encryption);
if (status) {
delete encryption;
return status;
}

*encryption_entries_end_++ = encryption;
}

    pos += size;  //consume payload
assert(pos <= stop);
}

assert(pos == stop);

return 0;
}
","[1, 11, 12, 13, 14, 15, 16, 22, 29]","                                                long long size,/~/    const long status = ParseElementHeader(pReader,/~/                                           pos,/~/                                           stop,/~/                                           id,/~/                                           size);/~/    if (status < 0)  //error/~/    pos += size;  //consume payload/~/        new (std::nothrow) ContentCompression*[compression_count];/~/        new (std::nothrow) ContentEncryption*[encryption_count];/~/      delete [] compression_entries_;/~/    long status = ParseElementHeader(pReader,/~/                                     pos,/~/                                     stop,/~/                                     id,/~/                                     size);/~/    if (status < 0)  //error/~/        new (std::nothrow) ContentCompression();/~/    pos += size;  //consume payload"
145,"IMPEG2D_ERROR_CODES_T impeg2d_dec_seq_hdr(dec_state_t *ps_dec)
{
stream_t *ps_stream;
ps_stream = &ps_dec->s_bit_stream;
UWORD16 u2_height;
UWORD16 u2_width;

if (impeg2d_bit_stream_nxt(ps_stream,START_CODE_LEN) != SEQUENCE_HEADER_CODE)
{
impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);
return IMPEG2D_FRM_HDR_START_CODE_NOT_FOUND;

}
impeg2d_bit_stream_flush(ps_stream,START_CODE_LEN);

u2_width    = impeg2d_bit_stream_get(ps_stream,12);
u2_height   = impeg2d_bit_stream_get(ps_stream,12);

if (0 == u2_width || 0 == u2_height)
{
IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_FRM_HDR_DECODE_ERR;
return e_error;
}

if ((u2_width != ps_dec->u2_horizontal_size)
|| (u2_height != ps_dec->u2_vertical_size))
{
if (0 == ps_dec->u2_header_done)
{

/* This is the first time we are reading the resolution */
ps_dec->u2_horizontal_size = u2_width;
ps_dec->u2_vertical_size = u2_height;
            if (0 == ps_dec->u4_frm_buf_stride)
            {
                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);
            }
}
else
{
if (0 == ps_dec->i4_pic_count)
{
/* Decoder has not decoded a single frame since the last
* reset/init. This implies that we have two headers in the
* input stream. So, do not indicate a resolution change, since
* this can take the decoder into an infinite loop.
*/
return (IMPEG2D_ERROR_CODES_T) IMPEG2D_FRM_HDR_DECODE_ERR;
}
else if((u2_width > ps_dec->u2_create_max_width)
|| (u2_height > ps_dec->u2_create_max_height))
{
IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;

ps_dec->u2_reinit_max_height   = u2_height;
ps_dec->u2_reinit_max_width    = u2_width;


return e_error;
}
else
{
/* The resolution has changed */
return (IMPEG2D_ERROR_CODES_T)IVD_RES_CHANGED;
}
}
}

if((ps_dec->u2_horizontal_size > ps_dec->u2_create_max_width)
|| (ps_dec->u2_vertical_size > ps_dec->u2_create_max_height))
{
IMPEG2D_ERROR_CODES_T e_error = IMPEG2D_UNSUPPORTED_DIMENSIONS;
ps_dec->u2_reinit_max_height   = ps_dec->u2_vertical_size;
ps_dec->u2_reinit_max_width    = ps_dec->u2_horizontal_size;

return e_error;
}


/*------------------------------------------------------------------------*/
/* Flush the following as they are not being used                         */
/* aspect_ratio_info (4 bits)                                             */
/*------------------------------------------------------------------------*/
ps_dec->u2_aspect_ratio_info = impeg2d_bit_stream_get(ps_stream,4);

/*------------------------------------------------------------------------*/
/* Frame rate code(4 bits)                                                */
/*------------------------------------------------------------------------*/
ps_dec->u2_frame_rate_code = impeg2d_bit_stream_get(ps_stream,4);
if (ps_dec->u2_frame_rate_code > MPEG2_MAX_FRAME_RATE_CODE)
{
return IMPEG2D_FRM_HDR_DECODE_ERR;
}
/*------------------------------------------------------------------------*/
/* Flush the following as they are not being used                         */
/* bit_rate_value (18 bits)                                               */
/*------------------------------------------------------------------------*/
impeg2d_bit_stream_flush(ps_stream,18);
GET_MARKER_BIT(ps_dec,ps_stream);
/*------------------------------------------------------------------------*/
/* Flush the following as they are not being used                         */
/* vbv_buffer_size_value(10 bits), constrained_parameter_flag (1 bit)     */
/*------------------------------------------------------------------------*/
impeg2d_bit_stream_flush(ps_stream,11);

/*------------------------------------------------------------------------*/
/* Quantization matrix for the intra blocks                               */
/*------------------------------------------------------------------------*/
if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
{
UWORD16 i;
for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
{
ps_dec->au1_intra_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
}

}
else
{
memcpy(ps_dec->au1_intra_quant_matrix,gau1_impeg2_intra_quant_matrix_default,
NUM_PELS_IN_BLOCK);
}

/*------------------------------------------------------------------------*/
/* Quantization matrix for the inter blocks                               */
/*------------------------------------------------------------------------*/
if(impeg2d_bit_stream_get_bit(ps_stream) == 1)
{
UWORD16 i;
for(i = 0; i < NUM_PELS_IN_BLOCK; i++)
{
ps_dec->au1_inter_quant_matrix[gau1_impeg2_inv_scan_zig_zag[i]] = (UWORD8)impeg2d_bit_stream_get(ps_stream,8);
}
}
else
{
memcpy(ps_dec->au1_inter_quant_matrix,gau1_impeg2_inter_quant_matrix_default,
NUM_PELS_IN_BLOCK);
}
impeg2d_next_start_code(ps_dec);

return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
","[1, 7, 10, 15, 18, 21, 23, 27, 28]",            if (0 == ps_dec->u4_frm_buf_stride)/~/            {/~/                ps_dec->u4_frm_buf_stride  = (UWORD32) (u2_width);/~/            }
146,"v8::Local<v8::Value> V8Debugger::generatorObjectLocation(v8::Local<v8::Object> object)
{
if (!enabled()) {
NOTREACHED();
return v8::Null(m_isolate);
}
v8::Local<v8::Value> argv[] = { object };
v8::Local<v8::Value> location = callDebuggerMethod(""getGeneratorObjectLocation"", 1, argv).ToLocalChecked();
    if (!location->IsObject())
return v8::Null(m_isolate);
    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);
    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))
return v8::Null(m_isolate);
    return location;
}
","[8, 10, 11, 13]","    if (!location->IsObject())/~/    v8::Local<v8::Context> context = m_debuggerContext.Get(m_isolate);/~/    if (!markAsInternal(context, v8::Local<v8::Object>::Cast(location), V8InternalValueType::kLocation))/~/    return location;"
147,"vips_malloc( VipsObject *object, size_t size )
{
void *buf;

	buf = g_malloc( size );

if( object ) {
g_signal_connect( object, ""postclose"",
G_CALLBACK( vips_malloc_cb ), buf );
object->local_memory += size;
}

return( buf );
}
",[3],	buf = g_malloc( size );
148,"PP_Bool LaunchSelLdr(PP_Instance instance,
                     const char* alleged_url,
                     int socket_count,
void* imc_handles) {
std::vector<nacl::FileDescriptor> sockets;
IPC::Sender* sender = content::RenderThread::Get();
if (sender == NULL)
sender = g_background_thread_sender.Pointer()->get();

  IPC::ChannelHandle channel_handle;
if (!sender->Send(new ChromeViewHostMsg_LaunchNaCl(
          GURL(alleged_url), socket_count, &sockets,
          &channel_handle))) {
return PP_FALSE;
  }
  // Don't save invalid channel handles.
  bool invalid_handle = channel_handle.name.empty();
#if defined(OS_POSIX)
  if (!invalid_handle)
    invalid_handle = (channel_handle.socket.fd == -1);
#endif
  if (!invalid_handle)
    g_channel_handle_map.Get()[instance] = channel_handle;

CHECK(static_cast<int>(sockets.size()) == socket_count);
for (int i = 0; i < socket_count; i++) {
static_cast<nacl::Handle*>(imc_handles)[i] =
nacl::ToNativeHandle(sockets[i]);
}

return PP_TRUE;
}
","[1, 2, 8, 10, 11, 13, 14, 15, 16, 17, 18, 19, 20, 21, 26, 28]","                     const char* alleged_url,/~/                     int socket_count,/~/  IPC::ChannelHandle channel_handle;/~/          GURL(alleged_url), socket_count, &sockets,/~/          &channel_handle))) {/~/  }/~/  // Don't save invalid channel handles./~/  bool invalid_handle = channel_handle.name.empty();/~/#if defined(OS_POSIX)/~/  if (!invalid_handle)/~/    invalid_handle = (channel_handle.socket.fd == -1);/~/#endif/~/  if (!invalid_handle)/~/    g_channel_handle_map.Get()[instance] = channel_handle;"
149,"void comps_mrtree_unite(COMPS_MRTree *rt1, COMPS_MRTree *rt2) {
COMPS_HSList *tmplist, *tmp_subnodes;
COMPS_HSListItem *it, *it2;
struct Pair {
COMPS_HSList * subnodes;
char * key;
        char added;
} *pair, *parent_pair;

pair = malloc(sizeof(struct Pair));
pair->subnodes = rt2->subnodes;
pair->key = NULL;

tmplist = comps_hslist_create();
comps_hslist_init(tmplist, NULL, NULL, &free);
comps_hslist_append(tmplist, pair, 0);

while (tmplist->first != NULL) {
it = tmplist->first;
comps_hslist_remove(tmplist, tmplist->first);
tmp_subnodes = ((struct Pair*)it->data)->subnodes;
parent_pair = (struct Pair*) it->data;
free(it);

        pair->added = 0;
for (it = tmp_subnodes->first; it != NULL; it=it->next) {
pair = malloc(sizeof(struct Pair));
pair->subnodes = ((COMPS_MRTreeData*)it->data)->subnodes;

if (parent_pair->key != NULL) {
pair->key =
malloc(sizeof(char)
* (strlen(((COMPS_MRTreeData*)it->data)->key)
+ strlen(parent_pair->key) + 1));
memcpy(pair->key, parent_pair->key,
sizeof(char) * strlen(parent_pair->key));
memcpy(pair->key+strlen(parent_pair->key),
((COMPS_MRTreeData*)it->data)->key,
sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));
} else {
pair->key = malloc(sizeof(char)*
(strlen(((COMPS_MRTreeData*)it->data)->key) +
1));
memcpy(pair->key, ((COMPS_MRTreeData*)it->data)->key,
sizeof(char)*(strlen(((COMPS_MRTreeData*)it->data)->key)+1));
}
/* current node has data */
if (((COMPS_MRTreeData*)it->data)->data->first != NULL) {
for (it2 = ((COMPS_MRTreeData*)it->data)->data->first;
it2 != NULL; it2 = it2->next) {
comps_mrtree_set(rt1, pair->key, it2->data);
}

if (((COMPS_MRTreeData*)it->data)->subnodes->first) {
comps_hslist_append(tmplist, pair, 0);
} else {
free(pair->key);
free(pair);
}
/* current node hasn't data */
} else {
if (((COMPS_MRTreeData*)it->data)->subnodes->first) {
comps_hslist_append(tmplist, pair, 0);
} else {
free(pair->key);
free(pair);
}
}
}
free(parent_pair->key);
free(parent_pair);
}
comps_hslist_destroy(&tmplist);
}
","[6, 20]",        char added;/~/        pair->added = 0;
150,"void comps_objmrtree_unite(COMPS_ObjMRTree *rt1, COMPS_ObjMRTree *rt2) {
COMPS_HSList *tmplist, *tmp_subnodes;
COMPS_HSListItem *it;
COMPS_ObjListIt *it2;
struct Pair {
COMPS_HSList * subnodes;
char * key;
        char added;
} *pair, *parent_pair;

pair = malloc(sizeof(struct Pair));
pair->subnodes = rt2->subnodes;
pair->key = NULL;

tmplist = comps_hslist_create();
comps_hslist_init(tmplist, NULL, NULL, &free);
comps_hslist_append(tmplist, pair, 0);

while (tmplist->first != NULL) {
it = tmplist->first;
comps_hslist_remove(tmplist, tmplist->first);
tmp_subnodes = ((struct Pair*)it->data)->subnodes;
parent_pair = (struct Pair*) it->data;
free(it);

        pair->added = 0;
for (it = tmp_subnodes->first; it != NULL; it=it->next) {
pair = malloc(sizeof(struct Pair));
pair->subnodes = ((COMPS_ObjMRTreeData*)it->data)->subnodes;

if (parent_pair->key != NULL) {
pair->key =
malloc(sizeof(char)
* (strlen(((COMPS_ObjMRTreeData*)it->data)->key)
+ strlen(parent_pair->key) + 1));
memcpy(pair->key, parent_pair->key,
sizeof(char) * strlen(parent_pair->key));
memcpy(pair->key+strlen(parent_pair->key),
((COMPS_ObjMRTreeData*)it->data)->key,
sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));
} else {
pair->key = malloc(sizeof(char)*
(strlen(((COMPS_ObjMRTreeData*)it->data)->key) +
1));
memcpy(pair->key, ((COMPS_ObjMRTreeData*)it->data)->key,
sizeof(char)*(strlen(((COMPS_ObjMRTreeData*)it->data)->key)+1));
}
/* current node has data */
if (((COMPS_ObjMRTreeData*)it->data)->data->first != NULL) {
for (it2 = ((COMPS_ObjMRTreeData*)it->data)->data->first;
it2 != NULL; it2 = it2->next) {
comps_objmrtree_set(rt1, pair->key, it2->comps_obj);
}

if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {
comps_hslist_append(tmplist, pair, 0);
} else {
free(pair->key);
free(pair);
}
/* current node hasn't data */
} else {
if (((COMPS_ObjMRTreeData*)it->data)->subnodes->first) {
comps_hslist_append(tmplist, pair, 0);
} else {
free(pair->key);
free(pair);
}
}
}
free(parent_pair->key);
free(parent_pair);
}
comps_hslist_destroy(&tmplist);
}
","[7, 21]",        char added;/~/        pair->added = 0;
151,"int mif_validate(jas_stream_t *in)
{
	uchar buf[MIF_MAGICLEN];
uint_fast32_t magic;
int i;
int n;

assert(JAS_STREAM_MAXPUTBACK >= MIF_MAGICLEN);

/* Read the validation data (i.e., the data used for detecting
the format). */
if ((n = jas_stream_read(in, buf, MIF_MAGICLEN)) < 0) {
return -1;
}

/* Put the validation data back onto the stream, so that the
stream position will not be changed. */
for (i = n - 1; i >= 0; --i) {
if (jas_stream_ungetc(in, buf[i]) == EOF) {
return -1;
}
}

/* Was enough data read? */
if (n < MIF_MAGICLEN) {
return -1;
}

/* Compute the signature value. */
magic = (JAS_CAST(uint_fast32_t, buf[0]) << 24) |
(JAS_CAST(uint_fast32_t, buf[1]) << 16) |
(JAS_CAST(uint_fast32_t, buf[2]) << 8) |
buf[3];

/* Ensure that the signature is correct for this format. */
if (magic != MIF_MAGIC) {
return -1;
}

return 0;
}
",[2],	uchar buf[MIF_MAGICLEN];
152,"static void put_crypt_info(struct fscrypt_info *ci)
{
if (!ci)
return;

	key_put(ci->ci_keyring_key);
crypto_free_skcipher(ci->ci_ctfm);
kmem_cache_free(fscrypt_info_cachep, ci);
}
",[4],	key_put(ci->ci_keyring_key);
153,"void SetManualFallbacksForFilling(bool enabled) {
if (enabled) {
scoped_feature_list_.InitAndEnableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
} else {
scoped_feature_list_.InitAndDisableFeature(
          password_manager::features::kEnableManualFallbacksFilling);
}
}
","[3, 6]",          password_manager::features::kEnableManualFallbacksFilling);/~/          password_manager::features::kEnableManualFallbacksFilling);
154,"static int encrypt(struct blkcipher_desc *desc,
struct scatterlist *dst, struct scatterlist *src,
unsigned int nbytes)
{
struct blkcipher_walk walk;
struct crypto_blkcipher *tfm = desc->tfm;
struct salsa20_ctx *ctx = crypto_blkcipher_ctx(tfm);
int err;

blkcipher_walk_init(&walk, dst, src, nbytes);
err = blkcipher_walk_virt_block(desc, &walk, 64);

salsa20_ivsetup(ctx, walk.iv);

	if (likely(walk.nbytes == nbytes))
	{
		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
				      walk.src.virt.addr, nbytes);
		return blkcipher_walk_done(desc, &walk, 0);
	}
while (walk.nbytes >= 64) {
salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
walk.src.virt.addr,
walk.nbytes - (walk.nbytes % 64));
err = blkcipher_walk_done(desc, &walk, walk.nbytes % 64);
}

if (walk.nbytes) {
salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,
walk.src.virt.addr, walk.nbytes);
err = blkcipher_walk_done(desc, &walk, 0);
}

return err;
}
","[3, 11, 12, 13, 14, 15, 16, 18, 22, 24, 27, 29]","	if (likely(walk.nbytes == nbytes))/~/	{/~/		salsa20_encrypt_bytes(ctx, walk.dst.virt.addr,/~/				      walk.src.virt.addr, nbytes);/~/		return blkcipher_walk_done(desc, &walk, 0);/~/	}"
155,"PassRefPtr<DocumentFragment> XSLTProcessor::transformToFragment(Node* sourceNode, Document* outputDoc)
{
String resultMIMEType;
String resultString;
String resultEncoding;

// If the output document is HTML, default to HTML method.
if (outputDoc->isHTMLDocument())
resultMIMEType = ""text/html"";

if (!transformToString(sourceNode, resultMIMEType, resultString, resultEncoding))
return 0;
    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);
}
",[10],"    return createFragmentFromSource(resultString, resultMIMEType, outputDoc);"
156,"long long BlockGroup::GetNextTimeCode() const
{
    return m_next;
}
","[1, 2, 3]",{/~/    return m_next;/~/}
157,"void RenderBlockFlow::styleDidChange(StyleDifference diff, const RenderStyle* oldStyle)
{
RenderBlock::styleDidChange(diff, oldStyle);

// After our style changed, if we lose our ability to propagate floats into next sibling
// blocks, then we need to find the top most parent containing that overhanging float and
// then mark its descendants with floats for layout and clear all floats from its next
// sibling blocks that exist in our floating objects list. See bug 56299 and 62875.
bool canPropagateFloatIntoSibling = !isFloatingOrOutOfFlowPositioned() && !avoidsFloats();
    if (diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && !canPropagateFloatIntoSibling && hasOverhangingFloats()) {
RenderBlockFlow* parentBlockFlow = this;
const FloatingObjectSet& floatingObjectSet = m_floatingObjects->set();
FloatingObjectSetIterator end = floatingObjectSet.end();

for (RenderObject* curr = parent(); curr && !curr->isRenderView(); curr = curr->parent()) {
if (curr->isRenderBlockFlow()) {
RenderBlockFlow* currBlock = toRenderBlockFlow(curr);

if (currBlock->hasOverhangingFloats()) {
for (FloatingObjectSetIterator it = floatingObjectSet.begin(); it != end; ++it) {
RenderBox* renderer = (*it)->renderer();
if (currBlock->hasOverhangingFloat(renderer)) {
parentBlockFlow = currBlock;
break;
}
}
}
}
}

parentBlockFlow->markAllDescendantsWithFloatsForLayout();
parentBlockFlow->markSiblingsWithFloatsForLayout();
}

    if (diff == StyleDifferenceLayout || !oldStyle)
createOrDestroyMultiColumnFlowThreadIfNeeded();
}
","[8, 29]",    if (diff == StyleDifferenceLayout && s_canPropagateFloatIntoSibling && !canPropagateFloatIntoSibling && hasOverhangingFloats()) {/~/    if (diff == StyleDifferenceLayout || !oldStyle)
158,"iakerb_gss_delete_sec_context(OM_uint32 *minor_status,
gss_ctx_id_t *context_handle,
gss_buffer_t output_token)
{
    OM_uint32 major_status = GSS_S_COMPLETE;

if (output_token != GSS_C_NO_BUFFER) {
output_token->length = 0;
output_token->value = NULL;
}

*minor_status = 0;

    if (*context_handle != GSS_C_NO_CONTEXT) {
        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;
        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {
            iakerb_release_context(iakerb_ctx);
            *context_handle = GSS_C_NO_CONTEXT;
        } else {
            assert(iakerb_ctx->magic == KG_CONTEXT);
            major_status = krb5_gss_delete_sec_context(minor_status,
                                                       context_handle,
                                                       output_token);
        }
    }
    return major_status;
}
","[4, 8, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]","    OM_uint32 major_status = GSS_S_COMPLETE;/~/    if (*context_handle != GSS_C_NO_CONTEXT) {/~/        iakerb_ctx_id_t iakerb_ctx = (iakerb_ctx_id_t)*context_handle;/~/        if (iakerb_ctx->magic == KG_IAKERB_CONTEXT) {/~/            iakerb_release_context(iakerb_ctx);/~/            *context_handle = GSS_C_NO_CONTEXT;/~/        } else {/~/            assert(iakerb_ctx->magic == KG_CONTEXT);/~/            major_status = krb5_gss_delete_sec_context(minor_status,/~/                                                       context_handle,/~/                                                       output_token);/~/        }/~/    }/~/    return major_status;"
159,"double GetGPMFSampleRate(size_t handle, uint32_t fourcc, uint32_t flags)
{
mp4object *mp4 = (mp4object *)handle;
if (mp4 == NULL) return 0.0;

GPMF_stream metadata_stream, *ms = &metadata_stream;
uint32_t teststart = 0;
uint32_t testend = mp4->indexcount;
double rate = 0.0;

if (mp4->indexcount < 1)
return 0.0;

	if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. 
	{
		teststart++;
		testend--;
	}
	uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload
	uint32_t payloadsize = GetPayloadSize(handle, teststart);
	int32_t ret = GPMF_Init(ms, payload, payloadsize);

if (ret != GPMF_OK)
goto cleanup;

{
uint32_t startsamples = 0;
uint32_t endsamples = 0;
		uint32_t missing_samples = 0;

		while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
{
			missing_samples = 1;
teststart++;
payload = GetPayload(handle, payload, teststart); // second last payload
payloadsize = GetPayloadSize(handle, teststart);
ret = GPMF_Init(ms, payload, payloadsize);
}

		if (missing_samples)
		{
			teststart++;   //samples after sensor start are statistically the best
			payload = GetPayload(handle, payload, teststart);
			payloadsize = GetPayloadSize(handle, teststart);
			ret = GPMF_Init(ms, payload, payloadsize);
		}
		if (ret == GPMF_OK)
{
			uint32_t samples = GPMF_Repeat(ms);
GPMF_stream find_stream;
GPMF_CopyState(ms, &find_stream);

			if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
{
				startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;

				payload = GetPayload(handle, payload, testend); // second last payload
payloadsize = GetPayloadSize(handle, testend);
ret = GPMF_Init(ms, payload, payloadsize);
				if (ret != GPMF_OK)
					goto cleanup;

				if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
{
					GPMF_CopyState(ms, &find_stream);
					if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))
{
						endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));
						rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
						goto cleanup;
}
}
				rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
}
			else // for increased precision, for older GPMF streams sometimes missing the total sample count 
{
				uint32_t payloadpos = 0, payloadcount = 0;
				double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;
				uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);
				memset(repeatarray, 0, mp4->indexcount * 4 + 4);

				samples = 0;

				for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)
{
					payload = GetPayload(handle, payload, payloadpos); // second last payload
					payloadsize = GetPayloadSize(handle, payloadpos);
					ret = GPMF_Init(ms, payload, payloadsize);

					if (ret != GPMF_OK)
						goto cleanup;

					if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))
{
						GPMF_stream find_stream2;
						GPMF_CopyState(ms, &find_stream2);

						if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats
{
							if (repeatarray)
							{
								float in, out;

								do
{
									samples++;
								} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));

								repeatarray[payloadpos] = samples;
								meanY += (double)samples;

								GetPayloadTime(handle, payloadpos, &in, &out);
								meanX += out;
							}
						}
						else
						{
							uint32_t repeat = GPMF_Repeat(ms);
							samples += repeat;

							if (repeatarray)
{
								float in, out;

								repeatarray[payloadpos] = samples;
								meanY += (double)samples;

								GetPayloadTime(handle, payloadpos, &in, &out);
								meanX += out;
}
}
}
				}
				// Compute the line of best fit for a jitter removed sample rate.  
				// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  
				// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift.
				if (repeatarray)
				{
					meanY /= (double)payloadcount;
					meanX /= (double)payloadcount;

					for (payloadpos = teststart; payloadpos < testend; payloadpos++)
{
						float in, out;
						GetPayloadTime(handle, payloadpos, &in, &out);

						top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);
						bot += ((double)out - meanX)*((double)out - meanX);
					}

					slope = top / bot;

#if 0
					// This sample code might be useful for compare data latency between channels.
{
						double intercept;
						intercept = meanY - slope*meanX;
						printf(""%c%c%c%c start offset = %f (%.3fms)\n"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);
}
#endif
					rate = slope;
				}
				else
				{
					rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);
				}
				free(repeatarray);

				goto cleanup;
}
		}
	}

cleanup:
	if (payload) 
	{
		FreePayload(payload);
		payload = NULL;
	}
	return rate;
}
","[1, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 23, 24, 25, 26, 27, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38]","	if (mp4->indexcount > 3) // samples after first and before last are statistically the best, avoiding camera start up or shutdown anomollies. /~/	{/~/		teststart++;/~/		testend--;/~/	}/~/	uint32_t *payload = GetPayload(handle, NULL, teststart); // second payload/~/	uint32_t payloadsize = GetPayloadSize(handle, teststart);/~/	int32_t ret = GPMF_Init(ms, payload, payloadsize);/~/		uint32_t missing_samples = 0;/~/		while (ret == GPMF_OK && GPMF_OK != GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))/~/			missing_samples = 1;/~/		if (missing_samples)/~/		{/~/			teststart++;   //samples after sensor start are statistically the best/~/			payload = GetPayload(handle, payload, teststart);/~/			payloadsize = GetPayloadSize(handle, teststart);/~/			ret = GPMF_Init(ms, payload, payloadsize);/~/		}/~/		if (ret == GPMF_OK)/~/			uint32_t samples = GPMF_Repeat(ms);/~/			if (!(flags & GPMF_SAMPLE_RATE_PRECISE) && GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))/~/				startsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream)) - samples;/~/				payload = GetPayload(handle, payload, testend); // second last payload/~/				if (ret != GPMF_OK)/~/					goto cleanup;/~/				if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))/~/					GPMF_CopyState(ms, &find_stream);/~/					if (GPMF_OK == GPMF_FindPrev(&find_stream, GPMF_KEY_TOTAL_SAMPLES, GPMF_CURRENT_LEVEL))/~/						endsamples = BYTESWAP32(*(uint32_t *)GPMF_RawData(&find_stream));/~/						rate = (double)(endsamples - startsamples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);/~/						goto cleanup;/~/				rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);/~/			else // for increased precision, for older GPMF streams sometimes missing the total sample count /~/				uint32_t payloadpos = 0, payloadcount = 0;/~/				double slope, top = 0.0, bot = 0.0, meanX = 0, meanY = 0;/~/				uint32_t *repeatarray = malloc(mp4->indexcount * 4 + 4);/~/				memset(repeatarray, 0, mp4->indexcount * 4 + 4);/~/				samples = 0;/~/				for (payloadpos = teststart; payloadpos < testend; payloadcount++, payloadpos++)/~/					payload = GetPayload(handle, payload, payloadpos); // second last payload/~/					payloadsize = GetPayloadSize(handle, payloadpos);/~/					ret = GPMF_Init(ms, payload, payloadsize);/~/					if (ret != GPMF_OK)/~/						goto cleanup;/~/					if (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_RECURSE_LEVELS))/~/						GPMF_stream find_stream2;/~/						GPMF_CopyState(ms, &find_stream2);/~/						if (GPMF_OK == GPMF_FindNext(&find_stream2, fourcc, GPMF_CURRENT_LEVEL)) // Count the instances, not the repeats/~/							if (repeatarray)/~/							{/~/								float in, out;/~/								do/~/									samples++;/~/								} while (GPMF_OK == GPMF_FindNext(ms, fourcc, GPMF_CURRENT_LEVEL));/~/								repeatarray[payloadpos] = samples;/~/								meanY += (double)samples;/~/								GetPayloadTime(handle, payloadpos, &in, &out);/~/								meanX += out;/~/							}/~/						}/~/						else/~/						{/~/							uint32_t repeat = GPMF_Repeat(ms);/~/							samples += repeat;/~/							if (repeatarray)/~/								float in, out;/~/								repeatarray[payloadpos] = samples;/~/								meanY += (double)samples;/~/								GetPayloadTime(handle, payloadpos, &in, &out);/~/								meanX += out;/~/				}/~/				// Compute the line of best fit for a jitter removed sample rate.  /~/				// This does assume an unchanging clock, even though the IMU data can thermally impacted causing small clock changes.  /~/				// TODO: Next enhancement would be a low order polynominal fit the compensate for any thermal clock drift./~/				if (repeatarray)/~/				{/~/					meanY /= (double)payloadcount;/~/					meanX /= (double)payloadcount;/~/					for (payloadpos = teststart; payloadpos < testend; payloadpos++)/~/						float in, out;/~/						GetPayloadTime(handle, payloadpos, &in, &out);/~/						top += ((double)out - meanX)*((double)repeatarray[payloadpos] - meanY);/~/						bot += ((double)out - meanX)*((double)out - meanX);/~/					}/~/					slope = top / bot;/~/					// This sample code might be useful for compare data latency between channels./~/						double intercept;/~/						intercept = meanY - slope*meanX;/~/						printf(""%c%c%c%c start offset = %f (%.3fms)\n"", PRINTF_4CC(fourcc), intercept, 1000.0 * intercept / slope);/~/#endif/~/					rate = slope;/~/				}/~/				else/~/				{/~/					rate = (double)(samples) / (mp4->metadatalength * ((double)(testend - teststart + 1)) / (double)mp4->indexcount);/~/				}/~/				free(repeatarray);/~/				goto cleanup;/~/		}/~/	}/~/cleanup:/~/	if (payload) /~/	{/~/		FreePayload(payload);/~/		payload = NULL;/~/	}/~/	return rate;/~/}"
160,"static int llc_ui_getname(struct socket *sock, struct sockaddr *uaddr,
int *uaddrlen, int peer)
{
struct sockaddr_llc sllc;
struct sock *sk = sock->sk;
struct llc_sock *llc = llc_sk(sk);
	int rc = 0;

memset(&sllc, 0, sizeof(sllc));
lock_sock(sk);
if (sock_flag(sk, SOCK_ZAPPED))
goto out;
*uaddrlen = sizeof(sllc);
	memset(uaddr, 0, *uaddrlen);
if (peer) {
rc = -ENOTCONN;
if (sk->sk_state != TCP_ESTABLISHED)
goto out;
if(llc->dev)
sllc.sllc_arphrd = llc->dev->type;
sllc.sllc_sap = llc->daddr.lsap;
memcpy(&sllc.sllc_mac, &llc->daddr.mac, IFHWADDRLEN);
} else {
rc = -EINVAL;
if (!llc->sap)
goto out;
sllc.sllc_sap = llc->sap->laddr.lsap;

if (llc->dev) {
sllc.sllc_arphrd = llc->dev->type;
memcpy(&sllc.sllc_mac, llc->dev->dev_addr,
IFHWADDRLEN);
}
}
rc = 0;
sllc.sllc_family = AF_LLC;
memcpy(uaddr, &sllc, sizeof(sllc));
out:
release_sock(sk);
return rc;
}
","[6, 12]","	int rc = 0;/~/	memset(uaddr, 0, *uaddrlen);"
161,"PasswordGenerationUIData GetTestGenerationUIData2() {
  PasswordForm form;
  form.form_data = autofill::FormData();
  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");
  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");
  PasswordGenerationUIData data;
  data.password_form = form;
  data.generation_element = ASCIIToUTF16(""testelement2"");
  data.max_length = 11;
  return data;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","  PasswordForm form;/~/  form.form_data = autofill::FormData();/~/  form.form_data.action = GURL(""http://www.example2.com/accounts/Login"");/~/  form.form_data.origin = GURL(""http://www.example2.com/accounts/LoginAuth"");/~/  PasswordGenerationUIData data;/~/  data.password_form = form;/~/  data.generation_element = ASCIIToUTF16(""testelement2"");/~/  data.max_length = 11;/~/  return data;/~/}"
162,"xmlStringLenDecodeEntities(xmlParserCtxtPtr ctxt, const xmlChar *str, int len,
int what, xmlChar end, xmlChar  end2, xmlChar end3) {
xmlChar *buffer = NULL;
int buffer_size = 0;

xmlChar *current = NULL;
xmlChar *rep = NULL;
const xmlChar *last;
xmlEntityPtr ent;
int c,l;
int nbchars = 0;

if ((ctxt == NULL) || (str == NULL) || (len < 0))
return(NULL);
last = str + len;

if (((ctxt->depth > 40) &&
((ctxt->options & XML_PARSE_HUGE) == 0)) ||
(ctxt->depth > 1024)) {
xmlFatalErr(ctxt, XML_ERR_ENTITY_LOOP, NULL);
return(NULL);
}

/*
* allocate a translation buffer.
*/
buffer_size = XML_PARSER_BIG_BUFFER_SIZE;
buffer = (xmlChar *) xmlMallocAtomic(buffer_size * sizeof(xmlChar));
if (buffer == NULL) goto mem_error;

/*
* OK loop until we reach one of the ending char or a size limit.
* we are operating on already parsed values.
*/
if (str < last)
c = CUR_SCHAR(str, l);
else
c = 0;
while ((c != 0) && (c != end) && /* non input consuming loop */
(c != end2) && (c != end3)) {

if (c == 0) break;
if ((c == '&') && (str[1] == '#')) {
int val = xmlParseStringCharRef(ctxt, &str);
if (val != 0) {
COPY_BUF(0,buffer,nbchars,val);
}
if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {
growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
}
} else if ((c == '&') && (what & XML_SUBSTITUTE_REF)) {
if (xmlParserDebugEntities)
xmlGenericError(xmlGenericErrorContext,
""String decoding Entity Reference: %.30s\n"",
str);
ent = xmlParseStringEntityRef(ctxt, &str);
if ((ctxt->lastError.code == XML_ERR_ENTITY_LOOP) ||
(ctxt->lastError.code == XML_ERR_INTERNAL_ERROR))
goto int_error;
if (ent != NULL)
ctxt->nbentities += ent->checked;
if ((ent != NULL) &&
(ent->etype == XML_INTERNAL_PREDEFINED_ENTITY)) {
if (ent->content != NULL) {
COPY_BUF(0,buffer,nbchars,ent->content[0]);
if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {
growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
}
} else {
xmlFatalErrMsg(ctxt, XML_ERR_INTERNAL_ERROR,
""predefined entity has no content\n"");
}
} else if ((ent != NULL) && (ent->content != NULL)) {
ctxt->depth++;
rep = xmlStringDecodeEntities(ctxt, ent->content, what,
0, 0, 0);
ctxt->depth--;

if (rep != NULL) {
current = rep;
while (*current != 0) { /* non input consuming loop */
buffer[nbchars++] = *current++;
if (nbchars >
buffer_size - XML_PARSER_BUFFER_SIZE) {
if (xmlParserEntityCheck(ctxt, nbchars, ent))
goto int_error;
growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
}
}
xmlFree(rep);
rep = NULL;
}
} else if (ent != NULL) {
int i = xmlStrlen(ent->name);
const xmlChar *cur = ent->name;

buffer[nbchars++] = '&';
if (nbchars > buffer_size - i - XML_PARSER_BUFFER_SIZE) {
		    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
}
for (;i > 0;i--)
buffer[nbchars++] = *cur++;
buffer[nbchars++] = ';';
}
} else if (c == '%' && (what & XML_SUBSTITUTE_PEREF)) {
if (xmlParserDebugEntities)
xmlGenericError(xmlGenericErrorContext,
""String decoding PE Reference: %.30s\n"", str);
ent = xmlParseStringPEReference(ctxt, &str);
if (ctxt->lastError.code == XML_ERR_ENTITY_LOOP)
goto int_error;
if (ent != NULL)
ctxt->nbentities += ent->checked;
if (ent != NULL) {
if (ent->content == NULL) {
xmlLoadEntityContent(ctxt, ent);
}
ctxt->depth++;
rep = xmlStringDecodeEntities(ctxt, ent->content, what,
0, 0, 0);
ctxt->depth--;
if (rep != NULL) {
current = rep;
while (*current != 0) { /* non input consuming loop */
buffer[nbchars++] = *current++;
if (nbchars >
buffer_size - XML_PARSER_BUFFER_SIZE) {
if (xmlParserEntityCheck(ctxt, nbchars, ent))
goto int_error;
growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
}
}
xmlFree(rep);
rep = NULL;
}
}
} else {
COPY_BUF(l,buffer,nbchars,c);
str += l;
if (nbchars > buffer_size - XML_PARSER_BUFFER_SIZE) {
growBuffer(buffer, XML_PARSER_BUFFER_SIZE);
}
}
if (str < last)
c = CUR_SCHAR(str, l);
else
c = 0;
}
buffer[nbchars] = 0;
return(buffer);

mem_error:
xmlErrMemory(ctxt, NULL);
int_error:
if (rep != NULL)
xmlFree(rep);
if (buffer != NULL)
xmlFree(buffer);
return(NULL);
}
",[42],"		    growBuffer(buffer, XML_PARSER_BUFFER_SIZE);"
163,"static unsigned int stack_maxrandom_size(void)
{
	unsigned int max = 0;
if ((current->flags & PF_RANDOMIZE) &&
!(current->personality & ADDR_NO_RANDOMIZE)) {
		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
}

return max;
}
","[2, 5]",	unsigned int max = 0;/~/		max = ((-1U) & STACK_RND_MASK) << PAGE_SHIFT;
164,"Compositor::Compositor(const viz::FrameSinkId& frame_sink_id,
ui::ContextFactory* context_factory,
ui::ContextFactoryPrivate* context_factory_private,
scoped_refptr<base::SingleThreadTaskRunner> task_runner,
bool enable_surface_synchronization,
bool enable_pixel_canvas,
bool external_begin_frames_enabled,
bool force_software_compositor,
const char* trace_environment_name)
: context_factory_(context_factory),
context_factory_private_(context_factory_private),
frame_sink_id_(frame_sink_id),
task_runner_(task_runner),
vsync_manager_(new CompositorVSyncManager()),
external_begin_frames_enabled_(external_begin_frames_enabled),
force_software_compositor_(force_software_compositor),
layer_animator_collection_(this),
is_pixel_canvas_(enable_pixel_canvas),
lock_manager_(task_runner),
trace_environment_name_(trace_environment_name
? trace_environment_name
: kDefaultTraceEnvironmentName),
context_creation_weak_ptr_factory_(this) {
if (context_factory_private) {
auto* host_frame_sink_manager =
context_factory_private_->GetHostFrameSinkManager();
host_frame_sink_manager->RegisterFrameSinkId(
        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kYes);
host_frame_sink_manager->SetFrameSinkDebugLabel(frame_sink_id_,
""Compositor"");
}
root_web_layer_ = cc::Layer::Create();

base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();

cc::LayerTreeSettings settings;

// This will ensure PictureLayers always can have LCD text, to match the
// previous behaviour with ContentLayers, where LCD-not-allowed notifications
// were ignored.
settings.layers_always_allowed_lcd_text = true;
// Use occlusion to allow more overlapping windows to take less memory.
settings.use_occlusion_for_tile_prioritization = true;
refresh_rate_ = context_factory_->GetRefreshRate();
settings.main_frame_before_activation_enabled = false;
settings.delegated_sync_points_required =
context_factory_->SyncTokensRequiredForDisplayCompositor();

// Disable edge anti-aliasing in order to increase support for HW overlays.
settings.enable_edge_anti_aliasing = false;

if (command_line->HasSwitch(switches::kLimitFps)) {
std::string fps_str =
command_line->GetSwitchValueASCII(switches::kLimitFps);
double fps;
if (base::StringToDouble(fps_str, &fps) && fps > 0) {
forced_refresh_rate_ = fps;
}
}

if (command_line->HasSwitch(cc::switches::kUIShowCompositedLayerBorders)) {
std::string layer_borders_string = command_line->GetSwitchValueASCII(
cc::switches::kUIShowCompositedLayerBorders);
std::vector<base::StringPiece> entries = base::SplitStringPiece(
layer_borders_string, "","", base::TRIM_WHITESPACE, base::SPLIT_WANT_ALL);
if (entries.empty()) {
settings.initial_debug_state.show_debug_borders.set();
} else {
for (const auto& entry : entries) {
const struct {
const char* name;
cc::DebugBorderType type;
} kBorders[] = {{cc::switches::kCompositedRenderPassBorders,
cc::DebugBorderType::RENDERPASS},
{cc::switches::kCompositedSurfaceBorders,
cc::DebugBorderType::SURFACE},
{cc::switches::kCompositedLayerBorders,
cc::DebugBorderType::LAYER}};
for (const auto& border : kBorders) {
if (border.name == entry) {
settings.initial_debug_state.show_debug_borders.set(border.type);
break;
}
}
}
}
}
settings.initial_debug_state.show_fps_counter =
command_line->HasSwitch(cc::switches::kUIShowFPSCounter);
settings.initial_debug_state.show_layer_animation_bounds_rects =
command_line->HasSwitch(cc::switches::kUIShowLayerAnimationBounds);
settings.initial_debug_state.show_paint_rects =
command_line->HasSwitch(switches::kUIShowPaintRects);
settings.initial_debug_state.show_property_changed_rects =
command_line->HasSwitch(cc::switches::kUIShowPropertyChangedRects);
settings.initial_debug_state.show_surface_damage_rects =
command_line->HasSwitch(cc::switches::kUIShowSurfaceDamageRects);
settings.initial_debug_state.show_screen_space_rects =
command_line->HasSwitch(cc::switches::kUIShowScreenSpaceRects);

settings.initial_debug_state.SetRecordRenderingStats(
command_line->HasSwitch(cc::switches::kEnableGpuBenchmarking));
settings.enable_surface_synchronization = enable_surface_synchronization;
settings.build_hit_test_data = features::IsVizHitTestingSurfaceLayerEnabled();

settings.use_zero_copy = IsUIZeroCopyEnabled();

settings.use_layer_lists =
command_line->HasSwitch(cc::switches::kUIEnableLayerLists);

// UI compositor always uses partial raster if not using zero-copy. Zero copy
// doesn't currently support partial raster.
settings.use_partial_raster = !settings.use_zero_copy;

settings.use_rgba_4444 =
command_line->HasSwitch(switches::kUIEnableRGBA4444Textures);

#if defined(OS_MACOSX)
// Using CoreAnimation to composite requires using GpuMemoryBuffers, which
// require zero copy.
settings.resource_settings.use_gpu_memory_buffer_resources =
settings.use_zero_copy;
settings.enable_elastic_overscroll = true;
#endif

settings.memory_policy.bytes_limit_when_visible = 512 * 1024 * 1024;
settings.memory_policy.priority_cutoff_when_visible =
gpu::MemoryAllocation::CUTOFF_ALLOW_NICE_TO_HAVE;

settings.disallow_non_exact_resource_reuse =
command_line->HasSwitch(switches::kDisallowNonExactResourceReuse);

if (command_line->HasSwitch(switches::kRunAllCompositorStagesBeforeDraw)) {
settings.wait_for_all_pipeline_stages_before_draw = true;
settings.enable_latency_recovery = false;
}

settings.always_request_presentation_time =
command_line->HasSwitch(cc::switches::kAlwaysRequestPresentationTime);

animation_host_ = cc::AnimationHost::CreateMainInstance();

cc::LayerTreeHost::InitParams params;
params.client = this;
params.task_graph_runner = context_factory_->GetTaskGraphRunner();
params.settings = &settings;
params.main_task_runner = task_runner_;
params.mutator_host = animation_host_.get();
host_ = cc::LayerTreeHost::CreateSingleThreaded(this, std::move(params));

if (base::FeatureList::IsEnabled(features::kUiCompositorScrollWithLayers) &&
host_->GetInputHandler()) {
scroll_input_handler_.reset(
new ScrollInputHandler(host_->GetInputHandler()));
}

animation_timeline_ =
cc::AnimationTimeline::Create(cc::AnimationIdProvider::NextTimelineId());
animation_host_->AddAnimationTimeline(animation_timeline_.get());

host_->SetHasGpuRasterizationTrigger(features::IsUiGpuRasterizationEnabled());
host_->SetRootLayer(root_web_layer_);
host_->SetVisible(true);

if (command_line->HasSwitch(switches::kUISlowAnimations)) {
slow_animations_ = std::make_unique<ScopedAnimationDurationScaleMode>(
ScopedAnimationDurationScaleMode::SLOW_DURATION);
}
}
",[27],"        frame_sink_id_, this, viz::ReportFirstSurfaceActivation::kYes);"
165,"InputImeEventRouter* GetInputImeEventRouter(Profile* profile) {
if (!profile)
return nullptr;
return extensions::InputImeEventRouterFactory::GetInstance()->GetRouter(
      profile->GetOriginalProfile());
}
",[4],      profile->GetOriginalProfile());
166,"static int usb_enumerate_device_otg(struct usb_device *udev)
{
int err = 0;

#ifdef	CONFIG_USB_OTG
/*
* OTG-aware devices on OTG-capable root hubs may be able to use SRP,
* to wake us after we've powered off VBUS; and HNP, switching roles
* ""host"" to ""peripheral"".  The OTG descriptor helps figure this out.
*/
if (!udev->bus->is_b_host
&& udev->config
&& udev->parent == udev->bus->root_hub) {
struct usb_otg_descriptor	*desc = NULL;
struct usb_bus			*bus = udev->bus;
unsigned			port1 = udev->portnum;

/* descriptor may appear anywhere in config */
err = __usb_get_extra_descriptor(udev->rawdescriptors[0],
le16_to_cpu(udev->config[0].desc.wTotalLength),
				USB_DT_OTG, (void **) &desc);
if (err || !(desc->bmAttributes & USB_OTG_HNP))
return 0;

dev_info(&udev->dev, ""Dual-Role OTG device on %sHNP port\n"",
(port1 == bus->otg_port) ? """" : ""non-"");

/* enable HNP before suspend, it's simpler */
if (port1 == bus->otg_port) {
bus->b_hnp_enable = 1;
err = usb_control_msg(udev,
usb_sndctrlpipe(udev, 0),
USB_REQ_SET_FEATURE, 0,
USB_DEVICE_B_HNP_ENABLE,
0, NULL, 0,
USB_CTRL_SET_TIMEOUT);
if (err < 0) {
/*
* OTG MESSAGE: report errors here,
* customize to match your product.
*/
dev_err(&udev->dev, ""can't set HNP mode: %d\n"",
err);
bus->b_hnp_enable = 0;
}
} else if (desc->bLength == sizeof
(struct usb_otg_descriptor)) {
/* Set a_alt_hnp_support for legacy otg device */
err = usb_control_msg(udev,
usb_sndctrlpipe(udev, 0),
USB_REQ_SET_FEATURE, 0,
USB_DEVICE_A_ALT_HNP_SUPPORT,
0, NULL, 0,
USB_CTRL_SET_TIMEOUT);
if (err < 0)
dev_err(&udev->dev,
""set a_alt_hnp_support failed: %d\n"",
err);
}
}
#endif
return err;
}
",[22],"				USB_DT_OTG, (void **) &desc);"
167,"static int omninet_open(struct tty_struct *tty, struct usb_serial_port *port)
{
	struct usb_serial	*serial = port->serial;
	struct usb_serial_port	*wport;
	wport = serial->port[1];
	tty_port_tty_set(&wport->port, tty);
return usb_serial_generic_open(tty, port);
}
","[6, 7]","	struct usb_serial	*serial = port->serial;/~/	struct usb_serial_port	*wport;/~/	wport = serial->port[1];/~/	tty_port_tty_set(&wport->port, tty);"
168,"void CreateOAuth2ServiceDelegate(
signin::AccountConsistencyMethod account_consistency) {
    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(
client_.get(), &signin_error_controller_, &account_tracker_service_,
token_web_data_, account_consistency, revoke_all_tokens_on_load_,
        true /* can_revoke_credantials */));
    // Make sure PO2TS has a chance to load itself before continuing.
base::RunLoop().RunUntilIdle();
oauth2_service_delegate_->AddObserver(this);
}
","[2, 5, 6]",    oauth2_service_delegate_.reset(new MutableProfileOAuth2TokenServiceDelegate(/~/        true /* can_revoke_credantials */));/~/    // Make sure PO2TS has a chance to load itself before continuing.
169,"void* sspi_SecureHandleGetLowerPointer(SecHandle* handle)
{
void* pointer;

	if (!handle)
return NULL;

pointer = (void*) ~((size_t) handle->dwLower);

return pointer;
}
",[3],	if (!handle)
170,"void UkmPageLoadMetricsObserver::RecordTimingMetrics(
const page_load_metrics::mojom::PageLoadTiming& timing,
const page_load_metrics::PageLoadExtraInfo& info) {
ukm::builders::PageLoad builder(info.source_id);
  bool is_user_initiated_navigation =
      // All browser initiated page loads are user-initiated.
      info.user_initiated_info.browser_initiated ||
      // Renderer-initiated navigations are user-initiated if there is an
      // associated input timestamp.
      timing.input_to_navigation_start;
  builder.SetExperimental_Navigation_UserInitiated(
      is_user_initiated_navigation);
if (timing.input_to_navigation_start) {
builder.SetExperimental_InputToNavigationStart(
timing.input_to_navigation_start.value().InMilliseconds());
}
if (timing.parse_timing->parse_start) {
builder.SetParseTiming_NavigationToParseStart(
timing.parse_timing->parse_start.value().InMilliseconds());
}
if (timing.document_timing->dom_content_loaded_event_start) {
builder.SetDocumentTiming_NavigationToDOMContentLoadedEventFired(
timing.document_timing->dom_content_loaded_event_start.value()
.InMilliseconds());
}
if (timing.document_timing->load_event_start) {
builder.SetDocumentTiming_NavigationToLoadEventFired(
timing.document_timing->load_event_start.value().InMilliseconds());
}
if (timing.paint_timing->first_paint) {
builder.SetPaintTiming_NavigationToFirstPaint(
timing.paint_timing->first_paint.value().InMilliseconds());
}
if (timing.paint_timing->first_contentful_paint) {
builder.SetPaintTiming_NavigationToFirstContentfulPaint(
timing.paint_timing->first_contentful_paint.value().InMilliseconds());
}
if (timing.paint_timing->first_meaningful_paint) {
builder.SetExperimental_PaintTiming_NavigationToFirstMeaningfulPaint(
timing.paint_timing->first_meaningful_paint.value().InMilliseconds());
}
if (timing.paint_timing->largest_image_paint.has_value() &&
WasStartedInForegroundOptionalEventInForeground(
timing.paint_timing->largest_image_paint, info)) {
builder.SetExperimental_PaintTiming_NavigationToLargestImagePaint(
timing.paint_timing->largest_image_paint.value().InMilliseconds());
}
if (timing.paint_timing->last_image_paint.has_value() &&
WasStartedInForegroundOptionalEventInForeground(
timing.paint_timing->last_image_paint, info)) {
builder.SetExperimental_PaintTiming_NavigationToLastImagePaint(
timing.paint_timing->last_image_paint.value().InMilliseconds());
}
if (timing.paint_timing->largest_text_paint.has_value() &&
WasStartedInForegroundOptionalEventInForeground(
timing.paint_timing->largest_text_paint, info)) {
builder.SetExperimental_PaintTiming_NavigationToLargestTextPaint(
timing.paint_timing->largest_text_paint.value().InMilliseconds());
}
if (timing.paint_timing->last_text_paint.has_value() &&
WasStartedInForegroundOptionalEventInForeground(
timing.paint_timing->last_text_paint, info)) {
builder.SetExperimental_PaintTiming_NavigationToLastTextPaint(
timing.paint_timing->last_text_paint.value().InMilliseconds());
}
base::Optional<base::TimeDelta> largest_content_paint_time;
uint64_t largest_content_paint_size;
AssignTimeAndSizeForLargestContentfulPaint(largest_content_paint_time,
largest_content_paint_size,
timing.paint_timing);
if (largest_content_paint_size > 0 &&
WasStartedInForegroundOptionalEventInForeground(
largest_content_paint_time, info)) {
builder.SetExperimental_PaintTiming_NavigationToLargestContentPaint(
largest_content_paint_time.value().InMilliseconds());
}
if (timing.interactive_timing->interactive) {
base::TimeDelta time_to_interactive =
timing.interactive_timing->interactive.value();
if (!timing.interactive_timing->first_invalidating_input ||
timing.interactive_timing->first_invalidating_input.value() >
time_to_interactive) {
builder.SetExperimental_NavigationToInteractive(
time_to_interactive.InMilliseconds());
}
}
if (timing.interactive_timing->first_input_delay) {
base::TimeDelta first_input_delay =
timing.interactive_timing->first_input_delay.value();
builder.SetInteractiveTiming_FirstInputDelay2(
first_input_delay.InMilliseconds());
}
if (timing.interactive_timing->first_input_timestamp) {
base::TimeDelta first_input_timestamp =
timing.interactive_timing->first_input_timestamp.value();
builder.SetInteractiveTiming_FirstInputTimestamp2(
first_input_timestamp.InMilliseconds());
}

if (timing.interactive_timing->longest_input_delay) {
base::TimeDelta longest_input_delay =
timing.interactive_timing->longest_input_delay.value();
builder.SetInteractiveTiming_LongestInputDelay2(
longest_input_delay.InMilliseconds());
}
if (timing.interactive_timing->longest_input_timestamp) {
base::TimeDelta longest_input_timestamp =
timing.interactive_timing->longest_input_timestamp.value();
builder.SetInteractiveTiming_LongestInputTimestamp2(
longest_input_timestamp.InMilliseconds());
}

// Use a bucket spacing factor of 1.3 for bytes.
builder.SetNet_CacheBytes(ukm::GetExponentialBucketMin(cache_bytes_, 1.3));
builder.SetNet_NetworkBytes(
ukm::GetExponentialBucketMin(network_bytes_, 1.3));

if (main_frame_timing_)
ReportMainResourceTimingMetrics(timing, &builder);

builder.Record(ukm::UkmRecorder::Get());
}
","[4, 5, 6, 7, 8, 9, 10, 11]",  bool is_user_initiated_navigation =/~/      // All browser initiated page loads are user-initiated./~/      info.user_initiated_info.browser_initiated ||/~/      // Renderer-initiated navigations are user-initiated if there is an/~/      // associated input timestamp./~/      timing.input_to_navigation_start;/~/  builder.SetExperimental_Navigation_UserInitiated(/~/      is_user_initiated_navigation);
171,"u32 secure_ipv4_port_ephemeral(__be32 saddr, __be32 daddr, __be16 dport)
{
	struct keydata *keyptr = get_keyptr();
	u32 hash[4];
	/*
	 *  Pick a unique starting offset for each ephemeral port search
	 *  (saddr, daddr, dport) and 48bits of random data.
	 *
	hash[0] = (__force u32)saddr;
	hash[1] = (__force u32)daddr;
	hash[2] = (__force u32)dport ^ keyptr->secret[10];
	hash[3] = keyptr->secret[11];
	return half_md4_transform(hash, keyptr->secret);
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]","{/~/	struct keydata *keyptr = get_keyptr();/~/	u32 hash[4];/~/	/*/~/	 *  Pick a unique starting offset for each ephemeral port search/~/	 *  (saddr, daddr, dport) and 48bits of random data./~/	 */~/	hash[0] = (__force u32)saddr;/~/	hash[1] = (__force u32)daddr;/~/	hash[2] = (__force u32)dport ^ keyptr->secret[10];/~/	hash[3] = keyptr->secret[11];/~/	return half_md4_transform(hash, keyptr->secret);/~/}"
172,"static boolean parse_identifier( const char **pcur, char *ret )
{
const char *cur = *pcur;
int i = 0;
if (is_alpha_underscore( cur )) {
ret[i++] = *cur++;
      while (is_alpha_underscore( cur ) || is_digit( cur ))
ret[i++] = *cur++;
ret[i++] = '\0';
*pcur = cur;
return TRUE;

/* Parse floating point.
*/
static boolean parse_float( const char **pcur, float *val )
{
const char *cur = *pcur;
boolean integral_part = FALSE;
boolean fractional_part = FALSE;

if (*cur == '0' && *(cur + 1) == 'x') {
union fi fi;
fi.ui = strtoul(cur, NULL, 16);
*val = fi.f;
cur += 10;
goto out;
}

*val = (float) atof( cur );
if (*cur == '-' || *cur == '+')
cur++;
if (is_digit( cur )) {
cur++;
integral_part = TRUE;
while (is_digit( cur ))
cur++;
}
if (*cur == '.') {
cur++;
if (is_digit( cur )) {
cur++;
fractional_part = TRUE;
while (is_digit( cur ))
cur++;
}
}
if (!integral_part && !fractional_part)
return FALSE;
if (uprcase( *cur ) == 'E') {
cur++;
if (*cur == '-' || *cur == '+')
cur++;
if (is_digit( cur )) {
cur++;
while (is_digit( cur ))
cur++;
}
else
return FALSE;
}

out:
*pcur = cur;
return TRUE;
}

static boolean parse_double( const char **pcur, uint32_t *val0, uint32_t *val1)
{
const char *cur = *pcur;
union {
double dval;
uint32_t uval[2];
} v;

v.dval = strtod(cur, (char**)pcur);
if (*pcur == cur)
return FALSE;

*val0 = v.uval[0];
*val1 = v.uval[1];

return TRUE;
}

struct translate_ctx
{
const char *text;
const char *cur;
struct tgsi_token *tokens;
struct tgsi_token *tokens_cur;
struct tgsi_token *tokens_end;
struct tgsi_header *header;
unsigned processor : 4;
unsigned implied_array_size : 6;
unsigned num_immediates;
};

static void report_error(struct translate_ctx *ctx, const char *format, ...)
{
va_list args;
int line = 1;
int column = 1;
const char *itr = ctx->text;

debug_printf(""\nTGSI asm error: "");

va_start(args, format);
_debug_vprintf(format, args);
va_end(args);

while (itr != ctx->cur) {
if (*itr == '\n') {
column = 1;
++line;
}
++column;
++itr;
}

debug_printf("" [%d : %d] \n"", line, column);
}

/* Parse shader header.
* Return TRUE for one of the following headers.
*    FRAG
*    GEOM
*    VERT
*/
static boolean parse_header( struct translate_ctx *ctx )
{
uint processor;

if (str_match_nocase_whole( &ctx->cur, ""FRAG"" ))
processor = TGSI_PROCESSOR_FRAGMENT;
else if (str_match_nocase_whole( &ctx->cur, ""VERT"" ))
processor = TGSI_PROCESSOR_VERTEX;
else if (str_match_nocase_whole( &ctx->cur, ""GEOM"" ))
processor = TGSI_PROCESSOR_GEOMETRY;
else if (str_match_nocase_whole( &ctx->cur, ""TESS_CTRL"" ))
processor = TGSI_PROCESSOR_TESS_CTRL;
else if (str_match_nocase_whole( &ctx->cur, ""TESS_EVAL"" ))
processor = TGSI_PROCESSOR_TESS_EVAL;
else if (str_match_nocase_whole( &ctx->cur, ""COMP"" ))
processor = TGSI_PROCESSOR_COMPUTE;
else {
report_error( ctx, ""Unknown header"" );
return FALSE;
}

if (ctx->tokens_cur >= ctx->tokens_end)
return FALSE;
ctx->header = (struct tgsi_header *) ctx->tokens_cur++;
*ctx->header = tgsi_build_header();

if (ctx->tokens_cur >= ctx->tokens_end)
return FALSE;
*(struct tgsi_processor *) ctx->tokens_cur++ = tgsi_build_processor( processor, ctx->header );
ctx->processor = processor;

return TRUE;
}

static boolean parse_label( struct translate_ctx *ctx, uint *val )
{
const char *cur = ctx->cur;

if (parse_uint( &cur, val )) {
eat_opt_white( &cur );
if (*cur == ':') {
cur++;
ctx->cur = cur;
return TRUE;
}
}
return FALSE;
}

static boolean
parse_file( const char **pcur, uint *file )
{
uint i;

for (i = 0; i < TGSI_FILE_COUNT; i++) {
const char *cur = *pcur;

if (str_match_nocase_whole( &cur, tgsi_file_name(i) )) {
*pcur = cur;
*file = i;
return TRUE;
}
}
return FALSE;
}

static boolean
parse_opt_writemask(
struct translate_ctx *ctx,
uint *writemask )
{
const char *cur;

cur = ctx->cur;
eat_opt_white( &cur );
if (*cur == '.') {
cur++;
*writemask = TGSI_WRITEMASK_NONE;
eat_opt_white( &cur );
if (uprcase( *cur ) == 'X') {
cur++;
*writemask |= TGSI_WRITEMASK_X;
}
if (uprcase( *cur ) == 'Y') {
cur++;
*writemask |= TGSI_WRITEMASK_Y;
}
if (uprcase( *cur ) == 'Z') {
cur++;
*writemask |= TGSI_WRITEMASK_Z;
}
if (uprcase( *cur ) == 'W') {
cur++;
*writemask |= TGSI_WRITEMASK_W;
}

if (*writemask == TGSI_WRITEMASK_NONE) {
report_error( ctx, ""Writemask expected"" );
return FALSE;
}

ctx->cur = cur;
}
else {
*writemask = TGSI_WRITEMASK_XYZW;
}
return TRUE;
}


/* <register_file_bracket> ::= <file> `['
*/
static boolean
parse_register_file_bracket(
struct translate_ctx *ctx,
uint *file )
{
if (!parse_file( &ctx->cur, file )) {
report_error( ctx, ""Unknown register file"" );
return FALSE;
}
eat_opt_white( &ctx->cur );
if (*ctx->cur != '[') {
report_error( ctx, ""Expected `['"" );
return FALSE;
}
ctx->cur++;
return TRUE;
}

/* <register_file_bracket_index> ::= <register_file_bracket> <uint>
*/
static boolean
parse_register_file_bracket_index(
struct translate_ctx *ctx,
uint *file,
int *index )
{
uint uindex;

if (!parse_register_file_bracket( ctx, file ))
return FALSE;
eat_opt_white( &ctx->cur );
if (!parse_uint( &ctx->cur, &uindex )) {
report_error( ctx, ""Expected literal unsigned integer"" );
return FALSE;
}
*index = (int) uindex;
return TRUE;
}

/* Parse simple 1d register operand.
*    <register_dst> ::= <register_file_bracket_index> `]'
*/
static boolean
parse_register_1d(struct translate_ctx *ctx,
uint *file,
int *index )
{
if (!parse_register_file_bracket_index( ctx, file, index ))
return FALSE;
eat_opt_white( &ctx->cur );
if (*ctx->cur != ']') {
report_error( ctx, ""Expected `]'"" );
return FALSE;
}
ctx->cur++;
return TRUE;
}

struct parsed_bracket {
int index;

uint ind_file;
int ind_index;
uint ind_comp;
uint ind_array;
};


static boolean
parse_register_bracket(
struct translate_ctx *ctx,
struct parsed_bracket *brackets)
{
const char *cur;
uint uindex;

memset(brackets, 0, sizeof(struct parsed_bracket));

eat_opt_white( &ctx->cur );

cur = ctx->cur;
if (parse_file( &cur, &brackets->ind_file )) {
if (!parse_register_1d( ctx, &brackets->ind_file,
&brackets->ind_index ))
return FALSE;
eat_opt_white( &ctx->cur );

if (*ctx->cur == '.') {
ctx->cur++;
eat_opt_white(&ctx->cur);

switch (uprcase(*ctx->cur)) {
case 'X':
brackets->ind_comp = TGSI_SWIZZLE_X;
break;
case 'Y':
brackets->ind_comp = TGSI_SWIZZLE_Y;
break;
case 'Z':
brackets->ind_comp = TGSI_SWIZZLE_Z;
break;
case 'W':
brackets->ind_comp = TGSI_SWIZZLE_W;
break;
default:
report_error(ctx, ""Expected indirect register swizzle component `x', `y', `z' or `w'"");
return FALSE;
}
ctx->cur++;
eat_opt_white(&ctx->cur);
}

if (*ctx->cur == '+' || *ctx->cur == '-')
parse_int( &ctx->cur, &brackets->index );
else
brackets->index = 0;
}
else {
if (!parse_uint( &ctx->cur, &uindex )) {
report_error( ctx, ""Expected literal unsigned integer"" );
return FALSE;
}
brackets->index = (int) uindex;
brackets->ind_file = TGSI_FILE_NULL;
brackets->ind_index = 0;
}
eat_opt_white( &ctx->cur );
if (*ctx->cur != ']') {
report_error( ctx, ""Expected `]'"" );
return FALSE;
}
ctx->cur++;
if (*ctx->cur == '(') {
ctx->cur++;
eat_opt_white( &ctx->cur );
if (!parse_uint( &ctx->cur, &brackets->ind_array )) {
report_error( ctx, ""Expected literal unsigned integer"" );
return FALSE;
}
eat_opt_white( &ctx->cur );
if (*ctx->cur != ')') {
report_error( ctx, ""Expected `)'"" );
return FALSE;
}
ctx->cur++;
}
return TRUE;
}

static boolean
parse_opt_register_src_bracket(
struct translate_ctx *ctx,
struct parsed_bracket *brackets,
int *parsed_brackets)
{
const char *cur = ctx->cur;

*parsed_brackets = 0;

eat_opt_white( &cur );
if (cur[0] == '[') {
++cur;
ctx->cur = cur;

if (!parse_register_bracket(ctx, brackets))
return FALSE;

*parsed_brackets = 1;
}

return TRUE;
}


/* Parse source register operand.
*    <register_src> ::= <register_file_bracket_index> `]' |
*                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `]' |
*                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `+' <uint> `]' |
*                       <register_file_bracket> <register_dst> [`.' (`x' | `y' | `z' | `w')] `-' <uint> `]'
*/
static boolean
parse_register_src(
struct translate_ctx *ctx,
uint *file,
struct parsed_bracket *brackets)
{
brackets->ind_comp = TGSI_SWIZZLE_X;
if (!parse_register_file_bracket( ctx, file ))
return FALSE;
if (!parse_register_bracket( ctx, brackets ))
return FALSE;

return TRUE;
}

struct parsed_dcl_bracket {
uint first;
uint last;
};

static boolean
parse_register_dcl_bracket(
struct translate_ctx *ctx,
struct parsed_dcl_bracket *bracket)
{
uint uindex;
memset(bracket, 0, sizeof(struct parsed_dcl_bracket));

eat_opt_white( &ctx->cur );

if (!parse_uint( &ctx->cur, &uindex )) {
/* it can be an empty bracket [] which means its range
* is from 0 to some implied size */
if (ctx->cur[0] == ']' && ctx->implied_array_size != 0) {
bracket->first = 0;
bracket->last = ctx->implied_array_size - 1;
goto cleanup;
}
report_error( ctx, ""Expected literal unsigned integer"" );
return FALSE;
}
bracket->first = uindex;

eat_opt_white( &ctx->cur );

if (ctx->cur[0] == '.' && ctx->cur[1] == '.') {
uint uindex;

ctx->cur += 2;
eat_opt_white( &ctx->cur );
if (!parse_uint( &ctx->cur, &uindex )) {
report_error( ctx, ""Expected literal integer"" );
return FALSE;
}
bracket->last = (int) uindex;
eat_opt_white( &ctx->cur );
}
else {
bracket->last = bracket->first;
}

cleanup:
if (*ctx->cur != ']') {
report_error( ctx, ""Expected `]' or `..'"" );
return FALSE;
}
ctx->cur++;
return TRUE;
}

/* Parse register declaration.
*    <register_dcl> ::= <register_file_bracket_index> `]' |
*                       <register_file_bracket_index> `..' <index> `]'
*/
static boolean
parse_register_dcl(
struct translate_ctx *ctx,
uint *file,
struct parsed_dcl_bracket *brackets,
int *num_brackets)
{
const char *cur;

*num_brackets = 0;

if (!parse_register_file_bracket( ctx, file ))
return FALSE;
if (!parse_register_dcl_bracket( ctx, &brackets[0] ))
return FALSE;

*num_brackets = 1;

cur = ctx->cur;
eat_opt_white( &cur );

if (cur[0] == '[') {
bool is_in = *file == TGSI_FILE_INPUT;
bool is_out = *file == TGSI_FILE_OUTPUT;

++cur;
ctx->cur = cur;
if (!parse_register_dcl_bracket( ctx, &brackets[1] ))
return FALSE;
/* for geometry shader we don't really care about
* the first brackets it's always the size of the
* input primitive. so we want to declare just
* the index relevant to the semantics which is in
* the second bracket */

/* tessellation has similar constraints to geometry shader */
if ((ctx->processor == TGSI_PROCESSOR_GEOMETRY && is_in) ||
(ctx->processor == TGSI_PROCESSOR_TESS_EVAL && is_in) ||
(ctx->processor == TGSI_PROCESSOR_TESS_CTRL && (is_in || is_out))) {
brackets[0] = brackets[1];
*num_brackets = 1;
} else {
*num_brackets = 2;
}
}

return TRUE;
}


/* Parse destination register operand.*/
static boolean
parse_register_dst(
struct translate_ctx *ctx,
uint *file,
struct parsed_bracket *brackets)
{
brackets->ind_comp = TGSI_SWIZZLE_X;
if (!parse_register_file_bracket( ctx, file ))
return FALSE;
if (!parse_register_bracket( ctx, brackets ))
return FALSE;

return TRUE;
}

static boolean
parse_dst_operand(
struct translate_ctx *ctx,
struct tgsi_full_dst_register *dst )
{
uint file;
uint writemask;
const char *cur;
struct parsed_bracket bracket[2];
int parsed_opt_brackets;

if (!parse_register_dst( ctx, &file, &bracket[0] ))
return FALSE;
if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))
return FALSE;

cur = ctx->cur;
eat_opt_white( &cur );

if (!parse_opt_writemask( ctx, &writemask ))
return FALSE;

dst->Register.File = file;
if (parsed_opt_brackets) {
dst->Register.Dimension = 1;
dst->Dimension.Indirect = 0;
dst->Dimension.Dimension = 0;
dst->Dimension.Index = bracket[0].index;

if (bracket[0].ind_file != TGSI_FILE_NULL) {
dst->Dimension.Indirect = 1;
dst->DimIndirect.File = bracket[0].ind_file;
dst->DimIndirect.Index = bracket[0].ind_index;
dst->DimIndirect.Swizzle = bracket[0].ind_comp;
dst->DimIndirect.ArrayID = bracket[0].ind_array;
}
bracket[0] = bracket[1];
}
dst->Register.Index = bracket[0].index;
dst->Register.WriteMask = writemask;
if (bracket[0].ind_file != TGSI_FILE_NULL) {
dst->Register.Indirect = 1;
dst->Indirect.File = bracket[0].ind_file;
dst->Indirect.Index = bracket[0].ind_index;
dst->Indirect.Swizzle = bracket[0].ind_comp;
dst->Indirect.ArrayID = bracket[0].ind_array;
}
return TRUE;
}

static boolean
parse_optional_swizzle(
struct translate_ctx *ctx,
uint *swizzle,
boolean *parsed_swizzle,
int components)
{
const char *cur = ctx->cur;

*parsed_swizzle = FALSE;

eat_opt_white( &cur );
if (*cur == '.') {
uint i;

cur++;
eat_opt_white( &cur );
for (i = 0; i < components; i++) {
if (uprcase( *cur ) == 'X')
swizzle[i] = TGSI_SWIZZLE_X;
else if (uprcase( *cur ) == 'Y')
swizzle[i] = TGSI_SWIZZLE_Y;
else if (uprcase( *cur ) == 'Z')
swizzle[i] = TGSI_SWIZZLE_Z;
else if (uprcase( *cur ) == 'W')
swizzle[i] = TGSI_SWIZZLE_W;
else {
report_error( ctx, ""Expected register swizzle component `x', `y', `z' or `w'"" );
return FALSE;
}
cur++;
}
*parsed_swizzle = TRUE;
ctx->cur = cur;
}
return TRUE;
}

static boolean
parse_src_operand(
struct translate_ctx *ctx,
struct tgsi_full_src_register *src )
{
uint file;
uint swizzle[4];
boolean parsed_swizzle;
struct parsed_bracket bracket[2];
int parsed_opt_brackets;

if (*ctx->cur == '-') {
ctx->cur++;
eat_opt_white( &ctx->cur );
src->Register.Negate = 1;
}

if (*ctx->cur == '|') {
ctx->cur++;
eat_opt_white( &ctx->cur );
src->Register.Absolute = 1;
}

if (!parse_register_src(ctx, &file, &bracket[0]))
return FALSE;
if (!parse_opt_register_src_bracket(ctx, &bracket[1], &parsed_opt_brackets))
return FALSE;

src->Register.File = file;
if (parsed_opt_brackets) {
src->Register.Dimension = 1;
src->Dimension.Indirect = 0;
src->Dimension.Dimension = 0;
src->Dimension.Index = bracket[0].index;
if (bracket[0].ind_file != TGSI_FILE_NULL) {
src->Dimension.Indirect = 1;
src->DimIndirect.File = bracket[0].ind_file;
src->DimIndirect.Index = bracket[0].ind_index;
src->DimIndirect.Swizzle = bracket[0].ind_comp;
src->DimIndirect.ArrayID = bracket[0].ind_array;
}
bracket[0] = bracket[1];
}
src->Register.Index = bracket[0].index;
if (bracket[0].ind_file != TGSI_FILE_NULL) {
src->Register.Indirect = 1;
src->Indirect.File = bracket[0].ind_file;
src->Indirect.Index = bracket[0].ind_index;
src->Indirect.Swizzle = bracket[0].ind_comp;
src->Indirect.ArrayID = bracket[0].ind_array;
}

/* Parse optional swizzle.
*/
if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {
if (parsed_swizzle) {
src->Register.SwizzleX = swizzle[0];
src->Register.SwizzleY = swizzle[1];
src->Register.SwizzleZ = swizzle[2];
src->Register.SwizzleW = swizzle[3];
}
}

if (src->Register.Absolute) {
eat_opt_white( &ctx->cur );
if (*ctx->cur != '|') {
report_error( ctx, ""Expected `|'"" );
return FALSE;
}
ctx->cur++;
}


return TRUE;
}

static boolean
parse_texoffset_operand(
struct translate_ctx *ctx,
struct tgsi_texture_offset *src )
{
uint file;
uint swizzle[3];
boolean parsed_swizzle;
struct parsed_bracket bracket;

if (!parse_register_src(ctx, &file, &bracket))
return FALSE;

src->File = file;
src->Index = bracket.index;

/* Parse optional swizzle.
*/
if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 3 )) {
if (parsed_swizzle) {
src->SwizzleX = swizzle[0];
src->SwizzleY = swizzle[1];
src->SwizzleZ = swizzle[2];
}
}

return TRUE;
}

static boolean
match_inst(const char **pcur,
unsigned *saturate,
const struct tgsi_opcode_info *info)
{
const char *cur = *pcur;

/* simple case: the whole string matches the instruction name */
if (str_match_nocase_whole(&cur, info->mnemonic)) {
*pcur = cur;
*saturate = 0;
return TRUE;
}

if (str_match_no_case(&cur, info->mnemonic)) {
/* the instruction has a suffix, figure it out */
if (str_match_nocase_whole(&cur, ""_SAT"")) {
*pcur = cur;
*saturate = 1;
return TRUE;
}
}

return FALSE;
}

static boolean
parse_instruction(
struct translate_ctx *ctx,
boolean has_label )
{
uint i;
uint saturate = 0;
const struct tgsi_opcode_info *info;
struct tgsi_full_instruction inst;
const char *cur;
uint advance;

inst = tgsi_default_full_instruction();

/* Parse predicate.
*/
eat_opt_white( &ctx->cur );
if (*ctx->cur == '(') {
uint file;
int index;
uint swizzle[4];
boolean parsed_swizzle;

inst.Instruction.Predicate = 1;

ctx->cur++;
if (*ctx->cur == '!') {
ctx->cur++;
inst.Predicate.Negate = 1;
}

if (!parse_register_1d( ctx, &file, &index ))
return FALSE;

if (parse_optional_swizzle( ctx, swizzle, &parsed_swizzle, 4 )) {
if (parsed_swizzle) {
inst.Predicate.SwizzleX = swizzle[0];
inst.Predicate.SwizzleY = swizzle[1];
inst.Predicate.SwizzleZ = swizzle[2];
inst.Predicate.SwizzleW = swizzle[3];
}
}

if (*ctx->cur != ')') {
report_error( ctx, ""Expected `)'"" );
return FALSE;
}

ctx->cur++;
}

/* Parse instruction name.
*/
eat_opt_white( &ctx->cur );
for (i = 0; i < TGSI_OPCODE_LAST; i++) {
cur = ctx->cur;

info = tgsi_get_opcode_info( i );
if (match_inst(&cur, &saturate, info)) {
if (info->num_dst + info->num_src + info->is_tex == 0) {
ctx->cur = cur;
break;
}
else if (*cur == '\0' || eat_white( &cur )) {
ctx->cur = cur;
break;
}
}
}
if (i == TGSI_OPCODE_LAST) {
if (has_label)
report_error( ctx, ""Unknown opcode"" );
else
report_error( ctx, ""Expected `DCL', `IMM' or a label"" );
return FALSE;
}

inst.Instruction.Opcode = i;
inst.Instruction.Saturate = saturate;
inst.Instruction.NumDstRegs = info->num_dst;
inst.Instruction.NumSrcRegs = info->num_src;

if (i >= TGSI_OPCODE_SAMPLE && i <= TGSI_OPCODE_GATHER4) {
/*
* These are not considered tex opcodes here (no additional
* target argument) however we're required to set the Texture
* bit so we can set the number of tex offsets.
*/
inst.Instruction.Texture = 1;
inst.Texture.Texture = TGSI_TEXTURE_UNKNOWN;
}

/* Parse instruction operands.
*/
for (i = 0; i < info->num_dst + info->num_src + info->is_tex; i++) {
if (i > 0) {
eat_opt_white( &ctx->cur );
if (*ctx->cur != ',') {
report_error( ctx, ""Expected `,'"" );
return FALSE;
}
ctx->cur++;
eat_opt_white( &ctx->cur );
}

if (i < info->num_dst) {
if (!parse_dst_operand( ctx, &inst.Dst[i] ))
return FALSE;
}
else if (i < info->num_dst + info->num_src) {
if (!parse_src_operand( ctx, &inst.Src[i - info->num_dst] ))
return FALSE;
}
else {
uint j;

for (j = 0; j < TGSI_TEXTURE_COUNT; j++) {
if (str_match_nocase_whole( &ctx->cur, tgsi_texture_names[j] )) {
inst.Instruction.Texture = 1;
inst.Texture.Texture = j;
break;
}
}
if (j == TGSI_TEXTURE_COUNT) {
report_error( ctx, ""Expected texture target"" );
return FALSE;
}
}
}

cur = ctx->cur;
eat_opt_white( &cur );
for (i = 0; inst.Instruction.Texture && *cur == ','; i++) {
cur++;
eat_opt_white( &cur );
ctx->cur = cur;
if (!parse_texoffset_operand( ctx, &inst.TexOffsets[i] ))
return FALSE;
cur = ctx->cur;
eat_opt_white( &cur );
}
inst.Texture.NumOffsets = i;

cur = ctx->cur;
eat_opt_white( &cur );
if (info->is_branch && *cur == ':') {
uint target;

cur++;
eat_opt_white( &cur );
if (!parse_uint( &cur, &target )) {
report_error( ctx, ""Expected a label"" );
return FALSE;
}
inst.Instruction.Label = 1;
inst.Label.Label = target;
ctx->cur = cur;
}

advance = tgsi_build_full_instruction(
&inst,
ctx->tokens_cur,
ctx->header,
(uint) (ctx->tokens_end - ctx->tokens_cur) );
if (advance == 0)
return FALSE;
ctx->tokens_cur += advance;

return TRUE;
}

/* parses a 4-touple of the form {x, y, z, w}
* where x, y, z, w are numbers */
static boolean parse_immediate_data(struct translate_ctx *ctx, unsigned type,
union tgsi_immediate_data *values)
{
unsigned i;
int ret;

eat_opt_white( &ctx->cur );
if (*ctx->cur != '{') {
report_error( ctx, ""Expected `{'"" );
return FALSE;
}
ctx->cur++;
for (i = 0; i < 4; i++) {
eat_opt_white( &ctx->cur );
if (i > 0) {
if (*ctx->cur != ',') {
report_error( ctx, ""Expected `,'"" );
return FALSE;
}
ctx->cur++;
eat_opt_white( &ctx->cur );
}

switch (type) {
case TGSI_IMM_FLOAT64:
ret = parse_double(&ctx->cur, &values[i].Uint, &values[i+1].Uint);
i++;
break;
case TGSI_IMM_FLOAT32:
ret = parse_float(&ctx->cur, &values[i].Float);
break;
case TGSI_IMM_UINT32:
ret = parse_uint(&ctx->cur, &values[i].Uint);
break;
case TGSI_IMM_INT32:
ret = parse_int(&ctx->cur, &values[i].Int);
break;
default:
assert(0);
ret = FALSE;
break;
}

if (!ret) {
report_error( ctx, ""Expected immediate constant"" );
return FALSE;
}
}
eat_opt_white( &ctx->cur );
if (*ctx->cur != '}') {
report_error( ctx, ""Expected `}'"" );
return FALSE;
}
ctx->cur++;

return TRUE;
}

static boolean parse_declaration( struct translate_ctx *ctx )
{
struct tgsi_full_declaration decl;
uint file;
struct parsed_dcl_bracket brackets[2];
int num_brackets;
uint writemask;
const char *cur, *cur2;
uint advance;
boolean is_vs_input;

if (!eat_white( &ctx->cur )) {
report_error( ctx, ""Syntax error"" );
return FALSE;
}
if (!parse_register_dcl( ctx, &file, brackets, &num_brackets))
return FALSE;
if (!parse_opt_writemask( ctx, &writemask ))
return FALSE;

decl = tgsi_default_full_declaration();
decl.Declaration.File = file;
decl.Declaration.UsageMask = writemask;

if (num_brackets == 1) {
decl.Range.First = brackets[0].first;
decl.Range.Last = brackets[0].last;
} else {
decl.Range.First = brackets[1].first;
decl.Range.Last = brackets[1].last;

decl.Declaration.Dimension = 1;
decl.Dim.Index2D = brackets[0].first;
}

is_vs_input = (file == TGSI_FILE_INPUT &&
ctx->processor == TGSI_PROCESSOR_VERTEX);

cur = ctx->cur;
eat_opt_white( &cur );
if (*cur == ',') {
cur2 = cur;
cur2++;
eat_opt_white( &cur2 );
if (str_match_nocase_whole( &cur2, ""ARRAY"" )) {
int arrayid;
if (*cur2 != '(') {
report_error( ctx, ""Expected `('"" );
return FALSE;
}
cur2++;
eat_opt_white( &cur2 );
if (!parse_int( &cur2, &arrayid )) {
report_error( ctx, ""Expected `,'"" );
return FALSE;
}
eat_opt_white( &cur2 );
if (*cur2 != ')') {
report_error( ctx, ""Expected `)'"" );
return FALSE;
}
cur2++;
decl.Declaration.Array = 1;
decl.Array.ArrayID = arrayid;
ctx->cur = cur = cur2;
}
}

if (*cur == ',' && !is_vs_input) {
uint i, j;

cur++;
eat_opt_white( &cur );
if (file == TGSI_FILE_RESOURCE) {
for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {
if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {
decl.Resource.Resource = i;
break;
}
}
if (i == TGSI_TEXTURE_COUNT) {
report_error(ctx, ""Expected texture target"");
return FALSE;
}

cur2 = cur;
eat_opt_white(&cur2);
while (*cur2 == ',') {
cur2++;
eat_opt_white(&cur2);
if (str_match_nocase_whole(&cur2, ""RAW"")) {
decl.Resource.Raw = 1;

} else if (str_match_nocase_whole(&cur2, ""WR"")) {
decl.Resource.Writable = 1;

} else {
break;
}
cur = cur2;
eat_opt_white(&cur2);
}

ctx->cur = cur;

} else if (file == TGSI_FILE_SAMPLER_VIEW) {
for (i = 0; i < TGSI_TEXTURE_COUNT; i++) {
if (str_match_nocase_whole(&cur, tgsi_texture_names[i])) {
decl.SamplerView.Resource = i;
break;
}
}
if (i == TGSI_TEXTURE_COUNT) {
report_error(ctx, ""Expected texture target"");
return FALSE;
}
eat_opt_white( &cur );
if (*cur != ',') {
report_error( ctx, ""Expected `,'"" );
return FALSE;
}
++cur;
eat_opt_white( &cur );
for (j = 0; j < 4; ++j) {
for (i = 0; i < TGSI_RETURN_TYPE_COUNT; ++i) {
if (str_match_nocase_whole(&cur, tgsi_return_type_names[i])) {
switch (j) {
case 0:
decl.SamplerView.ReturnTypeX = i;
break;
case 1:
decl.SamplerView.ReturnTypeY = i;
break;
case 2:
decl.SamplerView.ReturnTypeZ = i;
break;
case 3:
decl.SamplerView.ReturnTypeW = i;
break;
default:
assert(0);
}
break;
}
}
if (i == TGSI_RETURN_TYPE_COUNT) {
if (j == 0 || j >  2) {
report_error(ctx, ""Expected type name"");
return FALSE;
}
break;
} else {
cur2 = cur;
eat_opt_white( &cur2 );
if (*cur2 == ',') {
cur2++;
eat_opt_white( &cur2 );
cur = cur2;
continue;
} else
break;
}
}
if (j < 4) {
decl.SamplerView.ReturnTypeY =
decl.SamplerView.ReturnTypeZ =
decl.SamplerView.ReturnTypeW =
decl.SamplerView.ReturnTypeX;
}
ctx->cur = cur;
} else {
if (str_match_nocase_whole(&cur, ""LOCAL"")) {
decl.Declaration.Local = 1;
ctx->cur = cur;
}

cur = ctx->cur;
eat_opt_white( &cur );
if (*cur == ',') {
cur++;
eat_opt_white( &cur );

for (i = 0; i < TGSI_SEMANTIC_COUNT; i++) {
if (str_match_nocase_whole(&cur, tgsi_semantic_names[i])) {
uint index;

cur2 = cur;
eat_opt_white( &cur2 );
if (*cur2 == '[') {
cur2++;
eat_opt_white( &cur2 );
if (!parse_uint( &cur2, &index )) {
report_error( ctx, ""Expected literal integer"" );
return FALSE;
}
eat_opt_white( &cur2 );
if (*cur2 != ']') {
report_error( ctx, ""Expected `]'"" );
return FALSE;
}
cur2++;

decl.Semantic.Index = index;

cur = cur2;
}

decl.Declaration.Semantic = 1;
decl.Semantic.Name = i;

ctx->cur = cur;
break;
}
}
}
}
}

cur = ctx->cur;
eat_opt_white( &cur );
if (*cur == ',' && !is_vs_input) {
uint i;

cur++;
eat_opt_white( &cur );
for (i = 0; i < TGSI_INTERPOLATE_COUNT; i++) {
if (str_match_nocase_whole( &cur, tgsi_interpolate_names[i] )) {
decl.Declaration.Interpolate = 1;
decl.Interp.Interpolate = i;

ctx->cur = cur;
break;
}
}
if (i == TGSI_INTERPOLATE_COUNT) {
report_error( ctx, ""Expected semantic or interpolate attribute"" );
return FALSE;
}
}

cur = ctx->cur;
eat_opt_white( &cur );
if (*cur == ',' && !is_vs_input) {
uint i;

cur++;
eat_opt_white( &cur );
for (i = 0; i < TGSI_INTERPOLATE_LOC_COUNT; i++) {
if (str_match_nocase_whole( &cur, tgsi_interpolate_locations[i] )) {
decl.Interp.Location = i;

ctx->cur = cur;
break;
}
}
}

advance = tgsi_build_full_declaration(
&decl,
ctx->tokens_cur,
ctx->header,
(uint) (ctx->tokens_end - ctx->tokens_cur) );

if (advance == 0)
return FALSE;
ctx->tokens_cur += advance;

return TRUE;
}

static boolean parse_immediate( struct translate_ctx *ctx )
{
struct tgsi_full_immediate imm;
uint advance;
int type;

if (*ctx->cur == '[') {
uint uindex;

++ctx->cur;

eat_opt_white( &ctx->cur );
if (!parse_uint( &ctx->cur, &uindex )) {
report_error( ctx, ""Expected literal unsigned integer"" );
return FALSE;
}

if (uindex != ctx->num_immediates) {
report_error( ctx, ""Immediates must be sorted"" );
return FALSE;
}

eat_opt_white( &ctx->cur );
if (*ctx->cur != ']') {
report_error( ctx, ""Expected `]'"" );
return FALSE;
}

ctx->cur++;
}

if (!eat_white( &ctx->cur )) {
report_error( ctx, ""Syntax error"" );
return FALSE;
}
for (type = 0; type < Elements(tgsi_immediate_type_names); ++type) {
if (str_match_nocase_whole(&ctx->cur, tgsi_immediate_type_names[type]))
break;
}
if (type == Elements(tgsi_immediate_type_names)) {
report_error( ctx, ""Expected immediate type"" );
return FALSE;
}

imm = tgsi_default_full_immediate();
imm.Immediate.NrTokens += 4;
imm.Immediate.DataType = type;
parse_immediate_data(ctx, type, imm.u);

advance = tgsi_build_full_immediate(
&imm,
ctx->tokens_cur,
ctx->header,
(uint) (ctx->tokens_end - ctx->tokens_cur) );
if (advance == 0)
return FALSE;
ctx->tokens_cur += advance;

ctx->num_immediates++;

return TRUE;
}

static boolean
parse_primitive( const char **pcur, uint *primitive )
{
uint i;

for (i = 0; i < PIPE_PRIM_MAX; i++) {
const char *cur = *pcur;

if (str_match_nocase_whole( &cur, tgsi_primitive_names[i])) {
*primitive = i;
*pcur = cur;
return TRUE;
}
}
return FALSE;
}

static boolean
parse_fs_coord_origin( const char **pcur, uint *fs_coord_origin )
{
uint i;

for (i = 0; i < Elements(tgsi_fs_coord_origin_names); i++) {
const char *cur = *pcur;

if (str_match_nocase_whole( &cur, tgsi_fs_coord_origin_names[i])) {
*fs_coord_origin = i;
*pcur = cur;
return TRUE;
}
}
return FALSE;
}

static boolean
parse_fs_coord_pixel_center( const char **pcur, uint *fs_coord_pixel_center )
{
uint i;

for (i = 0; i < Elements(tgsi_fs_coord_pixel_center_names); i++) {
const char *cur = *pcur;

if (str_match_nocase_whole( &cur, tgsi_fs_coord_pixel_center_names[i])) {
*fs_coord_pixel_center = i;
*pcur = cur;
return TRUE;
}
}
return FALSE;
}


static boolean parse_property( struct translate_ctx *ctx )
{
struct tgsi_full_property prop;
uint property_name;
uint values[8];
uint advance;
char id[64];

if (!eat_white( &ctx->cur )) {
report_error( ctx, ""Syntax error"" );
return FALSE;
}
report_error( ctx, ""Syntax error"" );
return FALSE;
}
   if (!parse_identifier( &ctx->cur, id )) {
report_error( ctx, ""Syntax error"" );
return FALSE;
}
break;
}
}
",[6],"      while (is_alpha_underscore( cur ) || is_digit( cur ))/~/   if (!parse_identifier( &ctx->cur, id )) {"
173,"void TabStripGtk::TabDetachedAt(TabContents* contents, int index) {
GenerateIdealBounds();
  StartRemoveTabAnimation(index, contents->web_contents());
// Have to do this _after_ calling StartRemoveTabAnimation, so that any
// previous remove is completed fully and index is valid in sync with the
// model index.
GetTabAt(index)->set_closing(true);
}
",[2],"  StartRemoveTabAnimation(index, contents->web_contents());"
174,"static int ps_files_valid_key(const char *key)
{
       size_t len;
       const char *p;
       char c;
       int ret = 1;
       for (p = key; (c = *p); p++) {
               /* valid characters are a..z,A..Z,0..9 *
               if (!((c >= 'a' && c <= 'z')
                               || (c >= 'A' && c <= 'Z')
                               || (c >= '0' && c <= '9')
                               || c == ','
                               || c == '-')) {
                       ret = 0;
                       break;
               }
       }
       len = p - key;
       /* Somewhat arbitrary length limit here, but should be way more than
          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH *
       if (len == 0 || len > 128) {
               ret = 0;
       }
       return ret;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]","{/~/       size_t len;/~/       const char *p;/~/       char c;/~/       int ret = 1;/~/       for (p = key; (c = *p); p++) {/~/               /* valid characters are a..z,A..Z,0..9 */~/               if (!((c >= 'a' && c <= 'z')/~/                               || (c >= 'A' && c <= 'Z')/~/                               || (c >= '0' && c <= '9')/~/                               || c == ','/~/                               || c == '-')) {/~/                       ret = 0;/~/                       break;/~/               }/~/       }/~/       len = p - key;/~/       /* Somewhat arbitrary length limit here, but should be way more than/~/          anyone needs and avoids file-level warnings later on if we exceed MAX_PATH */~/       if (len == 0 || len > 128) {/~/               ret = 0;/~/       }/~/       return ret;/~/}"
175,"php_http_url_t *php_http_url_parse(const char *str, size_t len, unsigned flags TSRMLS_DC)
{
	size_t maxlen = 3 * len;
struct parse_state *state = ecalloc(1, sizeof(*state) + maxlen);

state->end = str + len;
state->ptr = str;
state->flags = flags;
state->maxlen = maxlen;
TSRMLS_SET_CTX(state->ts);

if (!parse_scheme(state)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL scheme: '%s'"", state->ptr);
efree(state);
return NULL;
}

if (!parse_hier(state)) {
efree(state);
return NULL;
}

if (!parse_query(state)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL query: '%s'"", state->ptr);
efree(state);
return NULL;
}

if (!parse_fragment(state)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Failed to parse URL fragment: '%s'"", state->ptr);
efree(state);
return NULL;
}

return (php_http_url_t *) state;
}
",[2],	size_t maxlen = 3 * len;
176,"void MojoJpegDecodeAccelerator::Decode(
const BitstreamBuffer& bitstream_buffer,
const scoped_refptr<VideoFrame>& video_frame) {
DCHECK(io_task_runner_->BelongsToCurrentThread());
DCHECK(jpeg_decoder_.is_bound());

DCHECK(
base::SharedMemory::IsHandleValid(video_frame->shared_memory_handle()));

base::SharedMemoryHandle output_handle =
base::SharedMemory::DuplicateHandle(video_frame->shared_memory_handle());
if (!base::SharedMemory::IsHandleValid(output_handle)) {
DLOG(ERROR) << ""Failed to duplicate handle of VideoFrame"";
return;
}

size_t output_buffer_size = VideoFrame::AllocationSize(
video_frame->format(), video_frame->coded_size());
mojo::ScopedSharedBufferHandle output_frame_handle =
      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,
                                   false /* read_only */);

// base::Unretained is safe because |this| owns |jpeg_decoder_|.
jpeg_decoder_->Decode(bitstream_buffer, video_frame->coded_size(),
std::move(output_frame_handle),
base::checked_cast<uint32_t>(output_buffer_size),
base::Bind(&MojoJpegDecodeAccelerator::OnDecodeAck,
base::Unretained(this)));
}
","[16, 17]","      mojo::WrapSharedMemoryHandle(output_handle, output_buffer_size,/~/                                   false /* read_only */);"
177,"void cJSON_AddItemReferenceToObject( cJSON *object, const char *string, cJSON *item )
{
	cJSON_AddItemToObject( object, string, create_reference( item ) );
}
","[1, 2, 3]","{/~/	cJSON_AddItemToObject( object, string, create_reference( item ) );/~/}"
178,"ConflictResolver::ProcessSimpleConflict(WriteTransaction* trans,
const Id& id,
const Cryptographer* cryptographer,
StatusController* status) {
MutableEntry entry(trans, syncable::GET_BY_ID, id);
// Must be good as the entry won't have been cleaned up.
CHECK(entry.good());

// This function can only resolve simple conflicts.  Simple conflicts have
// both IS_UNSYNCED and IS_UNAPPLIED_UDPATE set.
if (!entry.Get(syncable::IS_UNAPPLIED_UPDATE) ||
!entry.Get(syncable::IS_UNSYNCED)) {
// This is very unusual, but it can happen in tests.  We may be able to
// assert NOTREACHED() here when those tests are updated.
return NO_SYNC_PROGRESS;
}

if (entry.Get(syncable::IS_DEL) && entry.Get(syncable::SERVER_IS_DEL)) {
// we've both deleted it, so lets just drop the need to commit/update this
// entry.
entry.Put(syncable::IS_UNSYNCED, false);
entry.Put(syncable::IS_UNAPPLIED_UPDATE, false);
// we've made changes, but they won't help syncing progress.
// METRIC simple conflict resolved by merge.
return NO_SYNC_PROGRESS;
}

// This logic determines ""client wins"" vs. ""server wins"" strategy picking.
// By the time we get to this point, we rely on the following to be true:
// a) We can decrypt both the local and server data (else we'd be in
//    conflict encryption and not attempting to resolve).
// b) All unsynced changes have been re-encrypted with the default key (
//    occurs either in AttemptToUpdateEntry, SetEncryptionPassphrase,
//    SetDecryptionPassphrase, or RefreshEncryption).
// c) Base_server_specifics having a valid datatype means that we received
//    an undecryptable update that only changed specifics, and since then have
//    not received any further non-specifics-only or decryptable updates.
// d) If the server_specifics match specifics, server_specifics are
//    encrypted with the default key, and all other visible properties match,
//    then we can safely ignore the local changes as redundant.
// e) Otherwise if the base_server_specifics match the server_specifics, no
//    functional change must have been made server-side (else
//    base_server_specifics would have been cleared), and we can therefore
//    safely ignore the server changes as redundant.
// f) Otherwise, it's in general safer to ignore local changes, with the
//    exception of deletion conflicts (choose to undelete) and conflicts
//    where the non_unique_name or parent don't match.
if (!entry.Get(syncable::SERVER_IS_DEL)) {
// TODO(nick): The current logic is arbitrary; instead, it ought to be made
// consistent with the ModelAssociator behavior for a datatype.  It would
// be nice if we could route this back to ModelAssociator code to pick one
// of three options: CLIENT, SERVER, or MERGE.  Some datatypes (autofill)
// are easily mergeable.
// See http://crbug.com/77339.
bool name_matches = entry.Get(syncable::NON_UNIQUE_NAME) ==
entry.Get(syncable::SERVER_NON_UNIQUE_NAME);
bool parent_matches = entry.Get(syncable::PARENT_ID) ==
entry.Get(syncable::SERVER_PARENT_ID);
bool entry_deleted = entry.Get(syncable::IS_DEL);

// This positional check is meant to be necessary but not sufficient. As a
// result, it may be false even when the position hasn't changed, possibly
// resulting in unnecessary commits, but if it's true the position has
// definitely not changed. The check works by verifying that the prev id
// as calculated from the server position (which will ignore any
// unsynced/unapplied predecessors and be root for non-bookmark datatypes)
// matches the client prev id. Because we traverse chains of conflicting
// items in predecessor -> successor order, we don't need to also verify the
// successor matches (If it's in conflict, we'll verify it next. If it's
// not, then it should be taken into account already in the
// ComputePrevIdFromServerPosition calculation). This works even when there
// are chains of conflicting items.
//
// Example: Original sequence was abcde. Server changes to aCDbe, while
// client changes to aDCbe (C and D are in conflict). Locally, D's prev id
// is a, while C's prev id is D. On the other hand, the server prev id will
// ignore unsynced/unapplied items, so D's server prev id will also be a,
// just like C's. Because we traverse in client predecessor->successor
// order, we evaluate D first. Since prev id and server id match, we
// consider the position to have remained the same for D, and will unset
// it's UNSYNCED/UNAPPLIED bits. When we evaluate C though, we'll see that
// the prev id is D locally while the server's prev id is a. C will
// therefore count as a positional conflict (and the local data will be
// overwritten by the server data typically). The final result will be
// aCDbe (the same as the server's view). Even though both C and D were
// modified, only one counted as being in actual conflict and was resolved
// with local/server wins.
//
// In general, when there are chains of positional conflicts, only the first
// item in chain (based on the clients point of view) will have both its
// server prev id and local prev id match. For all the rest the server prev
// id will be the predecessor of the first item in the chain, and therefore
// not match the local prev id.
//
// Similarly, chains of conflicts where the server and client info are the
// same are supported due to the predecessor->successor ordering. In this
// case, from the first item onward, we unset the UNSYNCED/UNAPPLIED bits as
// we decide that nothing changed. The subsequent item's server prev id will
// accurately match the local prev id because the predecessor is no longer
// UNSYNCED/UNAPPLIED.
// TODO(zea): simplify all this once we can directly compare server position
// to client position.
syncable::Id server_prev_id = entry.ComputePrevIdFromServerPosition(
entry.Get(syncable::SERVER_PARENT_ID));
bool needs_reinsertion = !parent_matches ||
server_prev_id != entry.Get(syncable::PREV_ID);
DVLOG_IF(1, needs_reinsertion) << ""Insertion needed, server prev id ""
<< "" is "" << server_prev_id << "", local prev id is ""
<< entry.Get(syncable::PREV_ID);
const sync_pb::EntitySpecifics& specifics =
entry.Get(syncable::SPECIFICS);
const sync_pb::EntitySpecifics& server_specifics =
entry.Get(syncable::SERVER_SPECIFICS);
const sync_pb::EntitySpecifics& base_server_specifics =
entry.Get(syncable::BASE_SERVER_SPECIFICS);
std::string decrypted_specifics, decrypted_server_specifics;
bool specifics_match = false;
bool server_encrypted_with_default_key = false;
if (specifics.has_encrypted()) {
DCHECK(cryptographer->CanDecryptUsingDefaultKey(specifics.encrypted()));
decrypted_specifics = cryptographer->DecryptToString(
specifics.encrypted());
} else {
decrypted_specifics = specifics.SerializeAsString();
}
if (server_specifics.has_encrypted()) {
server_encrypted_with_default_key =
cryptographer->CanDecryptUsingDefaultKey(
server_specifics.encrypted());
decrypted_server_specifics = cryptographer->DecryptToString(
server_specifics.encrypted());
} else {
decrypted_server_specifics = server_specifics.SerializeAsString();
}
if (decrypted_server_specifics == decrypted_specifics &&
server_encrypted_with_default_key == specifics.has_encrypted()) {
specifics_match = true;
}
bool base_server_specifics_match = false;
if (server_specifics.has_encrypted() &&
IsRealDataType(GetModelTypeFromSpecifics(base_server_specifics))) {
std::string decrypted_base_server_specifics;
if (!base_server_specifics.has_encrypted()) {
decrypted_base_server_specifics =
base_server_specifics.SerializeAsString();
} else {
decrypted_base_server_specifics = cryptographer->DecryptToString(
base_server_specifics.encrypted());
}
if (decrypted_server_specifics == decrypted_base_server_specifics)
base_server_specifics_match = true;
}

// We manually merge nigori data.
if (entry.GetModelType() == syncable::NIGORI) {
// Create a new set of specifics based on the server specifics (which
// preserves their encryption keys).
sync_pb::EntitySpecifics specifics =
entry.Get(syncable::SERVER_SPECIFICS);
sync_pb::NigoriSpecifics* server_nigori = specifics.mutable_nigori();
// Store the merged set of encrypted types (cryptographer->Update(..) will
// have merged the local types already).
cryptographer->UpdateNigoriFromEncryptedTypes(server_nigori);
// The cryptographer has the both the local and remote encryption keys
// (added at cryptographer->Update(..) time).
// If the cryptographer is ready, then it already merged both sets of keys
// and we can store them back in. In that case, the remote key was already
// part of the local keybag, so we preserve the local key as the default
// (including whether it's an explicit key).
// If the cryptographer is not ready, then the user will have to provide
// the passphrase to decrypt the pending keys. When they do so, the
// SetDecryptionPassphrase code will act based on whether the server
// update has an explicit passphrase or not.
// - If the server had an explicit passphrase, that explicit passphrase
//   will be preserved as the default encryption key.
// - If the server did not have an explicit passphrase, we assume the
//   local passphrase is the most up to date and preserve the local
//   default encryption key marked as an implicit passphrase.
// This works fine except for the case where we had locally set an
// explicit passphrase. In that case the nigori node will have the default
// key based on the local explicit passphassphrase, but will not have it
// marked as explicit. To fix this we'd have to track whether we have a
// explicit passphrase or not separate from the nigori, which would
// introduce even more complexity, so we leave it up to the user to
// reset that passphrase as an explicit one via settings. The goal here
// is to ensure both sets of encryption keys are preserved.
if (cryptographer->is_ready()) {
cryptographer->GetKeys(server_nigori->mutable_encrypted());
server_nigori->set_using_explicit_passphrase(
entry.Get(syncable::SPECIFICS).nigori().
using_explicit_passphrase());
}
      // TODO(zea): Find a better way of doing this. As it stands, we have to
      // update this code whenever we add a new non-cryptographer related field
      // to the nigori node.
      if (entry.Get(syncable::SPECIFICS).nigori().sync_tabs()) {
        server_nigori->set_sync_tabs(true);
      }
// We deliberately leave the server's device information. This client will
// add its own device information on restart.
entry.Put(syncable::SPECIFICS, specifics);
DVLOG(1) << ""Resolving simple conflict, merging nigori nodes: "" << entry;
status->increment_num_server_overwrites();
OverwriteServerChanges(trans, &entry);
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
NIGORI_MERGE,
CONFLICT_RESOLUTION_SIZE);
} else if (!entry_deleted && name_matches && parent_matches &&
specifics_match && !needs_reinsertion) {
DVLOG(1) << ""Resolving simple conflict, everything matches, ignoring ""
<< ""changes for: "" << entry;
// This unsets both IS_UNSYNCED and IS_UNAPPLIED_UPDATE, and sets the
// BASE_VERSION to match the SERVER_VERSION. If we didn't also unset
// IS_UNAPPLIED_UPDATE, then we would lose unsynced positional data from
// adjacent entries when the server update gets applied and the item is
// re-inserted into the PREV_ID/NEXT_ID linked list. This is primarily
// an issue because we commit after applying updates, and is most
// commonly seen when positional changes are made while a passphrase
// is required (and hence there will be many encryption conflicts).
OverwriteServerChanges(trans, &entry);
IgnoreLocalChanges(&entry);
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
CHANGES_MATCH,
CONFLICT_RESOLUTION_SIZE);
} else if (base_server_specifics_match) {
DVLOG(1) << ""Resolving simple conflict, ignoring server encryption ""
<< "" changes for: "" << entry;
status->increment_num_server_overwrites();
OverwriteServerChanges(trans, &entry);
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
IGNORE_ENCRYPTION,
CONFLICT_RESOLUTION_SIZE);
} else if (entry_deleted || !name_matches || !parent_matches) {
OverwriteServerChanges(trans, &entry);
status->increment_num_server_overwrites();
DVLOG(1) << ""Resolving simple conflict, overwriting server changes ""
<< ""for: "" << entry;
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
OVERWRITE_SERVER,
CONFLICT_RESOLUTION_SIZE);
} else {
DVLOG(1) << ""Resolving simple conflict, ignoring local changes for: ""
<< entry;
IgnoreLocalChanges(&entry);
status->increment_num_local_overwrites();
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
OVERWRITE_LOCAL,
CONFLICT_RESOLUTION_SIZE);
}
// Now that we've resolved the conflict, clear the prev server
// specifics.
entry.Put(syncable::BASE_SERVER_SPECIFICS, sync_pb::EntitySpecifics());
return SYNC_PROGRESS;
} else {  // SERVER_IS_DEL is true
// If a server deleted folder has local contents it should be a hierarchy
// conflict.  Hierarchy conflicts should not be processed by this function.
// We could end up here if a change was made since we last tried to detect
// conflicts, which was during update application.
if (entry.Get(syncable::IS_DIR)) {
Directory::ChildHandles children;
trans->directory()->GetChildHandlesById(trans,
entry.Get(syncable::ID),
&children);
if (0 != children.size()) {
DVLOG(1) << ""Entry is a server deleted directory with local contents, ""
<< ""should be a hierarchy conflict. (race condition)."";
return NO_SYNC_PROGRESS;
}
}

// The entry is deleted on the server but still exists locally.
if (!entry.Get(syncable::UNIQUE_CLIENT_TAG).empty()) {
// If we've got a client-unique tag, we can undelete while retaining
// our present ID.
DCHECK_EQ(entry.Get(syncable::SERVER_VERSION), 0) << ""For the server to ""
""know to re-create, client-tagged items should revert to version 0 ""
""when server-deleted."";
OverwriteServerChanges(trans, &entry);
status->increment_num_server_overwrites();
DVLOG(1) << ""Resolving simple conflict, undeleting server entry: ""
<< entry;
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
OVERWRITE_SERVER,
CONFLICT_RESOLUTION_SIZE);
// Clobber the versions, just in case the above DCHECK is violated.
entry.Put(syncable::SERVER_VERSION, 0);
entry.Put(syncable::BASE_VERSION, 0);
} else {
// Otherwise, we've got to undelete by creating a new locally
// uncommitted entry.
SyncerUtil::SplitServerInformationIntoNewEntry(trans, &entry);

MutableEntry server_update(trans, syncable::GET_BY_ID, id);
CHECK(server_update.good());
CHECK(server_update.Get(syncable::META_HANDLE) !=
entry.Get(syncable::META_HANDLE))
<< server_update << entry;
UMA_HISTOGRAM_ENUMERATION(""Sync.ResolveSimpleConflict"",
UNDELETE,
CONFLICT_RESOLUTION_SIZE);
}
return SYNC_PROGRESS;
}
}
","[14, 23]","      // TODO(zea): Find a better way of doing this. As it stands, we have to/~/      // update this code whenever we add a new non-cryptographer related field/~/      // to the nigori node./~/      if (entry.Get(syncable::SPECIFICS).nigori().sync_tabs()) {/~/        server_nigori->set_sync_tabs(true);/~/      }"
179,"void PlatformSensorProviderAndroid::CreateAbsoluteOrientationQuaternionSensor(
JNIEnv* env,
    mojo::ScopedSharedBufferMapping mapping,
const CreateSensorCallback& callback) {
ScopedJavaLocalRef<jobject> sensor = Java_PlatformSensorProvider_createSensor(
env, j_object_,
static_cast<jint>(mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION));

if (sensor.obj()) {
auto concrete_sensor = base::MakeRefCounted<PlatformSensorAndroid>(
        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),
this, sensor);

callback.Run(concrete_sensor);
} else {
auto sensor_fusion_algorithm =
std::make_unique<OrientationQuaternionFusionAlgorithmUsingEulerAngles>(
true /* absolute */);

// If this PlatformSensorFusion object is successfully initialized,
// |callback| will be run with a reference to this object.
    PlatformSensorFusion::Create(std::move(mapping), this,
std::move(sensor_fusion_algorithm), callback);
}
}
","[2, 9, 18]","    mojo::ScopedSharedBufferMapping mapping,/~/        mojom::SensorType::ABSOLUTE_ORIENTATION_QUATERNION, std::move(mapping),/~/    PlatformSensorFusion::Create(std::move(mapping), this,"
180,"void jas_matrix_divpow2(jas_matrix_t *matrix, int n)
{
	int i;
	int j;
jas_seqent_t *rowstart;
	int rowstep;
jas_seqent_t *data;

if (jas_matrix_numrows(matrix) > 0 && jas_matrix_numcols(matrix) > 0) {
assert(matrix->rows_);
rowstep = jas_matrix_rowstep(matrix);
for (i = matrix->numrows_, rowstart = matrix->rows_[0]; i > 0; --i,
rowstart += rowstep) {
for (j = matrix->numcols_, data = rowstart; j > 0; --j,
++data) {
*data = (*data >= 0) ? ((*data) >> n) :
(-((-(*data)) >> n));
}
}
}
}
","[2, 3, 5]",	int i;/~/	int j;/~/	int rowstep;
181,"void FileSystemOperation::GetUsageAndQuotaThenRunTask(
const GURL& origin, FileSystemType type,
const base::Closure& task,
const base::Closure& error_callback) {
quota::QuotaManagerProxy* quota_manager_proxy =
file_system_context()->quota_manager_proxy();
if (!quota_manager_proxy ||
!file_system_context()->GetQuotaUtil(type)) {
// If we don't have the quota manager or the requested filesystem type
// does not support quota, we should be able to let it go.
operation_context_.set_allowed_bytes_growth(kint64max);
task.Run();
return;
}

TaskParamsForDidGetQuota params;
params.origin = origin;
params.type = type;
params.task = task;
params.error_callback = error_callback;

DCHECK(quota_manager_proxy);
DCHECK(quota_manager_proxy->quota_manager());
quota_manager_proxy->quota_manager()->GetUsageAndQuota(
origin,
FileSystemTypeToQuotaStorageType(type),
base::Bind(&FileSystemOperation::DidGetUsageAndQuotaAndRunTask,
                 base::Unretained(this), params));
}
",[25],"                 base::Unretained(this), params));"
182,"void GpuProcessHostUIShim::OnAcceleratedSurfaceNew(
const GpuHostMsg_AcceleratedSurfaceNew_Params& params) {
RenderWidgetHostViewPort* view = GetRenderWidgetHostViewFromSurfaceID(
params.surface_id);
if (!view)
return;
view->AcceleratedSurfaceNew(
      params.width, params.height, params.surface_handle);
}
",[7],"      params.width, params.height, params.surface_handle);"
183,"IMPEG2D_ERROR_CODES_T impeg2d_vld_decode(
dec_state_t *ps_dec,
WORD16      *pi2_outAddr, /*!< Address where decoded symbols will be stored */
const UWORD8 *pu1_scan, /*!< Scan table to be used */
UWORD8      *pu1_pos, /*!< Scan table to be used */
UWORD16     u2_intra_flag, /*!< Intra Macroblock or not */
UWORD16     u2_chroma_flag, /*!< Chroma Block or not */
UWORD16     u2_d_picture, /*!< D Picture or not */
UWORD16     u2_intra_vlc_format, /*!< Intra VLC format */
UWORD16     u2_mpeg2, /*!< MPEG-2 or not */
WORD32      *pi4_num_coeffs /*!< Returns the number of coeffs in block */
)
{

UWORD32 u4_sym_len;

UWORD32 u4_decoded_value;
UWORD32 u4_level_first_byte;
WORD32  u4_level;
UWORD32 u4_run, u4_numCoeffs;
UWORD32 u4_buf;
UWORD32 u4_buf_nxt;
UWORD32 u4_offset;
UWORD32 *pu4_buf_aligned;
UWORD32 u4_bits;
stream_t *ps_stream = &ps_dec->s_bit_stream;
WORD32  u4_pos;
UWORD32 u4_nz_cols;
UWORD32 u4_nz_rows;

*pi4_num_coeffs = 0;

ps_dec->u4_non_zero_cols = 0;
ps_dec->u4_non_zero_rows = 0;
u4_nz_cols = ps_dec->u4_non_zero_cols;
u4_nz_rows = ps_dec->u4_non_zero_rows;

GET_TEMP_STREAM_DATA(u4_buf,u4_buf_nxt,u4_offset,pu4_buf_aligned,ps_stream)
/**************************************************************************/
/* Decode the DC coefficient in case of Intra block                       */
/**************************************************************************/
if(u2_intra_flag)
{
WORD32 dc_size;
WORD32 dc_diff;
WORD32 maxLen;
WORD32 idx;


maxLen = MPEG2_DCT_DC_SIZE_LEN;
idx = 0;
if(u2_chroma_flag != 0)
{
maxLen += 1;
idx++;
}


{
WORD16  end = 0;
UWORD32 maxLen_tmp = maxLen;
UWORD16 m_iBit;


/* Get the maximum number of bits needed to decode a symbol */
IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,maxLen)
do
{
maxLen_tmp--;
/* Read one bit at a time from the variable to decode the huffman code */
m_iBit = (UWORD8)((u4_bits >> maxLen_tmp) & 0x1);

/* Get the next node pointer or the symbol from the tree */
end = gai2_impeg2d_dct_dc_size[idx][end][m_iBit];
}while(end > 0);
dc_size = end + MPEG2_DCT_DC_SIZE_OFFSET;

/* Flush the appropriate number of bits from the stream */
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,(maxLen - maxLen_tmp),pu4_buf_aligned)

}



if (dc_size != 0)
{
UWORD32 u4_bits;

IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, dc_size)
dc_diff = u4_bits;

if ((dc_diff & (1 << (dc_size - 1))) == 0) //v Probably the prediction algo?
dc_diff -= (1 << dc_size) - 1;
}
else
{
dc_diff = 0;
}


pi2_outAddr[*pi4_num_coeffs] = dc_diff;
/* This indicates the position of the coefficient. Since this is the DC
* coefficient, we put the position as 0.
*/
pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
(*pi4_num_coeffs)++;

if (0 != dc_diff)
{
u4_nz_cols |= 0x01;
u4_nz_rows |= 0x01;
}

u4_numCoeffs = 1;
}
/**************************************************************************/
/* Decoding of first AC coefficient in case of non Intra block            */
/**************************************************************************/
else
{
/* First symbol can be 1s */
UWORD32 u4_bits;

IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,1)

if(u4_bits == 1)
{

FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,1, pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned, 1)
if(u4_bits == 1)
{
pi2_outAddr[*pi4_num_coeffs] = -1;
}
else
{
pi2_outAddr[*pi4_num_coeffs] = 1;
}

/* This indicates the position of the coefficient. Since this is the DC
* coefficient, we put the position as 0.
*/
pu1_pos[*pi4_num_coeffs] = pu1_scan[0];
(*pi4_num_coeffs)++;
u4_numCoeffs = 1;

u4_nz_cols |= 0x01;
u4_nz_rows |= 0x01;
}
else
{
u4_numCoeffs = 0;
}
}
if (1 == u2_d_picture)
{
PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)
ps_dec->u4_non_zero_cols  = u4_nz_cols;
ps_dec->u4_non_zero_rows  = u4_nz_rows;
return ((IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE);
}



if (1 == u2_intra_vlc_format && u2_intra_flag)
{

while(1)
{
//Putting the impeg2d_dec_ac_coeff_one function inline.

UWORD32 lead_zeros;
WORD16 DecodedValue;

u4_sym_len = 17;
IBITS_NXT(u4_buf,u4_buf_nxt,u4_offset,u4_bits,u4_sym_len)

DecodedValue = gau2_impeg2d_tab_one_1_9[u4_bits >> 8];
u4_sym_len = (DecodedValue & 0xf);
u4_level = DecodedValue >> 9;
/* One table lookup */
if(0 != u4_level)
{
u4_run = ((DecodedValue >> 4) & 0x1f);
u4_numCoeffs       += u4_run;
u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;

FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
pi2_outAddr[*pi4_num_coeffs] = u4_level;

(*pi4_num_coeffs)++;
}
else
{
if (DecodedValue == END_OF_BLOCK_ONE)
{
u4_sym_len = 4;

break;
}
else
{
/*Second table lookup*/
lead_zeros = CLZ(u4_bits) - 20;/* -16 since we are dealing with WORD32 */
if (0 != lead_zeros)
{

u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

/* Flush the number of bits */
if (1 == lead_zeros)
{
u4_sym_len         = ((u4_bits & 0x18) >> 3) == 2 ? 11:10;
}
else
{
u4_sym_len         = 11 + lead_zeros;
}
/* flushing */
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)

/* Calculate the address */
u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

DecodedValue = gau2_impeg2d_tab_one_10_16[u4_bits];

u4_run = BITS(DecodedValue, 8,4);
u4_level = ((WORD16) DecodedValue) >> 9;

u4_numCoeffs       += u4_run;
u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;
pi2_outAddr[*pi4_num_coeffs] = u4_level;
(*pi4_num_coeffs)++;
}
/*********************************************************************/
/* MPEG2 Escape Code                                                 */
/*********************************************************************/
else if(u2_mpeg2 == 1)
{
u4_sym_len         = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
u4_decoded_value    = u4_bits;
u4_run             = (u4_decoded_value >> 12);
u4_level           = (u4_decoded_value & 0x0FFF);

if (u4_level)
u4_level = (u4_level - ((u4_level & 0x0800) << 1));

u4_numCoeffs       += u4_run;
u4_pos             = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;
pi2_outAddr[*pi4_num_coeffs] = u4_level;
(*pi4_num_coeffs)++;
}
/*********************************************************************/
/* MPEG1 Escape Code                                                 */
/*********************************************************************/
else
{
/*-----------------------------------------------------------
* MPEG-1 Stream
*
* <See D.9.3 of MPEG-2> Run-level escape syntax
* Run-level values that cannot be coded with a VLC are coded
* by the escape code '0000 01' followed by
* either a 14-bit FLC (127 <= level <= 127),
* or a 22-bit FLC (255 <= level <= 255).
* This is described in Annex B,B.5f of MPEG-1.standard
*-----------------------------------------------------------*/

/*-----------------------------------------------------------
* First 6 bits are the value of the Run. Next is First 8 bits
* of Level. These bits decide whether it is 14 bit FLC or
* 22-bit FLC.
*
* If( first 8 bits of Level == '1000000' or '00000000')
*      then its is 22-bit FLC.
* else
*      it is 14-bit FLC.
*-----------------------------------------------------------*/
u4_sym_len         = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
u4_decoded_value     = u4_bits;
u4_run              = (u4_decoded_value >> 8);
u4_level_first_byte = (u4_decoded_value & 0x0FF);
if(u4_level_first_byte & 0x7F)
{
/*-------------------------------------------------------
* First 8 bits of level are neither 1000000 nor 00000000
* Hence 14-bit FLC (Last 8 bits are used to get level)
*
*  Level = (msb of Level_First_Byte is 1)?
*          Level_First_Byte - 256 : Level_First_Byte
*-------------------------------------------------------*/
u4_level = (u4_level_first_byte -
((u4_level_first_byte & 0x80) << 1));
}
else
{
/*-------------------------------------------------------
* Next 8 bits are either 1000000 or 00000000
* Hence 22-bit FLC (Last 16 bits are used to get level)
*
*  Level = (msb of Level_First_Byte is 1)?
*          Level_Second_Byte - 256 : Level_Second_Byte
*-------------------------------------------------------*/
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
u4_level = u4_bits;
u4_level = (u4_level - (u4_level_first_byte << 1));
}
u4_numCoeffs += u4_run;

u4_pos = pu1_scan[u4_numCoeffs++ & 63];

pu1_pos[*pi4_num_coeffs] = u4_pos;
pi2_outAddr[*pi4_num_coeffs] = u4_level;
(*pi4_num_coeffs)++;
}
}
}


u4_nz_cols |= 1 << (u4_pos & 0x7);
u4_nz_rows |= 1 << (u4_pos >> 0x3);


}
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)
            if (u4_numCoeffs > 64)
            {
                return IMPEG2D_MB_TEX_DECODE_ERR;
            }
}
else
{
// Inline
while(1)
{

UWORD32 lead_zeros;
UWORD16 DecodedValue;

u4_sym_len = 17;
IBITS_NXT(u4_buf, u4_buf_nxt, u4_offset, u4_bits, u4_sym_len)


DecodedValue = gau2_impeg2d_tab_zero_1_9[u4_bits >> 8];
u4_sym_len = BITS(DecodedValue, 3, 0);
u4_level = ((WORD16) DecodedValue) >> 9;

if (0 != u4_level)
{
u4_run = BITS(DecodedValue, 8,4);

u4_numCoeffs       += u4_run;

u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;

FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
pi2_outAddr[*pi4_num_coeffs] = u4_level;
(*pi4_num_coeffs)++;
}
else
{
if(DecodedValue == END_OF_BLOCK_ZERO)
{
u4_sym_len = 2;

break;
}
else
{
lead_zeros = CLZ(u4_bits) - 20;/* -15 since we are dealing with WORD32 */
/*Second table lookup*/
if (0 != lead_zeros)
{
u4_bits         = (u4_bits >> (6 - lead_zeros)) & 0x001F;

/* Flush the number of bits */
u4_sym_len         = 11 + lead_zeros;

/* Calculate the address */
u4_bits         = ((lead_zeros - 1) << 5) + u4_bits;

DecodedValue = gau2_impeg2d_tab_zero_10_16[u4_bits];

u4_run = BITS(DecodedValue, 8,4);
u4_level = ((WORD16) DecodedValue) >> 9;

u4_numCoeffs       += u4_run;

u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;
if (1 == lead_zeros)
u4_sym_len--;
/* flushing */
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
pi2_outAddr[*pi4_num_coeffs] = u4_level;

(*pi4_num_coeffs)++;
}
/*Escape Sequence*/
else if(u2_mpeg2 == 1)
{
u4_sym_len         = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,18)
u4_decoded_value    = u4_bits;
u4_run             = (u4_decoded_value >> 12);
u4_level           = (u4_decoded_value & 0x0FFF);

if (u4_level)
u4_level = (u4_level - ((u4_level & 0x0800) << 1));

u4_numCoeffs           += u4_run;

u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;
pi2_outAddr[*pi4_num_coeffs] = u4_level;

(*pi4_num_coeffs)++;
}
/*********************************************************************/
/* MPEG1 Escape Code                                                 */
/*********************************************************************/
else
{
/*-----------------------------------------------------------
* MPEG-1 Stream
*
* <See D.9.3 of MPEG-2> Run-level escape syntax
* Run-level values that cannot be coded with a VLC are coded
* by the escape code '0000 01' followed by
* either a 14-bit FLC (127 <= level <= 127),
* or a 22-bit FLC (255 <= level <= 255).
* This is described in Annex B,B.5f of MPEG-1.standard
*-----------------------------------------------------------*/

/*-----------------------------------------------------------
* First 6 bits are the value of the Run. Next is First 8 bits
* of Level. These bits decide whether it is 14 bit FLC or
* 22-bit FLC.
*
* If( first 8 bits of Level == '1000000' or '00000000')
*      then its is 22-bit FLC.
* else
*      it is 14-bit FLC.
*-----------------------------------------------------------*/
u4_sym_len             = 6;
FLUSH_BITS(u4_offset,u4_buf,u4_buf_nxt,u4_sym_len,pu4_buf_aligned)
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,14)
u4_decoded_value        = u4_bits;
u4_run                 = (u4_decoded_value >> 8);
u4_level_first_byte    = (u4_decoded_value & 0x0FF);
if(u4_level_first_byte & 0x7F)
{
/*-------------------------------------------------------
* First 8 bits of level are neither 1000000 nor 00000000
* Hence 14-bit FLC (Last 8 bits are used to get level)
*
*  Level = (msb of Level_First_Byte is 1)?
*          Level_First_Byte - 256 : Level_First_Byte
*-------------------------------------------------------*/
u4_level = (u4_level_first_byte -
((u4_level_first_byte & 0x80) << 1));
}
else
{
/*-------------------------------------------------------
* Next 8 bits are either 1000000 or 00000000
* Hence 22-bit FLC (Last 16 bits are used to get level)
*
*  Level = (msb of Level_First_Byte is 1)?
*          Level_Second_Byte - 256 : Level_Second_Byte
*-------------------------------------------------------*/
IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,8)
u4_level = u4_bits;
u4_level = (u4_level - (u4_level_first_byte << 1));
}
u4_numCoeffs           += u4_run;

u4_pos                 = pu1_scan[u4_numCoeffs++ & 63];
pu1_pos[*pi4_num_coeffs] = u4_pos;
pi2_outAddr[*pi4_num_coeffs] = u4_level;

(*pi4_num_coeffs)++;
}
}
}


u4_nz_cols |= 1 << (u4_pos & 0x7);
u4_nz_rows |= 1 << (u4_pos >> 0x3);
            }
            if (u4_numCoeffs > 64)
            {
                return IMPEG2D_MB_TEX_DECODE_ERR;
}

IBITS_GET(u4_buf,u4_buf_nxt,u4_offset,u4_bits,pu4_buf_aligned,u4_sym_len)

}

PUT_TEMP_STREAM_DATA(u4_buf, u4_buf_nxt, u4_offset, pu4_buf_aligned, ps_stream)

ps_dec->u4_non_zero_cols  = u4_nz_cols;
ps_dec->u4_non_zero_rows  = u4_nz_rows;

return (IMPEG2D_ERROR_CODES_T)IVD_ERROR_NONE;
}
",[12],            if (u4_numCoeffs > 64)/~/            {/~/                return IMPEG2D_MB_TEX_DECODE_ERR;/~/            }/~/            }/~/            if (u4_numCoeffs > 64)/~/            {/~/                return IMPEG2D_MB_TEX_DECODE_ERR;
184,"void CuePoint::TrackPosition::Parse(IMkvReader* pReader, long long start_,
long long size_) {
const long long stop = start_ + size_;
long long pos = start_;

m_track = -1;
m_pos = -1;
m_block = 1; // default


while (pos < stop) {
long len;

    const long long id = ReadUInt(pReader, pos, len);
    assert(id >= 0);  // TODO
    assert((pos + len) <= stop);

pos += len;  // consume ID

const long long size = ReadUInt(pReader, pos, len);
    assert(size >= 0);
    assert((pos + len) <= stop);

pos += len;  // consume Size field
    assert((pos + size) <= stop);

if (id == 0x77)  // CueTrack ID
m_track = UnserializeUInt(pReader, pos, size);

else if (id == 0x71) // CueClusterPos ID
m_pos = UnserializeUInt(pReader, pos, size);

else if (id == 0x1378) // CueBlockNumber

m_block = UnserializeUInt(pReader, pos, size);

pos += size;  // consume payload
    assert(pos <= stop);
}

  assert(m_pos >= 0);
  assert(m_track > 0);
  // assert(m_block > 0);
}
","[9, 10, 11, 14, 15, 17, 25, 27, 28, 29]","    const long long id = ReadUInt(pReader, pos, len);/~/    assert(id >= 0);  // TODO/~/    assert((pos + len) <= stop);/~/    assert(size >= 0);/~/    assert((pos + len) <= stop);/~/    assert((pos + size) <= stop);/~/    assert(pos <= stop);/~/  assert(m_pos >= 0);/~/  assert(m_track > 0);/~/  // assert(m_block > 0);"
185,"static size_t safecat(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST char *cat)
{
while (pos < bufsize && cat != NULL && *cat != 0)
buffer[pos++] = *cat++;

if (pos >= bufsize)
pos = bufsize-1;

buffer[pos] = 0;
return pos;
}
",[1],   PNG_CONST char *cat)
186,"PHP_FUNCTION(imagesetstyle)
{
zval *IM, *styles;
gdImagePtr im;
int * stylearr;
int index;
HashPosition pos;

if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""ra"", &IM, &styles) == FAILURE)  {
return;
}

ZEND_FETCH_RESOURCE(im, gdImagePtr, &IM, -1, ""Image"", le_gd);

/* copy the style values in the stylearr */
stylearr = safe_emalloc(sizeof(int), zend_hash_num_elements(HASH_OF(styles)), 0);

zend_hash_internal_pointer_reset_ex(HASH_OF(styles), &pos);

for (index = 0;; zend_hash_move_forward_ex(HASH_OF(styles), &pos))	{
zval ** item;

if (zend_hash_get_current_data_ex(HASH_OF(styles), (void **) &item, &pos) == FAILURE) {
break;
}

		convert_to_long_ex(item);
		stylearr[index++] = Z_LVAL_PP(item);
}

gdImageSetStyle(im, stylearr, index);

efree(stylearr);

RETURN_TRUE;
}
","[20, 21]",		convert_to_long_ex(item);/~/		stylearr[index++] = Z_LVAL_PP(item);
187,"static void _out_result(conn_t out, nad_t nad) {
int attr;
jid_t from, to;
char *rkey;
int rkeylen;

attr = nad_find_attr(nad, 0, -1, ""from"", NULL);
if(attr < 0 || (from = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {
log_debug(ZONE, ""missing or invalid from on db result packet"");
nad_free(nad);
return;
}

attr = nad_find_attr(nad, 0, -1, ""to"", NULL);
if(attr < 0 || (to = jid_new(NAD_AVAL(nad, attr), NAD_AVAL_L(nad, attr))) == NULL) {
log_debug(ZONE, ""missing or invalid to on db result packet"");
jid_free(from);
nad_free(nad);
return;
}

rkey = s2s_route_key(NULL, to->domain, from->domain);
rkeylen = strlen(rkey);

/* key is valid */
    if(nad_find_attr(nad, 0, -1, ""type"", ""valid"") >= 0) {
log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] outgoing route '%s' is now valid%s%s"", out->fd->fd, out->ip, out->port, rkey, (out->s->flags & SX_SSL_WRAPPER) ? "", TLS negotiated"" : """", out->s->compressed ? "", ZLIB compression enabled"" : """");

xhash_put(out->states, pstrdup(xhash_pool(out->states), rkey), (void *) conn_VALID);    /* !!! small leak here */

log_debug(ZONE, ""%s valid, flushing queue"", rkey);

/* flush the queue */
out_flush_route_queue(out->s2s, rkey, rkeylen);

free(rkey);

jid_free(from);
jid_free(to);

nad_free(nad);

return;
}

/* invalid */
log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] outgoing route '%s' is now invalid"", out->fd->fd, out->ip, out->port, rkey);

/* close connection */
log_write(out->s2s->log, LOG_NOTICE, ""[%d] [%s, port=%d] closing connection"", out->fd->fd, out->ip, out->port);

/* report stream error */
sx_error(out->s, stream_err_INVALID_ID, ""dialback negotiation failed"");

/* close the stream */
sx_close(out->s);

/* bounce queue */
out_bounce_route_queue(out->s2s, rkey, rkeylen, stanza_err_SERVICE_UNAVAILABLE);

free(rkey);

jid_free(from);
jid_free(to);

nad_free(nad);
}
",[21],"    if(nad_find_attr(nad, 0, -1, ""type"", ""valid"") >= 0) {"
188,"void NavigationRequest::OnRequestRedirected(
const net::RedirectInfo& redirect_info,
const scoped_refptr<network::ResourceResponse>& response) {
response_ = response;
ssl_info_ = response->head.ssl_info;
#if defined(OS_ANDROID)
base::WeakPtr<NavigationRequest> this_ptr(weak_factory_.GetWeakPtr());

bool should_override_url_loading = false;
if (!GetContentClient()->browser()->ShouldOverrideUrlLoading(
frame_tree_node_->frame_tree_node_id(), browser_initiated_,
redirect_info.new_url, redirect_info.new_method,
// Redirects are always not counted as from user gesture.
false, true, frame_tree_node_->IsMainFrame(),
common_params_.transition, &should_override_url_loading)) {
// A Java exception was thrown by the embedding application; we
// need to return from this task. Specifically, it's not safe from
// this point on to make any JNI calls.
return;
}

// The content/ embedder might cause |this| to be deleted while
// |ShouldOverrideUrlLoading| is called.
// See https://crbug.com/770157.
if (!this_ptr)
return;

if (should_override_url_loading) {
navigation_handle_->set_net_error_code(net::ERR_ABORTED);
common_params_.url = redirect_info.new_url;
common_params_.method = redirect_info.new_method;
// Update the navigation handle to point to the new url to ensure
// AwWebContents sees the new URL and thus passes that URL to onPageFinished
// (rather than passing the old URL).
navigation_handle_->UpdateStateFollowingRedirect(
GURL(redirect_info.new_referrer),
base::Bind(&NavigationRequest::OnRedirectChecksComplete,
base::Unretained(this)));
frame_tree_node_->ResetNavigationRequest(false, true);
return;
}
#endif
if (!ChildProcessSecurityPolicyImpl::GetInstance()->CanRedirectToURL(
redirect_info.new_url)) {
DVLOG(1) << ""Denied redirect for ""
<< redirect_info.new_url.possibly_invalid_spec();
    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);
    frame_tree_node_->ResetNavigationRequest(false, true);
return;
}

// For renderer-initiated navigations we need to check if the source has
// access to the URL. Browser-initiated navigations only rely on the
// |CanRedirectToURL| test above.
if (!browser_initiated_ && source_site_instance() &&
!ChildProcessSecurityPolicyImpl::GetInstance()->CanRequestURL(
source_site_instance()->GetProcess()->GetID(),
redirect_info.new_url)) {
DVLOG(1) << ""Denied unauthorized redirect for ""
<< redirect_info.new_url.possibly_invalid_spec();
    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);
    frame_tree_node_->ResetNavigationRequest(false, true);
return;
}

// For now, DevTools needs the POST data sent to the renderer process even if
// it is no longer a POST after the redirect.
if (redirect_info.new_method != ""POST"")
common_params_.post_data = nullptr;

// Mark time for the Navigation Timing API.
if (commit_params_.navigation_timing.redirect_start.is_null()) {
commit_params_.navigation_timing.redirect_start =
commit_params_.navigation_timing.fetch_start;
}
commit_params_.navigation_timing.redirect_end = base::TimeTicks::Now();
commit_params_.navigation_timing.fetch_start = base::TimeTicks::Now();

commit_params_.redirect_response.push_back(response->head);
commit_params_.redirect_infos.push_back(redirect_info);

// On redirects, the initial origin_to_commit is no longer correct, so it
// must be cleared to avoid sending incorrect value to the renderer process.
if (commit_params_.origin_to_commit)
commit_params_.origin_to_commit.reset();

commit_params_.redirects.push_back(common_params_.url);
common_params_.url = redirect_info.new_url;
common_params_.method = redirect_info.new_method;
common_params_.referrer.url = GURL(redirect_info.new_referrer);
common_params_.referrer =
Referrer::SanitizeForRequest(common_params_.url, common_params_.referrer);

// Check Content Security Policy before the NavigationThrottles run. This
// gives CSP a chance to modify requests that NavigationThrottles would
// otherwise block.
net::Error net_error =
CheckContentSecurityPolicy(true /* has_followed_redirect */,
redirect_info.insecure_scheme_was_upgraded,
false /* is_response_check */);
if (net_error != net::OK) {
OnRequestFailedInternal(
network::URLLoaderCompletionStatus(net_error), false /*skip_throttles*/,
base::nullopt /*error_page_content*/, false /*collapse_frame*/);

// DO NOT ADD CODE after this. The previous call to OnRequestFailedInternal
// has destroyed the NavigationRequest.
return;
}

if (CheckCredentialedSubresource() ==
CredentialedSubresourceCheckResult::BLOCK_REQUEST ||
CheckLegacyProtocolInSubresource() ==
LegacyProtocolInSubresourceCheckResult::BLOCK_REQUEST) {
OnRequestFailedInternal(
network::URLLoaderCompletionStatus(net::ERR_ABORTED),
false /*skip_throttles*/, base::nullopt /*error_page_content*/,
false /*collapse_frame*/);

// DO NOT ADD CODE after this. The previous call to OnRequestFailedInternal
// has destroyed the NavigationRequest.
return;
}

// Compute the SiteInstance to use for the redirect and pass its
// RenderProcessHost if it has a process. Keep a reference if it has a
// process, so that the SiteInstance and its associated process aren't deleted
// before the navigation is ready to commit.
scoped_refptr<SiteInstance> site_instance =
frame_tree_node_->render_manager()->GetSiteInstanceForNavigationRequest(
*this);
speculative_site_instance_ =
site_instance->HasProcess() ? site_instance : nullptr;

// If the new site instance doesn't yet have a process, then tell the
// SpareRenderProcessHostManager so it can decide whether to start warming up
// the spare at this time (note that the actual behavior depends on
// RenderProcessHostImpl::IsSpareProcessKeptAtAllTimes).
if (!site_instance->HasProcess()) {
RenderProcessHostImpl::NotifySpareManagerAboutRecentlyUsedBrowserContext(
site_instance->GetBrowserContext());
}

// Re-evaluate the PreviewsState, but do not update the URLLoader. The
// URLLoader PreviewsState is considered immutable after the URLLoader is
// created.
common_params_.previews_state =
GetContentClient()->browser()->DetermineAllowedPreviews(
common_params_.previews_state, navigation_handle_.get(),
common_params_.url);

// Check what the process of the SiteInstance is. It will be passed to the
// NavigationHandle, and informed to expect a navigation to the redirected
// URL.
// Note: calling GetProcess on the SiteInstance can lead to the creation of a
// new process if it doesn't have one. In this case, it should only be called
// on a SiteInstance that already has a process.
RenderProcessHost* expected_process =
site_instance->HasProcess() ? site_instance->GetProcess() : nullptr;

// It's safe to use base::Unretained because this NavigationRequest owns the
// NavigationHandle where the callback will be stored.
navigation_handle_->WillRedirectRequest(
common_params_.referrer.url, expected_process,
base::Bind(&NavigationRequest::OnRedirectChecksComplete,
base::Unretained(this)));
}
",[35],"    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);/~/    frame_tree_node_->ResetNavigationRequest(false, true);/~/    navigation_handle_->set_net_error_code(net::ERR_UNSAFE_REDIRECT);/~/    frame_tree_node_->ResetNavigationRequest(false, true);"
189,"void FileBrowserHandlerCustomBindings::GetExternalFileEntry(
    const v8::FunctionCallbackInfo<v8::Value>& args) {
  // TODO(zelidrag): Make this magic work on other platforms when file browser
  // matures enough on ChromeOS.
#if defined(OS_CHROMEOS)
CHECK(args.Length() == 1);
CHECK(args[0]->IsObject());
v8::Local<v8::Object> file_def = args[0]->ToObject();
std::string file_system_name(
*v8::String::Utf8Value(file_def->Get(
v8::String::NewFromUtf8(args.GetIsolate(), ""fileSystemName""))));
GURL file_system_root(
*v8::String::Utf8Value(file_def->Get(
v8::String::NewFromUtf8(args.GetIsolate(), ""fileSystemRoot""))));
std::string file_full_path(
*v8::String::Utf8Value(file_def->Get(
v8::String::NewFromUtf8(args.GetIsolate(), ""fileFullPath""))));
bool is_directory = file_def->Get(v8::String::NewFromUtf8(
args.GetIsolate(), ""fileIsDirectory""))->ToBoolean()->Value();
blink::WebDOMFileSystem::EntryType entry_type =
is_directory ? blink::WebDOMFileSystem::EntryTypeDirectory
: blink::WebDOMFileSystem::EntryTypeFile;
blink::WebLocalFrame* webframe =
        blink::WebLocalFrame::frameForContext(context()->v8_context());
args.GetReturnValue().Set(
blink::WebDOMFileSystem::create(
webframe,
blink::WebFileSystemTypeExternal,
blink::WebString::fromUTF8(file_system_name),
file_system_root)
.createV8Entry(blink::WebString::fromUTF8(file_full_path),
entry_type,
args.Holder(),
args.GetIsolate()));
#endif
}
","[1, 2, 3, 23]",    const v8::FunctionCallbackInfo<v8::Value>& args) {/~/  // TODO(zelidrag): Make this magic work on other platforms when file browser/~/  // matures enough on ChromeOS./~/        blink::WebLocalFrame::frameForContext(context()->v8_context());
190,"atm_if_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, const u_char *p)
{
u_int caplen = h->caplen;
u_int length = h->len;
uint32_t llchdr;
u_int hdrlen = 0;

if (caplen < 1 || length < 1) {
ND_PRINT((ndo, ""%s"", tstr));
return (caplen);
}

/* Cisco Style NLPID ? */
if (*p == LLC_UI) {
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""CNLPID ""));
            isoclns_print(ndo, p + 1, length - 1, caplen - 1);
return hdrlen;
}

/*
* Must have at least a DSAP, an SSAP, and the first byte of the
* control field.
*/
if (caplen < 3 || length < 3) {
ND_PRINT((ndo, ""%s"", tstr));
return (caplen);
}

/*
* Extract the presumed LLC header into a variable, for quick
* testing.
* Then check for a header that's neither a header for a SNAP
* packet nor an RFC 2684 routed NLPID-formatted PDU nor
* an 802.2-but-no-SNAP IP packet.
*/
llchdr = EXTRACT_24BITS(p);
if (llchdr != LLC_UI_HDR(LLCSAP_SNAP) &&
llchdr != LLC_UI_HDR(LLCSAP_ISONS) &&
llchdr != LLC_UI_HDR(LLCSAP_IP)) {
/*
* XXX - assume 802.6 MAC header from Fore driver.
*
* Unfortunately, the above list doesn't check for
* all known SAPs, doesn't check for headers where
* the source and destination SAP aren't the same,
* and doesn't check for non-UI frames.  It also
* runs the risk of an 802.6 MAC header that happens
* to begin with one of those values being
* incorrectly treated as an 802.2 header.
*
* So is that Fore driver still around?  And, if so,
* is it still putting 802.6 MAC headers on ATM
* packets?  If so, could it be changed to use a
* new DLT_IEEE802_6 value if we added it?
*/
if (caplen < 20 || length < 20) {
ND_PRINT((ndo, ""%s"", tstr));
return (caplen);
}
if (ndo->ndo_eflag)
ND_PRINT((ndo, ""%08x%08x %08x%08x "",
EXTRACT_32BITS(p),
EXTRACT_32BITS(p+4),
EXTRACT_32BITS(p+8),
EXTRACT_32BITS(p+12)));
p += 20;
length -= 20;
caplen -= 20;
hdrlen += 20;
}
hdrlen += atm_llc_print(ndo, p, length, caplen);
return (hdrlen);
}
",[15],"            isoclns_print(ndo, p + 1, length - 1, caplen - 1);"
191,"size_t compile_tree(struct filter_op **fop)
{
int i = 1;
struct filter_op *array = NULL;
struct unfold_elm *ue;

   BUG_IF(tree_root == NULL);

fprintf(stdout, "" Unfolding the meta-tree "");
fflush(stdout);

/* start the recursion on the tree */
unfold_blk(&tree_root);

fprintf(stdout, "" done.\n\n"");

/* substitute the virtual labels with real offsets */
labels_to_offsets();

/* convert the tailq into an array */
TAILQ_FOREACH(ue, &unfolded_tree, next) {

/* label == 0 means a real instruction */
if (ue->label == 0) {
SAFE_REALLOC(array, i * sizeof(struct filter_op));
memcpy(&array[i - 1], &ue->fop, sizeof(struct filter_op));
i++;
}
}

/* always append the exit function to a script */
SAFE_REALLOC(array, i * sizeof(struct filter_op));
array[i - 1].opcode = FOP_EXIT;

/* return the pointer to the array */
*fop = array;

return (i);
}
",[5],   BUG_IF(tree_root == NULL);
192,"static int kvm_vm_ioctl_set_pit2(struct kvm *kvm, struct kvm_pit_state2 *ps)
{
int start = 0;
u32 prev_legacy, cur_legacy;
mutex_lock(&kvm->arch.vpit->pit_state.lock);
prev_legacy = kvm->arch.vpit->pit_state.flags & KVM_PIT_FLAGS_HPET_LEGACY;
cur_legacy = ps->flags & KVM_PIT_FLAGS_HPET_LEGACY;
if (!prev_legacy && cur_legacy)
start = 1;
memcpy(&kvm->arch.vpit->pit_state.channels, &ps->channels,
sizeof(kvm->arch.vpit->pit_state.channels));
kvm->arch.vpit->pit_state.flags = ps->flags;
	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);
mutex_unlock(&kvm->arch.vpit->pit_state.lock);
return 0;
}
",[12],"	kvm_pit_load_count(kvm, 0, kvm->arch.vpit->pit_state.channels[0].count, start);"
193,"jas_image_t *bmp_decode(jas_stream_t *in, char *optstr)
{
jas_image_t *image;
bmp_hdr_t hdr;
bmp_info_t *info;
uint_fast16_t cmptno;
jas_image_cmptparm_t cmptparms[3];
jas_image_cmptparm_t *cmptparm;
uint_fast16_t numcmpts;
long n;

if (optstr) {
jas_eprintf(""warning: ignoring BMP decoder options\n"");
}

jas_eprintf(
""THE BMP FORMAT IS NOT FULLY SUPPORTED!\n""
""THAT IS, THE JASPER SOFTWARE CANNOT DECODE ALL TYPES OF BMP DATA.\n""
""IF YOU HAVE ANY PROBLEMS, PLEASE TRY CONVERTING YOUR IMAGE DATA\n""
""TO THE PNM FORMAT, AND USING THIS FORMAT INSTEAD.\n""
);

/* Read the bitmap header. */
if (bmp_gethdr(in, &hdr)) {
jas_eprintf(""cannot get header\n"");
		return 0;
}
JAS_DBGLOG(1, (
""BMP header: magic 0x%x; siz %d; res1 %d; res2 %d; off %d\n"",
hdr.magic, hdr.siz, hdr.reserved1, hdr.reserved2, hdr.off
));

/* Read the bitmap information. */
if (!(info = bmp_getinfo(in))) {
jas_eprintf(""cannot get info\n"");
		return 0;
}
JAS_DBGLOG(1,
	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""
	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""
	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,
	  info->depth, info->enctype, info->siz, info->hres, info->vres,
	  info->numcolors, info->mincolors));

/* Ensure that we support this type of BMP file. */
if (!bmp_issupported(&hdr, info)) {
jas_eprintf(""error: unsupported BMP encoding\n"");
		bmp_info_destroy(info);
		return 0;
}

/* Skip over any useless data between the end of the palette
and start of the bitmap data. */
if ((n = hdr.off - (BMP_HDRLEN + BMP_INFOLEN + BMP_PALLEN(info))) < 0) {
jas_eprintf(""error: possibly bad bitmap offset?\n"");
		return 0;
}
if (n > 0) {
jas_eprintf(""skipping unknown data in BMP file\n"");
if (bmp_gobble(in, n)) {
			bmp_info_destroy(info);
			return 0;
}
}

/* Get the number of components. */
numcmpts = bmp_numcmpts(info);

for (cmptno = 0, cmptparm = cmptparms; cmptno < numcmpts; ++cmptno,
++cmptparm) {
cmptparm->tlx = 0;
cmptparm->tly = 0;
cmptparm->hstep = 1;
cmptparm->vstep = 1;
cmptparm->width = info->width;
cmptparm->height = info->height;
cmptparm->prec = 8;
cmptparm->sgnd = false;
}

/* Create image object. */
if (!(image = jas_image_create(numcmpts, cmptparms,
JAS_CLRSPC_UNKNOWN))) {
		bmp_info_destroy(info);
		return 0;
}

if (numcmpts == 3) {
jas_image_setclrspc(image, JAS_CLRSPC_SRGB);
jas_image_setcmpttype(image, 0,
JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_R));
jas_image_setcmpttype(image, 1,
JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_G));
jas_image_setcmpttype(image, 2,
JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_RGB_B));
} else {
jas_image_setclrspc(image, JAS_CLRSPC_SGRAY);
jas_image_setcmpttype(image, 0,
JAS_IMAGE_CT_COLOR(JAS_CLRSPC_CHANIND_GRAY_Y));
}

/* Read the bitmap data. */
if (bmp_getdata(in, info, image)) {
		bmp_info_destroy(info);
		jas_image_destroy(image);
		return 0;
}

bmp_info_destroy(info);

return image;
}
","[22, 31, 34, 35]","		return 0;/~/		return 0;/~/	  (""BMP information: len %d; width %d; height %d; numplanes %d; ""/~/	  ""depth %d; enctype %d; siz %d; hres %d; vres %d; numcolors %d; ""/~/	  ""mincolors %d\n"", info->len, info->width, info->height, info->numplanes,/~/	  info->depth, info->enctype, info->siz, info->hres, info->vres,/~/	  info->numcolors, info->mincolors));/~/		bmp_info_destroy(info);/~/		return 0;/~/		return 0;/~/			bmp_info_destroy(info);/~/			return 0;/~/		bmp_info_destroy(info);/~/		return 0;/~/		bmp_info_destroy(info);/~/		jas_image_destroy(image);/~/		return 0;"
194,"void ProcessControlLaunched() {
base::ScopedAllowBlockingForTesting allow_blocking;
base::ProcessId service_pid;
EXPECT_TRUE(GetServiceProcessData(NULL, &service_pid));
EXPECT_NE(static_cast<base::ProcessId>(0), service_pid);
#if defined(OS_WIN)
service_process_ =
base::Process::OpenWithAccess(service_pid,
SYNCHRONIZE | PROCESS_QUERY_INFORMATION);
#else
service_process_ = base::Process::Open(service_pid);
#endif
EXPECT_TRUE(service_process_.IsValid());
    // Quit the current message. Post a QuitTask instead of just calling Quit()
    // because this can get invoked in the context of a Launch() call and we
    // may not be in Run() yet.
    base::ThreadTaskRunnerHandle::Get()->PostTask(
        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());
}
","[13, 14, 15, 16, 17]","    // Quit the current message. Post a QuitTask instead of just calling Quit()/~/    // because this can get invoked in the context of a Launch() call and we/~/    // may not be in Run() yet./~/    base::ThreadTaskRunnerHandle::Get()->PostTask(/~/        FROM_HERE, base::RunLoop::QuitCurrentWhenIdleClosureDeprecated());"
195,"static int dccp_packet(struct nf_conn *ct, const struct sk_buff *skb,
unsigned int dataoff, enum ip_conntrack_info ctinfo,
u_int8_t pf, unsigned int hooknum,
unsigned int *timeouts)
{
struct net *net = nf_ct_net(ct);
enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
struct dccp_hdr _dh, *dh;
u_int8_t type, old_state, new_state;
enum ct_dccp_roles role;

	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);
BUG_ON(dh == NULL);
type = dh->dccph_type;

if (type == DCCP_PKT_RESET &&
!test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
/* Tear down connection immediately if only reply is a RESET */
nf_ct_kill_acct(ct, ctinfo, skb);
return NF_ACCEPT;
}

spin_lock_bh(&ct->lock);

role = ct->proto.dccp.role[dir];
old_state = ct->proto.dccp.state;
new_state = dccp_state_table[role][type][old_state];

switch (new_state) {
case CT_DCCP_REQUEST:
if (old_state == CT_DCCP_TIMEWAIT &&
role == CT_DCCP_ROLE_SERVER) {
/* Reincarnation in the reverse direction: reopen and
* reverse client/server roles. */
ct->proto.dccp.role[dir] = CT_DCCP_ROLE_CLIENT;
ct->proto.dccp.role[!dir] = CT_DCCP_ROLE_SERVER;
}
break;
case CT_DCCP_RESPOND:
if (old_state == CT_DCCP_REQUEST)
ct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);
break;
case CT_DCCP_PARTOPEN:
if (old_state == CT_DCCP_RESPOND &&
type == DCCP_PKT_ACK &&
dccp_ack_seq(dh) == ct->proto.dccp.handshake_seq)
set_bit(IPS_ASSURED_BIT, &ct->status);
break;
case CT_DCCP_IGNORE:
/*
* Connection tracking might be out of sync, so we ignore
* packets that might establish a new connection and resync
* if the server responds with a valid Response.
*/
if (ct->proto.dccp.last_dir == !dir &&
ct->proto.dccp.last_pkt == DCCP_PKT_REQUEST &&
type == DCCP_PKT_RESPONSE) {
ct->proto.dccp.role[!dir] = CT_DCCP_ROLE_CLIENT;
ct->proto.dccp.role[dir] = CT_DCCP_ROLE_SERVER;
ct->proto.dccp.handshake_seq = dccp_hdr_seq(dh);
new_state = CT_DCCP_RESPOND;
break;
}
ct->proto.dccp.last_dir = dir;
ct->proto.dccp.last_pkt = type;

spin_unlock_bh(&ct->lock);
if (LOG_INVALID(net, IPPROTO_DCCP))
nf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,
""nf_ct_dccp: invalid packet ignored "");
return NF_ACCEPT;
case CT_DCCP_INVALID:
spin_unlock_bh(&ct->lock);
if (LOG_INVALID(net, IPPROTO_DCCP))
nf_log_packet(net, pf, 0, skb, NULL, NULL, NULL,
""nf_ct_dccp: invalid state transition "");
return -NF_ACCEPT;
}

ct->proto.dccp.last_dir = dir;
ct->proto.dccp.last_pkt = type;
ct->proto.dccp.state = new_state;
spin_unlock_bh(&ct->lock);

if (new_state != old_state)
nf_conntrack_event_cache(IPCT_PROTOINFO, ct);

nf_ct_refresh_acct(ct, ctinfo, skb, timeouts[new_state]);

return NF_ACCEPT;
}
",[10],"	dh = skb_header_pointer(skb, dataoff, sizeof(_dh), &dh);"
196,"void TextTrack::addCue(TextTrackCue* cue) {
DCHECK(cue);

  // TODO(93143): Add spec-compliant behavior for negative time values.
  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||
      cue->startTime() < 0 || cue->endTime() < 0)
return;

// https://html.spec.whatwg.org/multipage/embedded-content.html#dom-texttrack-addcue

// The addCue(cue) method of TextTrack objects, when invoked, must run the
// following steps:

// (Steps 1 and 2 - pertaining to association of rendering rules - are not
// implemented.)

// 3. If the given cue is in a text track list of cues, then remove cue
// from that text track list of cues.
if (TextTrack* cue_track = cue->track())
cue_track->removeCue(cue, ASSERT_NO_EXCEPTION);

// 4. Add cue to the method's TextTrack object's text track's text track list
// of cues.
cue->SetTrack(this);
EnsureTextTrackCueList()->Add(cue);

if (GetCueTimeline() && mode_ != DisabledKeyword())
GetCueTimeline()->AddCue(this, cue);
}
","[2, 3, 4]",  // TODO(93143): Add spec-compliant behavior for negative time values./~/  if (std::isnan(cue->startTime()) || std::isnan(cue->endTime()) ||/~/      cue->startTime() < 0 || cue->endTime() < 0)
197,"static int iwch_l2t_send(struct t3cdev *tdev, struct sk_buff *skb, struct l2t_entry *l2e)
{
int	error = 0;
struct cxio_rdev *rdev;

rdev = (struct cxio_rdev *)tdev->ulp;
if (cxio_fatal_error(rdev)) {
kfree_skb(skb);
return -EIO;
}
error = l2t_send(tdev, skb, l2e);
if (error < 0)
kfree_skb(skb);
	return error;
}
",[13],	return error;
198,"static int mem_resize(jas_stream_memobj_t *m, int bufsize)
{
unsigned char *buf;

//assert(m->buf_);
	assert(bufsize >= 0);

	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));
if (!(buf = jas_realloc2(m->buf_, bufsize, sizeof(unsigned char))) &&
bufsize) {
JAS_DBGLOG(100, (""mem_resize realloc failed\n""));
return -1;
}
JAS_DBGLOG(100, (""mem_resize realloc succeeded\n""));
m->buf_ = buf;
m->bufsize_ = bufsize;
return 0;
}
","[4, 5]","	assert(bufsize >= 0);/~/	JAS_DBGLOG(100, (""mem_resize(%p, %d)\n"", m, bufsize));"
199,"bool ChildProcessSecurityPolicyImpl::CanSetAsOriginHeader(int child_id,
const GURL& url) {
if (!url.is_valid())
return false;  // Can't set invalid URLs as origin headers.

// about:srcdoc cannot be used as an origin
if (url == kAboutSrcDocURL)
return false;

// If this process can commit |url|, it can use |url| as an origin for
// outbound requests.
  if (CanCommitURL(child_id, url))
return true;

// Allow schemes which may come from scripts executing in isolated worlds;
// XHRs issued by such scripts reflect the script origin rather than the
// document origin.
{
base::AutoLock lock(lock_);
if (base::ContainsKey(schemes_okay_to_appear_as_origin_headers_,
url.scheme())) {
return true;
}
}
return false;
}
",[9],"  if (CanCommitURL(child_id, url))"
200,"struct sk_buff **udp_gro_receive(struct sk_buff **head, struct sk_buff *skb,
struct udphdr *uh)
{
struct udp_offload_priv *uo_priv;
struct sk_buff *p, **pp = NULL;
struct udphdr *uh2;
unsigned int off = skb_gro_offset(skb);
int flush = 1;

	if (NAPI_GRO_CB(skb)->udp_mark ||
(skb->ip_summed != CHECKSUM_PARTIAL &&
NAPI_GRO_CB(skb)->csum_cnt == 0 &&
!NAPI_GRO_CB(skb)->csum_valid))
goto out;

	/* mark that this skb passed once through the udp gro layer *
	NAPI_GRO_CB(skb)->udp_mark = 1;

rcu_read_lock();
uo_priv = rcu_dereference(udp_offload_base);
for (; uo_priv != NULL; uo_priv = rcu_dereference(uo_priv->next)) {
if (net_eq(read_pnet(&uo_priv->net), dev_net(skb->dev)) &&
uo_priv->offload->port == uh->dest &&
uo_priv->offload->callbacks.gro_receive)
goto unflush;
}
goto out_unlock;

unflush:
flush = 0;

for (p = *head; p; p = p->next) {
if (!NAPI_GRO_CB(p)->same_flow)
continue;

uh2 = (struct udphdr   *)(p->data + off);

/* Match ports and either checksums are either both zero
* or nonzero.
*/
if ((*(u32 *)&uh->source != *(u32 *)&uh2->source) ||
(!uh->check ^ !uh2->check)) {
NAPI_GRO_CB(p)->same_flow = 0;
continue;
}
}

skb_gro_pull(skb, sizeof(struct udphdr)); /* pull encapsulating udp header */
skb_gro_postpull_rcsum(skb, uh, sizeof(struct udphdr));
NAPI_GRO_CB(skb)->proto = uo_priv->offload->ipproto;
pp = uo_priv->offload->callbacks.gro_receive(head, skb,
uo_priv->offload);

out_unlock:
rcu_read_unlock();
out:
NAPI_GRO_CB(skb)->flush |= flush;
return pp;
}
","[8, 13, 14]",	if (NAPI_GRO_CB(skb)->udp_mark ||/~/	/* mark that this skb passed once through the udp gro layer */~/	NAPI_GRO_CB(skb)->udp_mark = 1;
201,"EncodedJSValue JSC_HOST_CALL JSTestObjConstructor::constructJSTestObj(ExecState* exec)
{
JSTestObjConstructor* castedThis = jsCast<JSTestObjConstructor*>(exec->callee());
if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
if (exec->argumentCount() <= 0 || !exec->argument(0).isFunction()) {
setDOMException(exec, TYPE_MISMATCH_ERR);
return JSValue::encode(jsUndefined());
}
RefPtr<TestCallback> testCallback = JSTestCallback::create(asObject(exec->argument(0)), castedThis->globalObject());
RefPtr<TestObj> object = TestObj::create(testCallback);
return JSValue::encode(asObject(toJS(exec, castedThis->globalObject(), object.get())));
}
",[4],"        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));"
202,"check_1_6_dummy(kadm5_principal_ent_t entry, long mask,
int n_ks_tuple, krb5_key_salt_tuple *ks_tuple, char **passptr)
{
int i;
char *password = *passptr;

/* Old-style randkey operations disallowed tickets to start. */
    if (!(mask & KADM5_ATTRIBUTES) ||
!(entry->attributes & KRB5_KDB_DISALLOW_ALL_TIX))
return;

/* The 1.6 dummy password was the octets 1..255. */
for (i = 0; (unsigned char) password[i] == i + 1; i++);
if (password[i] != '\0' || i != 255)
return;

/* This will make the caller use a random password instead. */
*passptr = NULL;
}
",[6],    if (!(mask & KADM5_ATTRIBUTES) ||
203,"void AllocateDataSet(cmsIT8* it8)
{
TABLE* t = GetTable(it8);

if (t -> Data) return;    // Already allocated

t-> nSamples   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_FIELDS""));
t-> nPatches   = atoi(cmsIT8GetProperty(it8, ""NUMBER_OF_SETS""));

    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));
    if (t->Data == NULL) {

        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");
}

}
","[6, 7, 8]","    t-> Data = (char**)AllocChunk (it8, ((cmsUInt32Number) t->nSamples + 1) * ((cmsUInt32Number) t->nPatches + 1) *sizeof (char*));/~/    if (t->Data == NULL) {/~/        SynError(it8, ""AllocateDataSet: Unable to allocate data array"");"
204,"bool AXNodeObject::isModal() const {
if (roleValue() != DialogRole && roleValue() != AlertDialogRole)
return false;

if (hasAttribute(aria_modalAttr)) {
const AtomicString& modal = getAttribute(aria_modalAttr);
    if (equalIgnoringCase(modal, ""true""))
return true;
    if (equalIgnoringCase(modal, ""false""))
return false;
}

if (getNode() && isHTMLDialogElement(*getNode()))
return toElement(getNode())->isInTopLayer();

return false;
}
","[5, 7]","    if (equalIgnoringCase(modal, ""true""))/~/    if (equalIgnoringCase(modal, ""false""))"
205,"base::string16 GetApplicationNameForProtocol(const GURL& url) {
  base::string16 application_name;
// Windows 8 or above has a new protocol association query.
if (base::win::GetVersion() >= base::win::VERSION_WIN8) {
    application_name = GetAppForProtocolUsingAssocQuery(url);
if (!application_name.empty())
return application_name;
}

return GetAppForProtocolUsingRegistry(url);
}
","[1, 4]",  base::string16 application_name;/~/    application_name = GetAppForProtocolUsingAssocQuery(url);
206,"static v8::Handle<v8::Value> convert4Callback(const v8::Arguments& args)
{
INC_STATS(""DOM.TestObj.convert4"");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(d*, , V8d::HasInstance(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)) ? V8d::toNative(v8::Handle<v8::Object>::Cast(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined))) : 0);
imp->convert4();
return v8::Handle<v8::Value>();
}
",[4],        return V8Proxy::throwNotEnoughArgumentsError();
207,"kdc_process_for_user(kdc_realm_t *kdc_active_realm,
krb5_pa_data *pa_data,
krb5_keyblock *tgs_session,
krb5_pa_s4u_x509_user **s4u_x509_user,
const char **status)
{
krb5_error_code             code;
krb5_pa_for_user            *for_user;
krb5_data                   req_data;

req_data.length = pa_data->length;
req_data.data = (char *)pa_data->contents;

code = decode_krb5_pa_for_user(&req_data, &for_user);
    if (code)
return code;

code = verify_for_user_checksum(kdc_context, tgs_session, for_user);
if (code) {
*status = ""INVALID_S4U2SELF_CHECKSUM"";
krb5_free_pa_for_user(kdc_context, for_user);
return code;
}

*s4u_x509_user = calloc(1, sizeof(krb5_pa_s4u_x509_user));
if (*s4u_x509_user == NULL) {
krb5_free_pa_for_user(kdc_context, for_user);
return ENOMEM;
}

(*s4u_x509_user)->user_id.user = for_user->user;
for_user->user = NULL;
krb5_free_pa_for_user(kdc_context, for_user);

return 0;
}
",[12],    if (code)
208,"void RenderWidgetHostImpl::DidNavigate(uint32_t next_source_id) {
current_content_source_id_ = next_source_id;
did_receive_first_frame_after_navigation_ = false;

if (enable_surface_synchronization_) {
// Resize messages before navigation are not acked, so reset
// |visual_properties_ack_pending_| and make sure the next resize will be
// acked if the last resize before navigation was supposed to be acked.
visual_properties_ack_pending_ = false;
    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();
if (view_)
view_->DidNavigate();
    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();
    // If |view_| didn't allocate a new surface id, then don't start
    // |new_content_rendering_timeout_|. Two reasons:
    //  1. It's not needed (because this was the first navigation event)
    //  2. If we don't change the surface id, then we will not get the call to
    //     OnFirstSurfaceActivation, and not stop the timer (even if we get new
    //     frames).
    // https://crbug.com/853651, https://crbug.com/535375
    if (old_surface_id == new_surface_id)
      return;
} else {
// It is possible for a compositor frame to arrive before the browser is
// notified about the page being committed, in which case no timer is
// necessary.
if (last_received_content_source_id_ >= current_content_source_id_)
return;
}

if (!new_content_rendering_timeout_)
return;

new_content_rendering_timeout_->Start(new_content_rendering_delay_);
}
","[8, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 26, 29]","    viz::LocalSurfaceId old_surface_id = view_->GetLocalSurfaceId();/~/    viz::LocalSurfaceId new_surface_id = view_->GetLocalSurfaceId();/~/    // If |view_| didn't allocate a new surface id, then don't start/~/    // |new_content_rendering_timeout_|. Two reasons:/~/    //  1. It's not needed (because this was the first navigation event)/~/    //  2. If we don't change the surface id, then we will not get the call to/~/    //     OnFirstSurfaceActivation, and not stop the timer (even if we get new/~/    //     frames)./~/    // https://crbug.com/853651, https://crbug.com/535375/~/    if (old_surface_id == new_surface_id)/~/      return;"
209,"static void oz_usb_handle_ep_data(struct oz_usb_ctx *usb_ctx,
struct oz_usb_hdr *usb_hdr, int len)
{
struct oz_data *data_hdr = (struct oz_data *)usb_hdr;

switch (data_hdr->format) {
case OZ_DATA_F_MULTIPLE_FIXED: {
struct oz_multiple_fixed *body =
(struct oz_multiple_fixed *)data_hdr;
u8 *data = body->data;
			int n = (len - sizeof(struct oz_multiple_fixed)+1)
/ body->unit_size;
while (n--) {
oz_hcd_data_ind(usb_ctx->hport, body->endpoint,
data, body->unit_size);
data += body->unit_size;
}
}
break;
case OZ_DATA_F_ISOC_FIXED: {
struct oz_isoc_fixed *body =
(struct oz_isoc_fixed *)data_hdr;
int data_len = len-sizeof(struct oz_isoc_fixed)+1;
int unit_size = body->unit_size;
u8 *data = body->data;
int count;
int i;

if (!unit_size)
break;
count = data_len/unit_size;
for (i = 0; i < count; i++) {
oz_hcd_data_ind(usb_ctx->hport,
body->endpoint, data, unit_size);
data += unit_size;
}
}
break;
}

}
",[9],			int n = (len - sizeof(struct oz_multiple_fixed)+1)
210,"void ThreadableBlobRegistry::registerBlobURL(SecurityOrigin* origin, const KURL& url, const KURL& srcURL)
{
// If the blob URL contains null origin, as in the context with unique
// security origin or file URL, save the mapping between url and origin so
// that the origin can be retrived when doing security origin check.
if (origin && BlobURL::getOrigin(url) == ""null"")
originMap()->add(url.string(), origin);

    if (isMainThread())
        blobRegistry().registerBlobURL(url, srcURL);
    else {
OwnPtr<BlobRegistryContext> context = adoptPtr(new BlobRegistryContext(url, srcURL));
callOnMainThread(&registerBlobURLFromTask, context.leakPtr());
}
}
","[7, 8, 9]","    if (isMainThread())/~/        blobRegistry().registerBlobURL(url, srcURL);/~/    else {"
211,"loadImage(TIFF* in, struct image_data *image, struct dump_opts *dump, unsigned char **read_ptr)
{
uint32   i;
float    xres = 0.0, yres = 0.0;
  uint16   nstrips = 0, ntiles = 0, planar = 0;
uint16   bps = 0, spp = 0, res_unit = 0;
uint16   orientation = 0;
uint16   input_compression = 0, input_photometric = 0;
uint16   subsampling_horiz, subsampling_vert;
uint32   width = 0, length = 0;
uint32   stsize = 0, tlsize = 0, buffsize = 0, scanlinesize = 0;
uint32   tw = 0, tl = 0;       /* Tile width and length */
uint32   tile_rowsize = 0;
unsigned char *read_buff = NULL;
unsigned char *new_buff  = NULL;
int      readunit = 0;
static   uint32  prev_readsize = 0;

TIFFGetFieldDefaulted(in, TIFFTAG_BITSPERSAMPLE, &bps);
TIFFGetFieldDefaulted(in, TIFFTAG_SAMPLESPERPIXEL, &spp);
TIFFGetFieldDefaulted(in, TIFFTAG_PLANARCONFIG, &planar);
TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
if (! TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric))
TIFFError(""loadImage"",""Image lacks Photometric interpreation tag"");
if (! TIFFGetField(in, TIFFTAG_IMAGEWIDTH,  &width))
TIFFError(""loadimage"",""Image lacks image width tag"");
if(! TIFFGetField(in, TIFFTAG_IMAGELENGTH, &length))
TIFFError(""loadimage"",""Image lacks image length tag"");
TIFFGetFieldDefaulted(in, TIFFTAG_XRESOLUTION, &xres);
TIFFGetFieldDefaulted(in, TIFFTAG_YRESOLUTION, &yres);
if (!TIFFGetFieldDefaulted(in, TIFFTAG_RESOLUTIONUNIT, &res_unit))
res_unit = RESUNIT_INCH;
if (!TIFFGetField(in, TIFFTAG_COMPRESSION, &input_compression))
input_compression = COMPRESSION_NONE;

#ifdef DEBUG2
char compressionid[16];

switch (input_compression)
{
case COMPRESSION_NONE:	/* 1  dump mode */
strcpy (compressionid, ""None/dump"");
break;
case COMPRESSION_CCITTRLE:	  /* 2 CCITT modified Huffman RLE */
strcpy (compressionid, ""Huffman RLE"");
break;
case COMPRESSION_CCITTFAX3:	  /* 3 CCITT Group 3 fax encoding */
strcpy (compressionid, ""Group3 Fax"");
break;
case COMPRESSION_CCITTFAX4:	  /* 4 CCITT Group 4 fax encoding */
strcpy (compressionid, ""Group4 Fax"");
break;
case COMPRESSION_LZW:	  /* 5 Lempel-Ziv  & Welch */
strcpy (compressionid, ""LZW"");
break;
case COMPRESSION_OJPEG:	  /* 6 !6.0 JPEG */
strcpy (compressionid, ""Old Jpeg"");
break;
case COMPRESSION_JPEG:	  /* 7 %JPEG DCT compression */
strcpy (compressionid, ""New Jpeg"");
break;
case COMPRESSION_NEXT:	  /* 32766 NeXT 2-bit RLE */
strcpy (compressionid, ""Next RLE"");
break;
case COMPRESSION_CCITTRLEW:   /* 32771 #1 w/ word alignment */
strcpy (compressionid, ""CITTRLEW"");
break;
case COMPRESSION_PACKBITS:	  /* 32773 Macintosh RLE */
strcpy (compressionid, ""Mac Packbits"");
break;
case COMPRESSION_THUNDERSCAN: /* 32809 ThunderScan RLE */
strcpy (compressionid, ""Thunderscan"");
break;
case COMPRESSION_IT8CTPAD:	  /* 32895 IT8 CT w/padding */
strcpy (compressionid, ""IT8 padded"");
break;
case COMPRESSION_IT8LW:	  /* 32896 IT8 Linework RLE */
strcpy (compressionid, ""IT8 RLE"");
break;
case COMPRESSION_IT8MP:	  /* 32897 IT8 Monochrome picture */
strcpy (compressionid, ""IT8 mono"");
break;
case COMPRESSION_IT8BL:	  /* 32898 IT8 Binary line art */
strcpy (compressionid, ""IT8 lineart"");
break;
case COMPRESSION_PIXARFILM:	  /* 32908 Pixar companded 10bit LZW */
strcpy (compressionid, ""Pixar 10 bit"");
break;
case COMPRESSION_PIXARLOG:	  /* 32909 Pixar companded 11bit ZIP */
strcpy (compressionid, ""Pixar 11bit"");
break;
case COMPRESSION_DEFLATE:	  /* 32946 Deflate compression */
strcpy (compressionid, ""Deflate"");
break;
case COMPRESSION_ADOBE_DEFLATE: /* 8 Deflate compression */
strcpy (compressionid, ""Adobe deflate"");
break;
default:
strcpy (compressionid, ""None/unknown"");
break;
}
TIFFError(""loadImage"", ""Input compression %s"", compressionid);
#endif

scanlinesize = TIFFScanlineSize(in);
image->bps = bps;
image->spp = spp;
image->planar = planar;
image->width = width;
image->length = length;
image->xres = xres;
image->yres = yres;
image->res_unit = res_unit;
image->compression = input_compression;
image->photometric = input_photometric;
#ifdef DEBUG2
char photometricid[12];

switch (input_photometric)
{
case PHOTOMETRIC_MINISWHITE:
strcpy (photometricid, ""MinIsWhite"");
break;
case PHOTOMETRIC_MINISBLACK:
strcpy (photometricid, ""MinIsBlack"");
break;
case PHOTOMETRIC_RGB:
strcpy (photometricid, ""RGB"");
break;
case PHOTOMETRIC_PALETTE:
strcpy (photometricid, ""Palette"");
break;
case PHOTOMETRIC_MASK:
strcpy (photometricid, ""Mask"");
break;
case PHOTOMETRIC_SEPARATED:
strcpy (photometricid, ""Separated"");
break;
case PHOTOMETRIC_YCBCR:
strcpy (photometricid, ""YCBCR"");
break;
case PHOTOMETRIC_CIELAB:
strcpy (photometricid, ""CIELab"");
break;
case PHOTOMETRIC_ICCLAB:
strcpy (photometricid, ""ICCLab"");
break;
case PHOTOMETRIC_ITULAB:
strcpy (photometricid, ""ITULab"");
break;
case PHOTOMETRIC_LOGL:
strcpy (photometricid, ""LogL"");
break;
case PHOTOMETRIC_LOGLUV:
strcpy (photometricid, ""LOGLuv"");
break;
default:
strcpy (photometricid, ""Unknown"");
break;
}
TIFFError(""loadImage"", ""Input photometric interpretation %s"", photometricid);

#endif
image->orientation = orientation;
switch (orientation)
{
case 0:
case ORIENTATION_TOPLEFT:
image->adjustments = 0;
break;
case ORIENTATION_TOPRIGHT:
image->adjustments = MIRROR_HORIZ;
break;
case ORIENTATION_BOTRIGHT:
image->adjustments = ROTATECW_180;
break;
case ORIENTATION_BOTLEFT:
image->adjustments = MIRROR_VERT;
break;
case ORIENTATION_LEFTTOP:
image->adjustments = MIRROR_VERT | ROTATECW_90;
break;
case ORIENTATION_RIGHTTOP:
image->adjustments = ROTATECW_90;
break;
case ORIENTATION_RIGHTBOT:
image->adjustments = MIRROR_VERT | ROTATECW_270;
break;
case ORIENTATION_LEFTBOT:
image->adjustments = ROTATECW_270;
break;
default:
image->adjustments = 0;
image->orientation = ORIENTATION_TOPLEFT;
}

if ((bps == 0) || (spp == 0))
{
TIFFError(""loadImage"", ""Invalid samples per pixel (%d) or bits per sample (%d)"",
spp, bps);
return (-1);
}

if (TIFFIsTiled(in))
{
readunit = TILE;
tlsize = TIFFTileSize(in);
ntiles = TIFFNumberOfTiles(in);
TIFFGetField(in, TIFFTAG_TILEWIDTH, &tw);
TIFFGetField(in, TIFFTAG_TILELENGTH, &tl);

tile_rowsize  = TIFFTileRowSize(in);
if (ntiles == 0 || tlsize == 0 || tile_rowsize == 0)
{
TIFFError(""loadImage"", ""File appears to be tiled, but the number of tiles, tile size, or tile rowsize is zero."");
exit(-1);
}
buffsize = tlsize * ntiles;
if (tlsize != (buffsize / ntiles))
{
TIFFError(""loadImage"", ""Integer overflow when calculating buffer size"");
exit(-1);
}

if (buffsize < (uint32)(ntiles * tl * tile_rowsize))
{
buffsize = ntiles * tl * tile_rowsize;
if (ntiles != (buffsize / tl / tile_rowsize))
{
TIFFError(""loadImage"", ""Integer overflow when calculating buffer size"");
exit(-1);
}

#ifdef DEBUG2
TIFFError(""loadImage"",
""Tilesize %u is too small, using ntiles * tilelength * tilerowsize %lu"",
tlsize, (unsigned long)buffsize);
#endif
}

if (dump->infile != NULL)
dump_info (dump->infile, dump->format, """",
""Tilesize: %u, Number of Tiles: %u, Tile row size: %u"",
tlsize, ntiles, tile_rowsize);
}
else
{
uint32 buffsize_check;
readunit = STRIP;
TIFFGetFieldDefaulted(in, TIFFTAG_ROWSPERSTRIP, &rowsperstrip);
stsize = TIFFStripSize(in);
nstrips = TIFFNumberOfStrips(in);
if (nstrips == 0 || stsize == 0)
{
TIFFError(""loadImage"", ""File appears to be striped, but the number of stipes or stripe size is zero."");
exit(-1);
}

buffsize = stsize * nstrips;
if (stsize != (buffsize / nstrips))
{
TIFFError(""loadImage"", ""Integer overflow when calculating buffer size"");
exit(-1);
}
buffsize_check = ((length * width * spp * bps) + 7);
if (length != ((buffsize_check - 7) / width / spp / bps))
{
TIFFError(""loadImage"", ""Integer overflow detected."");
exit(-1);
}
if (buffsize < (uint32) (((length * width * spp * bps) + 7) / 8))
{
buffsize =  ((length * width * spp * bps) + 7) / 8;
#ifdef DEBUG2
TIFFError(""loadImage"",
""Stripsize %u is too small, using imagelength * width * spp * bps / 8 = %lu"",
stsize, (unsigned long)buffsize);
#endif
}

if (dump->infile != NULL)
dump_info (dump->infile, dump->format, """",
""Stripsize: %u, Number of Strips: %u, Rows per Strip: %u, Scanline size: %u"",
stsize, nstrips, rowsperstrip, scanlinesize);
}

if (input_compression == COMPRESSION_JPEG)
{  /* Force conversion to RGB */
jpegcolormode = JPEGCOLORMODE_RGB;
TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
}
/* The clause up to the read statement is taken from Tom Lane's tiffcp patch */
else
{   /* Otherwise, can't handle subsampled input */
if (input_photometric == PHOTOMETRIC_YCBCR)
{
TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
&subsampling_horiz, &subsampling_vert);
if (subsampling_horiz != 1 || subsampling_vert != 1)
{
TIFFError(""loadImage"",
""Can't copy/convert subsampled image with subsampling %d horiz %d vert"",
subsampling_horiz, subsampling_vert);
return (-1);
}
}
}

read_buff = *read_ptr;
/* +3 : add a few guard bytes since reverseSamples16bits() can read a bit */
/* outside buffer */
if (!read_buff)
read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
else
{
if (prev_readsize < buffsize)
{
new_buff = _TIFFrealloc(read_buff, buffsize+3);
if (!new_buff)
{
free (read_buff);
read_buff = (unsigned char *)_TIFFmalloc(buffsize+3);
}
else
read_buff = new_buff;
}
}
if (!read_buff)
{
TIFFError(""loadImage"", ""Unable to allocate/reallocate read buffer"");
return (-1);
}

read_buff[buffsize] = 0;
read_buff[buffsize+1] = 0;
read_buff[buffsize+2] = 0;

prev_readsize = buffsize;
*read_ptr = read_buff;

/* N.B. The read functions used copy separate plane data into a buffer as interleaved
* samples rather than separate planes so the same logic works to extract regions
* regardless of the way the data are organized in the input file.
*/
switch (readunit) {
case STRIP:
if (planar == PLANARCONFIG_CONTIG)
{
if (!(readContigStripsIntoBuffer(in, read_buff)))
{
TIFFError(""loadImage"", ""Unable to read contiguous strips into buffer"");
return (-1);
}
}
else
{
if (!(readSeparateStripsIntoBuffer(in, read_buff, length, width, spp, dump)))
{
TIFFError(""loadImage"", ""Unable to read separate strips into buffer"");
return (-1);
}
}
break;

case TILE:
if (planar == PLANARCONFIG_CONTIG)
{
if (!(readContigTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
{
TIFFError(""loadImage"", ""Unable to read contiguous tiles into buffer"");
return (-1);
}
}
else
{
if (!(readSeparateTilesIntoBuffer(in, read_buff, length, width, tw, tl, spp, bps)))
{
TIFFError(""loadImage"", ""Unable to read separate tiles into buffer"");
return (-1);
}
}
break;
default: TIFFError(""loadImage"", ""Unsupported image file format"");
return (-1);
break;
}
if ((dump->infile != NULL) && (dump->level == 2))
{
dump_info  (dump->infile, dump->format, ""loadImage"",
""Image width %d, length %d, Raw image data, %4d bytes"",
width, length,  buffsize);
dump_info  (dump->infile, dump->format, """",
""Bits per sample %d, Samples per pixel %d"", bps, spp);

for (i = 0; i < length; i++)
dump_buffer(dump->infile, dump->format, 1, scanlinesize,
i, read_buff + (i * scanlinesize));
}
return (0);
}   /* end loadImage */
",[4],"  uint16   nstrips = 0, ntiles = 0, planar = 0;"
212,"static void nfs4_open_confirm_release(void *calldata)
{
struct nfs4_opendata *data = calldata;
struct nfs4_state *state = NULL;

/* If this request hasn't been cancelled, do nothing */
if (data->cancelled == 0)
goto out_free;
/* In case of error, no cleanup! */
if (!data->rpc_done)
goto out_free;
state = nfs4_opendata_to_nfs4_state(data);
if (!IS_ERR(state))
		nfs4_close_state(&data->path, state, data->o_arg.open_flags);
out_free:
nfs4_opendata_put(data);
}
",[12],"		nfs4_close_state(&data->path, state, data->o_arg.open_flags);"
213,"static inline void set_socket_blocking(int s, int blocking)
{
int opts;
    opts = fcntl(s, F_GETFL);
if (opts<0) APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
if(blocking)
opts &= ~O_NONBLOCK;
else opts |= O_NONBLOCK;
    if (fcntl(s, F_SETFL, opts) < 0)
APPL_TRACE_ERROR(""set blocking (%s)"", strerror(errno));
}
","[3, 8]","    opts = fcntl(s, F_GETFL);/~/    if (fcntl(s, F_SETFL, opts) < 0)"
214,"static void save_text_if_changed(const char *name, const char *new_value)
{
/* a text value can't be change if the file is not loaded */
/* returns NULL if the name is not found; otherwise nonzero */
if (!g_hash_table_lookup(g_loaded_texts, name))
return;

const char *old_value = g_cd ? problem_data_get_content_or_NULL(g_cd, name) : """";
if (!old_value)
old_value = """";
if (strcmp(new_value, old_value) != 0)
{
struct dump_dir *dd = wizard_open_directory_for_writing(g_dump_dir_name);
if (dd)
dd_save_text(dd, name, new_value);

//FIXME: else: what to do with still-unsaved data in the widget??
dd_close(dd);
        problem_data_reload_from_dump_dir();
        update_gui_state_from_problem_data(/* don't update selected event */ 0);
}
}
","[16, 17]",        problem_data_reload_from_dump_dir();/~/        update_gui_state_from_problem_data(/* don't update selected event */ 0);
215,"static void scsi_read_data(SCSIRequest *req)
{
SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req);
SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev);
uint32_t n;

if (r->sector_count == (uint32_t)-1) {
DPRINTF(""Read buf_len=%zd\n"", r->iov.iov_len);
r->sector_count = 0;
scsi_req_data(&r->req, r->iov.iov_len);
return;
}
DPRINTF(""Read sector_count=%d\n"", r->sector_count);
if (r->sector_count == 0) {
/* This also clears the sense buffer for REQUEST SENSE.  */
scsi_req_complete(&r->req, GOOD);
return;
}

/* No data transfer may already be in progress */
assert(r->req.aiocb == NULL);

if (r->req.cmd.mode == SCSI_XFER_TO_DEV) {
DPRINTF(""Data transfer direction invalid\n"");
scsi_read_complete(r, -EINVAL);
return;
}

    n = r->sector_count;
    if (n > SCSI_DMA_BUF_SIZE / 512)
        n = SCSI_DMA_BUF_SIZE / 512;
if (s->tray_open) {
scsi_read_complete(r, -ENOMEDIUM);
}
    r->iov.iov_len = n * 512;
    qemu_iovec_init_external(&r->qiov, &r->iov, 1);
bdrv_acct_start(s->bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_READ);
r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n,
scsi_read_complete, r);
if (r->req.aiocb == NULL) {
scsi_read_complete(r, -EIO);
}
}
","[24, 25, 26, 30, 31]","    n = r->sector_count;/~/    if (n > SCSI_DMA_BUF_SIZE / 512)/~/        n = SCSI_DMA_BUF_SIZE / 512;/~/    r->iov.iov_len = n * 512;/~/    qemu_iovec_init_external(&r->qiov, &r->iov, 1);"
216,"native_handle* Parcel::readNativeHandle() const
{
int numFds, numInts;
status_t err;
err = readInt32(&numFds);
if (err != NO_ERROR) return 0;
err = readInt32(&numInts);
if (err != NO_ERROR) return 0;

native_handle* h = native_handle_create(numFds, numInts);
if (!h) {
return 0;
}


for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
h->data[i] = dup(readFileDescriptor());
        if (h->data[i] < 0) err = BAD_VALUE;
}
err = read(h->data + numFds, sizeof(int)*numInts);
if (err != NO_ERROR) {
native_handle_close(h);
native_handle_delete(h);
h = 0;
}
return h;
}
",[14],        if (h->data[i] < 0) err = BAD_VALUE;
217,"bool GesturePoint::IsInSecondClickTimeWindow() const {
double duration =  last_touch_time_ - last_tap_time_;
  return duration < kMaximumSecondsBetweenDoubleClick;
}
",[2],  return duration < kMaximumSecondsBetweenDoubleClick;
218,"static int crypto_report_cipher(struct sk_buff *skb, struct crypto_alg *alg)
{
struct crypto_report_cipher rcipher;

	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");

rcipher.blocksize = alg->cra_blocksize;
rcipher.min_keysize = alg->cra_cipher.cia_min_keysize;
rcipher.max_keysize = alg->cra_cipher.cia_max_keysize;

if (nla_put(skb, CRYPTOCFGA_REPORT_CIPHER,
sizeof(struct crypto_report_cipher), &rcipher))
goto nla_put_failure;
return 0;

nla_put_failure:
return -EMSGSIZE;
}
",[3],"	snprintf(rcipher.type, CRYPTO_MAX_ALG_NAME, ""%s"", ""cipher"");"
219,"unsigned long long Chapters::Atom::GetUID() const
{
    return m_uid;
}
","[1, 2]",{/~/    return m_uid;
220,"jp2_box_t *jp2_box_get(jas_stream_t *in)
{
jp2_box_t *box;
jp2_boxinfo_t *boxinfo;
jas_stream_t *tmpstream;
uint_fast32_t len;
uint_fast64_t extlen;
bool dataflag;

box = 0;
tmpstream = 0;

if (!(box = jas_malloc(sizeof(jp2_box_t)))) {
goto error;
}
box->ops = &jp2_boxinfo_unk.ops;
if (jp2_getuint32(in, &len) || jp2_getuint32(in, &box->type)) {
goto error;
}
boxinfo = jp2_boxinfolookup(box->type);
box->info = boxinfo;
	box->ops = &boxinfo->ops;
box->len = len;
JAS_DBGLOG(10, (
""preliminary processing of JP2 box: type=%c%s%c (0x%08x); length=%d\n"",
'""', boxinfo->name, '""', box->type, box->len
));
if (box->len == 1) {
if (jp2_getuint64(in, &extlen)) {
goto error;
}
if (extlen > 0xffffffffUL) {
jas_eprintf(""warning: cannot handle large 64-bit box length\n"");
extlen = 0xffffffffUL;
}
box->len = extlen;
box->datalen = extlen - JP2_BOX_HDRLEN(true);
} else {
box->datalen = box->len - JP2_BOX_HDRLEN(false);
}
if (box->len != 0 && box->len < 8) {
goto error;
}

dataflag = !(box->info->flags & (JP2_BOX_SUPER | JP2_BOX_NODATA));

if (dataflag) {
if (!(tmpstream = jas_stream_memopen(0, 0))) {
goto error;
}
if (jas_stream_copy(tmpstream, in, box->datalen)) {
			// Mark the box data as never having been constructed
			// so that we will not errantly attempt to destroy it later.
			box->ops = &jp2_boxinfo_unk.ops;
jas_eprintf(""cannot copy box data\n"");
goto error;
}
jas_stream_rewind(tmpstream);

if (box->ops->getdata) {
if ((*box->ops->getdata)(box, tmpstream)) {
jas_eprintf(""cannot parse box data\n"");
goto error;
}
}
jas_stream_close(tmpstream);
}

if (jas_getdbglevel() >= 1) {
jp2_box_dump(box, stderr);
}

return box;

error:
if (box) {
jp2_box_destroy(box);
}
if (tmpstream) {
jas_stream_close(tmpstream);
}
return 0;
}
","[13, 19]",	box->ops = &boxinfo->ops;/~/			// Mark the box data as never having been constructed/~/			// so that we will not errantly attempt to destroy it later./~/			box->ops = &jp2_boxinfo_unk.ops;
221,"ext4_xattr_block_get(struct inode *inode, int name_index, const char *name,
void *buffer, size_t buffer_size)
{
struct buffer_head *bh = NULL;
struct ext4_xattr_entry *entry;
size_t size;
int error;
	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);

ea_idebug(inode, ""name=%d.%s, buffer=%p, buffer_size=%ld"",
name_index, name, buffer, (long)buffer_size);

error = -ENODATA;
if (!EXT4_I(inode)->i_file_acl)
goto cleanup;
ea_idebug(inode, ""reading block %llu"",
(unsigned long long)EXT4_I(inode)->i_file_acl);
bh = sb_bread(inode->i_sb, EXT4_I(inode)->i_file_acl);
if (!bh)
goto cleanup;
ea_bdebug(bh, ""b_count=%d, refcount=%d"",
atomic_read(&(bh->b_count)), le32_to_cpu(BHDR(bh)->h_refcount));
if (ext4_xattr_check_block(inode, bh)) {
bad_block:
EXT4_ERROR_INODE(inode, ""bad block %llu"",
EXT4_I(inode)->i_file_acl);
error = -EFSCORRUPTED;
goto cleanup;
}
ext4_xattr_cache_insert(ext4_mb_cache, bh);
entry = BFIRST(bh);
error = ext4_xattr_find_entry(&entry, name_index, name, bh->b_size, 1);
if (error == -EFSCORRUPTED)
goto bad_block;
if (error)
goto cleanup;
size = le32_to_cpu(entry->e_value_size);
if (buffer) {
error = -ERANGE;
if (size > buffer_size)
goto cleanup;
memcpy(buffer, bh->b_data + le16_to_cpu(entry->e_value_offs),
size);
}
error = size;

cleanup:
brelse(bh);
return error;
}
",[7],	struct mb_cache *ext4_mb_cache = EXT4_GET_MB_CACHE(inode);
222,"BaseRenderingContext2D::BaseRenderingContext2D()
    : clip_antialiasing_(kNotAntiAliased) {
state_stack_.push_back(CanvasRenderingContext2DState::Create());
}
",[1],    : clip_antialiasing_(kNotAntiAliased) {
223,"static enum AVPixelFormat h263_get_format(AVCodecContext *avctx)
{
/* MPEG-4 Studio Profile only, not supported by hardware */
if (avctx->bits_per_raw_sample > 8) {
        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
return avctx->pix_fmt;
}

if (avctx->codec->id == AV_CODEC_ID_MSS2)
return AV_PIX_FMT_YUV420P;

if (CONFIG_GRAY && (avctx->flags & AV_CODEC_FLAG_GRAY)) {
if (avctx->color_range == AVCOL_RANGE_UNSPECIFIED)
avctx->color_range = AVCOL_RANGE_MPEG;
return AV_PIX_FMT_GRAY8;
}

return avctx->pix_fmt = ff_get_format(avctx, avctx->codec->pix_fmts);
}
",[4],        av_assert1(avctx->profile == FF_PROFILE_MPEG4_SIMPLE_STUDIO);
224,"void RTCSessionDescriptionRequestImpl::requestFailed(const String& error)
{
if (m_errorCallback)
        m_errorCallback->handleEvent(error);

clear();
}
",[3],        m_errorCallback->handleEvent(error);
225,"void ResourceDispatcherHostImpl::OnSSLCertificateError(
net::URLRequest* request,
const net::SSLInfo& ssl_info,
bool is_hsts_host) {
DCHECK(request);
ResourceRequestInfoImpl* info = ResourceRequestInfoImpl::ForRequest(request);
DCHECK(info);
GlobalRequestID request_id(info->GetChildID(), info->GetRequestID());
int render_process_id;
int render_view_id;
if(!info->GetAssociatedRenderView(&render_process_id, &render_view_id))
NOTREACHED();
  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),
      request_id, info->GetResourceType(), request->url(), render_process_id,
      render_view_id, ssl_info, is_hsts_host);
}
","[12, 13, 14]","  SSLManager::OnSSLCertificateError(ssl_delegate_weak_factory_.GetWeakPtr(),/~/      request_id, info->GetResourceType(), request->url(), render_process_id,/~/      render_view_id, ssl_info, is_hsts_host);"
226,"int hashtable_set(hashtable_t *hashtable,
const char *key, size_t serial,
json_t *value)
{
pair_t *pair;
bucket_t *bucket;
size_t hash, index;

/* rehash if the load ratio exceeds 1 */
    if(hashtable->size >= num_buckets(hashtable))
if(hashtable_do_rehash(hashtable))
return -1;

hash = hash_str(key);
    index = hash % num_buckets(hashtable);
bucket = &hashtable->buckets[index];
pair = hashtable_find_pair(hashtable, bucket, key, hash);

if(pair)
{
json_decref(pair->value);
pair->value = value;
}
else
{
/* offsetof(...) returns the size of pair_t without the last,
flexible member. This way, the correct amount is
allocated. */
pair = jsonp_malloc(offsetof(pair_t, key) + strlen(key) + 1);
if(!pair)
return -1;

pair->hash = hash;
pair->serial = serial;
strcpy(pair->key, key);
pair->value = value;
list_init(&pair->list);

insert_to_bucket(hashtable, bucket, &pair->list);

hashtable->size++;
}
return 0;
}
","[8, 12]",    if(hashtable->size >= num_buckets(hashtable))/~/    index = hash % num_buckets(hashtable);
227,"bool AppCacheDatabase::FindEntriesForCache(int64_t cache_id,
std::vector<EntryRecord>* records) {
DCHECK(records && records->empty());
if (!LazyOpen(kDontCreate))
return false;

static const char kSql[] =
      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries""
""  WHERE cache_id = ?"";

sql::Statement statement(db_->GetCachedStatement(SQL_FROM_HERE, kSql));
statement.BindInt64(0, cache_id);

while (statement.Step()) {
records->push_back(EntryRecord());
ReadEntryRecord(statement, &records->back());
DCHECK(records->back().cache_id == cache_id);
}

return statement.Succeeded();
}
",[6],"      ""SELECT cache_id, url, flags, response_id, response_size FROM Entries"""
228,"static void svc_rdma_destroy_maps(struct svcxprt_rdma *xprt)
{
	while (!list_empty(&xprt->sc_maps)) {
		struct svc_rdma_req_map *map;
		map = list_first_entry(&xprt->sc_maps,
				       struct svc_rdma_req_map, free);
		list_del(&map->free);
		kfree(map);
	}
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9]","{/~/	while (!list_empty(&xprt->sc_maps)) {/~/		struct svc_rdma_req_map *map;/~/		map = list_first_entry(&xprt->sc_maps,/~/				       struct svc_rdma_req_map, free);/~/		list_del(&map->free);/~/		kfree(map);/~/	}/~/}"
229,"monitor_init(void)
{
	struct ssh *ssh = active_state;			/* XXX *
struct monitor *mon;

mon = xcalloc(1, sizeof(*mon));
monitor_openfds(mon, 1);

	/* Used to share zlib space across processes *
	if (options.compression) {
		mon->m_zback = mm_create(NULL, MM_MEMSIZE);
		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);
		/* Compression needs to share state across borders *
		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,
		    (ssh_packet_comp_alloc_func *)mm_zalloc,
		    (ssh_packet_comp_free_func *)mm_zfree);
	}
return mon;
}
","[7, 8, 9, 10, 11, 12, 13, 14, 15, 17]","	struct ssh *ssh = active_state;			/* XXX */~/	/* Used to share zlib space across processes */~/	if (options.compression) {/~/		mon->m_zback = mm_create(NULL, MM_MEMSIZE);/~/		mon->m_zlib = mm_create(mon->m_zback, 20 * MM_MEMSIZE);/~/		/* Compression needs to share state across borders */~/		ssh_packet_set_compress_hooks(ssh, mon->m_zlib,/~/		    (ssh_packet_comp_alloc_func *)mm_zalloc,/~/		    (ssh_packet_comp_free_func *)mm_zfree);/~/	}"
230,"image_transform_png_set_background_set(PNG_CONST image_transform *this,
transform_display *that, png_structp pp, png_infop pi)
{
png_byte colour_type, bit_depth;
png_byte random_bytes[8]; /* 8 bytes - 64 bits - the biggest pixel */
int expand;
png_color_16 back;

/* We need a background colour, because we don't know exactly what transforms
* have been set we have to supply the colour in the original file format and
* so we need to know what that is!  The background colour is stored in the
* transform_display.
*/
RANDOMIZE(random_bytes);

/* Read the random value, for colour type 3 the background colour is actually
* expressed as a 24bit rgb, not an index.
*/
colour_type = that->this.colour_type;
if (colour_type == 3)
{
colour_type = PNG_COLOR_TYPE_RGB;
bit_depth = 8;
expand = 0; /* passing in an RGB not a pixel index */
}


else
{
bit_depth = that->this.bit_depth;
expand = 1;
}

image_pixel_init(&data, random_bytes, colour_type,
      bit_depth, 0/*x*/, 0/*unused: palette*/);

/* Extract the background colour from this image_pixel, but make sure the
* unused fields of 'back' are garbage.
*/
RANDOMIZE(back);

if (colour_type & PNG_COLOR_MASK_COLOR)
{
back.red = (png_uint_16)data.red;
back.green = (png_uint_16)data.green;
back.blue = (png_uint_16)data.blue;
}

else
back.gray = (png_uint_16)data.red;

#  ifdef PNG_FLOATING_POINT_SUPPORTED
png_set_background(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
#  else
png_set_background_fixed(pp, &back, PNG_BACKGROUND_GAMMA_FILE, expand, 0);
#  endif

this->next->set(this->next, that, pp, pi);

}
",[29],"      bit_depth, 0/*x*/, 0/*unused: palette*/);"
231,"compile_bag_node(BagNode* node, regex_t* reg, ScanEnv* env)
{
int r, len;

switch (node->type) {
case BAG_MEMORY:
r = compile_bag_memory_node(node, reg, env);
break;

case BAG_OPTION:
r = compile_option_node(node, reg, env);
break;

case BAG_STOP_BACKTRACK:
if (NODE_IS_STOP_BT_SIMPLE_REPEAT(node)) {
QuantNode* qn = QUANT_(NODE_BAG_BODY(node));
r = compile_tree_n_times(NODE_QUANT_BODY(qn), qn->lower, reg, env);
if (r != 0) return r;

len = compile_length_tree(NODE_QUANT_BODY(qn), reg);
if (len < 0) return len;

r = add_op(reg, OP_PUSH);
if (r != 0) return r;
COP(reg)->push.addr = SIZE_INC_OP + len + SIZE_OP_POP_OUT + SIZE_OP_JUMP;

r = compile_tree(NODE_QUANT_BODY(qn), reg, env);
if (r != 0) return r;
r = add_op(reg, OP_POP_OUT);
if (r != 0) return r;

r = add_op(reg, OP_JUMP);
if (r != 0) return r;
COP(reg)->jump.addr = -((int )SIZE_OP_PUSH + len + (int )SIZE_OP_POP_OUT);
}
else {
r = add_op(reg, OP_ATOMIC_START);
if (r != 0) return r;
r = compile_tree(NODE_BAG_BODY(node), reg, env);
if (r != 0) return r;
r = add_op(reg, OP_ATOMIC_END);
}
break;

case BAG_IF_ELSE:
{
      int cond_len, then_len, jump_len;
Node* cond = NODE_BAG_BODY(node);
Node* Then = node->te.Then;
Node* Else = node->te.Else;

r = add_op(reg, OP_ATOMIC_START);
if (r != 0) return r;

cond_len = compile_length_tree(cond, reg);
if (cond_len < 0) return cond_len;
if (IS_NOT_NULL(Then)) {
then_len = compile_length_tree(Then, reg);
if (then_len < 0) return then_len;
}
else
then_len = 0;

      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;
      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;

r = add_op(reg, OP_PUSH);
if (r != 0) return r;
COP(reg)->push.addr = SIZE_INC_OP + jump_len;

r = compile_tree(cond, reg, env);
if (r != 0) return r;
r = add_op(reg, OP_ATOMIC_END);
if (r != 0) return r;

if (IS_NOT_NULL(Then)) {
r = compile_tree(Then, reg, env);
if (r != 0) return r;
}

if (IS_NOT_NULL(Else)) {
        int else_len = compile_length_tree(Else, reg);
        r = add_op(reg, OP_JUMP);
        if (r != 0) return r;
        COP(reg)->jump.addr = else_len + SIZE_INC_OP;

r = compile_tree(Else, reg, env);
}
}
break;
}

return r;
}
","[14, 18, 21, 23, 24, 25, 30, 32]","      int cond_len, then_len, jump_len;/~/      jump_len = cond_len + then_len + SIZE_OP_ATOMIC_END;/~/      if (IS_NOT_NULL(Else)) jump_len += SIZE_OP_JUMP;/~/        int else_len = compile_length_tree(Else, reg);/~/        r = add_op(reg, OP_JUMP);/~/        if (r != 0) return r;/~/        COP(reg)->jump.addr = else_len + SIZE_INC_OP;"
232,"static int generate_key(DH *dh)
{
int ok = 0;
int generate_new_key = 0;
unsigned l;
    BN_CTX *ctx;
BN_MONT_CTX *mont = NULL;
BIGNUM *pub_key = NULL, *priv_key = NULL;

ctx = BN_CTX_new();
if (ctx == NULL)
goto err;
generate_new_key = 1;
} else
",[5],    BN_CTX *ctx;
233,"static ssize_t o2nm_node_ipv4_address_store(struct config_item *item,
const char *page,
size_t count)
{
struct o2nm_node *node = to_o2nm_node(item);
	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
int ret, i;
struct rb_node **p, *parent;
unsigned int octets[4];
__be32 ipv4_addr = 0;

ret = sscanf(page, ""%3u.%3u.%3u.%3u"", &octets[3], &octets[2],
&octets[1], &octets[0]);
if (ret != 4)
return -EINVAL;

for (i = 0; i < ARRAY_SIZE(octets); i++) {
if (octets[i] > 255)
return -ERANGE;
be32_add_cpu(&ipv4_addr, octets[i] << (i * 8));
}

ret = 0;
write_lock(&cluster->cl_nodes_lock);
if (o2nm_node_ip_tree_lookup(cluster, ipv4_addr, &p, &parent))
ret = -EEXIST;
else if (test_and_set_bit(O2NM_NODE_ATTR_ADDRESS,
&node->nd_set_attributes))
ret = -EBUSY;
else {
rb_link_node(&node->nd_ip_node, parent, p);
rb_insert_color(&node->nd_ip_node, &cluster->cl_node_ip_tree);
}
write_unlock(&cluster->cl_nodes_lock);
if (ret)
return ret;

memcpy(&node->nd_ipv4_address, &ipv4_addr, sizeof(ipv4_addr));

return count;
}
",[5],	struct o2nm_cluster *cluster = to_o2nm_cluster_from_node(node);
234,"static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas) {
char *key;
size_t nkey;
int i = 0;
item *it;
token_t *key_token = &tokens[KEY_TOKEN];
char *suffix;
assert(c != NULL);

do {
while(key_token->length != 0) {

key = key_token->value;
nkey = key_token->length;

if(nkey > KEY_MAX_LENGTH) {
out_string(c, ""CLIENT_ERROR bad command line format"");
while (i-- > 0) {
item_remove(*(c->ilist + i));
}
return;
}

            it = item_get(key, nkey, c, DO_UPDATE);
if (settings.detail_enabled) {
stats_prefix_record_get(key, nkey, NULL != it);
}
if (it) {
if (i >= c->isize) {
item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
if (new_list) {
c->isize *= 2;
c->ilist = new_list;
} else {
STATS_LOCK();
stats.malloc_fails++;
STATS_UNLOCK();
item_remove(it);
break;
}
}

/*
* Construct the response. Each hit adds three elements to the
* outgoing data list:
*   ""VALUE ""
*   key
*   "" "" + flags + "" "" + data length + ""\r\n"" + data (with \r\n)
*/

if (return_cas || !settings.inline_ascii_response)
{
MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
it->nbytes, ITEM_get_cas(it));
/* Goofy mid-flight realloc. */
if (i >= c->suffixsize) {
char **new_suffix_list = realloc(c->suffixlist,
sizeof(char *) * c->suffixsize * 2);
if (new_suffix_list) {
c->suffixsize *= 2;
c->suffixlist  = new_suffix_list;
} else {
STATS_LOCK();
stats.malloc_fails++;
STATS_UNLOCK();
item_remove(it);
break;
}
}

suffix = do_cache_alloc(c->thread->suffix_cache);
if (suffix == NULL) {
STATS_LOCK();
stats.malloc_fails++;
STATS_UNLOCK();
out_of_memory(c, ""SERVER_ERROR out of memory making CAS suffix"");
item_remove(it);
while (i-- > 0) {
item_remove(*(c->ilist + i));
}
return;
}
*(c->suffixlist + i) = suffix;
int suffix_len = make_ascii_get_suffix(suffix, it, return_cas);
if (add_iov(c, ""VALUE "", 6) != 0 ||
add_iov(c, ITEM_key(it), it->nkey) != 0 ||
(settings.inline_ascii_response && add_iov(c, ITEM_suffix(it), it->nsuffix - 2) != 0) ||
add_iov(c, suffix, suffix_len) != 0)
{
item_remove(it);
break;
}
if ((it->it_flags & ITEM_CHUNKED) == 0) {
add_iov(c, ITEM_data(it), it->nbytes);
} else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
item_remove(it);
break;
}
}
else
{
MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey,
it->nbytes, ITEM_get_cas(it));
if (add_iov(c, ""VALUE "", 6) != 0 ||
add_iov(c, ITEM_key(it), it->nkey) != 0)
{
item_remove(it);
break;
}
if ((it->it_flags & ITEM_CHUNKED) == 0)
{
if (add_iov(c, ITEM_suffix(it), it->nsuffix + it->nbytes) != 0)
{
item_remove(it);
break;
}
} else if (add_iov(c, ITEM_suffix(it), it->nsuffix) != 0 ||
add_chunked_item_iovs(c, it, it->nbytes) != 0) {
item_remove(it);
break;
}
}


if (settings.verbose > 1) {
int ii;
fprintf(stderr, "">%d sending key "", c->sfd);
for (ii = 0; ii < it->nkey; ++ii) {
fprintf(stderr, ""%c"", key[ii]);
}
fprintf(stderr, ""\n"");
}

/* item_get() has incremented it->refcount for us */
pthread_mutex_lock(&c->thread->stats.mutex);
c->thread->stats.slab_stats[ITEM_clsid(it)].get_hits++;
c->thread->stats.get_cmds++;
pthread_mutex_unlock(&c->thread->stats.mutex);
*(c->ilist + i) = it;
i++;

} else {
pthread_mutex_lock(&c->thread->stats.mutex);
c->thread->stats.get_misses++;
c->thread->stats.get_cmds++;
pthread_mutex_unlock(&c->thread->stats.mutex);
MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
}

key_token++;
}

/*
* If the command string hasn't been fully processed, get the next set
* of tokens.
*/
if(key_token->value != NULL) {
ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
key_token = tokens;
}

} while(key_token->value != NULL);

c->icurr = c->ilist;
c->ileft = i;
if (return_cas || !settings.inline_ascii_response) {
c->suffixcurr = c->suffixlist;
c->suffixleft = i;
}

if (settings.verbose > 1)
fprintf(stderr, "">%d END\n"", c->sfd);

/*
If the loop was terminated because of out-of-memory, it is not
reliable to add END\r\n to the buffer, because it might not end
in \r\n. So we send SERVER_ERROR instead.
*/
if (key_token->value != NULL || add_iov(c, ""END\r\n"", 5) != 0
|| (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
out_of_memory(c, ""SERVER_ERROR out of memory writing get response"");
}
else {
conn_set_state(c, conn_mwrite);
c->msgcurr = 0;
}
}
",[19],"            it = item_get(key, nkey, c, DO_UPDATE);"
235,"static void ProxyLocaltimeCallToBrowser(time_t input, struct tm* output,
char* timezone_out,
size_t timezone_out_len) {
base::Pickle request;
request.WriteInt(LinuxSandbox::METHOD_LOCALTIME);
request.WriteString(
std::string(reinterpret_cast<char*>(&input), sizeof(input)));

uint8_t reply_buf[512];
const ssize_t r = base::UnixDomainSocket::SendRecvMsg(
GetSandboxFD(), reply_buf, sizeof(reply_buf), NULL, request);
if (r == -1) {
    memset(output, 0, sizeof(struct tm));
return;
}

base::Pickle reply(reinterpret_cast<char*>(reply_buf), r);
base::PickleIterator iter(reply);
  std::string result;
  std::string timezone;
  if (!iter.ReadString(&result) ||
      !iter.ReadString(&timezone) ||
      result.size() != sizeof(struct tm)) {
memset(output, 0, sizeof(struct tm));
    return;
  }
  memcpy(output, result.data(), sizeof(struct tm));
  if (timezone_out_len) {
    const size_t copy_len = std::min(timezone_out_len - 1, timezone.size());
    memcpy(timezone_out, timezone.data(), copy_len);
    timezone_out[copy_len] = 0;
    output->tm_zone = timezone_out;
  } else {
    base::AutoLock lock(g_timezones_lock.Get());
    auto ret_pair = g_timezones.Get().insert(timezone);
    output->tm_zone = ret_pair.first->c_str();
}
}
","[11, 12, 13, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]","    memset(output, 0, sizeof(struct tm));/~/  std::string result;/~/  std::string timezone;/~/  if (!iter.ReadString(&result) ||/~/      !iter.ReadString(&timezone) ||/~/      result.size() != sizeof(struct tm)) {/~/    return;/~/  }/~/  memcpy(output, result.data(), sizeof(struct tm));/~/  if (timezone_out_len) {/~/    const size_t copy_len = std::min(timezone_out_len - 1, timezone.size());/~/    memcpy(timezone_out, timezone.data(), copy_len);/~/    timezone_out[copy_len] = 0;/~/    output->tm_zone = timezone_out;/~/  } else {/~/    base::AutoLock lock(g_timezones_lock.Get());/~/    auto ret_pair = g_timezones.Get().insert(timezone);/~/    output->tm_zone = ret_pair.first->c_str();"
236,"virtual void scheduleBeginFrameAndCommit()
{
        CCMainThread::postTask(m_proxy->createBeginFrameAndCommitTaskOnCCThread());
}
",[2],        CCMainThread::postTask(m_proxy->createBeginFrameAndCommitTaskOnCCThread());
237,"static int emulate_store_desc_ptr(struct x86_emulate_ctxt *ctxt,
void (*get)(struct x86_emulate_ctxt *ctxt,
struct desc_ptr *ptr))
{
struct desc_ptr desc_ptr;

if (ctxt->mode == X86EMUL_MODE_PROT64)
ctxt->op_bytes = 8;
get(ctxt, &desc_ptr);
if (ctxt->op_bytes == 2) {
ctxt->op_bytes = 4;
desc_ptr.address &= 0x00ffffff;
}
/* Disable writeback. */
ctxt->dst.type = OP_NONE;
	return segmented_write(ctxt, ctxt->dst.addr.mem,
			       &desc_ptr, 2 + ctxt->op_bytes);
}
","[14, 15]","	return segmented_write(ctxt, ctxt->dst.addr.mem,/~/			       &desc_ptr, 2 + ctxt->op_bytes);"
238,"static void UpdatePropertyCallback(IBusPanelService* panel,
                                     IBusProperty* ibus_prop,
                                     gpointer user_data) {
    g_return_if_fail(user_data);
    InputMethodStatusConnection* self
        = static_cast<InputMethodStatusConnection*>(user_data);
    self->UpdateProperty(ibus_prop);
}
","[1, 2, 3, 4, 5, 6]","                                     IBusProperty* ibus_prop,/~/                                     gpointer user_data) {/~/    g_return_if_fail(user_data);/~/    InputMethodStatusConnection* self/~/        = static_cast<InputMethodStatusConnection*>(user_data);/~/    self->UpdateProperty(ibus_prop);"
239,"static int ext4_write_end(struct file *file,
struct address_space *mapping,
loff_t pos, unsigned len, unsigned copied,
struct page *page, void *fsdata)
{
handle_t *handle = ext4_journal_current_handle();
struct inode *inode = mapping->host;
loff_t old_size = inode->i_size;
int ret = 0, ret2;
int i_size_changed = 0;

trace_ext4_write_end(inode, pos, len, copied);
	if (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {
		ret = ext4_jbd2_file_inode(handle, inode);
		if (ret) {
			unlock_page(page);
			put_page(page);
			goto errout;
		}
	}
if (ext4_has_inline_data(inode)) {
ret = ext4_write_inline_data_end(inode, pos, len,
copied, page);
if (ret < 0)
goto errout;
copied = ret;
} else
copied = block_write_end(file, mapping, pos,
len, copied, page, fsdata);
/*
* it's important to update i_size while still holding page lock:
* page writeout could otherwise come in and zero beyond i_size.
*/
i_size_changed = ext4_update_inode_size(inode, pos + copied);
unlock_page(page);
put_page(page);

if (old_size < pos)
pagecache_isize_extended(inode, old_size, pos);
/*
* Don't mark the inode dirty under page lock. First, it unnecessarily
* makes the holding time of page lock longer. Second, it forces lock
* ordering of page lock and transaction start for journaling
* filesystems.
*/
if (i_size_changed)
ext4_mark_inode_dirty(handle, inode);

if (pos + len > inode->i_size && ext4_can_truncate(inode))
/* if we have allocated more blocks and copied
* less. We will have blocks allocated outside
* inode->i_size. So truncate them
*/
ext4_orphan_add(handle, inode);
errout:
ret2 = ext4_journal_stop(handle);
if (!ret)
ret = ret2;

if (pos + len > inode->i_size) {
ext4_truncate_failed_write(inode);
/*
* If truncate failed early the inode might still be
* on the orphan list; we need to make sure the inode
* is removed from the orphan list in that case.
*/
if (inode->i_nlink)
ext4_orphan_del(NULL, inode);
}

return ret ? ret : copied;
}
","[11, 12, 13, 14, 15, 16, 17, 18, 23, 33, 34]","	if (ext4_test_inode_state(inode, EXT4_STATE_ORDERED_MODE)) {/~/		ret = ext4_jbd2_file_inode(handle, inode);/~/		if (ret) {/~/			unlock_page(page);/~/			put_page(page);/~/			goto errout;/~/		}/~/	}"
240,"get_princs_2_svc(gprincs_arg *arg, struct svc_req *rqstp)
{
static gprincs_ret              ret;
char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
OM_uint32                       minor_stat;
kadm5_server_handle_t           handle;
const char                      *errmsg = NULL;

xdr_free(xdr_gprincs_ret, &ret);

if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
goto exit_func;

if ((ret.code = check_handle((void *)handle)))
goto exit_func;

ret.api_version = handle->api_version;

if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
ret.code = KADM5_FAILURE;
goto exit_func;
}
prime_arg = arg->exp;
if (prime_arg == NULL)
prime_arg = ""*"";

if (CHANGEPW_SERVICE(rqstp) || !kadm5int_acl_check(handle->context,
rqst2name(rqstp),
ACL_LIST,
NULL,
NULL)) {
ret.code = KADM5_AUTH_LIST;
log_unauth(""kadm5_get_principals"", prime_arg,
&client_name, &service_name, rqstp);
} else {
ret.code  = kadm5_get_principals((void *)handle,
arg->exp, &ret.princs,
&ret.count);
if( ret.code != 0 )
errmsg = krb5_get_error_message(handle->context, ret.code);

log_done(""kadm5_get_principals"", prime_arg, errmsg,
&client_name, &service_name, rqstp);

if (errmsg != NULL)
krb5_free_error_message(handle->context, errmsg);

}
gss_release_buffer(&minor_stat, &client_name);
gss_release_buffer(&minor_stat, &service_name);
exit_func:
free_server_handle(handle);
return &ret;
}
","[4, 5]","    gss_buffer_desc                 client_name,/~/        service_name;/~/exit_func:"
241,"bool IsTraceEventArgsWhitelisted(const char* category_group_name,
                                 const char* event_name) {
if (base::MatchPattern(category_group_name, ""toplevel"") &&
base::MatchPattern(event_name, ""*"")) {
return true;
}

return false;
}
",[1],                                 const char* event_name) {
242,"void svc_rdma_send_error(struct svcxprt_rdma *xprt, struct rpcrdma_msg *rmsgp,
			 int status)
{
	struct ib_send_wr err_wr;
	struct page *p;
	struct svc_rdma_op_ctxt *ctxt;
	enum rpcrdma_errcode err;
	__be32 *va;
	int length;
	int ret;
	ret = svc_rdma_repost_recv(xprt, GFP_KERNEL);
	if (ret)
		return;
	p = alloc_page(GFP_KERNEL);
	if (!p)
		return;
	va = page_address(p);
	/* XDR encode an error reply *
	err = ERR_CHUNK;
	if (status == -EPROTONOSUPPORT)
		err = ERR_VERS;
	length = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);
	ctxt = svc_rdma_get_context(xprt);
	ctxt->direction = DMA_TO_DEVICE;
	ctxt->count = 1;
	ctxt->pages[0] = p;
	/* Prepare SGE for local address *
	ctxt->sge[0].lkey = xprt->sc_pd->local_dma_lkey;
	ctxt->sge[0].length = length;
	ctxt->sge[0].addr = ib_dma_map_page(xprt->sc_cm_id->device,
					    p, 0, length, DMA_TO_DEVICE);
	if (ib_dma_mapping_error(xprt->sc_cm_id->device, ctxt->sge[0].addr)) {
		dprintk(""svcrdma: Error mapping buffer for protocol error\n"");
		svc_rdma_put_context(ctxt, 1);
		return;
	}
	svc_rdma_count_mappings(xprt, ctxt);
	/* Prepare SEND WR *
	memset(&err_wr, 0, sizeof(err_wr));
	ctxt->cqe.done = svc_rdma_wc_send;
	err_wr.wr_cqe = &ctxt->cqe;
	err_wr.sg_list = ctxt->sge;
	err_wr.num_sge = 1;
	err_wr.opcode = IB_WR_SEND;
	err_wr.send_flags = IB_SEND_SIGNALED;
	/* Post It *
	ret = svc_rdma_send(xprt, &err_wr);
	if (ret) {
		dprintk(""svcrdma: Error %d posting send for protocol error\n"",
			ret);
		svc_rdma_unmap_dma(ctxt);
		svc_rdma_put_context(ctxt, 1);
	}
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]","			 int status)/~/{/~/	struct ib_send_wr err_wr;/~/	struct page *p;/~/	struct svc_rdma_op_ctxt *ctxt;/~/	enum rpcrdma_errcode err;/~/	__be32 *va;/~/	int length;/~/	int ret;/~/	ret = svc_rdma_repost_recv(xprt, GFP_KERNEL);/~/	if (ret)/~/		return;/~/	p = alloc_page(GFP_KERNEL);/~/	if (!p)/~/		return;/~/	va = page_address(p);/~/	/* XDR encode an error reply */~/	err = ERR_CHUNK;/~/	if (status == -EPROTONOSUPPORT)/~/		err = ERR_VERS;/~/	length = svc_rdma_xdr_encode_error(xprt, rmsgp, err, va);/~/	ctxt = svc_rdma_get_context(xprt);/~/	ctxt->direction = DMA_TO_DEVICE;/~/	ctxt->count = 1;/~/	ctxt->pages[0] = p;/~/	/* Prepare SGE for local address */~/	ctxt->sge[0].lkey = xprt->sc_pd->local_dma_lkey;/~/	ctxt->sge[0].length = length;/~/	ctxt->sge[0].addr = ib_dma_map_page(xprt->sc_cm_id->device,/~/					    p, 0, length, DMA_TO_DEVICE);/~/	if (ib_dma_mapping_error(xprt->sc_cm_id->device, ctxt->sge[0].addr)) {/~/		dprintk(""svcrdma: Error mapping buffer for protocol error\n"");/~/		svc_rdma_put_context(ctxt, 1);/~/		return;/~/	}/~/	svc_rdma_count_mappings(xprt, ctxt);/~/	/* Prepare SEND WR */~/	memset(&err_wr, 0, sizeof(err_wr));/~/	ctxt->cqe.done = svc_rdma_wc_send;/~/	err_wr.wr_cqe = &ctxt->cqe;/~/	err_wr.sg_list = ctxt->sge;/~/	err_wr.num_sge = 1;/~/	err_wr.opcode = IB_WR_SEND;/~/	err_wr.send_flags = IB_SEND_SIGNALED;/~/	/* Post It */~/	ret = svc_rdma_send(xprt, &err_wr);/~/	if (ret) {/~/		dprintk(""svcrdma: Error %d posting send for protocol error\n"",/~/			ret);/~/		svc_rdma_unmap_dma(ctxt);/~/		svc_rdma_put_context(ctxt, 1);/~/	}/~/}"
243,"GesturePoint::GesturePoint()
: first_touch_time_(0.0),
last_touch_time_(0.0),
last_tap_time_(0.0),
      velocity_calculator_(kBufferedPoints) {
}
",[4],      velocity_calculator_(kBufferedPoints) {
244,"int main(int argc, char *argv[])
{
int ret;
struct lxc_lock *lock;

lock = lxc_newlock(NULL, NULL);
if (!lock) {
fprintf(stderr, ""%d: failed to get unnamed lock\n"", __LINE__);
exit(1);
}
ret = lxclock(lock, 0);
if (ret) {
fprintf(stderr, ""%d: failed to take unnamed lock (%d)\n"", __LINE__, ret);
exit(1);
}

ret = lxcunlock(lock);
if (ret) {
fprintf(stderr, ""%d: failed to put unnamed lock (%d)\n"", __LINE__, ret);
exit(1);
}
lxc_putlock(lock);

lock = lxc_newlock(""/var/lib/lxc"", mycontainername);
if (!lock) {
fprintf(stderr, ""%d: failed to get lock\n"", __LINE__);
exit(1);
}
struct stat sb;
	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";
ret = stat(pathname, &sb);
if (ret != 0) {
fprintf(stderr, ""%d: filename %s not created\n"", __LINE__,
pathname);
exit(1);
}
lxc_putlock(lock);

test_two_locks();

fprintf(stderr, ""all tests passed\n"");

exit(ret);
}
",[26],"	char *pathname = RUNTIME_PATH ""/lock/lxc/var/lib/lxc/"";"
245,"void WebPluginDelegateProxy::OnGetWindowScriptNPObject(
    int route_id, bool* success, intptr_t* npobject_ptr) {
*success = false;
NPObject* npobject = NULL;
if (plugin_)
npobject = plugin_->GetWindowScriptNPObject();

if (!npobject)
return;

// The stub will delete itself when the proxy tells it that it's released, or
// otherwise when the channel is closed.
window_script_object_ = (new NPObjectStub(
npobject, channel_host_.get(), route_id, 0, page_url_))->AsWeakPtr();
*success = true;
  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);
}
","[1, 13]","    int route_id, bool* success, intptr_t* npobject_ptr) {/~/  *npobject_ptr = reinterpret_cast<intptr_t>(npobject);"
246,"void gdImageGifCtx(gdImagePtr im, gdIOCtxPtr out)
{
gdImagePtr pim = 0, tim = im;
int interlace, BitsPerPixel;
interlace = im->interlace;
if (im->trueColor) {
/* Expensive, but the only way that produces an
acceptable result: mix down to a palette
based temporary image. */
pim = gdImageCreatePaletteFromTrueColor(im, 1, 256);
if (!pim) {
			return;
}
tim = pim;
}
BitsPerPixel = colorstobpp(tim->colorsTotal);
/* All set, let's do it. */
GIFEncode(
out, tim->sx, tim->sy, tim->interlace, 0, tim->transparent, BitsPerPixel,
tim->red, tim->green, tim->blue, tim);
if (pim) {
/* Destroy palette based temporary image. */
gdImageDestroy(	pim);
}
}
",[11],			return;
247,"int _our_safe_pcap_next_ex(pcap_t *pcap, struct pcap_pkthdr **pkthdr,
const u_char **pktdata, const char *funcname,
const int line, const char *file)
{
int res = pcap_next_ex(pcap, pkthdr, pktdata);

if (*pktdata && *pkthdr) {
if ((*pkthdr)->len > MAXPACKET) {
fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: %u is greater than maximum %u\n"",
file, funcname, line, (*pkthdr)->len, MAXPACKET);
exit(-1);
}

        if ((*pkthdr)->len < (*pkthdr)->caplen) {
            fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"",
file, funcname, line, (*pkthdr)->len, (*pkthdr)->caplen);
exit(-1);
}
}

return res;
}
","[11, 12]","        if ((*pkthdr)->len < (*pkthdr)->caplen) {/~/            fprintf(stderr, ""safe_pcap_next_ex ERROR: Invalid packet length in %s:%s() line %d: packet length %u is less than capture length %u\n"","
248,"static int crypto_report_akcipher(struct sk_buff *skb, struct crypto_alg *alg)
{
struct crypto_report_akcipher rakcipher;

	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));

if (nla_put(skb, CRYPTOCFGA_REPORT_AKCIPHER,
sizeof(struct crypto_report_akcipher), &rakcipher))
goto nla_put_failure;
return 0;

nla_put_failure:
return -EMSGSIZE;
}
",[3],"	strlcpy(rakcipher.type, ""akcipher"", sizeof(rakcipher.type));"
249,"v8::Handle<v8::Value> V8XMLHttpRequest::openCallback(const v8::Arguments& args)
{
INC_STATS(""DOM.XMLHttpRequest.open()"");
// Four cases:
// open(method, url)
// open(method, url, async)
// open(method, url, async, user)
// open(method, url, async, user, passwd)

if (args.Length() < 2)
        return V8Proxy::throwNotEnoughArgumentsError();

XMLHttpRequest* xmlHttpRequest = V8XMLHttpRequest::toNative(args.Holder());

String method = toWebCoreString(args[0]);
String urlstring = toWebCoreString(args[1]);
ScriptExecutionContext* context = getScriptExecutionContext();
if (!context)
return v8::Undefined();

KURL url = context->completeURL(urlstring);

ExceptionCode ec = 0;

if (args.Length() >= 3) {
bool async = args[2]->BooleanValue();

if (args.Length() >= 4 && !args[3]->IsUndefined()) {
String user = toWebCoreStringWithNullCheck(args[3]);

if (args.Length() >= 5 && !args[4]->IsUndefined()) {
String passwd = toWebCoreStringWithNullCheck(args[4]);
xmlHttpRequest->open(method, url, async, user, passwd, ec);
} else
xmlHttpRequest->open(method, url, async, user, ec);
} else
xmlHttpRequest->open(method, url, async, ec);
} else
xmlHttpRequest->open(method, url, ec);

if (ec)
return throwError(ec, args.GetIsolate());

return v8::Undefined();
}
",[9],        return V8Proxy::throwNotEnoughArgumentsError();
250,"static unsigned int seedsize(struct crypto_alg *alg)
{
struct rng_alg *ralg = container_of(alg, struct rng_alg, base);

	return alg->cra_rng.rng_make_random ?
	       alg->cra_rng.seedsize : ralg->seedsize;
}
","[3, 4]",	return alg->cra_rng.rng_make_random ?/~/	       alg->cra_rng.seedsize : ralg->seedsize;
251,"WORD32 ih264d_parse_decode_slice(UWORD8 u1_is_idr_slice,
UWORD8 u1_nal_ref_idc,
dec_struct_t *ps_dec /* Decoder parameters */
)
{
dec_bit_stream_t * ps_bitstrm = ps_dec->ps_bitstrm;
dec_pic_params_t *ps_pps;
dec_seq_params_t *ps_seq;
dec_slice_params_t *ps_cur_slice = ps_dec->ps_cur_slice;
pocstruct_t s_tmp_poc;
WORD32 i_delta_poc[2];
WORD32 i4_poc = 0;
UWORD16 u2_first_mb_in_slice, u2_frame_num;
UWORD8 u1_field_pic_flag, u1_redundant_pic_cnt = 0, u1_slice_type;
UWORD32 u4_idr_pic_id = 0;
UWORD8 u1_bottom_field_flag, u1_pic_order_cnt_type;

UWORD8 u1_nal_unit_type;
UWORD32 *pu4_bitstrm_buf = ps_bitstrm->pu4_buffer;
UWORD32 *pu4_bitstrm_ofst = &ps_bitstrm->u4_ofst;
WORD8 i1_is_end_of_poc;

WORD32 ret, end_of_frame;
WORD32 prev_slice_err, num_mb_skipped;
UWORD8 u1_mbaff;
pocstruct_t *ps_cur_poc;

UWORD32 u4_temp;
WORD32 i_temp;
UWORD32 u4_call_end_of_pic = 0;

/* read FirstMbInSlice  and slice type*/
ps_dec->ps_dpb_cmds->u1_dpb_commands_read_slc = 0;
u2_first_mb_in_slice = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
if(u2_first_mb_in_slice
> (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs))
{

return ERROR_CORRUPTED_SLICE;
}

/*we currently don not support ASO*/
if(((u2_first_mb_in_slice << ps_cur_slice->u1_mbaff_frame_flag)
<= ps_dec->u2_cur_mb_addr) && (ps_dec->u4_first_slice_in_pic == 0))
{
return ERROR_CORRUPTED_SLICE;
}

COPYTHECONTEXT(""SH: first_mb_in_slice"",u2_first_mb_in_slice);

u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);

if(u4_temp > 9)
return ERROR_INV_SLC_TYPE_T;

u1_slice_type = u4_temp;
COPYTHECONTEXT(""SH: slice_type"",(u1_slice_type));
ps_dec->u1_sl_typ_5_9 = 0;
/* Find Out the Slice Type is 5 to 9 or not then Set the Flag   */
/* u1_sl_typ_5_9 = 1 .Which tells that all the slices in the Pic*/
/* will be of same type of current                            */
if(u1_slice_type > 4)
{
u1_slice_type -= 5;
ps_dec->u1_sl_typ_5_9 = 1;
}

{
UWORD32 skip;

if((ps_dec->i4_app_skip_mode == IVD_SKIP_PB)
|| (ps_dec->i4_dec_skip_mode == IVD_SKIP_PB))
{
UWORD32 u4_bit_stream_offset = 0;

if(ps_dec->u1_nal_unit_type == IDR_SLICE_NAL)
{
skip = 0;

ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
}
else if((I_SLICE == u1_slice_type)
&& (1 >= ps_dec->ps_cur_sps->u1_num_ref_frames))
{
skip = 0;

ps_dec->i4_dec_skip_mode = IVD_SKIP_NONE;
}
else
{
skip = 1;
}

/* If one frame worth of data is already skipped, do not skip the next one */
if((0 == u2_first_mb_in_slice) && (1 == ps_dec->u4_prev_nal_skipped))
{
skip = 0;
}

if(skip)
{
ps_dec->u4_prev_nal_skipped = 1;
ps_dec->i4_dec_skip_mode = IVD_SKIP_PB;
return 0;
}
else
{
/* If the previous NAL was skipped, then
do not process that buffer in this call.
Return to app and process it in the next call.
This is necessary to handle cases where I/IDR is not complete in
the current buffer and application intends to fill the remaining part of the bitstream
later. This ensures we process only frame worth of data in every call */
if(1 == ps_dec->u4_prev_nal_skipped)
{
ps_dec->u4_return_to_app = 1;
return 0;
}
}
}

}

u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp & MASK_ERR_PIC_SET_ID)
return ERROR_INV_SLICE_HDR_T;
/* discard slice if pic param is invalid */
COPYTHECONTEXT(""SH: pic_parameter_set_id"", u4_temp);
ps_pps = &ps_dec->ps_pps[u4_temp];
if(FALSE == ps_pps->u1_is_valid)
{
return ERROR_INV_SLICE_HDR_T;
}
ps_seq = ps_pps->ps_sps;
if(!ps_seq)
return ERROR_INV_SLICE_HDR_T;
if(FALSE == ps_seq->u1_is_valid)
return ERROR_INV_SLICE_HDR_T;

/* Get the frame num */
u2_frame_num = ih264d_get_bits_h264(ps_bitstrm,
ps_seq->u1_bits_in_frm_num);
//    H264_DEC_DEBUG_PRINT(""FRAME %d First MB in slice: %d\n"", u2_frame_num, u2_first_mb_in_slice);


COPYTHECONTEXT(""SH: frame_num"", u2_frame_num);
//    H264_DEC_DEBUG_PRINT(""Second field: %d frame num: %d prv_frame_num: %d \n"", ps_dec->u1_second_field, u2_frame_num, ps_dec->u2_prv_frame_num);

/* Get the field related flags  */
if(!ps_seq->u1_frame_mbs_only_flag)
{

u1_field_pic_flag = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: field_pic_flag"", u1_field_pic_flag);
u1_bottom_field_flag = 0;

if(u1_field_pic_flag)
{
ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan_fld;
u1_bottom_field_flag = ih264d_get_bit_h264(ps_bitstrm);
COPYTHECONTEXT(""SH: bottom_field_flag"", u1_bottom_field_flag);

}
else
{
ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
}
}
else
{
u1_field_pic_flag = 0;
u1_bottom_field_flag = 0;

ps_dec->pu1_inv_scan = (UWORD8 *)gau1_ih264d_inv_scan;
}

u1_nal_unit_type = SLICE_NAL;
if(u1_is_idr_slice)
{
if(0 == u1_field_pic_flag)
{
ps_dec->u1_top_bottom_decoded = TOP_FIELD_ONLY | BOT_FIELD_ONLY;
}
u1_nal_unit_type = IDR_SLICE_NAL;
u4_idr_pic_id = ih264d_uev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
if(u4_idr_pic_id > 65535)
return ERROR_INV_SLICE_HDR_T;
COPYTHECONTEXT(""SH:  "", u4_idr_pic_id);
}

/* read delta pic order count information*/
i_delta_poc[0] = i_delta_poc[1] = 0;
s_tmp_poc.i4_pic_order_cnt_lsb = 0;
s_tmp_poc.i4_delta_pic_order_cnt_bottom = 0;
u1_pic_order_cnt_type = ps_seq->u1_pic_order_cnt_type;
if(u1_pic_order_cnt_type == 0)
{
i_temp = ih264d_get_bits_h264(
ps_bitstrm,
ps_seq->u1_log2_max_pic_order_cnt_lsb_minus);
if(i_temp < 0 || i_temp >= ps_seq->i4_max_pic_order_cntLsb)
return ERROR_INV_SLICE_HDR_T;
s_tmp_poc.i4_pic_order_cnt_lsb = i_temp;
COPYTHECONTEXT(""SH: pic_order_cnt_lsb"", s_tmp_poc.i4_pic_order_cnt_lsb);

if((ps_pps->u1_pic_order_present_flag == 1) && (!u1_field_pic_flag))
{
s_tmp_poc.i4_delta_pic_order_cnt_bottom = ih264d_sev(
pu4_bitstrm_ofst, pu4_bitstrm_buf);
//if(s_tmp_poc.i4_delta_pic_order_cnt_bottom > ps_seq->i4_max_pic_order_cntLsb)
COPYTHECONTEXT(""SH: delta_pic_order_cnt_bottom"",
s_tmp_poc.i4_delta_pic_order_cnt_bottom);
}
}

s_tmp_poc.i4_delta_pic_order_cnt[0] = 0;
s_tmp_poc.i4_delta_pic_order_cnt[1] = 0;
if(u1_pic_order_cnt_type == 1
&& (!ps_seq->u1_delta_pic_order_always_zero_flag))
{
s_tmp_poc.i4_delta_pic_order_cnt[0] = ih264d_sev(pu4_bitstrm_ofst,
pu4_bitstrm_buf);
COPYTHECONTEXT(""SH: delta_pic_order_cnt[0]"",
s_tmp_poc.i4_delta_pic_order_cnt[0]);

if(ps_pps->u1_pic_order_present_flag && !u1_field_pic_flag)
{
s_tmp_poc.i4_delta_pic_order_cnt[1] = ih264d_sev(
pu4_bitstrm_ofst, pu4_bitstrm_buf);
COPYTHECONTEXT(""SH: delta_pic_order_cnt[1]"",
s_tmp_poc.i4_delta_pic_order_cnt[1]);
}
}

if(ps_pps->u1_redundant_pic_cnt_present_flag)
{
u4_temp = ih264d_uev(pu4_bitstrm_ofst, pu4_bitstrm_buf);
if(u4_temp > MAX_REDUNDANT_PIC_CNT)
return ERROR_INV_SLICE_HDR_T;
u1_redundant_pic_cnt = u4_temp;
COPYTHECONTEXT(""SH: redundant_pic_cnt"", u1_redundant_pic_cnt);
}

/*--------------------------------------------------------------------*/
/* Check if the slice is part of new picture                          */
/*--------------------------------------------------------------------*/
/* First slice of a picture is always considered as part of new picture */
i1_is_end_of_poc = 1;
ps_dec->ps_dec_err_status->u1_err_flag &= MASK_REJECT_CUR_PIC;

if(ps_dec->u4_first_slice_in_pic != 2)
{
i1_is_end_of_poc = ih264d_is_end_of_pic(u2_frame_num, u1_nal_ref_idc,
&s_tmp_poc, &ps_dec->s_cur_pic_poc,
ps_cur_slice, u1_pic_order_cnt_type,

u1_nal_unit_type, u4_idr_pic_id,
u1_field_pic_flag,
u1_bottom_field_flag);
}

/*--------------------------------------------------------------------*/
/* Check for error in slice and parse the missing/corrupted MB's      */
/* as skip-MB's in an inserted P-slice                                */
/*--------------------------------------------------------------------*/
u1_mbaff = ps_seq->u1_mb_aff_flag && (!u1_field_pic_flag);
prev_slice_err = 0;

if(i1_is_end_of_poc || ps_dec->u1_first_slice_in_stream)
{
if(u2_frame_num != ps_dec->u2_prv_frame_num
&& ps_dec->u1_top_bottom_decoded != 0
&& ps_dec->u1_top_bottom_decoded
!= (TOP_FIELD_ONLY | BOT_FIELD_ONLY))
{
ps_dec->u1_dangling_field = 1;
if(ps_dec->u4_first_slice_in_pic)
{
// first slice - dangling field
prev_slice_err = 1;
}
else
{
// last slice - dangling field
prev_slice_err = 2;
}

if(ps_dec->u1_top_bottom_decoded ==TOP_FIELD_ONLY)
ps_cur_slice->u1_bottom_field_flag = 1;
else
ps_cur_slice->u1_bottom_field_flag = 0;

num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
- ps_dec->u2_total_mbs_coded;
ps_cur_poc = &ps_dec->s_cur_pic_poc;

u1_is_idr_slice = ps_cur_slice->u1_nal_unit_type == IDR_SLICE_NAL;
}
else if(ps_dec->u4_first_slice_in_pic == 2)
{
if(u2_first_mb_in_slice > 0)
{
// first slice - missing/header corruption
prev_slice_err = 1;
num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
ps_cur_poc = &s_tmp_poc;

// initializing slice parameters
ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
ps_cur_slice->i4_pic_order_cnt_lsb =
s_tmp_poc.i4_pic_order_cnt_lsb;
ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;
ps_cur_slice->u1_mbaff_frame_flag = ps_seq->u1_mb_aff_flag
&& (!u1_field_pic_flag);
}
}
else
{

if(ps_dec->u4_first_slice_in_pic)
{
/* if valid slice header is not decoded do start of pic processing
* since in the current process call, frame num is not updated in the slice structure yet
* ih264d_is_end_of_pic is checked with valid frame num of previous process call,
* although i1_is_end_of_poc is set there could be  more slices in the frame,
* so conceal only till cur slice */
prev_slice_err = 1;
num_mb_skipped = u2_first_mb_in_slice << u1_mbaff;
}
else
{
/* since i1_is_end_of_poc is set ,means new frame num is encountered. so conceal the current frame
* completely */
prev_slice_err = 2;
num_mb_skipped = (ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
- ps_dec->u2_total_mbs_coded;
}
ps_cur_poc = &s_tmp_poc;
}
}
else
{
if((u2_first_mb_in_slice << u1_mbaff) > ps_dec->u2_total_mbs_coded)
{
// previous slice - missing/corruption
prev_slice_err = 2;
num_mb_skipped = (u2_first_mb_in_slice << u1_mbaff)
- ps_dec->u2_total_mbs_coded;
ps_cur_poc = &s_tmp_poc;
}
else if((u2_first_mb_in_slice << u1_mbaff) < ps_dec->u2_total_mbs_coded)
{
return ERROR_CORRUPTED_SLICE;
}
}

if(prev_slice_err)
{
ret = ih264d_mark_err_slice_skip(ps_dec, num_mb_skipped, u1_is_idr_slice, u2_frame_num, ps_cur_poc, prev_slice_err);

if(ps_dec->u1_dangling_field == 1)
{
ps_dec->u1_second_field = 1 - ps_dec->u1_second_field;
ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
ps_dec->u2_prv_frame_num = u2_frame_num;
ps_dec->u1_first_slice_in_stream = 0;
return ERROR_DANGLING_FIELD_IN_PIC;
}

if(prev_slice_err == 2)
{
ps_dec->u1_first_slice_in_stream = 0;
return ERROR_INCOMPLETE_FRAME;
}

if(ps_dec->u2_total_mbs_coded
>= ps_dec->u2_frm_ht_in_mbs * ps_dec->u2_frm_wd_in_mbs)
{
/* return if all MBs in frame are parsed*/
ps_dec->u1_first_slice_in_stream = 0;
return ERROR_IN_LAST_SLICE_OF_PIC;
}

if(ps_dec->ps_dec_err_status->u1_err_flag & REJECT_CUR_PIC)
{
ih264d_err_pic_dispbuf_mgr(ps_dec);
return ERROR_NEW_FRAME_EXPECTED;
}

if(ret != OK)
return ret;

i1_is_end_of_poc = 0;
}

if (ps_dec->u4_first_slice_in_pic == 0)
{
ps_dec->ps_parse_cur_slice++;
ps_dec->u2_cur_slice_num++;
}

// in the case of single core increment ps_decode_cur_slice
if((ps_dec->u1_separate_parse == 0) && (ps_dec->u4_first_slice_in_pic == 0))
{
ps_dec->ps_decode_cur_slice++;

}
ps_dec->u1_slice_header_done = 0;

    /*--------------------------------------------------------------------*
    /* If the slice is part of new picture, do End of Pic processing.     *
    /*--------------------------------------------------------------------*
    if(!ps_dec->u1_first_slice_in_stream)
    {
        UWORD8 uc_mbs_exceed = 0;
        if(ps_dec->u2_total_mbs_coded
                        == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))
        {
            /*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so
             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture *
            if(ps_dec->u4_first_slice_in_pic == 0)
                uc_mbs_exceed = 1;
        }
        if(i1_is_end_of_poc || uc_mbs_exceed)
        {
            if(1 == ps_dec->u1_last_pic_not_decoded)
            {
                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);
                if(ret != OK)
                    return ret;
                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);
                if(ret != OK)
                    return ret;
#if WIN32
                H264_DEC_DEBUG_PRINT("" ------ PIC SKIPPED ------\n"");
#endif
                return RET_LAST_SKIP;
            }
            else
            {
                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);
                if(ret != OK)
                    return ret;
            }
        }
    }

if(u1_field_pic_flag)
{
ps_dec->u2_prv_frame_num = u2_frame_num;
}

if(ps_cur_slice->u1_mmco_equalto5)
{
WORD32 i4_temp_poc;
WORD32 i4_top_field_order_poc, i4_bot_field_order_poc;

if(!ps_cur_slice->u1_field_pic_flag) // or a complementary field pair
{
i4_top_field_order_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
i4_bot_field_order_poc =
ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
i4_temp_poc = MIN(i4_top_field_order_poc,
i4_bot_field_order_poc);
}
else if(!ps_cur_slice->u1_bottom_field_flag)
i4_temp_poc = ps_dec->ps_cur_pic->i4_top_field_order_cnt;
else
i4_temp_poc = ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;

ps_dec->ps_cur_pic->i4_top_field_order_cnt = i4_temp_poc
- ps_dec->ps_cur_pic->i4_top_field_order_cnt;
ps_dec->ps_cur_pic->i4_bottom_field_order_cnt = i4_temp_poc
- ps_dec->ps_cur_pic->i4_bottom_field_order_cnt;
ps_dec->ps_cur_pic->i4_poc = i4_temp_poc;
ps_dec->ps_cur_pic->i4_avg_poc = i4_temp_poc;
}
if(ps_dec->u4_first_slice_in_pic == 2)
{
ret = ih264d_decode_pic_order_cnt(u1_is_idr_slice, u2_frame_num,
&ps_dec->s_prev_pic_poc,
&s_tmp_poc, ps_cur_slice, ps_pps,
u1_nal_ref_idc,
u1_bottom_field_flag,
u1_field_pic_flag, &i4_poc);
if(ret != OK)
return ret;
/* Display seq no calculations */
if(i4_poc >= ps_dec->i4_max_poc)
ps_dec->i4_max_poc = i4_poc;
/* IDR Picture or POC wrap around */
if(i4_poc == 0)
{
ps_dec->i4_prev_max_display_seq = ps_dec->i4_prev_max_display_seq
+ ps_dec->i4_max_poc
+ ps_dec->u1_max_dec_frame_buffering + 1;
ps_dec->i4_max_poc = 0;
}
}

/*--------------------------------------------------------------------*/
/* Copy the values read from the bitstream to the slice header and then*/
/* If the slice is first slice in picture, then do Start of Picture   */
/* processing.                                                        */
/*--------------------------------------------------------------------*/
ps_cur_slice->i4_delta_pic_order_cnt[0] = i_delta_poc[0];
ps_cur_slice->i4_delta_pic_order_cnt[1] = i_delta_poc[1];
ps_cur_slice->u4_idr_pic_id = u4_idr_pic_id;
ps_cur_slice->u2_first_mb_in_slice = u2_first_mb_in_slice;
ps_cur_slice->u1_field_pic_flag = u1_field_pic_flag;
ps_cur_slice->u1_bottom_field_flag = u1_bottom_field_flag;
ps_cur_slice->u1_slice_type = u1_slice_type;
ps_cur_slice->i4_pic_order_cnt_lsb = s_tmp_poc.i4_pic_order_cnt_lsb;

ps_cur_slice->u1_nal_unit_type = u1_nal_unit_type;
ps_cur_slice->u1_redundant_pic_cnt = u1_redundant_pic_cnt;
ps_cur_slice->u1_nal_ref_idc = u1_nal_ref_idc;
ps_cur_slice->u1_pic_order_cnt_type = u1_pic_order_cnt_type;

if(ps_seq->u1_frame_mbs_only_flag)
ps_cur_slice->u1_direct_8x8_inference_flag =
ps_seq->u1_direct_8x8_inference_flag;
else
ps_cur_slice->u1_direct_8x8_inference_flag = 1;

if(u1_slice_type == B_SLICE)
{
ps_cur_slice->u1_direct_spatial_mv_pred_flag = ih264d_get_bit_h264(
ps_bitstrm);
COPYTHECONTEXT(""SH: direct_spatial_mv_pred_flag"",
ps_cur_slice->u1_direct_spatial_mv_pred_flag);

if(ps_cur_slice->u1_direct_spatial_mv_pred_flag)
ps_cur_slice->pf_decodeDirect = ih264d_decode_spatial_direct;
else
ps_cur_slice->pf_decodeDirect = ih264d_decode_temporal_direct;
if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
ps_dec->pf_mvpred = ih264d_mvpred_nonmbaffB;
}
else
{
if(!((ps_pps->ps_sps->u1_mb_aff_flag) && (!u1_field_pic_flag)))
ps_dec->pf_mvpred = ih264d_mvpred_nonmbaff;
}

if(ps_dec->u4_first_slice_in_pic == 2)
{
if(u2_first_mb_in_slice == 0)
{
ret = ih264d_start_of_pic(ps_dec, i4_poc, &s_tmp_poc, u2_frame_num, ps_pps);
if(ret != OK)
return ret;
}

ps_dec->u4_output_present = 0;

{
ih264d_get_next_display_field(ps_dec,
ps_dec->ps_out_buffer,
&(ps_dec->s_disp_op));
/* If error code is non-zero then there is no buffer available for display,
hence avoid format conversion */

if(0 != ps_dec->s_disp_op.u4_error_code)
{
ps_dec->u4_fmt_conv_cur_row = ps_dec->s_disp_frame_info.u4_y_ht;
}
else
ps_dec->u4_output_present = 1;
}
if(ps_dec->u1_separate_parse == 1)
{
if(ps_dec->u4_dec_thread_created == 0)
{
ithread_create(ps_dec->pv_dec_thread_handle, NULL,
(void *)ih264d_decode_picture_thread,
(void *)ps_dec);

ps_dec->u4_dec_thread_created = 1;
}

if((ps_dec->u4_num_cores == 3) &&
((ps_dec->u4_app_disable_deblk_frm == 0) || ps_dec->i1_recon_in_thread3_flag)
&& (ps_dec->u4_bs_deblk_thread_created == 0))
{
ps_dec->u4_start_recon_deblk = 0;
ithread_create(ps_dec->pv_bs_deblk_thread_handle, NULL,
(void *)ih264d_recon_deblk_thread,
(void *)ps_dec);
ps_dec->u4_bs_deblk_thread_created = 1;
}
}

}

/* INITIALIZATION of fn ptrs for MC and formMbPartInfo functions */
{
UWORD8 uc_nofield_nombaff;



uc_nofield_nombaff = ((ps_dec->ps_cur_slice->u1_field_pic_flag == 0)
&& (ps_dec->ps_cur_slice->u1_mbaff_frame_flag == 0)
&& (u1_slice_type != B_SLICE)
&& (ps_dec->ps_cur_pps->u1_wted_pred_flag == 0));

/* Initialise MC and formMbPartInfo fn ptrs one time based on profile_idc */

if(uc_nofield_nombaff)
{
ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_bp;
ps_dec->p_motion_compensate = ih264d_motion_compensate_bp;
}
else
{
ps_dec->p_form_mb_part_info = ih264d_form_mb_part_info_mp;
ps_dec->p_motion_compensate = ih264d_motion_compensate_mp;
}


}

/*
* Decide whether to decode the current picture or not
*/
{
dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
if(ps_err->u4_frm_sei_sync == u2_frame_num)
{
ps_err->u1_err_flag = ACCEPT_ALL_PICS;
ps_err->u4_frm_sei_sync = SYNC_FRM_DEFAULT;
}
ps_err->u4_cur_frm = u2_frame_num;
}

/* Decision for decoding if the picture is to be skipped */
{
WORD32 i4_skip_b_pic, i4_skip_p_pic;

i4_skip_b_pic = (ps_dec->u4_skip_frm_mask & B_SLC_BIT)
&& (B_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);

i4_skip_p_pic = (ps_dec->u4_skip_frm_mask & P_SLC_BIT)
&& (P_SLICE == u1_slice_type) && (0 == u1_nal_ref_idc);

/**************************************************************/
/* Skip the B picture if skip mask is set for B picture and   */
/* Current B picture is a non reference B picture or there is */
/* no user for reference B picture                            */
/**************************************************************/
if(i4_skip_b_pic)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
/* Don't decode the picture in SKIP-B mode if that picture is B */
/* and also it is not to be used as a reference picture         */
ps_dec->u1_last_pic_not_decoded = 1;

return OK;
}
/**************************************************************/
/* Skip the P picture if skip mask is set for P picture and   */
/* Current P picture is a non reference P picture or there is */
/* no user for reference P picture                            */
/**************************************************************/
if(i4_skip_p_pic)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
/* Don't decode the picture in SKIP-P mode if that picture is P */
/* and also it is not to be used as a reference picture         */
ps_dec->u1_last_pic_not_decoded = 1;

return OK;
}
}

{
UWORD16 u2_mb_x, u2_mb_y;

ps_dec->i4_submb_ofst = ((u2_first_mb_in_slice
<< ps_cur_slice->u1_mbaff_frame_flag) * SUB_BLK_SIZE)
- SUB_BLK_SIZE;
if(u2_first_mb_in_slice)
{
UWORD8 u1_mb_aff;
UWORD8 u1_field_pic;
UWORD16 u2_frm_wd_in_mbs;
u2_frm_wd_in_mbs = ps_seq->u2_frm_wd_in_mbs;
u1_mb_aff = ps_cur_slice->u1_mbaff_frame_flag;
u1_field_pic = ps_cur_slice->u1_field_pic_flag;

{
UWORD32 x_offset;
UWORD32 y_offset;
UWORD32 u4_frame_stride;
tfr_ctxt_t *ps_trns_addr; // = &ps_dec->s_tran_addrecon_parse;

if(ps_dec->u1_separate_parse)
{
ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
}
else
{
ps_trns_addr = &ps_dec->s_tran_addrecon;
}
u2_mb_x = MOD(u2_first_mb_in_slice, u2_frm_wd_in_mbs);
u2_mb_y = DIV(u2_first_mb_in_slice, u2_frm_wd_in_mbs);

u2_mb_y <<= u1_mb_aff;

if((u2_mb_x > u2_frm_wd_in_mbs - 1)
|| (u2_mb_y > ps_dec->u2_frm_ht_in_mbs - 1))
{
return ERROR_CORRUPTED_SLICE;
}

u4_frame_stride = ps_dec->u2_frm_wd_y << u1_field_pic;
x_offset = u2_mb_x << 4;
y_offset = (u2_mb_y * u4_frame_stride) << 4;

ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1 + x_offset
+ y_offset;

u4_frame_stride = ps_dec->u2_frm_wd_uv << u1_field_pic;
x_offset >>= 1;
y_offset = (u2_mb_y * u4_frame_stride) << 3;

x_offset *= YUV420SP_FACTOR;

ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2 + x_offset
+ y_offset;
ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3 + x_offset
+ y_offset;

ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;


// assign the deblock structure pointers to start of slice
if(ps_dec->u1_separate_parse == 1)
{
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
+ (u2_first_mb_in_slice << u1_mb_aff);
}
else
{
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic
+ (u2_first_mb_in_slice << u1_mb_aff);
}

ps_dec->u2_cur_mb_addr = (u2_first_mb_in_slice << u1_mb_aff);

ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv
+ ((u2_first_mb_in_slice << u1_mb_aff) << 4);
}
}
else
{
tfr_ctxt_t *ps_trns_addr;

if(ps_dec->u1_separate_parse)
{
ps_trns_addr = &ps_dec->s_tran_addrecon_parse;
}
else
{
ps_trns_addr = &ps_dec->s_tran_addrecon;
}

u2_mb_x = 0xffff;
u2_mb_y = 0;
// assign the deblock structure pointers to start of slice
ps_dec->u2_cur_mb_addr = 0;
ps_dec->ps_deblk_mbn = ps_dec->ps_deblk_pic;
ps_dec->ps_mv_cur = ps_dec->s_cur_pic.ps_mv;
ps_trns_addr->pu1_dest_y = ps_dec->s_cur_pic.pu1_buf1;
ps_trns_addr->pu1_dest_u = ps_dec->s_cur_pic.pu1_buf2;
ps_trns_addr->pu1_dest_v = ps_dec->s_cur_pic.pu1_buf3;

ps_trns_addr->pu1_mb_y = ps_trns_addr->pu1_dest_y;
ps_trns_addr->pu1_mb_u = ps_trns_addr->pu1_dest_u;
ps_trns_addr->pu1_mb_v = ps_trns_addr->pu1_dest_v;

}

ps_dec->ps_part = ps_dec->ps_parse_part_params;

ps_dec->u2_mbx =
(MOD(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
ps_dec->u2_mby =
(DIV(u2_first_mb_in_slice - 1, ps_seq->u2_frm_wd_in_mbs));
ps_dec->u2_mby <<= ps_cur_slice->u1_mbaff_frame_flag;
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;
}

/* RBSP stop bit is used for CABAC decoding*/
ps_bitstrm->u4_max_ofst += ps_dec->ps_cur_pps->u1_entropy_coding_mode;

ps_dec->u1_B = (u1_slice_type == B_SLICE);
ps_dec->u4_next_mb_skip = 0;

ps_dec->ps_parse_cur_slice->u4_first_mb_in_slice =
ps_dec->ps_cur_slice->u2_first_mb_in_slice;
ps_dec->ps_parse_cur_slice->slice_type =
ps_dec->ps_cur_slice->u1_slice_type;


ps_dec->u4_start_recon_deblk = 1;
{
WORD32 num_entries;
WORD32 size;
UWORD8 *pu1_buf;

num_entries = MIN(MAX_FRAMES, ps_dec->u4_num_ref_frames_at_init);
num_entries = 2 * ((2 * num_entries) + 1);

size = num_entries * sizeof(void *);
size += PAD_MAP_IDX_POC * sizeof(void *);

pu1_buf = (UWORD8 *)ps_dec->pv_map_ref_idx_to_poc_buf;
pu1_buf += size * ps_dec->u2_cur_slice_num;
ps_dec->ps_parse_cur_slice->ppv_map_ref_idx_to_poc = ( void *)pu1_buf;
}

if(ps_dec->u1_separate_parse)
{
ps_dec->ps_parse_cur_slice->pv_tu_coeff_data_start = ps_dec->pv_parse_tu_coeff_data;
}
else
{
ps_dec->pv_proc_tu_coeff_data = ps_dec->pv_parse_tu_coeff_data;
}

if(u1_slice_type == I_SLICE)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= I_SLC_BIT;

ret = ih264d_parse_islice(ps_dec, u2_first_mb_in_slice);

if(ps_dec->i4_pic_type != B_SLICE && ps_dec->i4_pic_type != P_SLICE)
ps_dec->i4_pic_type = I_SLICE;

}
else if(u1_slice_type == P_SLICE)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= P_SLC_BIT;
ret = ih264d_parse_pslice(ps_dec, u2_first_mb_in_slice);
ps_dec->u1_pr_sl_type = u1_slice_type;
if(ps_dec->i4_pic_type != B_SLICE)
ps_dec->i4_pic_type = P_SLICE;
}
else if(u1_slice_type == B_SLICE)
{
ps_dec->ps_cur_pic->u4_pack_slc_typ |= B_SLC_BIT;
ret = ih264d_parse_bslice(ps_dec, u2_first_mb_in_slice);
ps_dec->u1_pr_sl_type = u1_slice_type;
ps_dec->i4_pic_type = B_SLICE;
}
else
return ERROR_INV_SLC_TYPE_T;

if(ps_dec->u1_slice_header_done)
{
/* set to zero to indicate a valid slice has been decoded */
/* first slice header successfully decoded */
ps_dec->u4_first_slice_in_pic = 0;
ps_dec->u1_first_slice_in_stream = 0;
}

if(ret != OK)
return ret;

/* storing last Mb X and MbY of the slice */
ps_dec->i2_prev_slice_mbx = ps_dec->u2_mbx;
ps_dec->i2_prev_slice_mby = ps_dec->u2_mby;

/* End of Picture detection */

if(ps_dec->u2_total_mbs_coded >= (ps_seq->u2_max_mb_addr + 1))
{
ps_dec->u1_pic_decode_done = 1;

}

{
dec_err_status_t * ps_err = ps_dec->ps_dec_err_status;
if((ps_err->u1_err_flag & REJECT_PB_PICS)
&& (ps_err->u1_cur_pic_type == PIC_TYPE_I))
{
ps_err->u1_err_flag = ACCEPT_ALL_PICS;
}
}

PRINT_BIN_BIT_RATIO(ps_dec)

return ret;
}
",[4],"    /*--------------------------------------------------------------------*/~/    /* If the slice is part of new picture, do End of Pic processing.     */~/    /*--------------------------------------------------------------------*/~/    if(!ps_dec->u1_first_slice_in_stream)/~/    {/~/        UWORD8 uc_mbs_exceed = 0;/~/        if(ps_dec->u2_total_mbs_coded/~/                        == (ps_dec->ps_cur_sps->u2_max_mb_addr + 1))/~/        {/~/            /*u2_total_mbs_coded is forced  to u2_max_mb_addr+ 1 at the end of decode ,so/~/             ,if it is first slice in pic dont consider u2_total_mbs_coded to detect new picture */~/            if(ps_dec->u4_first_slice_in_pic == 0)/~/                uc_mbs_exceed = 1;/~/        }/~/        if(i1_is_end_of_poc || uc_mbs_exceed)/~/        {/~/            if(1 == ps_dec->u1_last_pic_not_decoded)/~/            {/~/                ret = ih264d_end_of_pic_dispbuf_mgr(ps_dec);/~/                if(ret != OK)/~/                    return ret;/~/                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);/~/                if(ret != OK)/~/                    return ret;/~/#if WIN32/~/                H264_DEC_DEBUG_PRINT("" ------ PIC SKIPPED ------\n"");/~/#endif/~/                return RET_LAST_SKIP;/~/            }/~/            else/~/            {/~/                ret = ih264d_end_of_pic(ps_dec, u1_is_idr_slice, u2_frame_num);/~/                if(ret != OK)/~/                    return ret;/~/            }/~/        }/~/    }"
252,"gamma_component_validate(PNG_CONST char *name, PNG_CONST validate_info *vi,
    PNG_CONST unsigned int id, PNG_CONST unsigned int od,
    PNG_CONST double alpha /* <0 for the alpha channel itself */,
    PNG_CONST double background /* component background value */)
{
   PNG_CONST unsigned int isbit = id >> vi->isbit_shift;
   PNG_CONST unsigned int sbit_max = vi->sbit_max;
   PNG_CONST unsigned int outmax = vi->outmax;
   PNG_CONST int do_background = vi->do_background;

double i;

/* First check on the 'perfect' result obtained from the digitized input
* value, id, and compare this against the actual digitized result, 'od'.
* 'i' is the input result in the range 0..1:
*/
i = isbit; i /= sbit_max;

/* Check for the fast route: if we don't do any background composition or if
* this is the alpha channel ('alpha' < 0) or if the pixel is opaque then
* just use the gamma_correction field to correct to the final output gamma.
*/
if (alpha == 1 /* opaque pixel component */ || !do_background
#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
|| do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_PNG
#endif
|| (alpha < 0 /* alpha channel */
#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
&& do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN
#endif
))
{
/* Then get the gamma corrected version of 'i' and compare to 'od', any
* error less than .5 is insignificant - just quantization of the output
* value to the nearest digital value (nevertheless the error is still
* recorded - it's interesting ;-)
*/
double encoded_sample = i;
double encoded_error;

/* alpha less than 0 indicates the alpha channel, which is always linear
*/
if (alpha >= 0 && vi->gamma_correction > 0)
encoded_sample = pow(encoded_sample, vi->gamma_correction);
encoded_sample *= outmax;

encoded_error = fabs(od-encoded_sample);

if (encoded_error > vi->dp->maxerrout)
vi->dp->maxerrout = encoded_error;

if (encoded_error < vi->maxout_total && encoded_error < vi->outlog)
return i;
}

/* The slow route - attempt to do linear calculations. */
/* There may be an error, or background processing is required, so calculate
* the actual sample values - unencoded light intensity values.  Note that in
* practice these are not completely unencoded because they include a
* 'viewing correction' to decrease or (normally) increase the perceptual
* contrast of the image.  There's nothing we can do about this - we don't
* know what it is - so assume the unencoded value is perceptually linear.
*/
{
double input_sample = i; /* In range 0..1 */
double output, error, encoded_sample, encoded_error;
double es_lo, es_hi;
int compose = 0; /* Set to one if composition done */
int output_is_encoded; /* Set if encoded to screen gamma */
int log_max_error = 1; /* Check maximum error values */
png_const_charp pass = 0; /* Reason test passes (or 0 for fail) */

/* Convert to linear light (with the above caveat.)  The alpha channel is
* already linear.
*/
if (alpha >= 0)
{
int tcompose;

if (vi->file_inverse > 0)
input_sample = pow(input_sample, vi->file_inverse);

/* Handle the compose processing: */
tcompose = 0;
input_sample = gamma_component_compose(do_background, input_sample,
alpha, background, &tcompose);

if (tcompose)
compose = 1;
}

/* And similarly for the output value, but we need to check the background
* handling to linearize it correctly.
*/
output = od;
output /= outmax;

output_is_encoded = vi->screen_gamma > 0;

if (alpha < 0) /* The alpha channel */
{
#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
if (do_background != ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN)
#endif
{
/* In all other cases the output alpha channel is linear already,
* don't log errors here, they are much larger in linear data.
*/
output_is_encoded = 0;
log_max_error = 0;
}
}

#ifdef PNG_READ_ALPHA_MODE_SUPPORTED
else /* A component */
{
if (do_background == ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED &&
alpha < 1) /* the optimized case - linear output */
{
if (alpha > 0) log_max_error = 0;
output_is_encoded = 0;
}
}
#endif

if (output_is_encoded)
output = pow(output, vi->screen_gamma);

/* Calculate (or recalculate) the encoded_sample value and repeat the
* check above (unnecessary if we took the fast route, but harmless.)
*/
encoded_sample = input_sample;
if (output_is_encoded)
encoded_sample = pow(encoded_sample, vi->screen_inverse);
encoded_sample *= outmax;

encoded_error = fabs(od-encoded_sample);

/* Don't log errors in the alpha channel, or the 'optimized' case,
* neither are significant to the overall perception.
*/
if (log_max_error && encoded_error > vi->dp->maxerrout)
vi->dp->maxerrout = encoded_error;

if (encoded_error < vi->maxout_total)
{
if (encoded_error < vi->outlog)
return i;

/* Test passed but error is bigger than the log limit, record why the
* test passed:
*/
pass = ""less than maxout:\n"";
}

/* i: the original input value in the range 0..1
*
* pngvalid calculations:
*  input_sample: linear result; i linearized and composed, range 0..1
*  encoded_sample: encoded result; input_sample scaled to ouput bit depth
*
* libpng calculations:
*  output: linear result; od scaled to 0..1 and linearized
*  od: encoded result from libpng
*/

/* Now we have the numbers for real errors, both absolute values as as a
* percentage of the correct value (output):
*/
error = fabs(input_sample-output);

if (log_max_error && error > vi->dp->maxerrabs)
vi->dp->maxerrabs = error;

/* The following is an attempt to ignore the tendency of quantization to
* dominate the percentage errors for lower result values:
*/
if (log_max_error && input_sample > .5)
{
double percentage_error = error/input_sample;
if (percentage_error > vi->dp->maxerrpc)
vi->dp->maxerrpc = percentage_error;
}

/* Now calculate the digitization limits for 'encoded_sample' using the
* 'max' values.  Note that maxout is in the encoded space but maxpc and
* maxabs are in linear light space.
*
* First find the maximum error in linear light space, range 0..1:
*/
{
double tmp = input_sample * vi->maxpc;
if (tmp < vi->maxabs) tmp = vi->maxabs;
/* If 'compose' is true the composition was done in linear space using
* integer arithmetic.  This introduces an extra error of +/- 0.5 (at
* least) in the integer space used.  'maxcalc' records this, taking
* into account the possibility that even for 16 bit output 8 bit space
* may have been used.
*/
if (compose && tmp < vi->maxcalc) tmp = vi->maxcalc;

/* The 'maxout' value refers to the encoded result, to compare with
* this encode input_sample adjusted by the maximum error (tmp) above.
*/
es_lo = encoded_sample - vi->maxout;

if (es_lo > 0 && input_sample-tmp > 0)
{
double low_value = input_sample-tmp;
if (output_is_encoded)
low_value = pow(low_value, vi->screen_inverse);
low_value *= outmax;
if (low_value < es_lo) es_lo = low_value;

/* Quantize this appropriately: */
es_lo = ceil(es_lo / vi->outquant - .5) * vi->outquant;
}

else
es_lo = 0;

es_hi = encoded_sample + vi->maxout;

if (es_hi < outmax && input_sample+tmp < 1)
{
double high_value = input_sample+tmp;
if (output_is_encoded)
high_value = pow(high_value, vi->screen_inverse);
high_value *= outmax;
if (high_value > es_hi) es_hi = high_value;

es_hi = floor(es_hi / vi->outquant + .5) * vi->outquant;
}

else
es_hi = outmax;
}

/* The primary test is that the final encoded value returned by the
* library should be between the two limits (inclusive) that were
* calculated above.
*/
if (od >= es_lo && od <= es_hi)
{
/* The value passes, but we may need to log the information anyway. */
if (encoded_error < vi->outlog)
return i;

if (pass == 0)
pass = ""within digitization limits:\n"";
}

{
/* There has been an error in processing, or we need to log this
* value.
*/
double is_lo, is_hi;

/* pass is set at this point if either of the tests above would have
* passed.  Don't do these additional tests here - just log the
* original [es_lo..es_hi] values.
*/
if (pass == 0 && vi->use_input_precision && vi->dp->sbit)
{
/* Ok, something is wrong - this actually happens in current libpng
* 16-to-8 processing.  Assume that the input value (id, adjusted
* for sbit) can be anywhere between value-.5 and value+.5 - quite a
* large range if sbit is low.
*
* NOTE: at present because the libpng gamma table stuff has been
* changed to use a rounding algorithm to correct errors in 8-bit
* calculations the precise sbit calculation (a shift) has been
* lost.  This can result in up to a +/-1 error in the presence of
* an sbit less than the bit depth.
*/
#           if PNG_LIBPNG_VER < 10700
#              define SBIT_ERROR .5
#           else
#              define SBIT_ERROR 1.
#           endif
double tmp = (isbit - SBIT_ERROR)/sbit_max;

if (tmp <= 0)
tmp = 0;

else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)
tmp = pow(tmp, vi->file_inverse);

tmp = gamma_component_compose(do_background, tmp, alpha, background,
NULL);

if (output_is_encoded && tmp > 0 && tmp < 1)
tmp = pow(tmp, vi->screen_inverse);

is_lo = ceil(outmax * tmp - vi->maxout_total);

if (is_lo < 0)
is_lo = 0;

tmp = (isbit + SBIT_ERROR)/sbit_max;

if (tmp >= 1)
tmp = 1;

else if (alpha >= 0 && vi->file_inverse > 0 && tmp < 1)
tmp = pow(tmp, vi->file_inverse);

tmp = gamma_component_compose(do_background, tmp, alpha, background,
NULL);

if (output_is_encoded && tmp > 0 && tmp < 1)
tmp = pow(tmp, vi->screen_inverse);

is_hi = floor(outmax * tmp + vi->maxout_total);

if (is_hi > outmax)
is_hi = outmax;

if (!(od < is_lo || od > is_hi))
{
if (encoded_error < vi->outlog)
return i;

pass = ""within input precision limits:\n"";
}

/* One last chance.  If this is an alpha channel and the 16to8
* option has been used and 'inaccurate' scaling is used then the
* bit reduction is obtained by simply using the top 8 bits of the
* value.
*
* This is only done for older libpng versions when the 'inaccurate'
* (chop) method of scaling was used.
*/
#           ifndef PNG_READ_16_TO_8_ACCURATE_SCALE_SUPPORTED
#              if PNG_LIBPNG_VER < 10504
/* This may be required for other components in the future,
* but at present the presence of gamma correction effectively
* prevents the errors in the component scaling (I don't quite
* understand why, but since it's better this way I care not
* to ask, JB 20110419.)
*/
if (pass == 0 && alpha < 0 && vi->scale16 && vi->sbit > 8 &&
vi->sbit + vi->isbit_shift == 16)
{
tmp = ((id >> 8) - .5)/255;

if (tmp > 0)
{
is_lo = ceil(outmax * tmp - vi->maxout_total);
if (is_lo < 0) is_lo = 0;
}

else
is_lo = 0;

tmp = ((id >> 8) + .5)/255;

if (tmp < 1)
{
is_hi = floor(outmax * tmp + vi->maxout_total);
if (is_hi > outmax) is_hi = outmax;
}

else
is_hi = outmax;

if (!(od < is_lo || od > is_hi))
{
if (encoded_error < vi->outlog)
return i;

pass = ""within 8 bit limits:\n"";
}
}
#              endif
#           endif
}
else /* !use_input_precision */
is_lo = es_lo, is_hi = es_hi;

/* Attempt to output a meaningful error/warning message: the message
* output depends on the background/composite operation being performed
* because this changes what parameters were actually used above.
*/
{
size_t pos = 0;
/* Need either 1/255 or 1/65535 precision here; 3 or 6 decimal
* places.  Just use outmax to work out which.
*/
int precision = (outmax >= 1000 ? 6 : 3);
int use_input=1, use_background=0, do_compose=0;
char msg[256];

if (pass != 0)
pos = safecat(msg, sizeof msg, pos, ""\n\t"");

/* Set up the various flags, the output_is_encoded flag above
* is also used below.  do_compose is just a double check.
*/
switch (do_background)
{
#           ifdef PNG_READ_BACKGROUND_SUPPORTED
case PNG_BACKGROUND_GAMMA_SCREEN:
case PNG_BACKGROUND_GAMMA_FILE:
case PNG_BACKGROUND_GAMMA_UNIQUE:
use_background = (alpha >= 0 && alpha < 1);
/*FALL THROUGH*/
#           endif
#           ifdef PNG_READ_ALPHA_MODE_SUPPORTED
case ALPHA_MODE_OFFSET + PNG_ALPHA_STANDARD:
case ALPHA_MODE_OFFSET + PNG_ALPHA_BROKEN:
case ALPHA_MODE_OFFSET + PNG_ALPHA_OPTIMIZED:
#           endif /* ALPHA_MODE_SUPPORTED */
do_compose = (alpha > 0 && alpha < 1);
use_input = (alpha != 0);
break;

default:
break;
}

/* Check the 'compose' flag */
if (compose != do_compose)
png_error(vi->pp, ""internal error (compose)"");

/* 'name' is the component name */
pos = safecat(msg, sizeof msg, pos, name);
pos = safecat(msg, sizeof msg, pos, ""("");
pos = safecatn(msg, sizeof msg, pos, id);
if (use_input || pass != 0/*logging*/)
{
if (isbit != id)
{
/* sBIT has reduced the precision of the input: */
pos = safecat(msg, sizeof msg, pos, "", sbit("");
pos = safecatn(msg, sizeof msg, pos, vi->sbit);
pos = safecat(msg, sizeof msg, pos, ""): "");
pos = safecatn(msg, sizeof msg, pos, isbit);
}
pos = safecat(msg, sizeof msg, pos, ""/"");
/* The output is either ""id/max"" or ""id sbit(sbit): isbit/max"" */
pos = safecatn(msg, sizeof msg, pos, vi->sbit_max);
}
pos = safecat(msg, sizeof msg, pos, "")"");

/* A component may have been multiplied (in linear space) by the
* alpha value, 'compose' says whether this is relevant.
*/
if (compose || pass != 0)
{
/* If any form of composition is being done report our
* calculated linear value here (the code above doesn't record
* the input value before composition is performed, so what
* gets reported is the value after composition.)
*/
if (use_input || pass != 0)
{
if (vi->file_inverse > 0)
{
pos = safecat(msg, sizeof msg, pos, ""^"");
pos = safecatd(msg, sizeof msg, pos, vi->file_inverse, 2);
}

else
pos = safecat(msg, sizeof msg, pos, ""[linear]"");

pos = safecat(msg, sizeof msg, pos, ""*(alpha)"");
pos = safecatd(msg, sizeof msg, pos, alpha, precision);
}

/* Now record the *linear* background value if it was used
* (this function is not passed the original, non-linear,
* value but it is contained in the test name.)
*/
if (use_background)
{
pos = safecat(msg, sizeof msg, pos, use_input ? ""+"" : "" "");
pos = safecat(msg, sizeof msg, pos, ""(background)"");
pos = safecatd(msg, sizeof msg, pos, background, precision);
pos = safecat(msg, sizeof msg, pos, ""*"");
pos = safecatd(msg, sizeof msg, pos, 1-alpha, precision);
}
}

/* Report the calculated value (input_sample) and the linearized
* libpng value (output) unless this is just a component gamma
* correction.
*/
if (compose || alpha < 0 || pass != 0)
{
pos = safecat(msg, sizeof msg, pos,
pass != 0 ? "" =\n\t"" : "" = "");
pos = safecatd(msg, sizeof msg, pos, input_sample, precision);
pos = safecat(msg, sizeof msg, pos, "" (libpng: "");
pos = safecatd(msg, sizeof msg, pos, output, precision);
pos = safecat(msg, sizeof msg, pos, "")"");

/* Finally report the output gamma encoding, if any. */
if (output_is_encoded)
{
pos = safecat(msg, sizeof msg, pos, "" ^"");
pos = safecatd(msg, sizeof msg, pos, vi->screen_inverse, 2);
pos = safecat(msg, sizeof msg, pos, ""(to screen) ="");
}

else
pos = safecat(msg, sizeof msg, pos, "" [screen is linear] ="");
}

if ((!compose && alpha >= 0) || pass != 0)
{
if (pass != 0) /* logging */
pos = safecat(msg, sizeof msg, pos, ""\n\t[overall:"");

/* This is the non-composition case, the internal linear
* values are irrelevant (though the log below will reveal
* them.)  Output a much shorter warning/error message and report
* the overall gamma correction.
*/
if (vi->gamma_correction > 0)
{
pos = safecat(msg, sizeof msg, pos, "" ^"");
pos = safecatd(msg, sizeof msg, pos, vi->gamma_correction, 2);
pos = safecat(msg, sizeof msg, pos, ""(gamma correction) ="");
}

else
pos = safecat(msg, sizeof msg, pos,
"" [no gamma correction] ="");

if (pass != 0)
pos = safecat(msg, sizeof msg, pos, ""]"");
}

/* This is our calculated encoded_sample which should (but does
* not) match od:
*/
pos = safecat(msg, sizeof msg, pos, pass != 0 ? ""\n\t"" : "" "");
pos = safecatd(msg, sizeof msg, pos, is_lo, 1);
pos = safecat(msg, sizeof msg, pos, "" < "");
pos = safecatd(msg, sizeof msg, pos, encoded_sample, 1);
pos = safecat(msg, sizeof msg, pos, "" (libpng: "");
pos = safecatn(msg, sizeof msg, pos, od);
pos = safecat(msg, sizeof msg, pos, "")"");
pos = safecat(msg, sizeof msg, pos, ""/"");
pos = safecatn(msg, sizeof msg, pos, outmax);
pos = safecat(msg, sizeof msg, pos, "" < "");
pos = safecatd(msg, sizeof msg, pos, is_hi, 1);

if (pass == 0) /* The error condition */
{
#              ifdef PNG_WARNINGS_SUPPORTED
png_warning(vi->pp, msg);
#              else
store_warning(vi->pp, msg);
#              endif
}

else /* logging this value */
store_verbose(&vi->dp->pm->this, vi->pp, pass, msg);
}
}
}

return i;
}
","[1, 2, 3, 5, 6, 7, 8]","    PNG_CONST unsigned int id, PNG_CONST unsigned int od,/~/    PNG_CONST double alpha /* <0 for the alpha channel itself */,/~/    PNG_CONST double background /* component background value */)/~/   PNG_CONST unsigned int isbit = id >> vi->isbit_shift;/~/   PNG_CONST unsigned int sbit_max = vi->sbit_max;/~/   PNG_CONST unsigned int outmax = vi->outmax;/~/   PNG_CONST int do_background = vi->do_background;"
253,"int PDFiumEngine::GetVisiblePageIndex(FPDF_PAGE page) {
  for (int page_index : visible_pages_) {
if (pages_[page_index]->GetPage() == page)
return page_index;
}
return -1;
}
",[1],  for (int page_index : visible_pages_) {
254,"int MSG_ReadBits( msg_t *msg, int bits ) {
int			value;
int			get;
qboolean	sgn;
int			i, nbits;
//	FILE*	fp;

value = 0;

if ( bits < 0 ) {
bits = -bits;
sgn = qtrue;
} else {
sgn = qfalse;
}

if (msg->oob) {
if(bits==8)
{
value = msg->data[msg->readcount];
msg->readcount += 1;
msg->bit += 8;
}
else if(bits==16)
{
short temp;

CopyLittleShort(&temp, &msg->data[msg->readcount]);
value = temp;
msg->readcount += 2;
msg->bit += 16;
}
else if(bits==32)
{
CopyLittleLong(&value, &msg->data[msg->readcount]);
msg->readcount += 4;
msg->bit += 32;
}
else
Com_Error(ERR_DROP, ""can't read %d bits"", bits);
} else {
nbits = 0;
if (bits&7) {
nbits = bits&7;
for(i=0;i<nbits;i++) {
value |= (Huff_getBit(msg->data, &msg->bit)<<i);
}
bits = bits - nbits;
}
if (bits) {
//			fp = fopen(""c:\\netchan.bin"", ""a"");
for(i=0;i<bits;i+=8) {
				Huff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);
//				fwrite(&get, 1, 1, fp);
value |= (get<<(i+nbits));
}
//			fclose(fp);
}
msg->readcount = (msg->bit>>3)+1;
}
if ( sgn && bits > 0 && bits < 32 ) {
if ( value & ( 1 << ( bits - 1 ) ) ) {
value |= -1 ^ ( ( 1 << bits ) - 1 );
}
}

return value;
}
",[55],"				Huff_offsetReceive (msgHuff.decompressor.tree, &get, msg->data, &msg->bit);"
255,"void BinaryUploadService::IsAuthorized(AuthorizationCallback callback) {
// Start |timer_| on the first call to IsAuthorized. This is necessary in
// order to invalidate the authorization every 24 hours.
if (!timer_.IsRunning()) {
timer_.Start(FROM_HERE, base::TimeDelta::FromHours(24), this,
&BinaryUploadService::ResetAuthorizationData);
}

if (!can_upload_data_.has_value()) {
// Send a request to check if the browser can upload data.
if (!pending_validate_data_upload_request_) {
      std::string dm_token = GetDMToken();
      if (dm_token.empty()) {
std::move(callback).Run(false);
return;
}

pending_validate_data_upload_request_ = true;
auto request = std::make_unique<ValidateDataUploadRequest>(base::BindOnce(
&BinaryUploadService::ValidateDataUploadRequestCallback,
weakptr_factory_.GetWeakPtr()));
      request->set_dm_token(dm_token);
UploadForDeepScanning(std::move(request));
}
authorization_callbacks_.push_back(std::move(callback));
return;
}
std::move(callback).Run(can_upload_data_.value());
}
","[10, 11, 19]",      std::string dm_token = GetDMToken();/~/      if (dm_token.empty()) {/~/      request->set_dm_token(dm_token);
256,"static void tcp_send_challenge_ack(struct sock *sk, const struct sk_buff *skb)
{
/* unprotected vars, we dont care of overwrites */
static u32 challenge_timestamp;
static unsigned int challenge_count;
struct tcp_sock *tp = tcp_sk(sk);
	u32 now;

/* First check our per-socket dupack rate limit. */
if (tcp_oow_rate_limited(sock_net(sk), skb,
LINUX_MIB_TCPACKSKIPPEDCHALLENGE,
&tp->last_oow_ack_time))
return;

	/* Then check the check host-wide RFC 5961 rate limit. *
now = jiffies / HZ;
if (now != challenge_timestamp) {
challenge_timestamp = now;
		challenge_count = 0;
}
	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
NET_INC_STATS(sock_net(sk), LINUX_MIB_TCPCHALLENGEACK);
tcp_send_ack(sk);
}
}
","[6, 12, 16, 18]",	u32 now;/~/	/* Then check the check host-wide RFC 5961 rate limit. */~/		challenge_count = 0;/~/	if (++challenge_count <= sysctl_tcp_challenge_ack_limit) {
257,"static void parse_input(h2o_http2_conn_t *conn)
{
size_t http2_max_concurrent_requests_per_connection = conn->super.ctx->globalconf->http2.max_concurrent_requests_per_connection;
int perform_early_exit = 0;

if (conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed != http2_max_concurrent_requests_per_connection)
perform_early_exit = 1;

/* handle the input */
while (conn->state < H2O_HTTP2_CONN_STATE_IS_CLOSING && conn->sock->input->size != 0) {
if (perform_early_exit == 1 &&
conn->num_streams.pull.half_closed + conn->num_streams.push.half_closed == http2_max_concurrent_requests_per_connection)
goto EarlyExit;
/* process a frame */
const char *err_desc = NULL;
ssize_t ret = conn->_read_expect(conn, (uint8_t *)conn->sock->input->bytes, conn->sock->input->size, &err_desc);
if (ret == H2O_HTTP2_ERROR_INCOMPLETE) {
break;
} else if (ret < 0) {
if (ret != H2O_HTTP2_ERROR_PROTOCOL_CLOSE_IMMEDIATELY) {
enqueue_goaway(conn, (int)ret,
err_desc != NULL ? (h2o_iovec_t){(char *)err_desc, strlen(err_desc)} : (h2o_iovec_t){});
}
            close_connection(conn);
            return;
}
/* advance to the next frame */
h2o_buffer_consume(&conn->sock->input, ret);
}

if (!h2o_socket_is_reading(conn->sock))
h2o_socket_read_start(conn->sock, on_read);
    return;

EarlyExit:
if (h2o_socket_is_reading(conn->sock))
h2o_socket_read_stop(conn->sock);
}
","[21, 22]",            close_connection(conn);/~/            return;/~/    return;
258,"ZEND_API void ZEND_FASTCALL _zend_hash_init(HashTable *ht, uint32_t nSize, dtor_func_t pDestructor, zend_bool persistent ZEND_FILE_LINE_DC)
{
GC_REFCOUNT(ht) = 1;
GC_TYPE_INFO(ht) = IS_ARRAY;
ht->u.flags = (persistent ? HASH_FLAG_PERSISTENT : 0) | HASH_FLAG_APPLY_PROTECTION | HASH_FLAG_STATIC_KEYS;
	ht->nTableSize = zend_hash_check_size(nSize);
ht->nTableMask = HT_MIN_MASK;
HT_SET_DATA_ADDR(ht, &uninitialized_bucket);
ht->nNumUsed = 0;
ht->nNumOfElements = 0;
ht->nInternalPointer = HT_INVALID_IDX;
ht->nNextFreeElement = 0;
ht->pDestructor = pDestructor;
}
",[5],	ht->nTableSize = zend_hash_check_size(nSize);
259,"void ExtensionViewGuest::DidNavigateMainFrame(
const content::LoadCommittedDetails& details,
const content::FrameNavigateParams& params) {
  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {
bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
bad_message::EVG_BAD_ORIGIN);
}
}
",[3],  if (attached() && (params.url.GetOrigin() != url_.GetOrigin())) {
260,"void WebProcessProxy::addExistingWebPage(WebPageProxy* webPage, uint64_t pageID)
{
m_pageMap.set(pageID, webPage);
globalPageMap().set(pageID, webPage);
#if PLATFORM(MAC)
    if (pageIsProcessSuppressible(webPage));
m_processSuppressiblePages.add(pageID);
updateProcessSuppressionState();
#endif
}
",[5],    if (pageIsProcessSuppressible(webPage));
261,"void BrowserPpapiHostImpl::DeleteInstance(PP_Instance instance) {
auto it = instance_map_.find(instance);
  DCHECK(it != instance_map_.end());
  // We need to tell the observers for that instance that we are destroyed
  // because we won't have the opportunity to once we remove them from the
  // |instance_map_|. If the instance was deleted, observers for those instances
  // should never call back into the host anyway, so it is safe to tell them
  // that the host is destroyed.
  for (auto& observer : it->second->observer_list)
    observer.OnHostDestroyed();

  instance_map_.erase(it);
}
","[2, 3, 4, 5, 6, 7, 8, 9, 10]","  DCHECK(it != instance_map_.end());/~/  // We need to tell the observers for that instance that we are destroyed/~/  // because we won't have the opportunity to once we remove them from the/~/  // |instance_map_|. If the instance was deleted, observers for those instances/~/  // should never call back into the host anyway, so it is safe to tell them/~/  // that the host is destroyed./~/  for (auto& observer : it->second->observer_list)/~/    observer.OnHostDestroyed();/~/  instance_map_.erase(it);"
262,"void Browser::FindInPage(bool find_next, bool forward_direction) {
ShowFindBar();
if (find_next) {
string16 find_text;
#if defined(OS_MACOSX)
// We always want to search for the contents of the find pasteboard on OS X.
find_text = GetFindPboardText();
#endif
GetSelectedTabContentsWrapper()->
        GetFindManager()->StartFinding(find_text,
                                       forward_direction,
                                       false);  // Not case sensitive.
}
}
","[9, 10, 11]","        GetFindManager()->StartFinding(find_text,/~/                                       forward_direction,/~/                                       false);  // Not case sensitive."
263,"int rds_sendmsg(struct socket *sock, struct msghdr *msg, size_t payload_len)
{
struct sock *sk = sock->sk;
struct rds_sock *rs = rds_sk_to_rs(sk);
DECLARE_SOCKADDR(struct sockaddr_in *, usin, msg->msg_name);
__be32 daddr;
__be16 dport;
struct rds_message *rm = NULL;
struct rds_connection *conn;
int ret = 0;
int queued = 0, allocated_mr = 0;
int nonblock = msg->msg_flags & MSG_DONTWAIT;
long timeo = sock_sndtimeo(sk, nonblock);

/* Mirror Linux UDP mirror of BSD error message compatibility */
/* XXX: Perhaps MSG_MORE someday */
if (msg->msg_flags & ~(MSG_DONTWAIT | MSG_CMSG_COMPAT)) {
ret = -EOPNOTSUPP;
goto out;
}

if (msg->msg_namelen) {
/* XXX fail non-unicast destination IPs? */
if (msg->msg_namelen < sizeof(*usin) || usin->sin_family != AF_INET) {
ret = -EINVAL;
goto out;
}
daddr = usin->sin_addr.s_addr;
dport = usin->sin_port;
} else {
/* We only care about consistency with ->connect() */
lock_sock(sk);
daddr = rs->rs_conn_addr;
dport = rs->rs_conn_port;
release_sock(sk);
}

	/* racing with another thread binding seems ok here *
if (daddr == 0 || rs->rs_bound_addr == 0) {
ret = -ENOTCONN; /* XXX not a great errno */
goto out;
}

if (payload_len > rds_sk_sndbuf(rs)) {
ret = -EMSGSIZE;
goto out;
}

/* size of rm including all sgs */
ret = rds_rm_size(msg, payload_len);
if (ret < 0)
goto out;

rm = rds_message_alloc(ret, GFP_KERNEL);
if (!rm) {
ret = -ENOMEM;
goto out;
}

/* Attach data to the rm */
if (payload_len) {
rm->data.op_sg = rds_message_alloc_sgs(rm, ceil(payload_len, PAGE_SIZE));
if (!rm->data.op_sg) {
ret = -ENOMEM;
goto out;
}
ret = rds_message_copy_from_user(rm, &msg->msg_iter);
if (ret)
goto out;
}
rm->data.op_active = 1;

rm->m_daddr = daddr;

/* rds_conn_create has a spinlock that runs with IRQ off.
* Caching the conn in the socket helps a lot. */
if (rs->rs_conn && rs->rs_conn->c_faddr == daddr)
conn = rs->rs_conn;
else {
conn = rds_conn_create_outgoing(sock_net(sock->sk),
rs->rs_bound_addr, daddr,
rs->rs_transport,
sock->sk->sk_allocation);
if (IS_ERR(conn)) {
ret = PTR_ERR(conn);
goto out;
}
rs->rs_conn = conn;
}

/* Parse any control messages the user may have included. */
ret = rds_cmsg_send(rs, rm, msg, &allocated_mr);
if (ret)
goto out;

if (rm->rdma.op_active && !conn->c_trans->xmit_rdma) {
printk_ratelimited(KERN_NOTICE ""rdma_op %p conn xmit_rdma %p\n"",
&rm->rdma, conn->c_trans->xmit_rdma);
ret = -EOPNOTSUPP;
goto out;
}

if (rm->atomic.op_active && !conn->c_trans->xmit_atomic) {
printk_ratelimited(KERN_NOTICE ""atomic_op %p conn xmit_atomic %p\n"",
&rm->atomic, conn->c_trans->xmit_atomic);
ret = -EOPNOTSUPP;
goto out;
}

rds_conn_connect_if_down(conn);

ret = rds_cong_wait(conn->c_fcong, dport, nonblock, rs);
if (ret) {
rs->rs_seen_congestion = 1;
goto out;
}

while (!rds_send_queue_rm(rs, conn, rm, rs->rs_bound_port,
dport, &queued)) {
rds_stats_inc(s_send_queue_full);

if (nonblock) {
ret = -EAGAIN;
goto out;
}

timeo = wait_event_interruptible_timeout(*sk_sleep(sk),
rds_send_queue_rm(rs, conn, rm,
rs->rs_bound_port,
dport,
&queued),
timeo);
rdsdebug(""sendmsg woke queued %d timeo %ld\n"", queued, timeo);
if (timeo > 0 || timeo == MAX_SCHEDULE_TIMEOUT)
continue;

ret = timeo;
if (ret == 0)
ret = -ETIMEDOUT;
goto out;
}

/*
* By now we've committed to the send.  We reuse rds_send_worker()
* to retry sends in the rds thread if the transport asks us to.
*/
rds_stats_inc(s_send_queued);

ret = rds_send_xmit(conn);
if (ret == -ENOMEM || ret == -EAGAIN)
queue_delayed_work(rds_wq, &conn->c_send_w, 1);

rds_message_put(rm);
return payload_len;

out:
/* If the user included a RDMA_MAP cmsg, we allocated a MR on the fly.
* If the sendmsg goes through, we keep the MR. If it fails with EAGAIN
* or in any other way, we need to destroy the MR again */
if (allocated_mr)
rds_rdma_unuse(rs, rds_rdma_cookie_key(rm->m_rdma_cookie), 1);

if (rm)
rds_message_put(rm);
return ret;
}
",[34],	/* racing with another thread binding seems ok here *
264,"CuePoint::~CuePoint()
{
    delete[] m_track_positions;
}
","[1, 2, 3]",{/~/    delete[] m_track_positions;/~/}
265,"static int accept_server_socket(int sfd)
{
struct sockaddr_un remote;
struct pollfd pfd;
int fd;
socklen_t len = sizeof(struct sockaddr_un);

BTIF_TRACE_EVENT(""accept fd %d"", sfd);

/* make sure there is data to process */

pfd.fd = sfd;
pfd.events = POLLIN;

    if (poll(&pfd, 1, 0) == 0)
{
BTIF_TRACE_EVENT(""accept poll timeout"");
return -1;
}


//BTIF_TRACE_EVENT(""poll revents 0x%x"", pfd.revents);

    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)
{
BTIF_TRACE_ERROR(""sock accept failed (%s)"", strerror(errno));
return -1;
}

//BTIF_TRACE_EVENT(""new fd %d"", fd);

return fd;
}
","[10, 16]","    if (poll(&pfd, 1, 0) == 0)/~/    if ((fd = accept(sfd, (struct sockaddr *)&remote, &len)) == -1)"
266,"v8::Handle<v8::Value> V8WebGLRenderingContext::getAttachedShadersCallback(const v8::Arguments& args)
{
INC_STATS(""DOM.WebGLRenderingContext.getAttachedShaders()"");

if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();

ExceptionCode ec = 0;
WebGLRenderingContext* context = V8WebGLRenderingContext::toNative(args.Holder());
if (args.Length() > 0 && !isUndefinedOrNull(args[0]) && !V8WebGLProgram::HasInstance(args[0])) {
V8Proxy::throwTypeError();
return notHandledByInterceptor();
}
WebGLProgram* program = V8WebGLProgram::HasInstance(args[0]) ? V8WebGLProgram::toNative(v8::Handle<v8::Object>::Cast(args[0])) : 0;
Vector<RefPtr<WebGLShader> > shaders;
bool succeed = context->getAttachedShaders(program, shaders, ec);
if (ec) {
V8Proxy::setDOMException(ec, args.GetIsolate());
return v8::Null();
}
if (!succeed)
return v8::Null();
v8::Local<v8::Array> array = v8::Array::New(shaders.size());
for (size_t ii = 0; ii < shaders.size(); ++ii)
array->Set(v8::Integer::New(ii), toV8(shaders[ii].get(), args.GetIsolate()));
return array;
}
",[4],        return V8Proxy::throwNotEnoughArgumentsError();
267,"mark_source_chains(const struct xt_table_info *newinfo,
unsigned int valid_hooks, void *entry0)
{
unsigned int hook;

/* No recursion; use packet counter to save back ptrs (reset
to 0 as we leave), and comefrom to save source hook bitmask */
for (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {
unsigned int pos = newinfo->hook_entry[hook];
struct ipt_entry *e = (struct ipt_entry *)(entry0 + pos);

if (!(valid_hooks & (1 << hook)))
continue;

/* Set initial back pointer. */
e->counters.pcnt = pos;

for (;;) {
const struct xt_standard_target *t
= (void *)ipt_get_target_c(e);
int visited = e->comefrom & (1 << hook);

if (e->comefrom & (1 << NF_INET_NUMHOOKS)) {
pr_err(""iptables: loop hook %u pos %u %08X.\n"",
hook, pos, e->comefrom);
return 0;
}
e->comefrom |= ((1 << hook) | (1 << NF_INET_NUMHOOKS));

/* Unconditional return/END. */
			if ((e->target_offset == sizeof(struct ipt_entry) &&
(strcmp(t->target.u.user.name,
XT_STANDARD_TARGET) == 0) &&
			     t->verdict < 0 && unconditional(&e->ip)) ||
			    visited) {
unsigned int oldpos, size;

if ((strcmp(t->target.u.user.name,
XT_STANDARD_TARGET) == 0) &&
t->verdict < -NF_MAX_VERDICT - 1) {
duprintf(""mark_source_chains: bad ""
""negative verdict (%i)\n"",
t->verdict);
return 0;
}

/* Return: backtrack through the last
big jump. */
do {
e->comefrom ^= (1<<NF_INET_NUMHOOKS);
#ifdef DEBUG_IP_FIREWALL_USER
if (e->comefrom
& (1 << NF_INET_NUMHOOKS)) {
duprintf(""Back unset ""
""on hook %u ""
""rule %u\n"",
hook, pos);
}
#endif
oldpos = pos;
pos = e->counters.pcnt;
e->counters.pcnt = 0;

/* We're at the start. */
if (pos == oldpos)
goto next;

e = (struct ipt_entry *)
(entry0 + pos);
} while (oldpos == pos + e->next_offset);

/* Move along one */
size = e->next_offset;
e = (struct ipt_entry *)
(entry0 + pos + size);
e->counters.pcnt = pos;
pos += size;
} else {
int newpos = t->verdict;

if (strcmp(t->target.u.user.name,
XT_STANDARD_TARGET) == 0 &&
newpos >= 0) {
if (newpos > newinfo->size -
sizeof(struct ipt_entry)) {
duprintf(""mark_source_chains: ""
""bad verdict (%i)\n"",
newpos);
return 0;
}
/* This a jump; chase it. */
duprintf(""Jump rule %u -> %u\n"",
pos, newpos);
} else {
/* ... this is a fallthru */
newpos = pos + e->next_offset;
}
e = (struct ipt_entry *)
(entry0 + newpos);
e->counters.pcnt = pos;
pos = newpos;
}
}
next:
duprintf(""Finished chain %u\n"", hook);
}
return 1;
}
","[24, 27, 28]",			if ((e->target_offset == sizeof(struct ipt_entry) &&/~/			     t->verdict < 0 && unconditional(&e->ip)) ||/~/			    visited) {
268,"void ScreenRecorder::DoAddConnection(
    scoped_refptr<ConnectionToClient> connection) {
  DCHECK(network_loop_->BelongsToCurrentThread());
  connections_.push_back(connection);
}
","[1, 2, 3, 4]",    scoped_refptr<ConnectionToClient> connection) {/~/  DCHECK(network_loop_->BelongsToCurrentThread());/~/  connections_.push_back(connection);/~/}
269,"nm_ip4_config_commit (const NMIP4Config *config, int ifindex, guint32 default_route_metric)
{
NMIP4ConfigPrivate *priv = NM_IP4_CONFIG_GET_PRIVATE (config);
	guint32 mtu = nm_ip4_config_get_mtu (config);
int i;

g_return_val_if_fail (ifindex > 0, FALSE);
g_return_val_if_fail (ifindex > 0, FALSE);
g_return_val_if_fail (config != NULL, FALSE);

/* Addresses */
nm_platform_ip4_address_sync (ifindex, priv->addresses, default_route_metric);

/* Routes */
{
int count = nm_ip4_config_get_num_routes (config);
GArray *routes = g_array_sized_new (FALSE, FALSE, sizeof (NMPlatformIP4Route), count);
const NMPlatformIP4Route *route;
gboolean success;

for (i = 0; i < count; i++) {
route = nm_ip4_config_get_route (config, i);

/* Don't add the route if it's more specific than one of the subnets
* the device already has an IP address on.
*/
if (   route->gateway == 0
&& nm_ip4_config_destination_is_direct (config, route->network, route->plen))
continue;

g_array_append_vals (routes, route, 1);
}

success = nm_route_manager_ip4_route_sync (nm_route_manager_get (), ifindex, routes);
g_array_unref (routes);
return FALSE;
}

	/* MTU *
	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))
		nm_platform_link_set_mtu (ifindex, mtu);
return TRUE;
}
","[3, 30, 31, 32]","	guint32 mtu = nm_ip4_config_get_mtu (config);/~/	/* MTU */~/	if (mtu && mtu != nm_platform_link_get_mtu (ifindex))/~/		nm_platform_link_set_mtu (ifindex, mtu);"
270,"void __detach_mounts(struct dentry *dentry)
{
struct mountpoint *mp;
struct mount *mnt;

namespace_lock();
mp = lookup_mountpoint(dentry);
if (IS_ERR_OR_NULL(mp))
goto out_unlock;

lock_mount_hash();
while (!hlist_empty(&mp->m_list)) {
mnt = hlist_entry(mp->m_list.first, struct mount, mnt_mp_list);
if (mnt->mnt.mnt_flags & MNT_UMOUNT) {
struct mount *p, *tmp;
list_for_each_entry_safe(p, tmp, &mnt->mnt_mounts,  mnt_child) {
hlist_add_head(&p->mnt_umount.s_list, &unmounted);
umount_mnt(p);
}
}
		else umount_tree(mnt, 0);
}
unlock_mount_hash();
put_mountpoint(mp);
out_unlock:
namespace_unlock();
}
",[18],"		else umount_tree(mnt, 0);"
271,"long Chapters::Atom::ParseDisplay(
    IMkvReader* pReader,
    long long pos,
    long long size)
{
    if (!ExpandDisplaysArray())
        return -1;
    Display& d = m_displays[m_displays_count++];
    d.Init();
    return d.Parse(pReader, pos, size);
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]","    IMkvReader* pReader,/~/    long long pos,/~/    long long size)/~/{/~/    if (!ExpandDisplaysArray())/~/        return -1;/~/    Display& d = m_displays[m_displays_count++];/~/    d.Init();/~/    return d.Parse(pReader, pos, size);/~/}"
272,"_ksba_name_new_from_der (ksba_name_t *r_name,
const unsigned char *image, size_t imagelen)
{
gpg_error_t err;
ksba_name_t name;
struct tag_info ti;
const unsigned char *der;
size_t derlen;
int n;
char *p;

if (!r_name || !image)
return gpg_error (GPG_ERR_INV_VALUE);

*r_name = NULL;

  /* count and check for encoding errors - we won;t do this again
during the second pass */
der = image;
derlen = imagelen;
n = 0;
while (derlen)
{
err = _ksba_ber_parse_tl (&der, &derlen, &ti);
if (err)
return err;
if (ti.class != CLASS_CONTEXT)
return gpg_error (GPG_ERR_INV_CERT_OBJ); /* we expected a tag */
if (ti.ndef)
return gpg_error (GPG_ERR_NOT_DER_ENCODED);
if (derlen < ti.length)
return gpg_error (GPG_ERR_BAD_BER);
switch (ti.tag)
{
case 1: /* rfc822Name - this is an imlicit IA5_STRING */
case 4: /* Name */
case 6: /* URI */
n++;
break;
default:
break;
}

/* advance pointer */
der += ti.length;
derlen -= ti.length;
}

/* allocate array and set all slots to NULL for easier error recovery */
err = ksba_name_new (&name);
if (err)
return err;
if (!n)
return 0; /* empty GeneralNames */
name->names = xtrycalloc (n, sizeof *name->names);
if (!name->names)
{
ksba_name_release (name);
return gpg_error (GPG_ERR_ENOMEM);
}
name->n_names = n;

/* start the second pass */
der = image;
derlen = imagelen;
n = 0;
while (derlen)
{
char numbuf[21];

err = _ksba_ber_parse_tl (&der, &derlen, &ti);
assert (!err);
switch (ti.tag)
{
case 1: /* rfc822Name - this is an imlicit IA5_STRING */
p = name->names[n] = xtrymalloc (ti.length+3);
if (!p)
{
ksba_name_release (name);
return gpg_error (GPG_ERR_ENOMEM);
}
*p++ = '<';
memcpy (p, der, ti.length);
p += ti.length;
*p++ = '>';
*p = 0;
n++;
break;
case 4: /* Name */
err = _ksba_derdn_to_str (der, ti.length, &p);
if (err)
return err; /* FIXME: we need to release some of the memory */
name->names[n++] = p;
break;
case 6: /* URI */
sprintf (numbuf, ""%u:"", (unsigned int)ti.length);
p = name->names[n] = xtrymalloc (1+5+strlen (numbuf)
+ ti.length +1+1);
if (!p)
{
ksba_name_release (name);
return gpg_error (GPG_ERR_ENOMEM);
}
p = stpcpy (p, ""(3:uri"");
p = stpcpy (p, numbuf);
memcpy (p, der, ti.length);
p += ti.length;
*p++ = ')';
*p = 0; /* extra safeguard null */
n++;
break;
default:
break;
}

/* advance pointer */
der += ti.length;
derlen -= ti.length;
}
*r_name = name;
return 0;
}
",[13],  /* count and check for encoding errors - we won;t do this again
273,"static int handle_vmptrst(struct kvm_vcpu *vcpu)
{
unsigned long exit_qualification = vmcs_readl(EXIT_QUALIFICATION);
u32 vmx_instruction_info = vmcs_read32(VMX_INSTRUCTION_INFO);
gva_t vmcs_gva;
struct x86_exception e;

if (!nested_vmx_check_permission(vcpu))
return 1;

if (get_vmx_mem_address(vcpu, exit_qualification,
vmx_instruction_info, true, &vmcs_gva))
return 1;
	/* ok to use *_system, as hardware has verified cpl=0 *
if (kvm_write_guest_virt_system(&vcpu->arch.emulate_ctxt, vmcs_gva,
(void *)&to_vmx(vcpu)->nested.current_vmptr,
sizeof(u64), &e)) {
kvm_inject_page_fault(vcpu, &e);
return 1;
}
nested_vmx_succeed(vcpu);
return kvm_skip_emulated_instruction(vcpu);
}
",[11],"	/* ok to use *_system, as hardware has verified cpl=0 *"
274,"void SynchronousCompositorImpl::PostInvalidate() {
DCHECK(CalledOnValidThread());
DCHECK(compositor_client_);
  compositor_client_->PostInvalidate();
}
",[3],  compositor_client_->PostInvalidate();
275,"krb5_gss_process_context_token(minor_status, context_handle,
token_buffer)
OM_uint32 *minor_status;
gss_ctx_id_t context_handle;
gss_buffer_t token_buffer;
{
krb5_gss_ctx_id_rec *ctx;
OM_uint32 majerr;

ctx = (krb5_gss_ctx_id_t) context_handle;

    if (! ctx->established) {
*minor_status = KG_CTX_INCOMPLETE;
return(GSS_S_NO_CONTEXT);
}

/* ""unseal"" the token */

if (GSS_ERROR(majerr = kg_unseal(minor_status, context_handle,
token_buffer,
GSS_C_NO_BUFFER, NULL, NULL,
KG_TOK_DEL_CTX)))
return(majerr);

    /* that's it.  delete the context *
    return(krb5_gss_delete_sec_context(minor_status, &context_handle,
                                       GSS_C_NO_BUFFER));
}
","[9, 19, 20, 21]","    if (! ctx->established) {/~/    /* that's it.  delete the context */~/    return(krb5_gss_delete_sec_context(minor_status, &context_handle,/~/                                       GSS_C_NO_BUFFER));"
276,"DrawingBuffer::DrawingBuffer(
std::unique_ptr<WebGraphicsContext3DProvider> context_provider,
std::unique_ptr<Extensions3DUtil> extensions_util,
Client* client,
bool discard_framebuffer_supported,
bool want_alpha_channel,
bool premultiplied_alpha,
PreserveDrawingBuffer preserve,
    WebGLVersion web_gl_version,
bool want_depth,
bool want_stencil,
ChromiumImageUsage chromium_image_usage,
const CanvasColorParams& color_params)
: client_(client),
preserve_drawing_buffer_(preserve),
      web_gl_version_(web_gl_version),
context_provider_(WTF::WrapUnique(new WebGraphicsContext3DProviderWrapper(
std::move(context_provider)))),
gl_(this->ContextProvider()->ContextGL()),
extensions_util_(std::move(extensions_util)),
discard_framebuffer_supported_(discard_framebuffer_supported),
want_alpha_channel_(want_alpha_channel),
premultiplied_alpha_(premultiplied_alpha),
software_rendering_(this->ContextProvider()->IsSoftwareRendering()),
want_depth_(want_depth),
want_stencil_(want_stencil),
color_space_(color_params.GetGfxColorSpace()),
chromium_image_usage_(chromium_image_usage) {
// Used by browser tests to detect the use of a DrawingBuffer.
TRACE_EVENT_INSTANT0(""test_gpu"", ""DrawingBufferCreation"",
TRACE_EVENT_SCOPE_GLOBAL);
}
","[8, 15]","    WebGLVersion web_gl_version,/~/      web_gl_version_(web_gl_version),"
277,"static int command_read(struct pci_dev *dev, int offset, u16 *value, void *data)
{
	int i;
	int ret;
	ret = xen_pcibk_read_config_word(dev, offset, value, data);
	if (!pci_is_enabled(dev))
		return ret;
	for (i = 0; i < PCI_ROM_RESOURCE; i++) {
		if (dev->resource[i].flags & IORESOURCE_IO)
			*value |= PCI_COMMAND_IO;
		if (dev->resource[i].flags & IORESOURCE_MEM)
			*value |= PCI_COMMAND_MEMORY;
}

return ret;
}
","[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 13]","	int i;/~/	int ret;/~/	ret = xen_pcibk_read_config_word(dev, offset, value, data);/~/	if (!pci_is_enabled(dev))/~/		return ret;/~/	for (i = 0; i < PCI_ROM_RESOURCE; i++) {/~/		if (dev->resource[i].flags & IORESOURCE_IO)/~/			*value |= PCI_COMMAND_IO;/~/		if (dev->resource[i].flags & IORESOURCE_MEM)/~/			*value |= PCI_COMMAND_MEMORY;"
278,"std::string GetUploadData(const std::string& brand) {
DCHECK(!brand.empty());
  std::string data(kPostXml);
  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");
  size_t placeholder_pos = data.find(placeholder);
  DCHECK(placeholder_pos != std::string::npos);
  data.replace(placeholder_pos, placeholder.size(), brand);
  return data;
}
","[2, 3, 4, 5, 6, 7]","  std::string data(kPostXml);/~/  const std::string placeholder(""__BRANDCODE_PLACEHOLDER__"");/~/  size_t placeholder_pos = data.find(placeholder);/~/  DCHECK(placeholder_pos != std::string::npos);/~/  data.replace(placeholder_pos, placeholder.size(), brand);/~/  return data;"
279,"my_object_many_args (MyObject *obj, guint32 x, const char *str, double trouble, double *d_ret, char **str_ret, GError **error)
{
  *d_ret = trouble + (x * 2);
  *str_ret = g_ascii_strup (str, -1);
  return TRUE;
}
","[1, 2, 3, 4, 5]","{/~/  *d_ret = trouble + (x * 2);/~/  *str_ret = g_ascii_strup (str, -1);/~/  return TRUE;/~/}"
280,"cJSON *cJSON_DetachItemFromArray( cJSON *array, int which )
{
	cJSON *c = array->child;
	while ( c && which > 0 ) {
		c = c->next;
		--which;
	}
	if ( ! c )
		return 0;
	if ( c->prev )
		c->prev->next = c->next;
	if ( c->next ) c->next->prev = c->prev;
	if ( c == array->child )
		array->child = c->next;
	c->prev = c->next = 0;
	return c;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16]",{/~/	cJSON *c = array->child;/~/	while ( c && which > 0 ) {/~/		c = c->next;/~/		--which;/~/	}/~/	if ( ! c )/~/		return 0;/~/	if ( c->prev )/~/		c->prev->next = c->next;/~/	if ( c->next ) c->next->prev = c->prev;/~/	if ( c == array->child )/~/		array->child = c->next;/~/	c->prev = c->next = 0;/~/	return c;/~/}
281,"void CastCastView::ButtonPressed(views::Button* sender,
const ui::Event& event) {
DCHECK(sender == stop_button_);
  StopCast();
}
",[3],  StopCast();
282,"void Document::InitContentSecurityPolicy(
    ContentSecurityPolicy* csp,
    const ContentSecurityPolicy* policy_to_inherit,
    const ContentSecurityPolicy* previous_document_csp) {
SetContentSecurityPolicy(csp ? csp : ContentSecurityPolicy::Create());

GetContentSecurityPolicy()->BindToExecutionContext(this);

  // We inherit the parent/opener's CSP for documents with ""local"" schemes:
  // 'about', 'blob', 'data', and 'filesystem'. We also inherit CSP for
  // documents with empty/invalid URLs because we treat those URLs as
  // 'about:blank' in Blink.
  
  // https://w3c.github.io/webappsec-csp/#initialize-document-csp
  
  // TODO(dcheng): This is similar enough to work we're doing in
  // 'DocumentLoader::ensureWriter' that it might make sense to combine them.
  if (policy_to_inherit) {
GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  } else {
    if (frame_) {
Frame* inherit_from = frame_->Tree().Parent()
? frame_->Tree().Parent()
: frame_->Client()->Opener();
if (inherit_from && frame_ != inherit_from) {
DCHECK(inherit_from->GetSecurityContext() &&
inherit_from->GetSecurityContext()->GetContentSecurityPolicy());
        policy_to_inherit =
            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();
}
}
    // If we don't have an opener or parent, inherit from the previous
    // document CSP.
    if (!policy_to_inherit)
      policy_to_inherit = previous_document_csp;
    // We should inherit the relevant CSP if the document is loaded using
    // a local-scheme url.
    if (policy_to_inherit &&
        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||
         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))
      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);
  }
  // Plugin documents inherit their parent/opener's 'plugin-types' directive
  // regardless of URL.
  if (policy_to_inherit && IsPluginDocument())
    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);
}
","[1, 2, 3, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34]","    ContentSecurityPolicy* csp,/~/    const ContentSecurityPolicy* policy_to_inherit,/~/    const ContentSecurityPolicy* previous_document_csp) {/~/  // We inherit the parent/opener's CSP for documents with ""local"" schemes:/~/  // 'about', 'blob', 'data', and 'filesystem'. We also inherit CSP for/~/  // documents with empty/invalid URLs because we treat those URLs as/~/  // 'about:blank' in Blink./~/  /~/  // https://w3c.github.io/webappsec-csp/#initialize-document-csp/~/  /~/  // TODO(dcheng): This is similar enough to work we're doing in/~/  // 'DocumentLoader::ensureWriter' that it might make sense to combine them./~/  if (policy_to_inherit) {/~/  } else {/~/    if (frame_) {/~/        policy_to_inherit =/~/            inherit_from->GetSecurityContext()->GetContentSecurityPolicy();/~/    // If we don't have an opener or parent, inherit from the previous/~/    // document CSP./~/    if (!policy_to_inherit)/~/      policy_to_inherit = previous_document_csp;/~/    // We should inherit the relevant CSP if the document is loaded using/~/    // a local-scheme url./~/    if (policy_to_inherit &&/~/        (url_.IsEmpty() || url_.ProtocolIsAbout() || url_.ProtocolIsData() ||/~/         url_.ProtocolIs(""blob"") || url_.ProtocolIs(""filesystem"")))/~/      GetContentSecurityPolicy()->CopyStateFrom(policy_to_inherit);/~/  }/~/  // Plugin documents inherit their parent/opener's 'plugin-types' directive/~/  // regardless of URL./~/  if (policy_to_inherit && IsPluginDocument())/~/    GetContentSecurityPolicy()->CopyPluginTypesFrom(policy_to_inherit);"
283,"BGD_DECLARE(void *) gdImageWebpPtrEx (gdImagePtr im, int *size, int quality)
{
void *rv;
gdIOCtx *out = gdNewDynamicCtx(2048, NULL);
if (out == NULL) {
return NULL;
}
	gdImageWebpCtx(im, out, quality);
	rv = gdDPExtractData(out, size);
out->gd_free(out);
return rv;
}
","[7, 8]","	gdImageWebpCtx(im, out, quality);/~/	rv = gdDPExtractData(out, size);"
284,"bool GesturePoint::IsSecondClickInsideManhattanSquare(
const TouchEvent& event) const {
int manhattanDistance = abs(event.x() - last_tap_position_.x()) +
abs(event.y() - last_tap_position_.y());
  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
}
",[4],  return manhattanDistance < kMaximumTouchMoveInPixelsForClick;
285,"NO_INLINE JsVar *jspeArrowFunction(JsVar *funcVar, JsVar *a) {
assert(!a || jsvIsName(a));
JSP_ASSERT_MATCH(LEX_ARROW_FUNCTION);
funcVar = jspeAddNamedFunctionParameter(funcVar, a);

bool expressionOnly = lex->tk!='{';
jspeFunctionDefinitionInternal(funcVar, expressionOnly);
if (execInfo.thisVar) {
jsvObjectSetChild(funcVar, JSPARSE_FUNCTION_THIS_NAME, execInfo.thisVar);
}
return funcVar;
}

// parse expressions with commas, maybe followed by an arrow function (bracket already matched)
NO_INLINE JsVar *jspeExpressionOrArrowFunction() {
JsVar *a = 0;
JsVar *funcVar = 0;
bool allNames = true;
while (lex->tk!=')' && !JSP_SHOULDNT_PARSE) {
if (allNames && a) {
// we never get here if this isn't a name and a string
funcVar = jspeAddNamedFunctionParameter(funcVar, a);
}
jsvUnLock(a);
a = jspeAssignmentExpression();
if (!(jsvIsName(a) && jsvIsString(a))) allNames = false;
if (lex->tk!=')') JSP_MATCH_WITH_CLEANUP_AND_RETURN(',', jsvUnLock2(a,funcVar), 0);
}
JSP_MATCH_WITH_CLEANUP_AND_RETURN(')', jsvUnLock2(a,funcVar), 0);
// if arrow is found, create a function
if (allNames && lex->tk==LEX_ARROW_FUNCTION) {
funcVar = jspeArrowFunction(funcVar, a);
jsvUnLock(a);
return funcVar;
} else {
jsvUnLock(funcVar);
return a;
}
}

/// Parse an ES6 class, expects LEX_R_CLASS already parsed
NO_INLINE JsVar *jspeClassDefinition(bool parseNamedClass) {
JsVar *classFunction = 0;
JsVar *classPrototype = 0;
JsVar *classInternalName = 0;

bool actuallyCreateClass = JSP_SHOULD_EXECUTE;
if (actuallyCreateClass)
classFunction = jsvNewWithFlags(JSV_FUNCTION);

if (parseNamedClass && lex->tk==LEX_ID) {
if (classFunction)
classInternalName = jslGetTokenValueAsVar(lex);
JSP_ASSERT_MATCH(LEX_ID);
}
if (classFunction) {
JsVar *prototypeName = jsvFindChildFromString(classFunction, JSPARSE_PROTOTYPE_VAR, true);
jspEnsureIsPrototype(classFunction, prototypeName); // make sure it's an object
classPrototype = jsvSkipName(prototypeName);
jsvUnLock(prototypeName);
}
if (lex->tk==LEX_R_EXTENDS) {
JSP_ASSERT_MATCH(LEX_R_EXTENDS);
JsVar *extendsFrom = actuallyCreateClass ? jsvSkipNameAndUnLock(jspGetNamedVariable(jslGetTokenValueAsString(lex))) : 0;
JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock4(extendsFrom,classFunction,classInternalName,classPrototype),0);
if (classPrototype) {
if (jsvIsFunction(extendsFrom)) {
jsvObjectSetChild(classPrototype, JSPARSE_INHERITS_VAR, extendsFrom);
// link in default constructor if ours isn't supplied
jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_CODE_NAME, jsvNewFromString(""if(this.__proto__.__proto__)this.__proto__.__proto__.apply(this,arguments)""));
} else
jsExceptionHere(JSET_SYNTAXERROR, ""'extends' argument should be a function, got %t"", extendsFrom);
}
jsvUnLock(extendsFrom);
}
JSP_MATCH_WITH_CLEANUP_AND_RETURN('{',jsvUnLock3(classFunction,classInternalName,classPrototype),0);

while ((lex->tk==LEX_ID || lex->tk==LEX_R_STATIC) && !jspIsInterrupted()) {
bool isStatic = lex->tk==LEX_R_STATIC;
if (isStatic) JSP_ASSERT_MATCH(LEX_R_STATIC);

JsVar *funcName = jslGetTokenValueAsVar(lex);
JSP_MATCH_WITH_CLEANUP_AND_RETURN(LEX_ID,jsvUnLock3(classFunction,classInternalName,classPrototype),0);
JsVar *method = jspeFunctionDefinition(false);
if (classFunction && classPrototype) {
if (jsvIsStringEqual(funcName, ""get"") || jsvIsStringEqual(funcName, ""set"")) {
jsExceptionHere(JSET_SYNTAXERROR, ""'get' and 'set' and not supported in Espruino"");
} else if (jsvIsStringEqual(funcName, ""constructor"")) {
jswrap_function_replaceWith(classFunction, method);
} else {
funcName = jsvMakeIntoVariableName(funcName, 0);
jsvSetValueOfName(funcName, method);
jsvAddName(isStatic ? classFunction : classPrototype, funcName);
}
}
jsvUnLock2(method,funcName);
}
jsvUnLock(classPrototype);
// If we had a name, add it to the end (or it gets confused with the constructor arguments)
if (classInternalName)
jsvObjectSetChildAndUnLock(classFunction, JSPARSE_FUNCTION_NAME_NAME, classInternalName);

JSP_MATCH_WITH_CLEANUP_AND_RETURN('}',jsvUnLock(classFunction),0);
return classFunction;
}

#endif

NO_INLINE JsVar *jspeFactor() {
if (lex->tk==LEX_ID) {
JsVar *a = jspGetNamedVariable(jslGetTokenValueAsString(lex));
JSP_ASSERT_MATCH(LEX_ID);
#ifndef SAVE_ON_FLASH
if (lex->tk==LEX_TEMPLATE_LITERAL)
jsExceptionHere(JSET_SYNTAXERROR, ""Tagged template literals not supported"");
else if (lex->tk==LEX_ARROW_FUNCTION && jsvIsName(a)) {
JsVar *funcVar = jspeArrowFunction(0,a);
jsvUnLock(a);
a=funcVar;
}
#endif
return a;
} else if (lex->tk==LEX_INT) {
JsVar *v = 0;
if (JSP_SHOULD_EXECUTE) {
v = jsvNewFromLongInteger(stringToInt(jslGetTokenValueAsString(lex)));
}
JSP_ASSERT_MATCH(LEX_INT);
return v;
} else if (lex->tk==LEX_FLOAT) {
JsVar *v = 0;
if (JSP_SHOULD_EXECUTE) {
v = jsvNewFromFloat(stringToFloat(jslGetTokenValueAsString(lex)));
}
JSP_ASSERT_MATCH(LEX_FLOAT);
return v;
} else if (lex->tk=='(') {
JSP_ASSERT_MATCH('(');
if (!jspCheckStackPosition()) return 0;
#ifdef SAVE_ON_FLASH
// Just parse a normal expression (which can include commas)
JsVar *a = jspeExpression();
if (!JSP_SHOULDNT_PARSE) JSP_MATCH_WITH_RETURN(')',a);
return a;
#else
return jspeExpressionOrArrowFunction();
#endif

} else if (lex->tk==LEX_R_TRUE) {
JSP_ASSERT_MATCH(LEX_R_TRUE);
return JSP_SHOULD_EXECUTE ? jsvNewFromBool(true) : 0;
} else if (lex->tk==LEX_R_FALSE) {
JSP_ASSERT_MATCH(LEX_R_FALSE);
return JSP_SHOULD_EXECUTE ? jsvNewFromBool(false) : 0;
} else if (lex->tk==LEX_R_NULL) {
JSP_ASSERT_MATCH(LEX_R_NULL);
return JSP_SHOULD_EXECUTE ? jsvNewWithFlags(JSV_NULL) : 0;
} else if (lex->tk==LEX_R_UNDEFINED) {
JSP_ASSERT_MATCH(LEX_R_UNDEFINED);
return 0;
} else if (lex->tk==LEX_STR) {
JsVar *a = 0;
if (JSP_SHOULD_EXECUTE)
a = jslGetTokenValueAsVar(lex);
JSP_ASSERT_MATCH(LEX_STR);
return a;
#ifndef SAVE_ON_FLASH
} else if (lex->tk==LEX_TEMPLATE_LITERAL) {
return jspeTemplateLiteral();
#endif
} else if (lex->tk==LEX_REGEX) {
JsVar *a = 0;
#ifdef SAVE_ON_FLASH
jsExceptionHere(JSET_SYNTAXERROR, ""RegEx are not supported in this version of Espruino\n"");
#else
JsVar *regex = jslGetTokenValueAsVar(lex);
size_t regexEnd = 0, regexLen = 0;
JsvStringIterator it;
jsvStringIteratorNew(&it, regex, 0);
while (jsvStringIteratorHasChar(&it)) {
regexLen++;
if (jsvStringIteratorGetChar(&it)=='/')
regexEnd = regexLen;
jsvStringIteratorNext(&it);
}
jsvStringIteratorFree(&it);
JsVar *flags = 0;
if (regexEnd < regexLen)
flags = jsvNewFromStringVar(regex, regexEnd, JSVAPPENDSTRINGVAR_MAXLENGTH);
JsVar *regexSource = jsvNewFromStringVar(regex, 1, regexEnd-2);
a = jswrap_regexp_constructor(regexSource, flags);
jsvUnLock3(regex, flags, regexSource);
#endif
JSP_ASSERT_MATCH(LEX_REGEX);
return a;
} else if (lex->tk=='{') {
if (!jspCheckStackPosition()) return 0;
return jspeFactorObject();
} else if (lex->tk=='[') {
if (!jspCheckStackPosition()) return 0;
return jspeFactorArray();
} else if (lex->tk==LEX_R_FUNCTION) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(LEX_R_FUNCTION);
return jspeFunctionDefinition(true);
#ifndef SAVE_ON_FLASH
} else if (lex->tk==LEX_R_CLASS) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(LEX_R_CLASS);
return jspeClassDefinition(true);
} else if (lex->tk==LEX_R_SUPER) {
JSP_ASSERT_MATCH(LEX_R_SUPER);
/* This is kind of nasty, since super appears to do
three different things.

* In the constructor it references the extended class's constructor
* in a method it references the constructor's prototype.
* in a static method it references the extended class's constructor (but this is different)
*/

if (jsvIsObject(execInfo.thisVar)) {
// 'this' is an object - must be calling a normal method
JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_INHERITS_VAR, 0); // if we're in a method, get __proto__ first
JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0; // still in method, get __proto__.__proto__
jsvUnLock(proto1);
if (!proto2) {
jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
return 0;
}
if (lex->tk=='(') return proto2; // eg. used in a constructor
// But if we're doing something else - eg '.' or '[' then it needs to reference the prototype
JsVar *proto3 = jsvIsFunction(proto2) ? jsvObjectGetChild(proto2, JSPARSE_PROTOTYPE_VAR, 0) : 0;
jsvUnLock(proto2);
return proto3;
} else if (jsvIsFunction(execInfo.thisVar)) {
// 'this' is a function - must be calling a static method
JsVar *proto1 = jsvObjectGetChild(execInfo.thisVar, JSPARSE_PROTOTYPE_VAR, 0);
JsVar *proto2 = jsvIsObject(proto1) ? jsvObjectGetChild(proto1, JSPARSE_INHERITS_VAR, 0) : 0;
jsvUnLock(proto1);
if (!proto2) {
jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
return 0;
}
return proto2;
}
jsExceptionHere(JSET_SYNTAXERROR, ""Calling 'super' outside of class"");
return 0;
#endif
} else if (lex->tk==LEX_R_THIS) {
JSP_ASSERT_MATCH(LEX_R_THIS);
return jsvLockAgain( execInfo.thisVar ? execInfo.thisVar : execInfo.root );
} else if (lex->tk==LEX_R_DELETE) {
if (!jspCheckStackPosition()) return 0;
return jspeFactorDelete();
} else if (lex->tk==LEX_R_TYPEOF) {
if (!jspCheckStackPosition()) return 0;
return jspeFactorTypeOf();
} else if (lex->tk==LEX_R_VOID) {
if (!jspCheckStackPosition()) return 0;
JSP_ASSERT_MATCH(LEX_R_VOID);
jsvUnLock(jspeUnaryExpression());
return 0;
}
JSP_MATCH(LEX_EOF);
jsExceptionHere(JSET_SYNTAXERROR, ""Unexpected end of Input\n"");
return 0;
}

NO_INLINE JsVar *__jspePostfixExpression(JsVar *a) {
while (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
int op = lex->tk;
JSP_ASSERT_MATCH(op);
if (JSP_SHOULD_EXECUTE) {
JsVar *one = jsvNewFromInteger(1);
JsVar *oldValue = jsvAsNumberAndUnLock(jsvSkipName(a)); // keep the old value (but convert to number)
JsVar *res = jsvMathsOpSkipNames(oldValue, one, op==LEX_PLUSPLUS ? '+' : '-');
jsvUnLock(one);

// in-place add/subtract
jspReplaceWith(a, res);
jsvUnLock(res);
// but then use the old value
jsvUnLock(a);
a = oldValue;
}
}
return a;
}

NO_INLINE JsVar *jspePostfixExpression() {
JsVar *a;
// TODO: should be in jspeUnaryExpression
if (lex->tk==LEX_PLUSPLUS || lex->tk==LEX_MINUSMINUS) {
int op = lex->tk;
JSP_ASSERT_MATCH(op);
a = jspePostfixExpression();
if (JSP_SHOULD_EXECUTE) {
JsVar *one = jsvNewFromInteger(1);
JsVar *res = jsvMathsOpSkipNames(a, one, op==LEX_PLUSPLUS ? '+' : '-');
jsvUnLock(one);
// in-place add/subtract
jspReplaceWith(a, res);
jsvUnLock(res);
}
} else
a = jspeFactorFunctionCall();
return __jspePostfixExpression(a);
}

NO_INLINE JsVar *jspeUnaryExpression() {
if (lex->tk=='!' || lex->tk=='~' || lex->tk=='-' || lex->tk=='+') {
short tk = lex->tk;
JSP_ASSERT_MATCH(tk);
if (!JSP_SHOULD_EXECUTE) {
return jspeUnaryExpression();
}
if (tk=='!') { // logical not
return jsvNewFromBool(!jsvGetBoolAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
} else if (tk=='~') { // bitwise not
return jsvNewFromInteger(~jsvGetIntegerAndUnLock(jsvSkipNameAndUnLock(jspeUnaryExpression())));
} else if (tk=='-') { // unary minus
return jsvNegateAndUnLock(jspeUnaryExpression()); // names already skipped
}  else if (tk=='+') { // unary plus (convert to number)
JsVar *v = jsvSkipNameAndUnLock(jspeUnaryExpression());
JsVar *r = jsvAsNumber(v); // names already skipped
jsvUnLock(v);
return r;
}
assert(0);
return 0;
} else
return jspePostfixExpression();
}


// Get the precedence of a BinaryExpression - or return 0 if not one
unsigned int jspeGetBinaryExpressionPrecedence(int op) {
switch (op) {
case LEX_OROR: return 1; break;
case LEX_ANDAND: return 2; break;
case '|' : return 3; break;
case '^' : return 4; break;
case '&' : return 5; break;
case LEX_EQUAL:
case LEX_NEQUAL:
case LEX_TYPEEQUAL:
case LEX_NTYPEEQUAL: return 6;
case LEX_LEQUAL:
case LEX_GEQUAL:
case '<':
case '>':
case LEX_R_INSTANCEOF: return 7;
case LEX_R_IN: return (execInfo.execute&EXEC_FOR_INIT)?0:7;
case LEX_LSHIFT:
case LEX_RSHIFT:
case LEX_RSHIFTUNSIGNED: return 8;
case '+':
case '-': return 9;
case '*':
case '/':
case '%': return 10;
default: return 0;
}
}

NO_INLINE JsVar *__jspeBinaryExpression(JsVar *a, unsigned int lastPrecedence) {
/* This one's a bit strange. Basically all the ops have their own precedence, it's not
* like & and | share the same precedence. We don't want to recurse for each one,
* so instead we do this.
*
* We deal with an expression in recursion ONLY if it's of higher precedence
* than the current one, otherwise we stick in the while loop.
*/
unsigned int precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
while (precedence && precedence>lastPrecedence) {
int op = lex->tk;
JSP_ASSERT_MATCH(op);

// if we have short-circuit ops, then if we know the outcome
// we don't bother to execute the other op. Even if not
// we need to tell mathsOp it's an & or |
if (op==LEX_ANDAND || op==LEX_OROR) {
bool aValue = jsvGetBoolAndUnLock(jsvSkipName(a));
if ((!aValue && op==LEX_ANDAND) ||
(aValue && op==LEX_OROR)) {
// use first argument (A)
JSP_SAVE_EXECUTE();
jspSetNoExecute();
jsvUnLock(__jspeBinaryExpression(jspeUnaryExpression(),precedence));
JSP_RESTORE_EXECUTE();
} else {
// use second argument (B)
jsvUnLock(a);
a = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
}
} else { // else it's a more 'normal' logical expression - just use Maths
JsVar *b = __jspeBinaryExpression(jspeUnaryExpression(),precedence);
if (JSP_SHOULD_EXECUTE) {
if (op==LEX_R_IN) {
JsVar *av = jsvSkipName(a); // needle
JsVar *bv = jsvSkipName(b); // haystack
if (jsvIsArray(bv) || jsvIsObject(bv)) { // search keys, NOT values
av = jsvAsArrayIndexAndUnLock(av);
JsVar *varFound = jspGetVarNamedField( bv, av, true);
jsvUnLock(a);
a = jsvNewFromBool(varFound!=0);
jsvUnLock(varFound);
} else {// else it will be undefined
jsExceptionHere(JSET_ERROR, ""Cannot use 'in' operator to search a %t"", bv);
jsvUnLock(a);
a = 0;
}
jsvUnLock2(av, bv);
} else if (op==LEX_R_INSTANCEOF) {
bool inst = false;
JsVar *av = jsvSkipName(a);
JsVar *bv = jsvSkipName(b);
if (!jsvIsFunction(bv)) {
jsExceptionHere(JSET_ERROR, ""Expecting a function on RHS in instanceof check, got %t"", bv);
} else {
if (jsvIsObject(av) || jsvIsFunction(av)) {
JsVar *bproto = jspGetNamedField(bv, JSPARSE_PROTOTYPE_VAR, false);
JsVar *proto = jsvObjectGetChild(av, JSPARSE_INHERITS_VAR, 0);
while (proto) {
if (proto == bproto) inst=true;
// search prototype chain
JsVar *childProto = jsvObjectGetChild(proto, JSPARSE_INHERITS_VAR, 0);
jsvUnLock(proto);
proto = childProto;
}
if (jspIsConstructor(bv, ""Object"")) inst = true;
jsvUnLock(bproto);
}
if (!inst) {
const char *name = jswGetBasicObjectName(av);
if (name) {
inst = jspIsConstructor(bv, name);
}
// Hack for built-ins that should also be instances of Object
if (!inst && (jsvIsArray(av) || jsvIsArrayBuffer(av)) &&
jspIsConstructor(bv, ""Object""))
inst = true;
}
}
jsvUnLock3(av, bv, a);
a = jsvNewFromBool(inst);
} else {  // --------------------------------------------- NORMAL
JsVar *res = jsvMathsOpSkipNames(a, b, op);
jsvUnLock(a); a = res;
}
}
jsvUnLock(b);
}
precedence = jspeGetBinaryExpressionPrecedence(lex->tk);
}
return a;
}

JsVar *jspeBinaryExpression() {
return __jspeBinaryExpression(jspeUnaryExpression(),0);
}

NO_INLINE JsVar *__jspeConditionalExpression(JsVar *lhs) {
if (lex->tk=='?') {
JSP_ASSERT_MATCH('?');
if (!JSP_SHOULD_EXECUTE) {
// just let lhs pass through
jsvUnLock(jspeAssignmentExpression());
JSP_MATCH(':');
jsvUnLock(jspeAssignmentExpression());
} else {
bool first = jsvGetBoolAndUnLock(jsvSkipName(lhs));
jsvUnLock(lhs);
if (first) {
lhs = jspeAssignmentExpression();
JSP_MATCH(':');
JSP_SAVE_EXECUTE();
jspSetNoExecute();
jsvUnLock(jspeAssignmentExpression());
JSP_RESTORE_EXECUTE();
} else {
JSP_SAVE_EXECUTE();
jspSetNoExecute();
jsvUnLock(jspeAssignmentExpression());
JSP_RESTORE_EXECUTE();
JSP_MATCH(':');
lhs = jspeAssignmentExpression();
}
}
}

return lhs;
}

JsVar *jspeConditionalExpression() {
return __jspeConditionalExpression(jspeBinaryExpression());
}

NO_INLINE JsVar *__jspeAssignmentExpression(JsVar *lhs) {
if (lex->tk=='=' || lex->tk==LEX_PLUSEQUAL || lex->tk==LEX_MINUSEQUAL ||
lex->tk==LEX_MULEQUAL || lex->tk==LEX_DIVEQUAL || lex->tk==LEX_MODEQUAL ||
lex->tk==LEX_ANDEQUAL || lex->tk==LEX_OREQUAL ||
lex->tk==LEX_XOREQUAL || lex->tk==LEX_RSHIFTEQUAL ||
lex->tk==LEX_LSHIFTEQUAL || lex->tk==LEX_RSHIFTUNSIGNEDEQUAL) {
JsVar *rhs;

int op = lex->tk;
JSP_ASSERT_MATCH(op);
rhs = jspeAssignmentExpression();
rhs = jsvSkipNameAndUnLock(rhs); // ensure we get rid of any references on the RHS

if (JSP_SHOULD_EXECUTE && lhs) {
if (op=='=') {
        /* If we're assigning to this and we don't have a parent,
         * add it to the symbol table root *
        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {
          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))
            jsvAddName(execInfo.root, lhs);
        }
        jspReplaceWith(lhs, rhs);
} else {
if (op==LEX_PLUSEQUAL) op='+';
else if (op==LEX_MINUSEQUAL) op='-';
else if (op==LEX_MULEQUAL) op='*';
else if (op==LEX_DIVEQUAL) op='/';
else if (op==LEX_MODEQUAL) op='%';
else if (op==LEX_ANDEQUAL) op='&';
else if (op==LEX_OREQUAL) op='|';
else if (op==LEX_XOREQUAL) op='^';
else if (op==LEX_RSHIFTEQUAL) op=LEX_RSHIFT;
else if (op==LEX_LSHIFTEQUAL) op=LEX_LSHIFT;
else if (op==LEX_RSHIFTUNSIGNEDEQUAL) op=LEX_RSHIFTUNSIGNED;
if (op=='+' && jsvIsName(lhs)) {
JsVar *currentValue = jsvSkipName(lhs);
if (jsvIsString(currentValue) && !jsvIsFlatString(currentValue) && jsvGetRefs(currentValue)==1 && rhs!=currentValue) {
/* A special case for string += where this is the only use of the string
* and we're not appending to ourselves. In this case we can do a
* simple append (rather than clone + append)*/
JsVar *str = jsvAsString(rhs, false);
jsvAppendStringVarComplete(currentValue, str);
jsvUnLock(str);
op = 0;
}
jsvUnLock(currentValue);
}
if (op) {
/* Fallback which does a proper add */
JsVar *res = jsvMathsOpSkipNames(lhs,rhs,op);
jspReplaceWith(lhs, res);
jsvUnLock(res);
}
}
}
jsvUnLock(rhs);
}
return lhs;
}


JsVar *jspeAssignmentExpression() {
return __jspeAssignmentExpression(jspeConditionalExpression());
}

// ',' is allowed to add multiple expressions, this is not allowed in jspeAssignmentExpression
NO_INLINE JsVar *jspeExpression() {
while (!JSP_SHOULDNT_PARSE) {
JsVar *a = jspeAssignmentExpression();
if (lex->tk!=',') return a;
// if we get a comma, we just forget this data and parse the next bit...
jsvCheckReferenceError(a);
jsvUnLock(a);
JSP_ASSERT_MATCH(',');
}
return 0;
}

/** Parse a block `{ ... }` but assume brackets are already parsed */
NO_INLINE void jspeBlockNoBrackets() {
if (JSP_SHOULD_EXECUTE) {
while (lex->tk && lex->tk!='}') {
JsVar *a = jspeStatement();
jsvCheckReferenceError(a);
jsvUnLock(a);
if (JSP_HAS_ERROR) {
if (lex && !(execInfo.execute&EXEC_ERROR_LINE_REPORTED)) {
execInfo.execute = (JsExecFlags)(execInfo.execute | EXEC_ERROR_LINE_REPORTED);
JsVar *stackTrace = jsvObjectGetChild(execInfo.hiddenRoot, JSPARSE_STACKTRACE_VAR, JSV_STRING_0);
if (stackTrace) {
jsvAppendPrintf(stackTrace, ""at "");
jspAppendStackTrace(stackTrace);
jsvUnLock(stackTrace);
}
}
}
if (JSP_SHOULDNT_PARSE)
return;
}
} else {
// fast skip of blocks
int brackets = 0;
while (lex->tk && (brackets || lex->tk != '}')) {
if (lex->tk == '{') brackets++;
if (lex->tk == '}') brackets--;
JSP_ASSERT_MATCH(lex->tk);
}
}
return;
}
","[8, 10, 20, 25, 35, 36]","        /* If we're assigning to this and we don't have a parent,/~/         * add it to the symbol table root */~/        if (!jsvGetRefs(lhs) && jsvIsName(lhs)) {/~/          if (!jsvIsArrayBufferName(lhs) && !jsvIsNewChild(lhs))/~/            jsvAddName(execInfo.root, lhs);/~/        }/~/        jspReplaceWith(lhs, rhs);"
286,"void ChromeContentRendererClient::RenderViewCreated(RenderView* render_view) {
ContentSettingsObserver* content_settings =
new ContentSettingsObserver(render_view);
  new DevToolsAgent(render_view);
new ExtensionHelper(render_view, extension_dispatcher_.get());
new PageLoadHistograms(render_view, histogram_snapshots_.get());
new PrintWebViewHelper(render_view);
new SearchBox(render_view);
new SpellCheckProvider(render_view, spellcheck_.get());
#if defined(ENABLE_SAFE_BROWSING)
safe_browsing::MalwareDOMDetails::Create(render_view);
#endif

#if defined(OS_MACOSX)
new TextInputClientObserver(render_view);
#endif  // defined(OS_MACOSX)

PasswordAutofillManager* password_autofill_manager =
new PasswordAutofillManager(render_view);
AutofillAgent* autofill_agent = new AutofillAgent(render_view,
password_autofill_manager);
PageClickTracker* page_click_tracker = new PageClickTracker(render_view);
// Note that the order of insertion of the listeners is important.
// The password_autocomplete_manager takes the first shot at processing the
// notification and can stop the propagation.
page_click_tracker->AddListener(password_autofill_manager);
page_click_tracker->AddListener(autofill_agent);

TranslateHelper* translate = new TranslateHelper(render_view, autofill_agent);
new ChromeRenderViewObserver(
render_view, content_settings, extension_dispatcher_.get(), translate);

// Used only for testing/automation.
if (CommandLine::ForCurrentProcess()->HasSwitch(
switches::kDomAutomationController)) {
new AutomationRendererHelper(render_view);
}
}
",[3],  new DevToolsAgent(render_view);
287,"ServiceWorkerHandler::ServiceWorkerHandler()
: DevToolsDomainHandler(ServiceWorker::Metainfo::domainName),
enabled_(false),
      process_(nullptr),
weak_factory_(this) {}
",[3],"      process_(nullptr),"
288,"rename_principal_2_svc(rprinc_arg *arg, struct svc_req *rqstp)
{
static generic_ret          ret;
    char                        *prime_arg1,
        *prime_arg2;
    gss_buffer_desc             client_name,
        service_name;
OM_uint32                   minor_stat;
kadm5_server_handle_t       handle;
restriction_t               *rp;
const char                  *errmsg = NULL;
size_t                      tlen1, tlen2, clen, slen;
char                        *tdots1, *tdots2, *cdots, *sdots;

xdr_free(xdr_generic_ret, &ret);

if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
goto exit_func;

if ((ret.code = check_handle((void *)handle)))
goto exit_func;

if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
ret.code = KADM5_FAILURE;
goto exit_func;
}
if (krb5_unparse_name(handle->context, arg->src, &prime_arg1) ||
krb5_unparse_name(handle->context, arg->dest, &prime_arg2)) {
ret.code = KADM5_BAD_PRINCIPAL;
goto exit_func;
}
tlen1 = strlen(prime_arg1);
trunc_name(&tlen1, &tdots1);
tlen2 = strlen(prime_arg2);
trunc_name(&tlen2, &tdots2);
clen = client_name.length;
trunc_name(&clen, &cdots);
slen = service_name.length;
trunc_name(&slen, &sdots);

ret.code = KADM5_OK;
if (! CHANGEPW_SERVICE(rqstp)) {
if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),
ACL_DELETE, arg->src, NULL))
ret.code = KADM5_AUTH_DELETE;
/* any restrictions at all on the ADD kills the RENAME */
if (!kadm5int_acl_check(handle->context, rqst2name(rqstp),
ACL_ADD, arg->dest, &rp) || rp) {
if (ret.code == KADM5_AUTH_DELETE)
ret.code = KADM5_AUTH_INSUFFICIENT;
else
ret.code = KADM5_AUTH_ADD;
}
} else
ret.code = KADM5_AUTH_INSUFFICIENT;
if (ret.code != KADM5_OK) {
/* okay to cast lengths to int because trunc_name limits max value */
krb5_klog_syslog(LOG_NOTICE,
_(""Unauthorized request: kadm5_rename_principal, ""
""%.*s%s to %.*s%s, ""
""client=%.*s%s, service=%.*s%s, addr=%s""),
(int)tlen1, prime_arg1, tdots1,
(int)tlen2, prime_arg2, tdots2,
(int)clen, (char *)client_name.value, cdots,
(int)slen, (char *)service_name.value, sdots,
client_addr(rqstp->rq_xprt));
} else {
ret.code = kadm5_rename_principal((void *)handle, arg->src,
arg->dest);
if( ret.code != 0 )
errmsg = krb5_get_error_message(handle->context, ret.code);

/* okay to cast lengths to int because trunc_name limits max value */
krb5_klog_syslog(LOG_NOTICE,
_(""Request: kadm5_rename_principal, ""
""%.*s%s to %.*s%s, %s, ""
""client=%.*s%s, service=%.*s%s, addr=%s""),
(int)tlen1, prime_arg1, tdots1,
(int)tlen2, prime_arg2, tdots2,
errmsg ? errmsg : _(""success""),
(int)clen, (char *)client_name.value, cdots,
(int)slen, (char *)service_name.value, sdots,
client_addr(rqstp->rq_xprt));

if (errmsg != NULL)
krb5_free_error_message(handle->context, errmsg);

}
free(prime_arg1);
free(prime_arg2);
gss_release_buffer(&minor_stat, &client_name);
gss_release_buffer(&minor_stat, &service_name);
exit_func:
free_server_handle(handle);
return &ret;
}
","[3, 4, 5, 6]","    char                        *prime_arg1,/~/        *prime_arg2;/~/    gss_buffer_desc             client_name,/~/        service_name;/~/exit_func:"
289,"XIQueryDevice(Display *dpy, int deviceid, int *ndevices_return)
{
XIDeviceInfo        *info = NULL;
xXIQueryDeviceReq   *req;
xXIQueryDeviceReq   *req;
xXIQueryDeviceReply reply;
char                *ptr;
int                 i;
char                *buf;

LockDisplay(dpy);
if (_XiCheckExtInit(dpy, XInput_2_0, extinfo) == -1)
goto error_unlocked;

GetReq(XIQueryDevice, req);
req->reqType  = extinfo->codes->major_opcode;
req->ReqType  = X_XIQueryDevice;
req->deviceid = deviceid;

if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))
goto error;
if (!_XReply(dpy, (xReply*) &reply, 0, xFalse))
goto error;

    *ndevices_return = reply.num_devices;
    info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));
if (!info)
goto error;

buf = Xmalloc(reply.length * 4);
_XRead(dpy, buf, reply.length * 4);
ptr = buf;

/* info is a null-terminated array */
info[reply.num_devices].name = NULL;
nclasses         = wire->num_classes;

ptr += sizeof(xXIDeviceInfo);

lib->name = Xcalloc(wire->name_len + 1, 1);
XIDeviceInfo    *lib = &info[i];
xXIDeviceInfo   *wire = (xXIDeviceInfo*)ptr;

lib->deviceid    = wire->deviceid;
lib->use         = wire->use;
lib->attachment  = wire->attachment;

Xfree(buf);

ptr += sizeof(xXIDeviceInfo);

lib->name = Xcalloc(wire->name_len + 1, 1);
strncpy(lib->name, ptr, wire->name_len);
ptr += ((wire->name_len + 3)/4) * 4;

sz = size_classes((xXIAnyInfo*)ptr, nclasses);
lib->classes = Xmalloc(sz);
ptr += copy_classes(lib, (xXIAnyInfo*)ptr, &nclasses);
/* We skip over unused classes */
lib->num_classes = nclasses;
}
","[20, 21]",    *ndevices_return = reply.num_devices;/~/    info = Xmalloc((reply.num_devices + 1) * sizeof(XIDeviceInfo));
290,"int ssl3_send_alert(SSL *s, int level, int desc)
{
/* Map tls/ssl alert value to correct one */
desc = s->method->ssl3_enc->alert_value(desc);
if (s->version == SSL3_VERSION && desc == SSL_AD_PROTOCOL_VERSION)
desc = SSL_AD_HANDSHAKE_FAILURE; /* SSL 3.0 does not have
* protocol_version alerts */
* protocol_version alerts */
if (desc < 0)
return -1;
    /* If a fatal one, remove from cache *
    if ((level == 2) && (s->session != NULL))
        SSL_CTX_remove_session(s->session_ctx, s->session);

s->s3->alert_dispatch = 1;
s->s3->send_alert[0] = level;
* else data is still being written out, we will get written some time in
* the future
*/
return -1;
}
","[10, 11, 12]","    /* If a fatal one, remove from cache */~/    if ((level == 2) && (s->session != NULL))/~/        SSL_CTX_remove_session(s->session_ctx, s->session);"
291,"parse_rock_ridge_inode_internal(struct iso_directory_record *de,
				struct inode *inode, int regard_xa)
{
int symlink_len = 0;
int cnt, sig;
struct inode *reloc;
struct rock_ridge *rr;
int rootflag;
struct rock_state rs;
int ret = 0;

if (!ISOFS_SB(inode->i_sb)->s_rock)
return 0;

init_rock_state(&rs, inode);
setup_rock_ridge(de, inode, &rs);
	if (regard_xa) {
rs.chr += 14;
rs.len -= 14;
if (rs.len < 0)
rs.len = 0;
}

repeat:
while (rs.len > 2) { /* There may be one byte for padding somewhere */
rr = (struct rock_ridge *)rs.chr;
/*
* Ignore rock ridge info if rr->len is out of range, but
* don't return -EIO because that would make the file
* invisible.
*/
if (rr->len < 3)
goto out;	/* Something got screwed up here */
sig = isonum_721(rs.chr);
if (rock_check_overflow(&rs, sig))
goto eio;
rs.chr += rr->len;
rs.len -= rr->len;
/*
* As above, just ignore the rock ridge info if rr->len
* is bogus.
*/
if (rs.len < 0)
goto out;	/* Something got screwed up here */

switch (sig) {
#ifndef CONFIG_ZISOFS		/* No flag for SF or ZF */
case SIG('R', 'R'):
if ((rr->u.RR.flags[0] &
(RR_PX | RR_TF | RR_SL | RR_CL)) == 0)
goto out;
break;
#endif
case SIG('S', 'P'):
if (check_sp(rr, inode))
goto out;
break;
case SIG('C', 'E'):
rs.cont_extent = isonum_733(rr->u.CE.extent);
rs.cont_offset = isonum_733(rr->u.CE.offset);
rs.cont_size = isonum_733(rr->u.CE.size);
break;
case SIG('E', 'R'):
ISOFS_SB(inode->i_sb)->s_rock = 1;
printk(KERN_DEBUG ""ISO 9660 Extensions: "");
{
int p;
for (p = 0; p < rr->u.ER.len_id; p++)
printk(""%c"", rr->u.ER.data[p]);
}
printk(""\n"");
break;
case SIG('P', 'X'):
inode->i_mode = isonum_733(rr->u.PX.mode);
set_nlink(inode, isonum_733(rr->u.PX.n_links));
i_uid_write(inode, isonum_733(rr->u.PX.uid));
i_gid_write(inode, isonum_733(rr->u.PX.gid));
break;
case SIG('P', 'N'):
{
int high, low;
high = isonum_733(rr->u.PN.dev_high);
low = isonum_733(rr->u.PN.dev_low);
/*
* The Rock Ridge standard specifies that if
* sizeof(dev_t) <= 4, then the high field is
* unused, and the device number is completely
* stored in the low field.  Some writers may
* ignore this subtlety,
* and as a result we test to see if the entire
* device number is
* stored in the low field, and use that.
*/
if ((low & ~0xff) && high == 0) {
inode->i_rdev =
MKDEV(low >> 8, low & 0xff);
} else {
inode->i_rdev =
MKDEV(high, low);
}
}
break;
case SIG('T', 'F'):
/*
* Some RRIP writers incorrectly place ctime in the
* TF_CREATE field. Try to handle this correctly for
* either case.
*/
/* Rock ridge never appears on a High Sierra disk */
cnt = 0;
if (rr->u.TF.flags & TF_CREATE) {
inode->i_ctime.tv_sec =
iso_date(rr->u.TF.times[cnt++].time,
0);
inode->i_ctime.tv_nsec = 0;
}
if (rr->u.TF.flags & TF_MODIFY) {
inode->i_mtime.tv_sec =
iso_date(rr->u.TF.times[cnt++].time,
0);
inode->i_mtime.tv_nsec = 0;
}
if (rr->u.TF.flags & TF_ACCESS) {
inode->i_atime.tv_sec =
iso_date(rr->u.TF.times[cnt++].time,
0);
inode->i_atime.tv_nsec = 0;
}
if (rr->u.TF.flags & TF_ATTRIBUTES) {
inode->i_ctime.tv_sec =
iso_date(rr->u.TF.times[cnt++].time,
0);
inode->i_ctime.tv_nsec = 0;
}
break;
case SIG('S', 'L'):
{
int slen;
struct SL_component *slp;
struct SL_component *oldslp;
slen = rr->len - 5;
slp = &rr->u.SL.link;
inode->i_size = symlink_len;
while (slen > 1) {
rootflag = 0;
switch (slp->flags & ~1) {
case 0:
inode->i_size +=
slp->len;
break;
case 2:
inode->i_size += 1;
break;
case 4:
inode->i_size += 2;
break;
case 8:
rootflag = 1;
inode->i_size += 1;
break;
default:
printk(""Symlink component flag ""
""not implemented\n"");
}
slen -= slp->len + 2;
oldslp = slp;
slp = (struct SL_component *)
(((char *)slp) + slp->len + 2);

if (slen < 2) {
if (((rr->u.SL.
flags & 1) != 0)
&&
((oldslp->
flags & 1) == 0))
inode->i_size +=
1;
break;
}

/*
* If this component record isn't
* continued, then append a '/'.
*/
if (!rootflag
&& (oldslp->flags & 1) == 0)
inode->i_size += 1;
}
}
symlink_len = inode->i_size;
break;
case SIG('R', 'E'):
printk(KERN_WARNING ""Attempt to read inode for ""
""relocated directory\n"");
goto out;
case SIG('C', 'L'):
			ISOFS_I(inode)->i_first_extent =
			    isonum_733(rr->u.CL.location);
			reloc =
			    isofs_iget(inode->i_sb,
				       ISOFS_I(inode)->i_first_extent,
				       0);
if (IS_ERR(reloc)) {
ret = PTR_ERR(reloc);
goto out;
}
inode->i_mode = reloc->i_mode;
set_nlink(inode, reloc->i_nlink);
inode->i_uid = reloc->i_uid;
inode->i_gid = reloc->i_gid;
inode->i_rdev = reloc->i_rdev;
inode->i_size = reloc->i_size;
inode->i_blocks = reloc->i_blocks;
inode->i_atime = reloc->i_atime;
inode->i_ctime = reloc->i_ctime;
inode->i_mtime = reloc->i_mtime;
iput(reloc);
break;
#ifdef CONFIG_ZISOFS
case SIG('Z', 'F'): {
int algo;

if (ISOFS_SB(inode->i_sb)->s_nocompress)
break;
algo = isonum_721(rr->u.ZF.algorithm);
if (algo == SIG('p', 'z')) {
int block_shift =
isonum_711(&rr->u.ZF.parms[1]);
if (block_shift > 17) {
printk(KERN_WARNING ""isofs: ""
""Can't handle ZF block ""
""size of 2^%d\n"",
block_shift);
} else {
/*
* Note: we don't change
* i_blocks here
*/
ISOFS_I(inode)->i_file_format =
isofs_file_compressed;
/*
* Parameters to compression
* algorithm (header size,
* block size)
*/
ISOFS_I(inode)->i_format_parm[0] =
isonum_711(&rr->u.ZF.parms[0]);
ISOFS_I(inode)->i_format_parm[1] =
isonum_711(&rr->u.ZF.parms[1]);
inode->i_size =
isonum_733(rr->u.ZF.
real_size);
}
} else {
printk(KERN_WARNING
""isofs: Unknown ZF compression ""
""algorithm: %c%c\n"",
rr->u.ZF.algorithm[0],
rr->u.ZF.algorithm[1]);
}
break;
}
#endif
default:
break;
}
}
ret = rock_continue(&rs);
if (ret == 0)
goto repeat;
if (ret == 1)
ret = 0;
out:
kfree(rs.buffer);
return ret;
eio:
ret = -EIO;
goto out;
}
","[1, 14]","				struct inode *inode, int regard_xa)/~/	if (regard_xa) {/~/			ISOFS_I(inode)->i_first_extent =/~/			    isonum_733(rr->u.CL.location);/~/			reloc =/~/			    isofs_iget(inode->i_sb,/~/				       ISOFS_I(inode)->i_first_extent,/~/				       0);"
292,"std::string MasterPreferences::GetCompressedVariationsSeed() const {
  return ExtractPrefString(prefs::kVariationsCompressedSeed);
}
",[1],  return ExtractPrefString(prefs::kVariationsCompressedSeed);
293,"static int em_sysenter(struct x86_emulate_ctxt *ctxt)
{
const struct x86_emulate_ops *ops = ctxt->ops;
struct desc_struct cs, ss;
u64 msr_data;
u16 cs_sel, ss_sel;
u64 efer = 0;

ops->get_msr(ctxt, MSR_EFER, &efer);
/* inject #GP if in real mode */
if (ctxt->mode == X86EMUL_MODE_REAL)
return emulate_gp(ctxt, 0);

/*
* Not recognized on AMD in compat mode (but is recognized in legacy
* mode).
*/
	if ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)
&& !vendor_intel(ctxt))
return emulate_ud(ctxt);

/* sysenter/sysexit have not been tested in 64bit mode. */
if (ctxt->mode == X86EMUL_MODE_PROT64)
return X86EMUL_UNHANDLEABLE;

setup_syscalls_segments(ctxt, &cs, &ss);

ops->get_msr(ctxt, MSR_IA32_SYSENTER_CS, &msr_data);
	switch (ctxt->mode) {
	case X86EMUL_MODE_PROT32:
		if ((msr_data & 0xfffc) == 0x0)
			return emulate_gp(ctxt, 0);
		break;
	case X86EMUL_MODE_PROT64:
		if (msr_data == 0x0)
			return emulate_gp(ctxt, 0);
		break;
	default:
		break;
	}

ctxt->eflags &= ~(EFLG_VM | EFLG_IF);
	cs_sel = (u16)msr_data;
	cs_sel &= ~SELECTOR_RPL_MASK;
ss_sel = cs_sel + 8;
	ss_sel &= ~SELECTOR_RPL_MASK;
	if (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {
cs.d = 0;
cs.l = 1;
}

ops->set_segment(ctxt, cs_sel, &cs, 0, VCPU_SREG_CS);
ops->set_segment(ctxt, ss_sel, &ss, 0, VCPU_SREG_SS);

ops->get_msr(ctxt, MSR_IA32_SYSENTER_EIP, &msr_data);
	ctxt->_eip = msr_data;

ops->get_msr(ctxt, MSR_IA32_SYSENTER_ESP, &msr_data);
	*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;

return X86EMUL_CONTINUE;
}
","[10, 15, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 36, 37]","	if ((ctxt->mode == X86EMUL_MODE_PROT32) && (efer & EFER_LMA)/~/	switch (ctxt->mode) {/~/	case X86EMUL_MODE_PROT32:/~/		if ((msr_data & 0xfffc) == 0x0)/~/			return emulate_gp(ctxt, 0);/~/		break;/~/	case X86EMUL_MODE_PROT64:/~/		if (msr_data == 0x0)/~/			return emulate_gp(ctxt, 0);/~/		break;/~/	default:/~/		break;/~/	}/~/	cs_sel = (u16)msr_data;/~/	cs_sel &= ~SELECTOR_RPL_MASK;/~/	ss_sel &= ~SELECTOR_RPL_MASK;/~/	if (ctxt->mode == X86EMUL_MODE_PROT64 || (efer & EFER_LMA)) {/~/	ctxt->_eip = msr_data;/~/	*reg_write(ctxt, VCPU_REGS_RSP) = msr_data;"
294,"static int sgi_clock_set(clockid_t clockid, struct timespec *tp)
{

u64 nsec;
	u64 rem;

nsec = rtc_time() * sgi_clock_period;

	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);

if (rem <= tp->tv_nsec)
sgi_clock_offset.tv_nsec = tp->tv_sec - rem;
else {
sgi_clock_offset.tv_nsec = tp->tv_sec + NSEC_PER_SEC - rem;
sgi_clock_offset.tv_sec--;
}
return 0;
}
","[3, 5]","	u64 rem;/~/	sgi_clock_offset.tv_sec = tp->tv_sec - div_long_long_rem(nsec, NSEC_PER_SEC, &rem);"
295,"ieee802_15_4_if_print(netdissect_options *ndo,
const struct pcap_pkthdr *h, const u_char *p)
{
u_int caplen = h->caplen;
	int hdrlen;
uint16_t fc;
uint8_t seq;

if (caplen < 3) {
		ND_PRINT((ndo, ""[|802.15.4] %x"", caplen));
return caplen;
}

fc = EXTRACT_LE_16BITS(p);
	hdrlen = extract_header_length(fc);
seq = EXTRACT_LE_8BITS(p + 2);

p += 3;
caplen -= 3;

	ND_PRINT((ndo,""IEEE 802.15.4 %s packet "", ftypes[fc & 0x7]));
if (ndo->ndo_vflag)
ND_PRINT((ndo,""seq %02x "", seq));
	if (hdrlen == -1) {
		ND_PRINT((ndo,""invalid! ""));
		return caplen;
	}
	if (!ndo->ndo_vflag) {
		p+= hdrlen;
		caplen -= hdrlen;
	} else {
		uint16_t panid = 0;

		switch ((fc >> 10) & 0x3) {
		case 0x00:
ND_PRINT((ndo,""none ""));
			break;
		case 0x01:
ND_PRINT((ndo,""reserved destination addressing mode""));
			return 0;
		case 0x02:
			panid = EXTRACT_LE_16BITS(p);
			p += 2;
			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));
			p += 2;
			break;
		case 0x03:
			panid = EXTRACT_LE_16BITS(p);
			p += 2;
			ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p)));
			p += 8;
			break;
}
ND_PRINT((ndo,""< ""));

		switch ((fc >> 14) & 0x3) {
		case 0x00:
ND_PRINT((ndo,""none ""));
			break;
		case 0x01:
ND_PRINT((ndo,""reserved source addressing mode""));
			return 0;
		case 0x02:
			if (!(fc & (1 << 6))) {
				panid = EXTRACT_LE_16BITS(p);
				p += 2;
}
			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));
p += 2;
			break;
		case 0x03:
			if (!(fc & (1 << 6))) {
				panid = EXTRACT_LE_16BITS(p);
				p += 2;
}
                        ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p)));
			p += 8;
			break;
}
		caplen -= hdrlen;
}

if (!ndo->ndo_suppress_default_print)
ND_DEFAULTPRINT(p, caplen);

	return 0;
}
","[4, 8, 9, 10, 12, 16, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 31, 32, 34, 35, 36, 37, 38, 39, 40, 41]","	int hdrlen;/~/		ND_PRINT((ndo, ""[|802.15.4] %x"", caplen));/~/	hdrlen = extract_header_length(fc);/~/	ND_PRINT((ndo,""IEEE 802.15.4 %s packet "", ftypes[fc & 0x7]));/~/	if (hdrlen == -1) {/~/		ND_PRINT((ndo,""invalid! ""));/~/		return caplen;/~/	}/~/	if (!ndo->ndo_vflag) {/~/		p+= hdrlen;/~/		caplen -= hdrlen;/~/	} else {/~/		uint16_t panid = 0;/~/		switch ((fc >> 10) & 0x3) {/~/		case 0x00:/~/			break;/~/		case 0x01:/~/			return 0;/~/		case 0x02:/~/			panid = EXTRACT_LE_16BITS(p);/~/			p += 2;/~/			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));/~/			p += 2;/~/			break;/~/		case 0x03:/~/			panid = EXTRACT_LE_16BITS(p);/~/			p += 2;/~/			ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p)));/~/			p += 8;/~/			break;/~/		switch ((fc >> 14) & 0x3) {/~/		case 0x00:/~/			break;/~/		case 0x01:/~/			return 0;/~/		case 0x02:/~/			if (!(fc & (1 << 6))) {/~/				panid = EXTRACT_LE_16BITS(p);/~/				p += 2;/~/			ND_PRINT((ndo,""%04x:%04x "", panid, EXTRACT_LE_16BITS(p)));/~/			break;/~/		case 0x03:/~/			if (!(fc & (1 << 6))) {/~/				panid = EXTRACT_LE_16BITS(p);/~/				p += 2;/~/                        ND_PRINT((ndo,""%04x:%s "", panid, le64addr_string(ndo, p)));/~/			p += 8;/~/			break;/~/		caplen -= hdrlen;/~/	return 0;"
296,"void f2fs_wait_discard_bios(struct f2fs_sb_info *sbi)
{
__issue_discard_cmd(sbi, false);
__drop_discard_cmd(sbi);
	__wait_discard_cmd(sbi, false);
}
",[4],"	__wait_discard_cmd(sbi, false);"
297,"static void sgi_timer_get(struct k_itimer *timr, struct itimerspec *cur_setting)
{

if (timr->it.mmtimer.clock == TIMER_OFF) {
cur_setting->it_interval.tv_nsec = 0;
cur_setting->it_interval.tv_sec = 0;
cur_setting->it_value.tv_nsec = 0;
cur_setting->it_value.tv_sec =0;
return;
}

	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);
	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);
	return;
}
","[7, 9, 10, 11]","	ns_to_timespec(cur_setting->it_interval, timr->it.mmtimer.incr * sgi_clock_period);/~/	ns_to_timespec(cur_setting->it_value, (timr->it.mmtimer.expires - rtc_time())* sgi_clock_period);/~/	return;"
298,"vhost_scsi_send_evt(struct vhost_scsi *vs,
struct vhost_scsi_tpg *tpg,
struct se_lun *lun,
u32 event,
u32 reason)
{
struct vhost_scsi_evt *evt;

evt = vhost_scsi_allocate_evt(vs, event, reason);
if (!evt)
return;

if (tpg && lun) {
/* TODO: share lun setup code with virtio-scsi.ko */
/*
* Note: evt->event is zeroed when we allocate it and
* lun[4-7] need to be zero according to virtio-scsi spec.
*/
evt->event.lun[0] = 0x01;
		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
if (lun->unpacked_lun >= 256)
evt->event.lun[2] = lun->unpacked_lun >> 8 | 0x40 ;
evt->event.lun[3] = lun->unpacked_lun & 0xFF;
}

llist_add(&evt->list, &vs->vs_event_list);
vhost_work_queue(&vs->dev, &vs->vs_event_work);
}
",[17],		evt->event.lun[1] = tpg->tport_tpgt & 0xFF;
299,"static int udp_v6_push_pending_frames(struct sock *sk)
{
struct sk_buff *skb;
struct udphdr *uh;
struct udp_sock  *up = udp_sk(sk);
struct inet_sock *inet = inet_sk(sk);
	struct flowi6 *fl6 = &inet->cork.fl.u.ip6;
int err = 0;
int is_udplite = IS_UDPLITE(sk);
__wsum csum = 0;

/* Grab the skbuff where UDP header space exists. */
if ((skb = skb_peek(&sk->sk_write_queue)) == NULL)
goto out;

/*
* Create a UDP header
*/
uh = udp_hdr(skb);
uh->source = fl6->fl6_sport;
uh->dest = fl6->fl6_dport;
uh->len = htons(up->len);
uh->check = 0;

if (is_udplite)
csum = udplite_csum_outgoing(sk, skb);
else if (skb->ip_summed == CHECKSUM_PARTIAL) { /* UDP hardware csum */
udp6_hwcsum_outgoing(sk, skb, &fl6->saddr, &fl6->daddr,
up->len);
goto send;
} else
csum = udp_csum_outgoing(sk, skb);

/* add protocol-dependent pseudo-header */
uh->check = csum_ipv6_magic(&fl6->saddr, &fl6->daddr,
up->len, fl6->flowi6_proto, csum);
if (uh->check == 0)
uh->check = CSUM_MANGLED_0;

send:
err = ip6_push_pending_frames(sk);
if (err) {
if (err == -ENOBUFS && !inet6_sk(sk)->recverr) {
UDP6_INC_STATS_USER(sock_net(sk),
UDP_MIB_SNDBUFERRORS, is_udplite);
err = 0;
}
} else
UDP6_INC_STATS_USER(sock_net(sk),
UDP_MIB_OUTDATAGRAMS, is_udplite);
out:
up->len = 0;
up->pending = 0;
return err;
}
",[6],	struct flowi6 *fl6 = &inet->cork.fl.u.ip6;
300,"rx_cache_insert(netdissect_options *ndo,
const u_char *bp, const struct ip *ip, int dport)
{
struct rx_cache_entry *rxent;
const struct rx_header *rxh = (const struct rx_header *) bp;

if (ndo->ndo_snapend - bp + 1 <= (int)(sizeof(struct rx_header) + sizeof(int32_t)))
return;

rxent = &rx_cache[rx_cache_next];

if (++rx_cache_next >= RX_CACHE_SIZE)
rx_cache_next = 0;

rxent->callnum = EXTRACT_32BITS(&rxh->callNumber);
UNALIGNED_MEMCPY(&rxent->client, &ip->ip_src, sizeof(uint32_t));
UNALIGNED_MEMCPY(&rxent->server, &ip->ip_dst, sizeof(uint32_t));
rxent->dport = dport;
	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
rxent->opcode = EXTRACT_32BITS(bp + sizeof(struct rx_header));
}
",[14],	rxent->serviceId = EXTRACT_32BITS(&rxh->serviceId);
301,"static irqreturn_t armv7pmu_handle_irq(int irq_num, void *dev)
{
unsigned long pmnc;
struct perf_sample_data data;
struct cpu_hw_events *cpuc;
struct pt_regs *regs;
int idx;

/*
* Get and reset the IRQ flags
*/
pmnc = armv7_pmnc_getreset_flags();

/*
* Did an overflow occur?
*/
if (!armv7_pmnc_has_overflowed(pmnc))
return IRQ_NONE;

/*
* Handle the counter(s) overflow(s)
*/
regs = get_irq_regs();

perf_sample_data_init(&data, 0);

cpuc = &__get_cpu_var(cpu_hw_events);
for (idx = 0; idx <= armpmu->num_events; ++idx) {
struct perf_event *event = cpuc->events[idx];
struct hw_perf_event *hwc;

if (!test_bit(idx, cpuc->active_mask))
continue;

/*
* We have a single interrupt for all counters. Check that
* each counter has overflowed before we process it.
*/
if (!armv7_pmnc_counter_has_overflowed(pmnc, idx))
continue;

hwc = &event->hw;
armpmu_event_update(event, hwc, idx, 1);
data.period = event->hw.last_period;
if (!armpmu_event_set_period(event, hwc, idx))
continue;

		if (perf_event_overflow(event, 0, &data, regs))
armpmu->disable(hwc, idx);
}

/*
* Handle the pending perf events.
*
* Note: this call *must* be run with interrupts disabled. For
* platforms that can have the PMU interrupts raised as an NMI, this
* will not work.
*/
irq_work_run();

return IRQ_HANDLED;
}
",[38],"		if (perf_event_overflow(event, 0, &data, regs))"
302,"dissect_spoolss_keybuffer(tvbuff_t *tvb, int offset, packet_info *pinfo,
proto_tree *tree, dcerpc_info *di, guint8 *drep)
{
guint32 size;
int end_offset;

if (di->conformant_run)
return offset;

/* Dissect size and data */

offset = dissect_ndr_uint32(tvb, offset, pinfo, tree, di, drep,
hf_keybuffer_size, &size);

end_offset = offset + (size*2);
if (end_offset < offset) {
/*
* Overflow - make the end offset one past the end of
* the packet data, so we throw an exception (as the
* size is almost certainly too big).
*/
end_offset = tvb_reported_length_remaining(tvb, offset) + 1;
}

	while (offset < end_offset)
offset = dissect_spoolss_uint16uni(
tvb, offset, pinfo, tree, drep, NULL, hf_keybuffer);

return offset;
}
",[19],	while (offset < end_offset)
303,"void SyncManager::SyncInternal::OnIPAddressChangedImpl() {
DCHECK(thread_checker_.CalledOnValidThread());
  // TODO(akalin): CheckServerReachable() can block, which may cause
  // jank if we try to shut down sync.  Fix this.
  connection_manager()->CheckServerReachable();
}
","[2, 3, 4]","  // TODO(akalin): CheckServerReachable() can block, which may cause/~/  // jank if we try to shut down sync.  Fix this./~/  connection_manager()->CheckServerReachable();"
304,"static int burl_normalize_2F_to_slash_fix (buffer *b, int qs, int i)
{
char * const s = b->ptr;
const int blen = (int)buffer_string_length(b);
const int used = qs < 0 ? blen : qs;
int j = i;
for (; i < used; ++i, ++j) {
s[j] = s[i];
if (s[i] == '%' && s[i+1] == '2' && s[i+2] == 'F') {
s[j] = '/';
i+=2;
}
}
if (qs >= 0) {
        memmove(s+j, s+qs, blen - qs);
        j += blen - qs;
}
buffer_string_set_length(b, j);
return qs;
}
","[14, 15]","        memmove(s+j, s+qs, blen - qs);/~/        j += blen - qs;"
305,"GURL DevToolsWindow::GetDevToolsURL(Profile* profile,
const GURL& base_url,
bool shared_worker_frontend,
bool v8_only_frontend,
const std::string& remote_frontend,
bool can_dock) {
// Compatibility errors are encoded with data urls, pass them
// through with no decoration.
if (base_url.SchemeIs(""data""))
return base_url;

std::string frontend_url(
!remote_frontend.empty() ?
remote_frontend :
base_url.is_empty() ? chrome::kChromeUIDevToolsURL : base_url.spec());
std::string url_string(
frontend_url +
((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&""));
if (shared_worker_frontend)
url_string += ""&isSharedWorker=true"";
if (v8_only_frontend)
url_string += ""&v8only=true"";
if (remote_frontend.size()) {
url_string += ""&remoteFrontend=true"";
} else {
url_string += ""&remoteBase="" + DevToolsUI::GetRemoteBaseURL().spec();
}
if (can_dock)
url_string += ""&can_dock=true"";
  return GURL(url_string);
}
",[28],  return GURL(url_string);
306,"krb5_gss_inquire_sec_context_by_oid (OM_uint32 *minor_status,
const gss_ctx_id_t context_handle,
const gss_OID desired_object,
gss_buffer_set_t *data_set)
{
krb5_gss_ctx_id_rec *ctx;
size_t i;

if (minor_status == NULL)
return GSS_S_CALL_INACCESSIBLE_WRITE;

*minor_status = 0;

if (desired_object == GSS_C_NO_OID)
return GSS_S_CALL_INACCESSIBLE_READ;

if (data_set == NULL)
return GSS_S_CALL_INACCESSIBLE_WRITE;

*data_set = GSS_C_NO_BUFFER_SET;

ctx = (krb5_gss_ctx_id_rec *) context_handle;

    if (!ctx->established)
return GSS_S_NO_CONTEXT;

for (i = 0; i < sizeof(krb5_gss_inquire_sec_context_by_oid_ops)/
sizeof(krb5_gss_inquire_sec_context_by_oid_ops[0]); i++) {
if (g_OID_prefix_equal(desired_object, &krb5_gss_inquire_sec_context_by_oid_ops[i].oid)) {
return (*krb5_gss_inquire_sec_context_by_oid_ops[i].func)(minor_status,
context_handle,
desired_object,
data_set);
}
}

*minor_status = EINVAL;

return GSS_S_UNAVAILABLE;
}
",[16],    if (!ctx->established)
307,"IPV6DefragReverseSimpleTest(void)
{
DefragContext *dc = NULL;
Packet *p1 = NULL, *p2 = NULL, *p3 = NULL;
Packet *reassembled = NULL;
int id = 12;
int i;
int ret = 0;

DefragInit();

dc = DefragContextNew();
if (dc == NULL)
goto end;

    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);
if (p1 == NULL)
goto end;
    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);
if (p2 == NULL)
goto end;
    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);
if (p3 == NULL)
goto end;

if (Defrag(NULL, NULL, p3, NULL) != NULL)
goto end;
if (Defrag(NULL, NULL, p2, NULL) != NULL)
goto end;
reassembled = Defrag(NULL, NULL, p1, NULL);
if (reassembled == NULL)
goto end;

/* 40 bytes in we should find 8 bytes of A. */
for (i = 40; i < 40 + 8; i++) {
if (GET_PKT_DATA(reassembled)[i] != 'A')
goto end;
}

/* 28 bytes in we should find 8 bytes of B. */
for (i = 48; i < 48 + 8; i++) {
if (GET_PKT_DATA(reassembled)[i] != 'B')
goto end;
}

/* And 36 bytes in we should find 3 bytes of C. */
for (i = 56; i < 56 + 3; i++) {
if (GET_PKT_DATA(reassembled)[i] != 'C')
goto end;
}

ret = 1;
end:
if (dc != NULL)
DefragContextDestroy(dc);
if (p1 != NULL)
SCFree(p1);
if (p2 != NULL)
SCFree(p2);
if (p3 != NULL)
SCFree(p3);
if (reassembled != NULL)
SCFree(reassembled);

DefragDestroy();
return ret;
}
","[12, 15, 18]","    p1 = IPV6BuildTestPacket(id, 0, 1, 'A', 8);/~/    p2 = IPV6BuildTestPacket(id, 1, 1, 'B', 8);/~/    p3 = IPV6BuildTestPacket(id, 2, 0, 'C', 3);"
308,"GURL DecorateFrontendURL(const GURL& base_url) {
std::string frontend_url = base_url.spec();
std::string url_string(
frontend_url +
((frontend_url.find(""?"") == std::string::npos) ? ""?"" : ""&"") +
""dockSide=undocked""); // TODO(dgozman): remove this support in M38.
base::CommandLine* command_line = base::CommandLine::ForCurrentProcess();
if (command_line->HasSwitch(switches::kEnableDevToolsExperiments))
url_string += ""&experiments=true"";

if (command_line->HasSwitch(switches::kDevToolsFlags)) {
    std::string flags = command_line->GetSwitchValueASCII(
                            switches::kDevToolsFlags);
    flags = net::EscapeQueryParamValue(flags, false);
    url_string += ""&flags="" + flags;
}

#if defined(DEBUG_DEVTOOLS)
url_string += ""&debugFrontend=true"";
#endif  // defined(DEBUG_DEVTOOLS)

return GURL(url_string);
}
","[10, 11, 12, 13]","    std::string flags = command_line->GetSwitchValueASCII(/~/                            switches::kDevToolsFlags);/~/    flags = net::EscapeQueryParamValue(flags, false);/~/    url_string += ""&flags="" + flags;"
309,"static char *rfc2047_decode_word(const char *s, size_t len, enum ContentEncoding enc)
{
const char *it = s;
const char *end = s + len;

if (enc == ENCQUOTEDPRINTABLE)
{
struct Buffer buf = { 0 };
for (; it < end; ++it)
{
if (*it == '_')
{
mutt_buffer_addch(&buf, ' ');
}
else if ((*it == '=') && (!(it[1] & ~127) && hexval(it[1]) != -1) &&
(!(it[2] & ~127) && hexval(it[2]) != -1))
{
mutt_buffer_addch(&buf, (hexval(it[1]) << 4) | hexval(it[2]));
it += 2;
}
else
{
mutt_buffer_addch(&buf, *it);
}
}
mutt_buffer_addch(&buf, '\0');
return buf.data;
}
else if (enc == ENCBASE64)
{
    char *out = mutt_mem_malloc(3 * len / 4 + 1);
    int dlen = mutt_b64_decode(out, it);
if (dlen == -1)
{
FREE(&out);
return NULL;
}
out[dlen] = '\0';
return out;
}

assert(0); /* The enc parameter has an invalid value */
return NULL;
}
","[29, 30]","    char *out = mutt_mem_malloc(3 * len / 4 + 1);/~/    int dlen = mutt_b64_decode(out, it);"
310,"static void php_wddx_process_data(void *user_data, const XML_Char *s, int len)
{
st_entry *ent;
wddx_stack *stack = (wddx_stack *)user_data;
TSRMLS_FETCH();

if (!wddx_stack_is_empty(stack) && !stack->done) {
wddx_stack_top(stack, (void**)&ent);
switch (ent->type) {
case ST_STRING:
if (Z_STRLEN_P(ent->data) == 0) {
STR_FREE(Z_STRVAL_P(ent->data));
Z_STRVAL_P(ent->data) = estrndup(s, len);
Z_STRLEN_P(ent->data) = len;
} else {
Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
Z_STRLEN_P(ent->data) += len;
Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
}
break;

case ST_BINARY:
if (Z_STRLEN_P(ent->data) == 0) {
STR_FREE(Z_STRVAL_P(ent->data));
Z_STRVAL_P(ent->data) = estrndup(s, len + 1);
} else {
Z_STRVAL_P(ent->data) = erealloc(Z_STRVAL_P(ent->data), Z_STRLEN_P(ent->data) + len + 1);
memcpy(Z_STRVAL_P(ent->data) + Z_STRLEN_P(ent->data), s, len);
}
Z_STRLEN_P(ent->data) += len;
Z_STRVAL_P(ent->data)[Z_STRLEN_P(ent->data)] = '\0';
break;

case ST_NUMBER:
Z_TYPE_P(ent->data) = IS_STRING;
Z_STRLEN_P(ent->data) = len;
Z_STRVAL_P(ent->data) = estrndup(s, len);
convert_scalar_to_number(ent->data TSRMLS_CC);
break;

case ST_BOOLEAN:
if(!ent->data) {
break;
}
if (!strcmp(s, ""true"")) {
Z_LVAL_P(ent->data) = 1;
} else if (!strcmp(s, ""false"")) {
Z_LVAL_P(ent->data) = 0;
} else {
zval_ptr_dtor(&ent->data);
if (ent->varname) {
efree(ent->varname);
ent->varname = NULL;
}
ent->data = NULL;
}
break;

case ST_DATETIME: {
char *tmp;

				tmp = emalloc(len + 1);
				memcpy(tmp, s, len);
tmp[len] = '\0';

Z_LVAL_P(ent->data) = php_parse_date(tmp, NULL);
/* date out of range < 1969 or > 2038 */
if (Z_LVAL_P(ent->data) == -1) {
					Z_TYPE_P(ent->data) = IS_STRING;
					Z_STRLEN_P(ent->data) = len;
					Z_STRVAL_P(ent->data) = estrndup(s, len);
}
				efree(tmp);
}
break;

default:
break;
}
}
}
","[11, 12]","				tmp = emalloc(len + 1);/~/				memcpy(tmp, s, len);/~/					Z_TYPE_P(ent->data) = IS_STRING;/~/					Z_STRLEN_P(ent->data) = len;/~/					Z_STRVAL_P(ent->data) = estrndup(s, len);/~/				efree(tmp);"
311,"void HTMLImportsController::Dispose() {
  for (const auto& loader : loaders_)
    loader->Dispose();
  loaders_.clear();

if (root_) {
root_->Dispose();
root_.Clear();
}
}
","[1, 2, 3]",  for (const auto& loader : loaders_)/~/    loader->Dispose();/~/  loaders_.clear();
312,"static v8::Handle<v8::Value> methodWithNonOptionalArgAndOptionalArgCallback(const v8::Arguments& args)
{
INC_STATS(""DOM.TestObj.methodWithNonOptionalArgAndOptionalArg"");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestObj* imp = V8TestObj::toNative(args.Holder());
EXCEPTION_BLOCK(int, nonOpt, toInt32(MAYBE_MISSING_PARAMETER(args, 0, DefaultIsUndefined)));
if (args.Length() <= 1) {
imp->methodWithNonOptionalArgAndOptionalArg(nonOpt);
return v8::Handle<v8::Value>();
}
EXCEPTION_BLOCK(int, opt, toInt32(MAYBE_MISSING_PARAMETER(args, 1, DefaultIsUndefined)));
imp->methodWithNonOptionalArgAndOptionalArg(nonOpt, opt);
return v8::Handle<v8::Value>();
}
",[4],        return V8Proxy::throwNotEnoughArgumentsError();
313,"void WallpaperManager::DoSetDefaultWallpaper(
const AccountId& account_id,
MovableOnDestroyCallbackHolder on_finish) {
// There is no visible wallpaper in kiosk mode.
if (user_manager::UserManager::Get()->IsLoggedInAsKioskApp())
return;
wallpaper_cache_.erase(account_id);

WallpaperResolution resolution = GetAppropriateResolution();
const bool use_small = (resolution == WALLPAPER_RESOLUTION_SMALL);

const base::FilePath* file = NULL;

const user_manager::User* user =
user_manager::UserManager::Get()->FindUser(account_id);

if (user_manager::UserManager::Get()->IsLoggedInAsGuest()) {
file =
use_small ? &guest_small_wallpaper_file_ : &guest_large_wallpaper_file_;
} else if (user && user->GetType() == user_manager::USER_TYPE_CHILD) {
file =
use_small ? &child_small_wallpaper_file_ : &child_large_wallpaper_file_;
} else {
file = use_small ? &default_small_wallpaper_file_
: &default_large_wallpaper_file_;
}
wallpaper::WallpaperLayout layout =
use_small ? wallpaper::WALLPAPER_LAYOUT_CENTER
: wallpaper::WALLPAPER_LAYOUT_CENTER_CROPPED;
DCHECK(file);
if (!default_wallpaper_image_.get() ||
default_wallpaper_image_->file_path() != *file) {
default_wallpaper_image_.reset();
if (!file->empty()) {
loaded_wallpapers_for_test_++;
      StartLoadAndSetDefaultWallpaper(*file, layout, std::move(on_finish),
&default_wallpaper_image_);
return;
}

CreateSolidDefaultWallpaper();
}
  // 1x1 wallpaper is actually solid color, so it should be stretched.
  if (default_wallpaper_image_->image().width() == 1 &&
      default_wallpaper_image_->image().height() == 1)
    layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;
  WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,
                     wallpaper::DEFAULT, base::Time::Now().LocalMidnight());
  SetWallpaper(default_wallpaper_image_->image(), info);
}
","[31, 37]","      StartLoadAndSetDefaultWallpaper(*file, layout, std::move(on_finish),/~/  // 1x1 wallpaper is actually solid color, so it should be stretched./~/  if (default_wallpaper_image_->image().width() == 1 &&/~/      default_wallpaper_image_->image().height() == 1)/~/    layout = wallpaper::WALLPAPER_LAYOUT_STRETCH;/~/  WallpaperInfo info(default_wallpaper_image_->file_path().value(), layout,/~/                     wallpaper::DEFAULT, base::Time::Now().LocalMidnight());/~/  SetWallpaper(default_wallpaper_image_->image(), info);"
314,"on_unregister_handler(TCMUService1HandlerManager1 *interface,
GDBusMethodInvocation *invocation,
gchar *subtype,
gpointer user_data)
{
struct tcmur_handler *handler = find_handler_by_subtype(subtype);
struct dbus_info *info = handler ? handler->opaque : NULL;

if (!handler) {
g_dbus_method_invocation_return_value(invocation,
g_variant_new(""(bs)"", FALSE,
""unknown subtype""));
return TRUE;
}
dbus_unexport_handler(handler);
	tcmur_unregister_handler(handler);
g_bus_unwatch_name(info->watcher_id);
g_free(info);
g_free(handler);
g_dbus_method_invocation_return_value(invocation,
g_variant_new(""(bs)"", TRUE, ""succeeded""));
return TRUE;
}
",[14],	tcmur_unregister_handler(handler);
315,"_exsltDateTruncateDate (exsltDateValPtr dt, exsltDateType type)
{
if (dt == NULL)
return 1;

if ((type & XS_TIME) != XS_TIME) {
dt->value.date.hour = 0;
dt->value.date.min  = 0;
dt->value.date.sec  = 0.0;
}

if ((type & XS_GDAY) != XS_GDAY)
        dt->value.date.day = 0;

if ((type & XS_GMONTH) != XS_GMONTH)
        dt->value.date.mon = 0;

if ((type & XS_GYEAR) != XS_GYEAR)
dt->value.date.year = 0;

dt->type = type;

return 0;
}
","[10, 12]",        dt->value.date.day = 0;/~/        dt->value.date.mon = 0;
316,"cib_remote_dispatch(gpointer user_data)
{
cib_t *cib = user_data;
cib_remote_opaque_t *private = cib->variant_opaque;

xmlNode *msg = NULL;
    const char *type = NULL;

crm_info(""Message on callback channel"");
    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);

    type = crm_element_value(msg, F_TYPE);
    crm_trace(""Activating %s callbacks..."", type);

    if (safe_str_eq(type, T_CIB)) {
        cib_native_callback(cib, msg, 0, 0);

    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {
        g_list_foreach(cib->notify_list, cib_native_notify, msg);

    } else {
        crm_err(""Unknown message type: %s"", type);
    }

    if (msg != NULL) {
free_xml(msg);
        return 0;
}
    return -1;
}
","[5, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22]","    const char *type = NULL;/~/    msg = crm_recv_remote_msg(private->callback.session, private->callback.encrypted);/~/    type = crm_element_value(msg, F_TYPE);/~/    crm_trace(""Activating %s callbacks..."", type);/~/    if (safe_str_eq(type, T_CIB)) {/~/        cib_native_callback(cib, msg, 0, 0);/~/    } else if (safe_str_eq(type, T_CIB_NOTIFY)) {/~/        g_list_foreach(cib->notify_list, cib_native_notify, msg);/~/    } else {/~/        crm_err(""Unknown message type: %s"", type);/~/    }/~/    if (msg != NULL) {/~/        return 0;/~/    return -1;"
317,"static void logi_dj_recv_add_djhid_device(struct dj_receiver_dev *djrcv_dev,
struct dj_report *dj_report)
{
/* Called in delayed work context */
struct hid_device *djrcv_hdev = djrcv_dev->hdev;
struct usb_interface *intf = to_usb_interface(djrcv_hdev->dev.parent);
struct usb_device *usbdev = interface_to_usbdev(intf);
struct hid_device *dj_hiddev;
struct dj_device *dj_dev;

/* Device index goes from 1 to 6, we need 3 bytes to store the
* semicolon, the index, and a null terminator
*/
unsigned char tmpstr[3];

if (dj_report->report_params[DEVICE_PAIRED_PARAM_SPFUNCTION] &
SPFUNCTION_DEVICE_LIST_EMPTY) {
dbg_hid(""%s: device list is empty\n"", __func__);
djrcv_dev->querying_devices = false;
return;
}

	if ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||
	    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {
		dev_err(&djrcv_hdev->dev, ""%s: invalid device index:%d\n"",
			__func__, dj_report->device_index);
		return;
	}
if (djrcv_dev->paired_dj_devices[dj_report->device_index]) {
/* The device is already known. No need to reallocate it. */
dbg_hid(""%s: device is already known\n"", __func__);
return;
}

dj_hiddev = hid_allocate_device();
if (IS_ERR(dj_hiddev)) {
dev_err(&djrcv_hdev->dev, ""%s: hid_allocate_device failed\n"",
__func__);
return;
}

dj_hiddev->ll_driver = &logi_dj_ll_driver;

dj_hiddev->dev.parent = &djrcv_hdev->dev;
dj_hiddev->bus = BUS_USB;
dj_hiddev->vendor = le16_to_cpu(usbdev->descriptor.idVendor);
dj_hiddev->product = le16_to_cpu(usbdev->descriptor.idProduct);
snprintf(dj_hiddev->name, sizeof(dj_hiddev->name),
""Logitech Unifying Device. Wireless PID:%02x%02x"",
dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_MSB],
dj_report->report_params[DEVICE_PAIRED_PARAM_EQUAD_ID_LSB]);

usb_make_path(usbdev, dj_hiddev->phys, sizeof(dj_hiddev->phys));
snprintf(tmpstr, sizeof(tmpstr), "":%d"", dj_report->device_index);
strlcat(dj_hiddev->phys, tmpstr, sizeof(dj_hiddev->phys));

dj_dev = kzalloc(sizeof(struct dj_device), GFP_KERNEL);

if (!dj_dev) {
dev_err(&djrcv_hdev->dev, ""%s: failed allocating dj_device\n"",
__func__);
goto dj_device_allocate_fail;
}

dj_dev->reports_supported = get_unaligned_le32(
dj_report->report_params + DEVICE_PAIRED_RF_REPORT_TYPE);
dj_dev->hdev = dj_hiddev;
dj_dev->dj_receiver_dev = djrcv_dev;
dj_dev->device_index = dj_report->device_index;
dj_hiddev->driver_data = dj_dev;

djrcv_dev->paired_dj_devices[dj_report->device_index] = dj_dev;

if (hid_add_device(dj_hiddev)) {
dev_err(&djrcv_hdev->dev, ""%s: failed adding dj_device\n"",
__func__);
goto hid_add_device_fail;
}

return;

hid_add_device_fail:
djrcv_dev->paired_dj_devices[dj_report->device_index] = NULL;
kfree(dj_dev);
dj_device_allocate_fail:
hid_destroy_device(dj_hiddev);
}
","[17, 18, 19, 20, 21, 22, 23, 24, 28, 29, 34, 35]","	if ((dj_report->device_index < DJ_DEVICE_INDEX_MIN) ||/~/	    (dj_report->device_index > DJ_DEVICE_INDEX_MAX)) {/~/		dev_err(&djrcv_hdev->dev, ""%s: invalid device index:%d\n"",/~/			__func__, dj_report->device_index);/~/		return;/~/	}"
318,"gplotAddPlot(GPLOT       *gplot,
NUMA        *nax,
NUMA        *nay,
l_int32      plotstyle,
const char  *plottitle)
{
char       buf[L_BUF_SIZE];
char       emptystring[] = """";
char      *datastr, *title;
l_int32    n, i;
l_float32  valx, valy, startx, delx;
SARRAY    *sa;

PROCNAME(""gplotAddPlot"");

if (!gplot)
return ERROR_INT(""gplot not defined"", procName, 1);
if (!nay)
return ERROR_INT(""nay not defined"", procName, 1);
if (plotstyle < 0 || plotstyle >= NUM_GPLOT_STYLES)
return ERROR_INT(""invalid plotstyle"", procName, 1);

if ((n = numaGetCount(nay)) == 0)
return ERROR_INT(""no points to plot"", procName, 1);
if (nax && (n != numaGetCount(nax)))
return ERROR_INT(""nax and nay sizes differ"", procName, 1);
if (n == 1 && plotstyle == GPLOT_LINES) {
L_INFO(""only 1 pt; changing style to points\n"", procName);
plotstyle = GPLOT_POINTS;
}

/* Save plotstyle and plottitle */
numaGetParameters(nay, &startx, &delx);
numaAddNumber(gplot->plotstyles, plotstyle);
if (plottitle) {
title = stringNew(plottitle);
sarrayAddString(gplot->plottitles, title, L_INSERT);
} else {
sarrayAddString(gplot->plottitles, emptystring, L_COPY);
}

/* Generate and save data filename */
gplot->nplots++;
    snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);
sarrayAddString(gplot->datanames, buf, L_COPY);

/* Generate data and save as a string */
sa = sarrayCreate(n);
for (i = 0; i < n; i++) {
if (nax)
numaGetFValue(nax, i, &valx);
else
valx = startx + i * delx;
numaGetFValue(nay, i, &valy);
        snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy);
sarrayAddString(sa, buf, L_COPY);
}
datastr = sarrayToString(sa, 0);
sarrayAddString(gplot->plotdata, datastr, L_INSERT);
sarrayDestroy(&sa);

return 0;
}
",[6],"char       buf[L_BUF_SIZE];/~/    snprintf(buf, L_BUF_SIZE, ""%s.data.%d"", gplot->rootname, gplot->nplots);/~/        snprintf(buf, L_BUF_SIZE, ""%f %f\n"", valx, valy);"
319,"static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
cJSON *current_element = NULL;

if ((object == NULL) || (name == NULL))
{
return NULL;
}

current_element = object->child;
if (case_sensitive)
{
        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))
{
current_element = current_element->next;
}
}
else
{
while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
{
current_element = current_element->next;
}
}

return current_element;
}
",[10],"        while ((current_element != NULL) && (strcmp(name, current_element->string) != 0))"
320,"long long mkvparser::ReadUInt(IMkvReader* pReader, long long pos, long& len) {
  assert(pReader);
  assert(pos >= 0);
  int status;
  //#ifdef _DEBUG
  //    long long total, available;
  //    status = pReader->Length(&total, &available);
  //    assert(status >= 0);
  //    assert((total < 0) || (available <= total));
  //    assert(pos < available);
  //    assert((available - pos) >= 1);  //assume here max u-int len is 8
  //#endif

len = 1;
unsigned char b;
  status = pReader->Read(pos, 1, &b);

if (status < 0)  // error or underflow
return status;

if (status > 0) // interpreted as ""underflow""
return E_BUFFER_NOT_FULL;

if (b == 0) // we can't handle u-int values larger than 8 bytes
return E_FILE_FORMAT_INVALID;

unsigned char m = 0x80;

while (!(b & m)) {
m >>= 1;

++len;
}

  //#ifdef _DEBUG
  //    assert((available - pos) >= len);
  //#endif
long long result = b & (~m);
++pos;

for (int i = 1; i < len; ++i) {
status = pReader->Read(pos, 1, &b);

if (status < 0) {
len = 1;
return status;
}

if (status > 0) {
len = 1;
return E_BUFFER_NOT_FULL;
}

result <<= 8;
result |= b;

++pos;
}


return result;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 14, 26, 27, 28, 32]","  assert(pReader);/~/  assert(pos >= 0);/~/  int status;/~/  //#ifdef _DEBUG/~/  //    long long total, available;/~/  //    status = pReader->Length(&total, &available);/~/  //    assert(status >= 0);/~/  //    assert((total < 0) || (available <= total));/~/  //    assert(pos < available);/~/  //    assert((available - pos) >= 1);  //assume here max u-int len is 8/~/  //#endif/~/  status = pReader->Read(pos, 1, &b);/~/  //#ifdef _DEBUG/~/  //    assert((available - pos) >= len);/~/  //#endif"
321,"long ContentEncoding::ParseCompressionEntry(
    long long start,
    long long size,
    IMkvReader* pReader,
    ContentCompression* compression) {
assert(pReader);
assert(compression);

long long pos = start;
const long long stop = start + size;

bool valid = false;


while (pos < stop) {
long long id, size;
    const long status = ParseElementHeader(pReader,
                                           pos,
                                           stop,
                                           id,
                                           size);
    if (status < 0)  //error
return status;

if (id == 0x254) {
// ContentCompAlgo
long long algo = UnserializeUInt(pReader, pos, size);
if (algo < 0)
return E_FILE_FORMAT_INVALID;
compression->algo = algo;
valid = true;
} else if (id == 0x255) {
// ContentCompSettings
if (size <= 0)
return E_FILE_FORMAT_INVALID;

const size_t buflen = static_cast<size_t>(size);
typedef unsigned char* buf_t;
const buf_t buf = new (std::nothrow) unsigned char[buflen];

if (buf == NULL)
return -1;

      const int read_status = pReader->Read(pos, buflen, buf);
if (read_status) {
        delete [] buf;
return status;
}

compression->settings = buf;

compression->settings_len = buflen;
}

    pos += size;  //consume payload
assert(pos <= stop);
}

// ContentCompAlgo is mandatory
if (!valid)
return E_FILE_FORMAT_INVALID;


return 0;
}
","[1, 2, 3, 4, 12, 13, 14, 15, 16, 17]","    long long start,/~/    long long size,/~/    IMkvReader* pReader,/~/    ContentCompression* compression) {/~/    const long status = ParseElementHeader(pReader,/~/                                           pos,/~/                                           stop,/~/                                           id,/~/                                           size);/~/    if (status < 0)  //error/~/      const int read_status = pReader->Read(pos, buflen, buf);/~/        delete [] buf;/~/    pos += size;  //consume payload"
322,"pvscsi_ring_init_data(PVSCSIRingInfo *m, PVSCSICmdDescSetupRings *ri)
{
int i;
uint32_t txr_len_log2, rxr_len_log2;
uint32_t req_ring_size, cmp_ring_size;
m->rs_pa = ri->ringsStatePPN << VMW_PAGE_SHIFT;

    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)
        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {
        return -1;
    }
req_ring_size = ri->reqRingNumPages * PVSCSI_MAX_NUM_REQ_ENTRIES_PER_PAGE;
cmp_ring_size = ri->cmpRingNumPages * PVSCSI_MAX_NUM_CMP_ENTRIES_PER_PAGE;
txr_len_log2 = pvscsi_log2(req_ring_size - 1);
}
","[6, 7, 8, 9, 13]",    if ((ri->reqRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)/~/        || (ri->cmpRingNumPages > PVSCSI_SETUP_RINGS_MAX_NUM_PAGES)) {/~/        return -1;/~/    }
323,"parse_netscreen_hex_dump(FILE_T fh, int pkt_len, const char *cap_int,
    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,
    int *err, gchar **err_info)
{
	guint8	*pd;
	gchar	line[NETSCREEN_LINE_LENGTH];
	gchar	*p;
	int	n, i = 0, offset = 0;
	gchar	dststr[13];
/* Make sure we have enough room for the packet */
	ws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);
pd = ws_buffer_start_ptr(buf);

while(1) {

/* The last packet is not delimited by an empty line, but by EOF
* So accept EOF as a valid delimiter too
*/
if (file_gets(line, NETSCREEN_LINE_LENGTH, fh) == NULL) {
break;
}

/*
* Skip blanks.
* The number of blanks is not fixed - for wireless
* interfaces, there may be 14 extra spaces before
* the hex data.
*/
for (p = &line[0]; g_ascii_isspace(*p); p++)
;
/* packets are delimited with empty lines */
if (*p == '\0') {
break;
}

n = parse_single_hex_dump_line(p, pd, offset);

/* the smallest packet has a length of 6 bytes, if
* the first hex-data is less then check whether
* it is a info-line and act accordingly
*/
if (offset == 0 && n < 6) {
if (info_line(line)) {
if (++i <= NETSCREEN_MAX_INFOLINES) {
continue;
}
} else {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""netscreen: cannot parse hex-data"");
return FALSE;
}
}

/* If there is no more data and the line was not empty,
* then there must be an error in the file
*/
		if(n == -1) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""netscreen: cannot parse hex-data"");
return FALSE;
}

/* Adjust the offset to the data that was just added to the buffer */
offset += n;

/* If there was more hex-data than was announced in the len=x
* header, then then there must be an error in the file
*/
		if(offset > pkt_len) {
*err = WTAP_ERR_BAD_FILE;
*err_info = g_strdup(""netscreen: too much hex-data"");
return FALSE;
}
}

/*
* Determine the encapsulation type, based on the
* first 4 characters of the interface name
*
* XXX	convert this to a 'case' structure when adding more
*	(non-ethernet) interfacetypes
*/
if (strncmp(cap_int, ""adsl"", 4) == 0) {
/* The ADSL interface can be bridged with or without
* PPP encapsulation. Check whether the first six bytes
* of the hex data are the same as the destination mac
* address in the header. If they are, assume ethernet
* LinkLayer or else PPP
*/
g_snprintf(dststr, 13, ""%02x%02x%02x%02x%02x%02x"",
pd[0], pd[1], pd[2], pd[3], pd[4], pd[5]);
if (strncmp(dststr, cap_dst, 12) == 0)
phdr->pkt_encap = WTAP_ENCAP_ETHERNET;
else
phdr->pkt_encap = WTAP_ENCAP_PPP;
}
else if (strncmp(cap_int, ""seri"", 4) == 0)
phdr->pkt_encap = WTAP_ENCAP_PPP;
else
phdr->pkt_encap = WTAP_ENCAP_ETHERNET;

phdr->caplen = offset;

return TRUE;
}
","[1, 2, 3, 15]","    const char *cap_dst, struct wtap_pkthdr *phdr, Buffer* buf,/~/    int *err, gchar **err_info)/~/{/~/	guint8	*pd;/~/	gchar	line[NETSCREEN_LINE_LENGTH];/~/	gchar	*p;/~/	int	n, i = 0, offset = 0;/~/	gchar	dststr[13];/~/	ws_buffer_assure_space(buf, NETSCREEN_MAX_PACKET_LEN);/~/		if(n == -1) {/~/		if(offset > pkt_len) {"
324,"l2tp_avp_print(netdissect_options *ndo, const u_char *dat, int length)
{
u_int len;
const uint16_t *ptr = (const uint16_t *)dat;
uint16_t attr_type;
int hidden = FALSE;

if (length <= 0) {
return;
}

ND_PRINT((ndo, "" ""));

ND_TCHECK(*ptr);	/* Flags & Length */
len = EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_LEN_MASK;

/* If it is not long enough to contain the header, we'll give up. */
if (len < 6)
goto trunc;

/* If it goes past the end of the remaining length of the packet,
we'll give up. */
if (len > (u_int)length)
goto trunc;

/* If it goes past the end of the remaining length of the captured
data, we'll give up. */
ND_TCHECK2(*ptr, len);
	/* After this point, no need to worry about truncation *

if (EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_FLAG_MANDATORY) {
ND_PRINT((ndo, ""*""));
}
if (EXTRACT_16BITS(ptr) & L2TP_AVP_HDR_FLAG_HIDDEN) {
hidden = TRUE;
ND_PRINT((ndo, ""?""));
}
ptr++;

if (EXTRACT_16BITS(ptr)) {
/* Vendor Specific Attribute */
ND_PRINT((ndo, ""VENDOR%04x:"", EXTRACT_16BITS(ptr))); ptr++;
ND_PRINT((ndo, ""ATTR%04x"", EXTRACT_16BITS(ptr))); ptr++;
ND_PRINT((ndo, ""(""));
print_octets(ndo, (const u_char *)ptr, len-6);
ND_PRINT((ndo, "")""));
} else {
/* IETF-defined Attributes */
ptr++;
attr_type = EXTRACT_16BITS(ptr); ptr++;
ND_PRINT((ndo, ""%s"", tok2str(l2tp_avp2str, ""AVP-#%u"", attr_type)));
ND_PRINT((ndo, ""(""));
if (hidden) {
ND_PRINT((ndo, ""???""));
} else {
switch (attr_type) {
case L2TP_AVP_MSGTYPE:
				l2tp_msgtype_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_RESULT_CODE:
l2tp_result_code_print(ndo, (const u_char *)ptr, len-6);
break;
case L2TP_AVP_PROTO_VER:
				l2tp_proto_ver_print(ndo, ptr);
break;
case L2TP_AVP_FRAMING_CAP:
				l2tp_framing_cap_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_BEARER_CAP:
				l2tp_bearer_cap_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_TIE_BREAKER:
print_octets(ndo, (const u_char *)ptr, 8);
break;
case L2TP_AVP_FIRM_VER:
case L2TP_AVP_ASSND_TUN_ID:
case L2TP_AVP_RECV_WIN_SIZE:
case L2TP_AVP_ASSND_SESS_ID:
print_16bits_val(ndo, ptr);
break;
case L2TP_AVP_HOST_NAME:
case L2TP_AVP_VENDOR_NAME:
case L2TP_AVP_CALLING_NUMBER:
case L2TP_AVP_CALLED_NUMBER:
case L2TP_AVP_SUB_ADDRESS:
case L2TP_AVP_PROXY_AUTH_NAME:
case L2TP_AVP_PRIVATE_GRP_ID:
print_string(ndo, (const u_char *)ptr, len-6);
break;
case L2TP_AVP_CHALLENGE:
case L2TP_AVP_INI_RECV_LCP:
case L2TP_AVP_LAST_SENT_LCP:
case L2TP_AVP_LAST_RECV_LCP:
case L2TP_AVP_PROXY_AUTH_CHAL:
case L2TP_AVP_PROXY_AUTH_RESP:
case L2TP_AVP_RANDOM_VECTOR:
print_octets(ndo, (const u_char *)ptr, len-6);
break;
case L2TP_AVP_Q931_CC:
l2tp_q931_cc_print(ndo, (const u_char *)ptr, len-6);
break;
case L2TP_AVP_CHALLENGE_RESP:
print_octets(ndo, (const u_char *)ptr, 16);
break;
case L2TP_AVP_CALL_SER_NUM:
case L2TP_AVP_MINIMUM_BPS:
case L2TP_AVP_MAXIMUM_BPS:
case L2TP_AVP_TX_CONN_SPEED:
case L2TP_AVP_PHY_CHANNEL_ID:
case L2TP_AVP_RX_CONN_SPEED:
print_32bits_val(ndo, (const uint32_t *)ptr);
break;
case L2TP_AVP_BEARER_TYPE:
				l2tp_bearer_type_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_FRAMING_TYPE:
				l2tp_framing_type_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_PACKET_PROC_DELAY:
l2tp_packet_proc_delay_print(ndo);
break;
case L2TP_AVP_PROXY_AUTH_TYPE:
				l2tp_proxy_auth_type_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_PROXY_AUTH_ID:
				l2tp_proxy_auth_id_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_CALL_ERRORS:
				l2tp_call_errors_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_ACCM:
				l2tp_accm_print(ndo, (const u_char *)ptr);
break;
case L2TP_AVP_SEQ_REQUIRED:
break;	/* No Attribute Value */
case L2TP_AVP_PPP_DISCON_CC:
l2tp_ppp_discon_cc_print(ndo, (const u_char *)ptr, len-6);
break;
default:
break;
}
}
ND_PRINT((ndo, "")""));
}

l2tp_avp_print(ndo, dat+len, length-len);
return;

trunc:
ND_PRINT((ndo, ""|...""));
}
",[23],"	/* After this point, no need to worry about truncation */~/				l2tp_msgtype_print(ndo, (const u_char *)ptr);/~/				l2tp_proto_ver_print(ndo, ptr);/~/				l2tp_framing_cap_print(ndo, (const u_char *)ptr);/~/				l2tp_bearer_cap_print(ndo, (const u_char *)ptr);/~/				l2tp_bearer_type_print(ndo, (const u_char *)ptr);/~/				l2tp_framing_type_print(ndo, (const u_char *)ptr);/~/				l2tp_proxy_auth_type_print(ndo, (const u_char *)ptr);/~/				l2tp_proxy_auth_id_print(ndo, (const u_char *)ptr);/~/				l2tp_call_errors_print(ndo, (const u_char *)ptr);/~/				l2tp_accm_print(ndo, (const u_char *)ptr);"
325,"bool GDataDirectory::FromProto(const GDataDirectoryProto& proto) {
DCHECK(proto.gdata_entry().file_info().is_directory());
DCHECK(!proto.gdata_entry().has_file_specific_info());

for (int i = 0; i < proto.child_files_size(); ++i) {
    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));
if (!file->FromProto(proto.child_files(i))) {
RemoveChildren();
return false;
}
AddEntry(file.release());
}
for (int i = 0; i < proto.child_directories_size(); ++i) {
    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,
                                                      directory_service_));
if (!dir->FromProto(proto.child_directories(i))) {
RemoveChildren();
return false;
}
AddEntry(dir.release());
}

// The states of the directory should be updated after children are
// handled successfully, so that incomplete states are not left.
if (!GDataEntry::FromProto(proto.gdata_entry()))
return false;

return true;
}
","[4, 12, 13]","    scoped_ptr<GDataFile> file(new GDataFile(NULL, directory_service_));/~/    scoped_ptr<GDataDirectory> dir(new GDataDirectory(NULL,/~/                                                      directory_service_));"
326,"do_prefetch_tables (const void *gcmM, size_t gcmM_size)
{
prefetch_table(gcmM, gcmM_size);
  prefetch_table(gcmR, sizeof(gcmR));
}
",[3],"  prefetch_table(gcmR, sizeof(gcmR));"
327,"WebsiteSettings* website_settings() {
if (!website_settings_.get()) {
website_settings_.reset(new WebsiteSettings(
mock_ui(), profile(), tab_specific_content_settings(),
          infobar_service(), url(), ssl(), cert_store()));
}
return website_settings_.get();
}
",[4],"          infobar_service(), url(), ssl(), cert_store()));"
328,"get_caller_uid (GDBusMethodInvocation *context, gint *uid)
{
        PolkitSubject *subject;
        PolkitSubject *process;

        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));
        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);
        if (!process) {
                g_object_unref (subject);
return FALSE;
}

        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));
        g_object_unref (subject);
        g_object_unref (process);

return TRUE;
}
","[2, 3, 4, 5, 6, 7, 10, 11, 12]","        PolkitSubject *subject;/~/        PolkitSubject *process;/~/        subject = polkit_system_bus_name_new (g_dbus_method_invocation_get_sender (context));/~/        process = polkit_system_bus_name_get_process_sync (POLKIT_SYSTEM_BUS_NAME (subject), NULL, NULL);/~/        if (!process) {/~/                g_object_unref (subject);/~/        *uid = polkit_unix_process_get_uid (POLKIT_UNIX_PROCESS (process));/~/        g_object_unref (subject);/~/        g_object_unref (process);"
329,"const Chapters::Display* Chapters::Atom::GetDisplay(int index) const
{
    if (index < 0)
        return NULL;
    if (index >= m_displays_count)
        return NULL;
    return m_displays + index;
}
","[1, 2, 3, 4, 5, 6, 7]",{/~/    if (index < 0)/~/        return NULL;/~/    if (index >= m_displays_count)/~/        return NULL;/~/    return m_displays + index;/~/}
330,"SYSCALL_DEFINE6(move_pages, pid_t, pid, unsigned long, nr_pages,
const void __user * __user *, pages,
const int __user *, nodes,
int __user *, status, int, flags)
{
	const struct cred *cred = current_cred(), *tcred;
struct task_struct *task;
struct mm_struct *mm;
int err;
nodemask_t task_nodes;

/* Check flags */
if (flags & ~(MPOL_MF_MOVE|MPOL_MF_MOVE_ALL))
return -EINVAL;

if ((flags & MPOL_MF_MOVE_ALL) && !capable(CAP_SYS_NICE))
return -EPERM;

/* Find the mm_struct */
rcu_read_lock();
task = pid ? find_task_by_vpid(pid) : current;
if (!task) {
rcu_read_unlock();
return -ESRCH;
}
get_task_struct(task);

/*
* Check if this process has the right to modify the specified
	 * process. The right exists if the process has administrative
	 * capabilities, superuser privileges or the same
	 * userid as the target process.
*/
	tcred = __task_cred(task);
	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&
	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&
	    !capable(CAP_SYS_NICE)) {
rcu_read_unlock();
err = -EPERM;
goto out;
}
rcu_read_unlock();

err = security_task_movememory(task);
if (err)
goto out;

task_nodes = cpuset_mems_allowed(task);
mm = get_task_mm(task);
put_task_struct(task);

if (!mm)
return -EINVAL;

if (nodes)
err = do_pages_move(mm, task_nodes, nr_pages, pages,
nodes, status, flags);
else
err = do_pages_stat(mm, nr_pages, pages, status);

mmput(mm);
return err;

out:
put_task_struct(task);
return err;
}
","[5, 25, 26, 27, 29, 30, 31, 32]","	const struct cred *cred = current_cred(), *tcred;/~/	 * process. The right exists if the process has administrative/~/	 * capabilities, superuser privileges or the same/~/	 * userid as the target process./~/	tcred = __task_cred(task);/~/	if (!uid_eq(cred->euid, tcred->suid) && !uid_eq(cred->euid, tcred->uid) &&/~/	    !uid_eq(cred->uid,  tcred->suid) && !uid_eq(cred->uid,  tcred->uid) &&/~/	    !capable(CAP_SYS_NICE)) {"
331,"ikev2_auth_print(netdissect_options *ndo, u_char tpay,
const struct isakmp_gen *ext,
u_int item_len _U_, const u_char *ep,
uint32_t phase _U_, uint32_t doi _U_,
uint32_t proto _U_, int depth _U_)
{
struct ikev2_auth a;
const char *v2_auth[]={ ""invalid"", ""rsasig"",
""shared-secret"", ""dsssig"" };
const u_char *authdata = (const u_char*)ext + sizeof(a);
unsigned int len;

	ND_TCHECK(*ext);
UNALIGNED_MEMCPY(&a, ext, sizeof(a));
ikev2_pay_print(ndo, NPSTR(tpay), a.h.critical);
len = ntohs(a.h.len);

/*
* Our caller has ensured that the length is >= 4.
*/
ND_PRINT((ndo,"" len=%u method=%s"", len-4,
STR_OR_ID(a.auth_method, v2_auth)));
if (len > 4) {
if (ndo->ndo_vflag > 1) {
ND_PRINT((ndo, "" authdata=(""));
if (!rawprint(ndo, (const uint8_t *)authdata, len - sizeof(a)))
goto trunc;
ND_PRINT((ndo, "") ""));
} else if (ndo->ndo_vflag) {
if (!ike_show_somedata(ndo, authdata, ep))
goto trunc;
}
}

return (const u_char *)ext + len;
trunc:
ND_PRINT((ndo,"" [|%s]"", NPSTR(tpay)));
return NULL;
}
",[11],	ND_TCHECK(*ext);
332,"static int skt_write(int fd, const void *p, size_t len)
{
int sent;
struct pollfd pfd;

FNLOG();

pfd.fd = fd;
pfd.events = POLLOUT;


/* poll for 500 ms */

/* send time out */
    if (poll(&pfd, 1, 500) == 0)
return 0;

ts_log(""skt_write"", len, NULL);

    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)
{
ERROR(""write failed with errno=%d\n"", errno);
return -1;
}

return sent;
}
","[9, 12]","    if (poll(&pfd, 1, 500) == 0)/~/    if ((sent = send(fd, p, len, MSG_NOSIGNAL)) == -1)"
333,"png_inflate(png_structp png_ptr, const png_byte *data, png_size_t size,
png_bytep output, png_size_t output_size)
{
png_size_t count = 0;

png_ptr->zstream.next_in = (png_bytep)data; /* const_cast: VALID */
png_ptr->zstream.avail_in = size;

while (1)
{
int ret, avail;

/* Reset the output buffer each time round - we empty it
* after every inflate call.
*/
png_ptr->zstream.next_out = png_ptr->zbuf;
png_ptr->zstream.avail_out = png_ptr->zbuf_size;

ret = inflate(&png_ptr->zstream, Z_NO_FLUSH);
avail = png_ptr->zbuf_size - png_ptr->zstream.avail_out;

/* First copy/count any new output - but only if we didn't
* get an error code.
*/
if ((ret == Z_OK || ret == Z_STREAM_END) && avail > 0)
{
if (output != 0 && output_size > count)
{
            int copy = output_size - count;
            if (avail < copy) copy = avail;
png_memcpy(output + count, png_ptr->zbuf, copy);
}
count += avail;
}

if (ret == Z_OK)
continue;

/* Termination conditions - always reset the zstream, it
* must be left in inflateInit state.
*/
png_ptr->zstream.avail_in = 0;
inflateReset(&png_ptr->zstream);

if (ret == Z_STREAM_END)
return count; /* NOTE: may be zero. */

/* Now handle the error codes - the API always returns 0
* and the error message is dumped into the uncompressed
* buffer if available.
*/
{
PNG_CONST char *msg;
if (png_ptr->zstream.msg != 0)
msg = png_ptr->zstream.msg;
else
{
#if defined(PNG_STDIO_SUPPORTED) && !defined(_WIN32_WCE)
char umsg[52];

switch (ret)
{
case Z_BUF_ERROR:
msg = ""Buffer error in compressed datastream in %s chunk"";
break;
case Z_DATA_ERROR:
msg = ""Data error in compressed datastream in %s chunk"";
break;
default:
msg = ""Incomplete compressed datastream in %s chunk"";
break;
}

png_snprintf(umsg, sizeof umsg, msg, png_ptr->chunk_name);
msg = umsg;
#else
msg = ""Damaged compressed datastream in chunk other than IDAT"";
#endif
}

png_warning(png_ptr, msg);
}

/* 0 means an error - notice that this code simple ignores
* zero length compressed chunks as a result.
*/
return 0;
}
}
","[23, 24]",            int copy = output_size - count;/~/            if (avail < copy) copy = avail;
334,"mm_sshpam_init_ctx(Authctxt *authctxt)
{
Buffer m;
int success;

debug3(""%s"", __func__);
buffer_init(&m);
	buffer_put_cstring(&m, authctxt->user);
mm_request_send(pmonitor->m_recvfd, MONITOR_REQ_PAM_INIT_CTX, &m);
debug3(""%s: waiting for MONITOR_ANS_PAM_INIT_CTX"", __func__);
mm_request_receive_expect(pmonitor->m_recvfd, MONITOR_ANS_PAM_INIT_CTX, &m);
success = buffer_get_int(&m);
if (success == 0) {
debug3(""%s: pam_init_ctx failed"", __func__);
buffer_free(&m);
return (NULL);
}
buffer_free(&m);
return (authctxt);
}
",[6],"	buffer_put_cstring(&m, authctxt->user);"
335,"bool WebGLRenderingContextBase::ValidateHTMLImageElement(
const SecurityOrigin* security_origin,
const char* function_name,
HTMLImageElement* image,
ExceptionState& exception_state) {
if (!image || !image->CachedImage()) {
SynthesizeGLError(GL_INVALID_VALUE, function_name, ""no image"");
return false;
}
const KURL& url = image->CachedImage()->GetResponse().Url();
if (url.IsNull() || url.IsEmpty() || !url.IsValid()) {
SynthesizeGLError(GL_INVALID_VALUE, function_name, ""invalid image"");
return false;
}

if (WouldTaintOrigin(image, security_origin)) {
    exception_state.ThrowSecurityError(""The cross-origin image at "" +
                                       url.ElidedString() +
                                       "" may not be loaded."");
return false;
}
return true;
}
","[15, 16, 17]","    exception_state.ThrowSecurityError(""The cross-origin image at "" +/~/                                       url.ElidedString() +/~/                                       "" may not be loaded."");"
336,"print_bacp_config_options(netdissect_options *ndo,
const u_char *p, int length)
{
int len, opt;

if (length < 2)
return 0;
ND_TCHECK2(*p, 2);
len = p[1];
opt = p[0];
if (length < len)
return 0;
if (len < 2) {
ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u (length bogus, should be >= 2)"",
tok2str(bacconfopts_values, ""Unknown"", opt),
opt,
len));
return 0;
}

ND_PRINT((ndo, ""\n\t  %s Option (0x%02x), length %u"",
tok2str(bacconfopts_values, ""Unknown"", opt),
opt,
len));

switch (opt) {
case BACPOPT_FPEER:
if (len != 6) {
ND_PRINT((ndo, "" (length bogus, should be = 6)""));
return len;
}
		ND_TCHECK2(*(p + 2), 4);
ND_PRINT((ndo, "": Magic-Num 0x%08x"", EXTRACT_32BITS(p + 2)));
break;
default:
/*
* Unknown option; dump it as raw bytes now if we're
* not going to do so below.
*/
if (ndo->ndo_vflag < 2)
print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2);
break;
}
if (ndo->ndo_vflag > 1)
print_unknown_data(ndo, &p[2], ""\n\t    "", len - 2); /* exclude TLV header */

return len;

trunc:
ND_PRINT((ndo, ""[|bacp]""));
return 0;
}
",[28],"		ND_TCHECK2(*(p + 2), 4);"
337,"void ResourcePrefetchPredictor::LearnOrigins(
const std::string& host,
const GURL& main_frame_origin,
    const std::map<GURL, OriginRequestSummary>& summaries) {
DCHECK_CURRENTLY_ON(BrowserThread::UI);
if (host.size() > ResourcePrefetchPredictorTables::kMaxStringLength)
return;

OriginData data;
bool exists = origin_data_->TryGetData(host, &data);
if (!exists) {
data.set_host(host);
data.set_last_visit_time(base::Time::Now().ToInternalValue());
size_t origins_size = summaries.size();
auto ordered_origins =
std::vector<const OriginRequestSummary*>(origins_size);
for (const auto& kv : summaries) {
size_t index = kv.second.first_occurrence;
DCHECK_LT(index, origins_size);
ordered_origins[index] = &kv.second;
}

for (const OriginRequestSummary* summary : ordered_origins) {
auto* origin_to_add = data.add_origins();
InitializeOriginStatFromOriginRequestSummary(origin_to_add, *summary);
}
} else {
data.set_last_visit_time(base::Time::Now().ToInternalValue());

    std::map<GURL, int> old_index;
int old_size = static_cast<int>(data.origins_size());
for (int i = 0; i < old_size; ++i) {
bool is_new =
          old_index.insert({GURL(data.origins(i).origin()), i}).second;
DCHECK(is_new);
}

// Update the old origins.
for (int i = 0; i < old_size; ++i) {
auto* old_origin = data.mutable_origins(i);
      GURL origin(old_origin->origin());
auto it = summaries.find(origin);
if (it == summaries.end()) {
// miss
old_origin->set_number_of_misses(old_origin->number_of_misses() + 1);
old_origin->set_consecutive_misses(old_origin->consecutive_misses() +
1);
} else {
// hit: update.
const auto& new_origin = it->second;
old_origin->set_always_access_network(new_origin.always_access_network);
old_origin->set_accessed_network(new_origin.accessed_network);

int position = new_origin.first_occurrence + 1;
int total =
old_origin->number_of_hits() + old_origin->number_of_misses();
old_origin->set_average_position(
((old_origin->average_position() * total) + position) /
(total + 1));
old_origin->set_number_of_hits(old_origin->number_of_hits() + 1);
old_origin->set_consecutive_misses(0);
}
}

// Add new origins.
for (const auto& kv : summaries) {
if (old_index.find(kv.first) != old_index.end())
continue;

auto* origin_to_add = data.add_origins();
InitializeOriginStatFromOriginRequestSummary(origin_to_add, kv.second);
}
}

// Trim and Sort.
ResourcePrefetchPredictorTables::TrimOrigins(&data,
config_.max_consecutive_misses);
ResourcePrefetchPredictorTables::SortOrigins(&data, main_frame_origin.spec());
if (data.origins_size() > static_cast<int>(config_.max_origins_per_entry)) {
data.mutable_origins()->DeleteSubrange(
config_.max_origins_per_entry,
data.origins_size() - config_.max_origins_per_entry);
}

// Update the database.
if (data.origins_size() == 0)
origin_data_->DeleteData({host});
else
origin_data_->UpdateData(host, data);
}
","[3, 26, 30, 36]","    const std::map<GURL, OriginRequestSummary>& summaries) {/~/    std::map<GURL, int> old_index;/~/          old_index.insert({GURL(data.origins(i).origin()), i}).second;/~/      GURL origin(old_origin->origin());"
338,"PassRefPtr<DocumentFragment> Range::createContextualFragment(const String& markup, ExceptionCode& ec)
{
if (!m_start.container()) {
ec = INVALID_STATE_ERR;
return 0;
}

Node* element = m_start.container()->isElementNode() ? m_start.container() : m_start.container()->parentNode();
if (!element || !element->isHTMLElement()) {
ec = NOT_SUPPORTED_ERR;
return 0;
}

    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);

if (!fragment) {
ec = NOT_SUPPORTED_ERR;
return 0;
}

return fragment.release();
}
",[11],"    RefPtr<DocumentFragment> fragment = createDocumentFragmentForElement(markup, toElement(element), AllowScriptingContentAndDoNotMarkAlreadyStarted);"
339,"void Editor::ChangeSelectionAfterCommand(
const SelectionInDOMTree& new_selection,
const SetSelectionData& options) {
if (new_selection.IsNone())
return;

// See <rdar://problem/5729315> Some shouldChangeSelectedDOMRange contain
// Ranges for selections that are no longer valid
bool selection_did_not_change_dom_position =
new_selection == GetFrame().Selection().GetSelectionInDOMTree();
GetFrame().Selection().SetSelection(
      SelectionInDOMTree::Builder(new_selection)
          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())
          .Build(),
      options);

// Some editing operations change the selection visually without affecting its
// position within the DOM. For example when you press return in the following
// (the caret is marked by ^):
// <div contentEditable=""true""><div>^Hello</div></div>
// WebCore inserts <div><br></div> *before* the current block, which correctly
// moves the paragraph down but which doesn't change the caret's DOM position
// ([""hello"", 0]). In these situations the above FrameSelection::setSelection
// call does not call EditorClient::respondToChangedSelection(), which, on the
// Mac, sends selection change notifications and starts a new kill ring
// sequence, but we want to do these things (matches AppKit).
if (selection_did_not_change_dom_position) {
Client().RespondToChangedSelection(
frame_, GetFrame().Selection().GetSelectionInDOMTree().Type());
}
}
","[10, 11, 12, 13]","      SelectionInDOMTree::Builder(new_selection)/~/          .SetIsHandleVisible(GetFrame().Selection().IsHandleVisible())/~/          .Build(),/~/      options);"
340,"void PaintLayerScrollableArea::UpdateCompositingLayersAfterScroll() {
PaintLayerCompositor* compositor = GetLayoutBox()->View()->Compositor();
if (!compositor->InCompositingMode())
return;

if (UsesCompositedScrolling()) {
DCHECK(Layer()->HasCompositedLayerMapping());
ScrollingCoordinator* scrolling_coordinator = GetScrollingCoordinator();
bool handled_scroll =
        Layer()->IsRootLayer() && scrolling_coordinator &&
scrolling_coordinator->UpdateCompositedScrollOffset(this);

if (!handled_scroll) {
if (!RuntimeEnabledFeatures::BlinkGenPropertyTreesEnabled()) {
// In non-BGPT mode, we need to do a full sub-tree update here, because
// we need to update the position property to compute
// offset_to_transform_parent. For more context, see the comment from
// chrishtr@ here:
// https://chromium-review.googlesource.com/c/chromium/src/+/1403639/6/third_party/blink/renderer/core/paint/paint_layer_scrollable_area.cc
Layer()->GetCompositedLayerMapping()->SetNeedsGraphicsLayerUpdate(
kGraphicsLayerUpdateSubtree);
}
compositor->SetNeedsCompositingUpdate(
kCompositingUpdateAfterGeometryChange);
}

// If we have fixed elements and we scroll the root layer we might
// change compositing since the fixed elements might now overlap a
// composited layer.
if (Layer()->IsRootLayer()) {
LocalFrame* frame = GetLayoutBox()->GetFrame();
if (frame && frame->View() &&
frame->View()->HasViewportConstrainedObjects()) {
Layer()->SetNeedsCompositingInputsUpdate();
}
}
} else {
Layer()->SetNeedsCompositingInputsUpdate();
}
}
",[8],        Layer()->IsRootLayer() && scrolling_coordinator &&
341,"set_string_2_svc(sstring_arg *arg, struct svc_req *rqstp)
{
static generic_ret              ret;
char                            *prime_arg;
    gss_buffer_desc                 client_name,
        service_name;
OM_uint32                       minor_stat;
kadm5_server_handle_t           handle;
const char                      *errmsg = NULL;

xdr_free(xdr_generic_ret, &ret);

if ((ret.code = new_server_handle(arg->api_version, rqstp, &handle)))
goto exit_func;

if ((ret.code = check_handle((void *)handle)))
goto exit_func;

ret.api_version = handle->api_version;

if (setup_gss_names(rqstp, &client_name, &service_name) < 0) {
ret.code = KADM5_FAILURE;
goto exit_func;
}
if (krb5_unparse_name(handle->context, arg->princ, &prime_arg)) {
ret.code = KADM5_BAD_PRINCIPAL;
goto exit_func;
}

if (CHANGEPW_SERVICE(rqstp)
|| !kadm5int_acl_check(handle->context, rqst2name(rqstp), ACL_MODIFY,
arg->princ, NULL)) {
ret.code = KADM5_AUTH_MODIFY;
log_unauth(""kadm5_mod_strings"", prime_arg,
&client_name, &service_name, rqstp);
} else {
ret.code = kadm5_set_string((void *)handle, arg->princ, arg->key,
arg->value);
if (ret.code != 0)
errmsg = krb5_get_error_message(handle->context, ret.code);

log_done(""kadm5_mod_strings"", prime_arg, errmsg,
&client_name, &service_name, rqstp);

if (errmsg != NULL)
krb5_free_error_message(handle->context, errmsg);
}
free(prime_arg);
gss_release_buffer(&minor_stat, &client_name);
gss_release_buffer(&minor_stat, &service_name);
exit_func:
free_server_handle(handle);
return &ret;
}
","[4, 5]","    gss_buffer_desc                 client_name,/~/        service_name;/~/exit_func:"
342,"void close_all_sockets(atransport* t) {
asocket* s;


/* this is a little gross, but since s->close() *will* modify
** the list out from under you, your options are limited.
*/
    adb_mutex_lock(&socket_list_lock);
restart:
for (s = local_socket_list.next; s != &local_socket_list; s = s->next) {
if (s->transport == t || (s->peer && s->peer->transport == t)) {
            local_socket_close_locked(s);
goto restart;
}
}
    adb_mutex_unlock(&socket_list_lock);
}
","[5, 9, 13]",    adb_mutex_lock(&socket_list_lock);/~/            local_socket_close_locked(s);/~/    adb_mutex_unlock(&socket_list_lock);
343,"static void skel(const char *homedir, uid_t u, gid_t g) {
char *fname;

// zsh
if (!arg_shell_none && (strcmp(cfg.shell,""/usr/bin/zsh"") == 0 || strcmp(cfg.shell,""/bin/zsh"") == 0)) {
// copy skel files
if (asprintf(&fname, ""%s/.zshrc"", homedir) == -1)
errExit(""asprintf"");
struct stat s;
// don't copy it if we already have the file
if (stat(fname, &s) == 0)
return;
if (stat(""/etc/skel/.zshrc"", &s) == 0) {
			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);
fs_logger(""clone /etc/skel/.zshrc"");
}
else {
touch_file_as_user(fname, u, g, 0644);
fs_logger2(""touch"", fname);
}
free(fname);
}
// csh
else if (!arg_shell_none && strcmp(cfg.shell,""/bin/csh"") == 0) {
// copy skel files
if (asprintf(&fname, ""%s/.cshrc"", homedir) == -1)
errExit(""asprintf"");
struct stat s;
// don't copy it if we already have the file
if (stat(fname, &s) == 0)
return;
if (stat(""/etc/skel/.cshrc"", &s) == 0) {
			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);
fs_logger(""clone /etc/skel/.cshrc"");
}
else {
touch_file_as_user(fname, u, g, 0644);
fs_logger2(""touch"", fname);
}
free(fname);
}
// bash etc.
else {
// copy skel files
if (asprintf(&fname, ""%s/.bashrc"", homedir) == -1)
errExit(""asprintf"");
struct stat s;
// don't copy it if we already have the file
if (stat(fname, &s) == 0)
return;
if (stat(""/etc/skel/.bashrc"", &s) == 0) {
			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);
fs_logger(""clone /etc/skel/.bashrc"");
}
free(fname);
}
}
","[12, 31]","			copy_file(""/etc/skel/.zshrc"", fname, u, g, 0644);/~/			copy_file(""/etc/skel/.cshrc"", fname, u, g, 0644);/~/			copy_file(""/etc/skel/.bashrc"", fname, u, g, 0644);"
344,"static void iwjpeg_scan_exif(struct iwjpegrcontext *rctx,
const iw_byte *d, size_t d_len)
{
struct iw_exif_state e;
iw_uint32 ifd;

if(d_len<8) return;

iw_zeromem(&e,sizeof(struct iw_exif_state));
e.d = d;
e.d_len = d_len;

e.endian = d[0]=='I' ? IW_ENDIAN_LITTLE : IW_ENDIAN_BIG;

	ifd = iw_get_ui32_e(&d[4],e.endian);

iwjpeg_scan_exif_ifd(rctx,&e,ifd);
}
",[10],"	ifd = iw_get_ui32_e(&d[4],e.endian);"
345,"static void __net_exit sctp_net_exit(struct net *net)
{
/* Free the local address list */
sctp_free_addr_wq(net);
sctp_free_local_addr_list(net);

	/* Free the control endpoint.  *
	inet_ctl_sock_destroy(net->sctp.ctl_sock);
sctp_dbg_objcnt_exit(net);

sctp_proc_exit(net);
cleanup_sctp_mibs(net);
sctp_sysctl_net_unregister(net);
}
","[5, 6]",	/* Free the control endpoint.  */~/	inet_ctl_sock_destroy(net->sctp.ctl_sock);
346,"vhost_scsi_make_tpg(struct se_wwn *wwn,
struct config_group *group,
const char *name)
{
struct vhost_scsi_tport *tport = container_of(wwn,
struct vhost_scsi_tport, tport_wwn);

struct vhost_scsi_tpg *tpg;
	unsigned long tpgt;
int ret;

if (strstr(name, ""tpgt_"") != name)
return ERR_PTR(-EINVAL);
	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)
return ERR_PTR(-EINVAL);

tpg = kzalloc(sizeof(struct vhost_scsi_tpg), GFP_KERNEL);
if (!tpg) {
pr_err(""Unable to allocate struct vhost_scsi_tpg"");
return ERR_PTR(-ENOMEM);
}
mutex_init(&tpg->tv_tpg_mutex);
INIT_LIST_HEAD(&tpg->tv_tpg_list);
tpg->tport = tport;
tpg->tport_tpgt = tpgt;

ret = core_tpg_register(&vhost_scsi_fabric_configfs->tf_ops, wwn,
&tpg->se_tpg, tpg, TRANSPORT_TPG_TYPE_NORMAL);
if (ret < 0) {
kfree(tpg);
return NULL;
}
mutex_lock(&vhost_scsi_mutex);
list_add_tail(&tpg->tv_tpg_list, &vhost_scsi_list);
mutex_unlock(&vhost_scsi_mutex);

return &tpg->se_tpg;
}
","[7, 11]","	unsigned long tpgt;/~/	if (kstrtoul(name + 5, 10, &tpgt) || tpgt > UINT_MAX)"
347,"bool MessageLoop::DoDelayedWork(TimeTicks* next_delayed_work_time) {
  if (!nestable_tasks_allowed_ ||
!SweepDelayedWorkQueueAndReturnTrueIfStillHasWork()) {
recent_time_ = *next_delayed_work_time = TimeTicks();
return false;
}

// When we ""fall behind"", there will be a lot of tasks in the delayed work
// queue that are ready to run.  To increase efficiency when we fall behind,
// we will only call Time::Now() intermittently, and then process all tasks
// that are ready to run before calling it again.  As a result, the more we
// fall behind (and have a lot of ready-to-run delayed tasks), the more
// efficient we'll be at handling the tasks.

TimeTicks next_run_time = delayed_work_queue_.top().delayed_run_time;
if (next_run_time > recent_time_) {
recent_time_ = TimeTicks::Now();  // Get a better view of Now();
if (next_run_time > recent_time_) {
*next_delayed_work_time = next_run_time;
return false;
}
}

PendingTask pending_task =
std::move(const_cast<PendingTask&>(delayed_work_queue_.top()));
delayed_work_queue_.pop();

if (SweepDelayedWorkQueueAndReturnTrueIfStillHasWork())
*next_delayed_work_time = delayed_work_queue_.top().delayed_run_time;

return DeferOrRunPendingTask(std::move(pending_task));
}
",[1],  if (!nestable_tasks_allowed_ ||
348,"static bool check_underflow(const struct ip6t_entry *e)
{
const struct xt_entry_target *t;
unsigned int verdict;

	if (!unconditional(&e->ipv6))
return false;
t = ip6t_get_target_c(e);
if (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)
return false;
verdict = ((struct xt_standard_target *)t)->verdict;
verdict = -verdict - 1;
return verdict == NF_DROP || verdict == NF_ACCEPT;
}
",[4],	if (!unconditional(&e->ipv6))
349,"static ssize_t WritePSDChannels(const PSDInfo *psd_info,
const ImageInfo *image_info,Image *image,Image *next_image,
MagickOffsetType size_offset,const MagickBooleanType separate)
{
Image
*mask;

MagickOffsetType
rows_offset;

size_t
channels,
count,
length,
offset_length;

unsigned char
*compact_pixels;

count=0;
offset_length=0;
rows_offset=0;
compact_pixels=(unsigned char *) NULL;
if (next_image->compression == RLECompression)
{
      compact_pixels=AcquireCompactPixels(image);
if (compact_pixels == (unsigned char *) NULL)
return(0);
}
channels=1;
if (separate == MagickFalse)
{
if (next_image->storage_class != PseudoClass)
{
if (IsGrayImage(next_image,&next_image->exception) == MagickFalse)
channels=next_image->colorspace == CMYKColorspace ? 4 : 3;
if (next_image->matte != MagickFalse)
channels++;
}
rows_offset=TellBlob(image)+2;
count+=WriteCompressionStart(psd_info,image,next_image,channels);
offset_length=(next_image->rows*(psd_info->version == 1 ? 2 : 4));
}
size_offset+=2;
if (next_image->storage_class == PseudoClass)
{
length=WritePSDChannel(psd_info,image_info,image,next_image,
IndexQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;
}
else
{
if (IsGrayImage(next_image,&next_image->exception) != MagickFalse)
{
length=WritePSDChannel(psd_info,image_info,image,next_image,
GrayQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;
}
else
{
if (next_image->colorspace == CMYKColorspace)
(void) NegateImage(next_image,MagickFalse);

length=WritePSDChannel(psd_info,image_info,image,next_image,
RedQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;

length=WritePSDChannel(psd_info,image_info,image,next_image,
GreenQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;

length=WritePSDChannel(psd_info,image_info,image,next_image,
BlueQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;

if (next_image->colorspace == CMYKColorspace)
{
length=WritePSDChannel(psd_info,image_info,image,next_image,
BlackQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;
}
}
if (next_image->matte != MagickFalse)
{
length=WritePSDChannel(psd_info,image_info,image,next_image,
AlphaQuantum,compact_pixels,rows_offset,separate);
if (separate != MagickFalse)
size_offset+=WritePSDSize(psd_info,image,length,size_offset)+2;
else
rows_offset+=offset_length;
count+=length;
}
}
compact_pixels=(unsigned char *) RelinquishMagickMemory(compact_pixels);
if (next_image->colorspace == CMYKColorspace)
(void) NegateImage(next_image,MagickFalse);
if (separate != MagickFalse)
{
const char
*property;

property=GetImageArtifact(next_image,""psd:opacity-mask"");
if (property != (const char *) NULL)
{
mask=(Image *) GetImageRegistry(ImageRegistryType,property,
&image->exception);
if (mask != (Image *) NULL)
{
if (mask->compression == RLECompression)
{
compact_pixels=AcquireCompactPixels(mask);
if (compact_pixels == (unsigned char *) NULL)
return(0);
}
length=WritePSDChannel(psd_info,image_info,image,mask,
RedQuantum,compact_pixels,rows_offset,MagickTrue);
(void) WritePSDSize(psd_info,image,length,size_offset);
count+=length;
compact_pixels=(unsigned char *) RelinquishMagickMemory(
compact_pixels);
}
}
}
return(count);
}
",[21],      compact_pixels=AcquireCompactPixels(image);
350,"void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd)
{
QXLDevSurfaceCreate surface;

memset(&surface, 0, sizeof(surface));

    dprint(1, ""%s/%d: %dx%d\n"", __func__, ssd->qxl.id,
           surface_width(ssd->ds), surface_height(ssd->ds));

surface.format     = SPICE_SURFACE_FMT_32_xRGB;
surface.width      = surface_width(ssd->ds);
{
dprint(1, ""%s/%d:\n"", __func__, ssd->qxl.id);

qemu_spice_destroy_primary_surface(ssd, 0, QXL_SYNC);
}

void qemu_spice_display_init_common(SimpleSpiceDisplay *ssd)
{
qemu_mutex_init(&ssd->lock);
QTAILQ_INIT(&ssd->updates);
ssd->mouse_x = -1;
ssd->mouse_y = -1;
if (ssd->num_surfaces == 0) {
ssd->num_surfaces = 1024;
}
ssd->bufsize = (16 * 1024 * 1024);
ssd->buf = g_malloc(ssd->bufsize);
}

/* display listener callbacks */

void qemu_spice_display_update(SimpleSpiceDisplay *ssd,
int x, int y, int w, int h)
{
if (ssd->num_surfaces == 0) {
ssd->num_surfaces = 1024;
}
    ssd->bufsize = (16 * 1024 * 1024);
    ssd->buf = g_malloc(ssd->bufsize);
}

/* display listener callbacks */
update_area.top = y;
update_area.bottom = y + h;

if (qemu_spice_rect_is_empty(&ssd->dirty)) {
ssd->notify++;
}
qemu_spice_rect_union(&ssd->dirty, &update_area);
}
","[4, 5, 21, 22, 31, 32]","    dprint(1, ""%s/%d: %dx%d\n"", __func__, ssd->qxl.id,/~/           surface_width(ssd->ds), surface_height(ssd->ds));/~/    ssd->bufsize = (16 * 1024 * 1024);/~/    ssd->buf = g_malloc(ssd->bufsize);"
351,"long Cluster::HasBlockEntries(
const Segment* pSegment,
    long long off,  //relative to start of segment payload
    long long& pos,
    long& len)
{
    assert(pSegment);
    assert(off >= 0);  //relative to segment

    IMkvReader* const pReader = pSegment->m_pReader;

    long long total, avail;

    long status = pReader->Length(&total, &avail);

    if (status < 0)  //error
        return status;

    assert((total < 0) || (avail <= total));

    pos = pSegment->m_start + off;  //absolute

    if ((total >= 0) && (pos >= total))
        return 0;  //we don't even have a complete cluster

    const long long segment_stop =
        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;

    long long cluster_stop = -1;  //interpreted later to mean ""unknown size""

    {
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        long long result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //need more data
            return E_BUFFER_NOT_FULL;
        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        if ((total >= 0) && ((pos + len) > total))
            return 0;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long id = ReadUInt(pReader, pos, len);
        if (id < 0)  //error
            return static_cast<long>(id);
        if (id != 0x0F43B675)  //weird: not cluster ID
            return -1;         //generic error
        pos += len;  //consume Cluster ID field
        //read size field
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //weird
            return E_BUFFER_NOT_FULL;
        if ((segment_stop >= 0) && ((pos + len) > segment_stop))
            return E_FILE_FORMAT_INVALID;
        if ((total >= 0) && ((pos + len) > total))
            return 0;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(pReader, pos, len);
        if (size < 0)  //error
            return static_cast<long>(size);
        if (size == 0)
            return 0;  //cluster does not have entries
        pos += len;  //consume size field
        //pos now points to start of payload
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (size != unknown_size)
        {
            cluster_stop = pos + size;
            assert(cluster_stop >= 0);
            if ((segment_stop >= 0) && (cluster_stop > segment_stop))
                return E_FILE_FORMAT_INVALID;
            if ((total >= 0) && (cluster_stop > total))
                //return E_FILE_FORMAT_INVALID;  //too conservative
                return 0;  //cluster does not have any entries
        }
}

    for (;;)
    {
        if ((cluster_stop >= 0) && (pos >= cluster_stop))
            return 0;  //no entries detected

        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }

        long long result = GetUIntLength(pReader, pos, len);

        if (result < 0)  //error
            return static_cast<long>(result);

        if (result > 0)  //need more data
            return E_BUFFER_NOT_FULL;

        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
            return E_FILE_FORMAT_INVALID;

        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;

        const long long id = ReadUInt(pReader, pos, len);

        if (id < 0)  //error
            return static_cast<long>(id);

        //This is the distinguished set of ID's we use to determine
        //that we have exhausted the sub-element's inside the cluster
        //whose ID we parsed earlier.

        if (id == 0x0F43B675)  //Cluster ID
            return 0;  //no entries found

        if (id == 0x0C53BB6B)  //Cues ID
            return 0;  //no entries found
        pos += len;  //consume id field
        if ((cluster_stop >= 0) && (pos >= cluster_stop))
            return E_FILE_FORMAT_INVALID;
        //read size field
        if ((pos + 1) > avail)
        {
            len = 1;
            return E_BUFFER_NOT_FULL;
        }
        result = GetUIntLength(pReader, pos, len);
        if (result < 0)  //error
            return static_cast<long>(result);
        if (result > 0)  //underflow
            return E_BUFFER_NOT_FULL;
        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > avail)
            return E_BUFFER_NOT_FULL;
        const long long size = ReadUInt(pReader, pos, len);
        if (size < 0)  //error
            return static_cast<long>(size);
        pos += len;  //consume size field
        //pos now points to start of payload
        if ((cluster_stop >= 0) && (pos > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if (size == 0)  //weird
            continue;
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (size == unknown_size)
            return E_FILE_FORMAT_INVALID;  //not supported inside cluster
        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))
            return E_FILE_FORMAT_INVALID;
        if (id == 0x20)  //BlockGroup ID
            return 1;    //have at least one entry
        if (id == 0x23)  //SimpleBlock ID
            return 1;    //have at least one entry
        pos += size;  //consume payload
        assert((cluster_stop < 0) || (pos <= cluster_stop));
}
}
","[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]","    long long off,  //relative to start of segment payload/~/    long long& pos,/~/    long& len)/~/{/~/    assert(pSegment);/~/    assert(off >= 0);  //relative to segment/~/    IMkvReader* const pReader = pSegment->m_pReader;/~/    long long total, avail;/~/    long status = pReader->Length(&total, &avail);/~/    if (status < 0)  //error/~/        return status;/~/    assert((total < 0) || (avail <= total));/~/    pos = pSegment->m_start + off;  //absolute/~/    if ((total >= 0) && (pos >= total))/~/        return 0;  //we don't even have a complete cluster/~/    const long long segment_stop =/~/        (pSegment->m_size < 0) ? -1 : pSegment->m_start + pSegment->m_size;/~/    long long cluster_stop = -1;  //interpreted later to mean ""unknown size""/~/    {/~/        if ((pos + 1) > avail)/~/        {/~/            len = 1;/~/            return E_BUFFER_NOT_FULL;/~/        }/~/        long long result = GetUIntLength(pReader, pos, len);/~/        if (result < 0)  //error/~/            return static_cast<long>(result);/~/        if (result > 0)  //need more data/~/            return E_BUFFER_NOT_FULL;/~/        if ((segment_stop >= 0) && ((pos + len) > segment_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((total >= 0) && ((pos + len) > total))/~/            return 0;/~/        if ((pos + len) > avail)/~/            return E_BUFFER_NOT_FULL;/~/        const long long id = ReadUInt(pReader, pos, len);/~/        if (id < 0)  //error/~/            return static_cast<long>(id);/~/        if (id != 0x0F43B675)  //weird: not cluster ID/~/            return -1;         //generic error/~/        pos += len;  //consume Cluster ID field/~/        //read size field/~/        if ((pos + 1) > avail)/~/        {/~/            len = 1;/~/            return E_BUFFER_NOT_FULL;/~/        }/~/        result = GetUIntLength(pReader, pos, len);/~/        if (result < 0)  //error/~/            return static_cast<long>(result);/~/        if (result > 0)  //weird/~/            return E_BUFFER_NOT_FULL;/~/        if ((segment_stop >= 0) && ((pos + len) > segment_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((total >= 0) && ((pos + len) > total))/~/            return 0;/~/        if ((pos + len) > avail)/~/            return E_BUFFER_NOT_FULL;/~/        const long long size = ReadUInt(pReader, pos, len);/~/        if (size < 0)  //error/~/            return static_cast<long>(size);/~/        if (size == 0)/~/            return 0;  //cluster does not have entries/~/        pos += len;  //consume size field/~/        //pos now points to start of payload/~/        const long long unknown_size = (1LL << (7 * len)) - 1;/~/        if (size != unknown_size)/~/        {/~/            cluster_stop = pos + size;/~/            assert(cluster_stop >= 0);/~/            if ((segment_stop >= 0) && (cluster_stop > segment_stop))/~/                return E_FILE_FORMAT_INVALID;/~/            if ((total >= 0) && (cluster_stop > total))/~/                //return E_FILE_FORMAT_INVALID;  //too conservative/~/                return 0;  //cluster does not have any entries/~/        }/~/    for (;;)/~/    {/~/        if ((cluster_stop >= 0) && (pos >= cluster_stop))/~/            return 0;  //no entries detected/~/        if ((pos + 1) > avail)/~/        {/~/            len = 1;/~/            return E_BUFFER_NOT_FULL;/~/        }/~/        long long result = GetUIntLength(pReader, pos, len);/~/        if (result < 0)  //error/~/            return static_cast<long>(result);/~/        if (result > 0)  //need more data/~/            return E_BUFFER_NOT_FULL;/~/        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((pos + len) > avail)/~/            return E_BUFFER_NOT_FULL;/~/        const long long id = ReadUInt(pReader, pos, len);/~/        if (id < 0)  //error/~/            return static_cast<long>(id);/~/        //This is the distinguished set of ID's we use to determine/~/        //that we have exhausted the sub-element's inside the cluster/~/        //whose ID we parsed earlier./~/        if (id == 0x0F43B675)  //Cluster ID/~/            return 0;  //no entries found/~/        if (id == 0x0C53BB6B)  //Cues ID/~/            return 0;  //no entries found/~/        pos += len;  //consume id field/~/        if ((cluster_stop >= 0) && (pos >= cluster_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        //read size field/~/        if ((pos + 1) > avail)/~/        {/~/            len = 1;/~/            return E_BUFFER_NOT_FULL;/~/        }/~/        result = GetUIntLength(pReader, pos, len);/~/        if (result < 0)  //error/~/            return static_cast<long>(result);/~/        if (result > 0)  //underflow/~/            return E_BUFFER_NOT_FULL;/~/        if ((cluster_stop >= 0) && ((pos + len) > cluster_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((pos + len) > avail)/~/            return E_BUFFER_NOT_FULL;/~/        const long long size = ReadUInt(pReader, pos, len);/~/        if (size < 0)  //error/~/            return static_cast<long>(size);/~/        pos += len;  //consume size field/~/        //pos now points to start of payload/~/        if ((cluster_stop >= 0) && (pos > cluster_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        if (size == 0)  //weird/~/            continue;/~/        const long long unknown_size = (1LL << (7 * len)) - 1;/~/        if (size == unknown_size)/~/            return E_FILE_FORMAT_INVALID;  //not supported inside cluster/~/        if ((cluster_stop >= 0) && ((pos + size) > cluster_stop))/~/            return E_FILE_FORMAT_INVALID;/~/        if (id == 0x20)  //BlockGroup ID/~/            return 1;    //have at least one entry/~/        if (id == 0x23)  //SimpleBlock ID/~/            return 1;    //have at least one entry/~/        pos += size;  //consume payload/~/        assert((cluster_stop < 0) || (pos <= cluster_stop));"
352,"void MediaElementAudioSourceHandler::Process(size_t number_of_frames) {
AudioBus* output_bus = Output(0).Bus();

// Use a tryLock() to avoid contention in the real-time audio thread.
// If we fail to acquire the lock then the HTMLMediaElement must be in the
// middle of reconfiguring its playback engine, so we output silence in this
// case.
MutexTryLocker try_locker(process_lock_);
if (try_locker.Locked()) {
if (!MediaElement() || !source_sample_rate_) {
output_bus->Zero();
return;
}

// TODO(crbug.com/811516): Although OnSetFormat() requested the output bus
// channels, the actual channel count might have not been changed yet.
// Output silence for such case until the channel count is resolved.
if (source_number_of_channels_ != output_bus->NumberOfChannels()) {
output_bus->Zero();
return;
}

AudioSourceProvider& provider = MediaElement()->GetAudioSourceProvider();
// Grab data from the provider so that the element continues to make
// progress, even if we're going to output silence anyway.
if (multi_channel_resampler_.get()) {
DCHECK_NE(source_sample_rate_, Context()->sampleRate());
multi_channel_resampler_->Process(&provider, output_bus,
number_of_frames);
} else {
// Bypass the resampler completely if the source is at the context's
// sample-rate.
DCHECK_EQ(source_sample_rate_, Context()->sampleRate());
provider.ProvideInput(output_bus, number_of_frames);
}
// Output silence if we don't have access to the element.
    if (!PassesCORSAccessCheck()) {
      if (maybe_print_cors_message_) {
        // Print a CORS message, but just once for each change in the current
        // media element source, and only if we have a document to print to.
        maybe_print_cors_message_ = false;
        PostCrossThreadTask(
            *task_runner_, FROM_HERE,
            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,
                            WrapRefCounted(this), current_src_string_));
      }
output_bus->Zero();
}
} else {
// We failed to acquire the lock.
output_bus->Zero();
}
}
","[11, 18, 31, 33, 34, 35, 36]","    if (!PassesCORSAccessCheck()) {/~/      if (maybe_print_cors_message_) {/~/        // Print a CORS message, but just once for each change in the current/~/        // media element source, and only if we have a document to print to./~/        maybe_print_cors_message_ = false;/~/        PostCrossThreadTask(/~/            *task_runner_, FROM_HERE,/~/            CrossThreadBind(&MediaElementAudioSourceHandler::PrintCORSMessage,/~/                            WrapRefCounted(this), current_src_string_));/~/      }"
353,"static int su3000_frontend_attach(struct dvb_usb_adapter *d)
{
	u8 obuf[3] = { 0xe, 0x80, 0 };
	u8 ibuf[] = { 0 };

	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
err(""command 0x0e transfer failed."");

	obuf[0] = 0xe;
	obuf[1] = 0x02;
	obuf[2] = 1;

	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
err(""command 0x0e transfer failed."");
msleep(300);

	obuf[0] = 0xe;
	obuf[1] = 0x83;
	obuf[2] = 0;

	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
err(""command 0x0e transfer failed."");

	obuf[0] = 0xe;
	obuf[1] = 0x83;
	obuf[2] = 1;

	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)
err(""command 0x0e transfer failed."");

	obuf[0] = 0x51;

	if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)
err(""command 0x51 transfer failed."");

	d->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,
					&d->dev->i2c_adap);
	if (d->fe_adap[0].fe == NULL)
return -EIO;

	if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,
&dw2104_ts2020_config,
				&d->dev->i2c_adap)) {
info(""Attached DS3000/TS2020!"");
return 0;
}

info(""Failed to attach DS3000/TS2020!"");
return -EIO;
}
","[2, 3, 4, 6, 7, 8, 9, 12, 13, 14, 15, 17, 18, 19, 20, 22, 23, 25, 26, 27, 29]","	u8 obuf[3] = { 0xe, 0x80, 0 };/~/	u8 ibuf[] = { 0 };/~/	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)/~/	obuf[0] = 0xe;/~/	obuf[1] = 0x02;/~/	obuf[2] = 1;/~/	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)/~/	obuf[0] = 0xe;/~/	obuf[1] = 0x83;/~/	obuf[2] = 0;/~/	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)/~/	obuf[0] = 0xe;/~/	obuf[1] = 0x83;/~/	obuf[2] = 1;/~/	if (dvb_usb_generic_rw(d->dev, obuf, 3, ibuf, 1, 0) < 0)/~/	obuf[0] = 0x51;/~/	if (dvb_usb_generic_rw(d->dev, obuf, 1, ibuf, 1, 0) < 0)/~/	d->fe_adap[0].fe = dvb_attach(ds3000_attach, &su3000_ds3000_config,/~/					&d->dev->i2c_adap);/~/	if (d->fe_adap[0].fe == NULL)/~/	if (dvb_attach(ts2020_attach, d->fe_adap[0].fe,/~/				&d->dev->i2c_adap)) {"
354,"spnego_gss_wrap_iov(OM_uint32 *minor_status,
gss_ctx_id_t context_handle,
int conf_req_flag,
gss_qop_t qop_req,
int *conf_state,
gss_iov_buffer_desc *iov,
int iov_count)
{
OM_uint32 ret;
ret = gss_wrap_iov(minor_status,
			   context_handle,
conf_req_flag,
qop_req,
conf_state,
iov,
iov_count);
return (ret);
}
",[10],"			   context_handle,"
355,"static void locationWithCallWithAttributeSetter(v8::Local<v8::Value> jsValue, const v8::PropertyCallbackInfo<void>& info)
{
TestObjectPython* proxyImp = V8TestObjectPython::toNative(info.Holder());
    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
if (!imp)
return;
V8TRYCATCH_FOR_V8STRINGRESOURCE_VOID(V8StringResource<>, cppValue, jsValue);
imp->setHrefCallWith(callingDOMWindow(info.GetIsolate()), enteredDOMWindow(info.GetIsolate()), cppValue);
}
",[3],    TestNode* imp = WTF::getPtr(proxyImp->locationWithCallWith());
356,"bool TabsCaptureVisibleTabFunction::RunImpl() {
PrefService* service = profile()->GetPrefs();
if (service->GetBoolean(prefs::kDisableScreenshots)) {
error_ = keys::kScreenshotsDisabled;
return false;
}

WebContents* web_contents = NULL;
if (!GetTabToCapture(&web_contents))
return false;

image_format_ = FORMAT_JPEG;  // Default format is JPEG.
image_quality_ = kDefaultQuality;  // Default quality setting.

if (HasOptionalArgument(1)) {
DictionaryValue* options = NULL;
EXTENSION_FUNCTION_VALIDATE(args_->GetDictionary(1, &options));

if (options->HasKey(keys::kFormatKey)) {
std::string format;
EXTENSION_FUNCTION_VALIDATE(
options->GetString(keys::kFormatKey, &format));

if (format == keys::kFormatValueJpeg) {
image_format_ = FORMAT_JPEG;
} else if (format == keys::kFormatValuePng) {
image_format_ = FORMAT_PNG;
} else {
// Schema validation should make this unreachable.
EXTENSION_FUNCTION_VALIDATE(0);
}
}

if (options->HasKey(keys::kQualityKey)) {
EXTENSION_FUNCTION_VALIDATE(
options->GetInteger(keys::kQualityKey, &image_quality_));
}
}

  // captureVisibleTab() can return an image containing sensitive information
  // that the browser would otherwise protect.  Ensure the extension has
  // permission to do this.
  if (!GetExtension()->CanCaptureVisiblePage(
        web_contents->GetURL(),
        SessionID::IdForTab(web_contents),
        &error_)) {
return false;
}

RenderViewHost* render_view_host = web_contents->GetRenderViewHost();
content::RenderWidgetHostView* view = render_view_host->GetView();
if (!view) {
error_ = keys::kInternalVisibleTabCaptureError;
return false;
}
render_view_host->CopyFromBackingStore(
gfx::Rect(),
view->GetViewBounds().size(),
base::Bind(&TabsCaptureVisibleTabFunction::CopyFromBackingStoreComplete,
this));
return true;
}
","[32, 33, 34, 35, 36, 37, 38]","  // captureVisibleTab() can return an image containing sensitive information/~/  // that the browser would otherwise protect.  Ensure the extension has/~/  // permission to do this./~/  if (!GetExtension()->CanCaptureVisiblePage(/~/        web_contents->GetURL(),/~/        SessionID::IdForTab(web_contents),/~/        &error_)) {"
357,"struct bpf_map *bpf_map_get_with_uref(u32 ufd)
{
struct fd f = fdget(ufd);
struct bpf_map *map;

map = __bpf_map_get(f);
if (IS_ERR(map))
return map;

	bpf_map_inc(map, true);
fdput(f);

return map;
}
",[7],"	bpf_map_inc(map, true);"
358,"bool Vp9Parser::ParseSuperframe() {
  const uint8_t* stream = stream_;
  off_t bytes_left = bytes_left_;
  DCHECK(frames_.empty());
  // Make sure we don't parse stream_ more than once.
  stream_ = nullptr;
  bytes_left_ = 0;
  if (bytes_left < 1)
    return false;
  // If this is a superframe, the last byte in the stream will contain the
  // superframe marker. If not, the whole buffer contains a single frame.
  uint8_t marker = *(stream + bytes_left - 1);
  if ((marker & 0xe0) != 0xc0) {
    frames_.push_back(FrameInfo(stream, bytes_left));
    return true;
  }
  DVLOG(1) << ""Parsing a superframe"";
  // The bytes immediately before the superframe marker constitute superframe
  // index, which stores information about sizes of each frame in it.
  // Calculate its size and set index_ptr to the beginning of it.
  size_t num_frames = (marker & 0x7) + 1;
  size_t mag = ((marker >> 3) & 0x3) + 1;
  off_t index_size = 2 + mag * num_frames;

  if (bytes_left < index_size)
return false;

  const uint8_t* index_ptr = stream + bytes_left - index_size;
  if (marker != *index_ptr)
    return false;
  ++index_ptr;
  bytes_left -= index_size;
  // Parse frame information contained in the index and add a pointer to and
  // size of each frame to frames_.
  for (size_t i = 0; i < num_frames; ++i) {
    uint32_t size = 0;
    for (size_t j = 0; j < mag; ++j) {
      size |= *index_ptr << (j * 8);
      ++index_ptr;
    }
    if (base::checked_cast<off_t>(size) > bytes_left) {
      DVLOG(1) << ""Not enough data in the buffer for frame "" << i;
      return false;
    }
    frames_.push_back(FrameInfo(stream, size));
    stream += size;
    bytes_left -= size;
    DVLOG(1) << ""Frame "" << i << "", size: "" << size;
  }

return true;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]","  const uint8_t* stream = stream_;/~/  off_t bytes_left = bytes_left_;/~/  DCHECK(frames_.empty());/~/  // Make sure we don't parse stream_ more than once./~/  stream_ = nullptr;/~/  bytes_left_ = 0;/~/  if (bytes_left < 1)/~/    return false;/~/  // If this is a superframe, the last byte in the stream will contain the/~/  // superframe marker. If not, the whole buffer contains a single frame./~/  uint8_t marker = *(stream + bytes_left - 1);/~/  if ((marker & 0xe0) != 0xc0) {/~/    frames_.push_back(FrameInfo(stream, bytes_left));/~/    return true;/~/  }/~/  DVLOG(1) << ""Parsing a superframe"";/~/  // The bytes immediately before the superframe marker constitute superframe/~/  // index, which stores information about sizes of each frame in it./~/  // Calculate its size and set index_ptr to the beginning of it./~/  size_t num_frames = (marker & 0x7) + 1;/~/  size_t mag = ((marker >> 3) & 0x3) + 1;/~/  off_t index_size = 2 + mag * num_frames;/~/  if (bytes_left < index_size)/~/  const uint8_t* index_ptr = stream + bytes_left - index_size;/~/  if (marker != *index_ptr)/~/    return false;/~/  ++index_ptr;/~/  bytes_left -= index_size;/~/  // Parse frame information contained in the index and add a pointer to and/~/  // size of each frame to frames_./~/  for (size_t i = 0; i < num_frames; ++i) {/~/    uint32_t size = 0;/~/    for (size_t j = 0; j < mag; ++j) {/~/      size |= *index_ptr << (j * 8);/~/      ++index_ptr;/~/    }/~/    if (base::checked_cast<off_t>(size) > bytes_left) {/~/      DVLOG(1) << ""Not enough data in the buffer for frame "" << i;/~/      return false;/~/    }/~/    frames_.push_back(FrameInfo(stream, size));/~/    stream += size;/~/    bytes_left -= size;/~/    DVLOG(1) << ""Frame "" << i << "", size: "" << size;/~/  }"
359,"void AppShortcutManager::OnceOffCreateShortcuts() {
  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);
  // Creation of shortcuts on Mac currently can be disabled with
  // --disable-app-shims, so check the flag, and set the pref accordingly.
#if defined(OS_MACOSX)
  bool is_now_enabled = apps::IsAppShimsEnabled();
#else
  bool is_now_enabled = true;
#endif  // defined(OS_MACOSX)
  if (was_enabled != is_now_enabled)
    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);
  if (was_enabled || !is_now_enabled)
return;

// Check if extension system/service are available. They might not be in
// tests.
extensions::ExtensionSystem* extension_system;
ExtensionServiceInterface* extension_service;
if (!(extension_system = extensions::ExtensionSystem::Get(profile_)) ||
!(extension_service = extension_system->extension_service()))
return;

// Create an applications menu shortcut for each app in this profile.
const extensions::ExtensionSet* apps = extension_service->extensions();
for (extensions::ExtensionSet::const_iterator it = apps->begin();
it != apps->end(); ++it) {
if (ShouldCreateShortcutFor(profile_, it->get()))
CreateShortcutsInApplicationsMenu(profile_, it->get());
}
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]","  bool was_enabled = prefs_->GetBoolean(prefs::kAppShortcutsHaveBeenCreated);/~/  // Creation of shortcuts on Mac currently can be disabled with/~/  // --disable-app-shims, so check the flag, and set the pref accordingly./~/#if defined(OS_MACOSX)/~/  bool is_now_enabled = apps::IsAppShimsEnabled();/~/#else/~/  bool is_now_enabled = true;/~/#endif  // defined(OS_MACOSX)/~/  if (was_enabled != is_now_enabled)/~/    prefs_->SetBoolean(prefs::kAppShortcutsHaveBeenCreated, is_now_enabled);/~/  if (was_enabled || !is_now_enabled)"
360,"Node::InsertionNotificationRequest HTMLBodyElement::insertedInto(ContainerNode* insertionPoint)
{
HTMLElement::insertedInto(insertionPoint);
    if (insertionPoint->inDocument()) {
        // FIXME: It's surprising this is web compatible since it means a marginwidth
        // and marginheight attribute can magically appear on the <body> of all documents
        // embedded through <iframe> or <frame>.
        Element* ownerElement = document().ownerElement();
        if (isHTMLFrameElementBase(ownerElement)) {
            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);
            int marginWidth = ownerFrameElement.marginWidth();
            if (marginWidth != -1)
                setIntegralAttribute(marginwidthAttr, marginWidth);
            int marginHeight = ownerFrameElement.marginHeight();
            if (marginHeight != -1)
                setIntegralAttribute(marginheightAttr, marginHeight);
        }
    }
    return InsertionDone;
}
","[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19]","    if (insertionPoint->inDocument()) {/~/        // FIXME: It's surprising this is web compatible since it means a marginwidth/~/        // and marginheight attribute can magically appear on the <body> of all documents/~/        // embedded through <iframe> or <frame>./~/        Element* ownerElement = document().ownerElement();/~/        if (isHTMLFrameElementBase(ownerElement)) {/~/            HTMLFrameElementBase& ownerFrameElement = toHTMLFrameElementBase(*ownerElement);/~/            int marginWidth = ownerFrameElement.marginWidth();/~/            if (marginWidth != -1)/~/                setIntegralAttribute(marginwidthAttr, marginWidth);/~/            int marginHeight = ownerFrameElement.marginHeight();/~/            if (marginHeight != -1)/~/                setIntegralAttribute(marginheightAttr, marginHeight);/~/        }/~/    }/~/    return InsertionDone;"
361,"cJSON *cJSON_CreateObject( void )
{
	cJSON *item = cJSON_New_Item();
	if ( item )
		item->type = cJSON_Object;
	return item;
}
","[1, 2, 3, 4, 5, 6]",{/~/	cJSON *item = cJSON_New_Item();/~/	if ( item )/~/		item->type = cJSON_Object;/~/	return item;/~/}
362,"void VideoCaptureImpl::OnBufferCreated(int32_t buffer_id,
mojo::ScopedSharedBufferHandle handle) {
DVLOG(1) << __func__ << "" buffer_id: "" << buffer_id;
DCHECK(io_thread_checker_.CalledOnValidThread());
DCHECK(handle.is_valid());

base::SharedMemoryHandle memory_handle;
size_t memory_size = 0;
  bool read_only_flag = false;

const MojoResult result = mojo::UnwrapSharedMemoryHandle(
      std::move(handle), &memory_handle, &memory_size, &read_only_flag);
DCHECK_EQ(MOJO_RESULT_OK, result);
DCHECK_GT(memory_size, 0u);

std::unique_ptr<base::SharedMemory> shm(
new base::SharedMemory(memory_handle, true /* read_only */));
if (!shm->Map(memory_size)) {
DLOG(ERROR) << ""OnBufferCreated: Map failed."";
return;
}
const bool inserted =
client_buffers_
.insert(std::make_pair(buffer_id,
new ClientBuffer(std::move(shm), memory_size)))
.second;
DCHECK(inserted);
}
","[7, 9]","  bool read_only_flag = false;/~/      std::move(handle), &memory_handle, &memory_size, &read_only_flag);"
363,"void __ip_select_ident(struct iphdr *iph, int segs)
{
static u32 ip_idents_hashrnd __read_mostly;
u32 hash, id;

net_get_random_once(&ip_idents_hashrnd, sizeof(ip_idents_hashrnd));

hash = jhash_3words((__force u32)iph->daddr,
(__force u32)iph->saddr,
			    iph->protocol,
ip_idents_hashrnd);
id = ip_idents_reserve(hash, segs);
iph->id = htons(id);
}
",[7],"			    iph->protocol,"
364,"static void spl_filesystem_object_free_storage(void *object TSRMLS_DC) /* {{{ */
{
spl_filesystem_object *intern = (spl_filesystem_object*)object;

if (intern->oth_handler && intern->oth_handler->dtor) {
intern->oth_handler->dtor(intern TSRMLS_CC);
}
	
zend_object_std_dtor(&intern->std TSRMLS_CC);
	
if (intern->_path) {
efree(intern->_path);
}
if (intern->file_name) {
efree(intern->file_name);
}
switch(intern->type) {
case SPL_FS_INFO:
break;
case SPL_FS_DIR:
if (intern->u.dir.dirp) {
php_stream_close(intern->u.dir.dirp);
intern->u.dir.dirp = NULL;
}
if (intern->u.dir.sub_path) {
efree(intern->u.dir.sub_path);
		}		
break;
case SPL_FS_FILE:
if (intern->u.file.stream) {
if (intern->u.file.zcontext) {
/*				zend_list_delref(Z_RESVAL_P(intern->zcontext));*/
}
if (!intern->u.file.stream->is_persistent) {
php_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE);
} else {
php_stream_free(intern->u.file.stream, PHP_STREAM_FREE_CLOSE_PERSISTENT);
}
if (intern->u.file.open_mode) {
efree(intern->u.file.open_mode);
}
if (intern->orig_path) {
efree(intern->orig_path);
}
}
spl_filesystem_file_free_line(intern TSRMLS_CC);
break;
}

{
zend_object_iterator *iterator;
iterator = (zend_object_iterator*)
spl_filesystem_object_to_iterator(intern);
if (iterator->data != NULL) {
iterator->data = NULL;
iterator->funcs->dtor(iterator TSRMLS_CC);
}
}
efree(object);
} /* }}} */
","[5, 9, 12, 20, 23, 30, 35, 38, 41, 42, 45]",	/~/	/~/		}		
365,"static void array_cleanup( char* arr[] , int arr_size)
{
int i=0;
	for( i=0; i< arr_size; i++ ){ 
if( arr[i*2] ){
efree( arr[i*2]);
}
}
efree(arr);
}
",[3],	for( i=0; i< arr_size; i++ ){ 
366,"static int decode_nal_unit(HEVCContext *s, const H2645NAL *nal)
{
HEVCLocalContext *lc = s->HEVClc;
GetBitContext *gb    = &lc->gb;
int ctb_addr_ts, ret;

*gb              = nal->gb;
s->nal_unit_type = nal->type;
s->temporal_id   = nal->temporal_id;

switch (s->nal_unit_type) {
case HEVC_NAL_VPS:
if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
ret = s->avctx->hwaccel->decode_params(s->avctx,
nal->type,
nal->raw_data,
nal->raw_size);
if (ret < 0)
goto fail;
}
ret = ff_hevc_decode_nal_vps(gb, s->avctx, &s->ps);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_SPS:
if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
ret = s->avctx->hwaccel->decode_params(s->avctx,
nal->type,
nal->raw_data,
nal->raw_size);
if (ret < 0)
goto fail;
}
ret = ff_hevc_decode_nal_sps(gb, s->avctx, &s->ps,
s->apply_defdispwin);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_PPS:
if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
ret = s->avctx->hwaccel->decode_params(s->avctx,
nal->type,
nal->raw_data,
nal->raw_size);
if (ret < 0)
goto fail;
}
ret = ff_hevc_decode_nal_pps(gb, s->avctx, &s->ps);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_SEI_PREFIX:
case HEVC_NAL_SEI_SUFFIX:
if (s->avctx->hwaccel && s->avctx->hwaccel->decode_params) {
ret = s->avctx->hwaccel->decode_params(s->avctx,
nal->type,
nal->raw_data,
nal->raw_size);
if (ret < 0)
goto fail;
}
ret = ff_hevc_decode_nal_sei(gb, s->avctx, &s->sei, &s->ps, s->nal_unit_type);
if (ret < 0)
goto fail;
break;
case HEVC_NAL_TRAIL_R:
case HEVC_NAL_TRAIL_N:
case HEVC_NAL_TSA_N:
case HEVC_NAL_TSA_R:
case HEVC_NAL_STSA_N:
case HEVC_NAL_STSA_R:
case HEVC_NAL_BLA_W_LP:
case HEVC_NAL_BLA_W_RADL:
case HEVC_NAL_BLA_N_LP:
case HEVC_NAL_IDR_W_RADL:
case HEVC_NAL_IDR_N_LP:
case HEVC_NAL_CRA_NUT:
case HEVC_NAL_RADL_N:
case HEVC_NAL_RADL_R:
case HEVC_NAL_RASL_N:
case HEVC_NAL_RASL_R:
ret = hls_slice_header(s);
if (ret < 0)
return ret;

if (
(s->avctx->skip_frame >= AVDISCARD_BIDIR && s->sh.slice_type == HEVC_SLICE_B) ||
(s->avctx->skip_frame >= AVDISCARD_NONINTRA && s->sh.slice_type != HEVC_SLICE_I) ||
(s->avctx->skip_frame >= AVDISCARD_NONKEY && !IS_IRAP(s))) {
break;
}

if (s->sh.first_slice_in_pic_flag) {
            if (s->ref) {
                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");
                goto fail;
            }
if (s->max_ra == INT_MAX) {
if (s->nal_unit_type == HEVC_NAL_CRA_NUT || IS_BLA(s)) {
s->max_ra = s->poc;
} else {
if (IS_IDR(s))
s->max_ra = INT_MIN;
}
}

if ((s->nal_unit_type == HEVC_NAL_RASL_R || s->nal_unit_type == HEVC_NAL_RASL_N) &&
s->poc <= s->max_ra) {
s->is_decoded = 0;
break;
} else {
if (s->nal_unit_type == HEVC_NAL_RASL_R && s->poc > s->max_ra)
s->max_ra = INT_MIN;
}

s->overlap ++;
ret = hevc_frame_start(s);
if (ret < 0)
return ret;
} else if (!s->ref) {
av_log(s->avctx, AV_LOG_ERROR, ""First slice in a frame missing.\n"");
goto fail;
}

if (s->nal_unit_type != s->first_nal_type) {
av_log(s->avctx, AV_LOG_ERROR,
""Non-matching NAL types of the VCL NALUs: %d %d\n"",
s->first_nal_type, s->nal_unit_type);
return AVERROR_INVALIDDATA;
}

if (!s->sh.dependent_slice_segment_flag &&
s->sh.slice_type != HEVC_SLICE_I) {
ret = ff_hevc_slice_rpl(s);
if (ret < 0) {
av_log(s->avctx, AV_LOG_WARNING,
""Error constructing the reference lists for the current slice.\n"");
goto fail;
}
}

if (s->sh.first_slice_in_pic_flag && s->avctx->hwaccel) {
ret = s->avctx->hwaccel->start_frame(s->avctx, NULL, 0);
if (ret < 0)
goto fail;
}

if (s->avctx->hwaccel) {
ret = s->avctx->hwaccel->decode_slice(s->avctx, nal->raw_data, nal->raw_size);
if (ret < 0)
goto fail;
} else {
if (s->threads_number > 1 && s->sh.num_entry_point_offsets > 0)
ctb_addr_ts = hls_slice_data_wpp(s, nal);
else
ctb_addr_ts = hls_slice_data(s);
if (ctb_addr_ts >= (s->ps.sps->ctb_width * s->ps.sps->ctb_height)) {
s->is_decoded = 1;
}

if (ctb_addr_ts < 0) {
ret = ctb_addr_ts;
goto fail;
}
}
break;
case HEVC_NAL_EOS_NUT:
case HEVC_NAL_EOB_NUT:
s->seq_decode = (s->seq_decode + 1) & 0xff;
s->max_ra     = INT_MAX;
break;
case HEVC_NAL_AUD:
case HEVC_NAL_FD_NUT:
break;
default:
av_log(s->avctx, AV_LOG_INFO,
""Skipping NAL unit %d\n"", s->nal_unit_type);
}

return 0;
fail:
if (s->avctx->err_recognition & AV_EF_EXPLODE)
return ret;
return 0;
}
","[16, 17, 20, 29, 30, 34]","            if (s->ref) {/~/                av_log(s->avctx, AV_LOG_ERROR, ""Two slices reporting being the first in the same frame.\n"");/~/                goto fail;/~/            }"
367,"void PartialMagnificationController::OnWindowDestroying(aura::Window* window) {
CloseMagnifierWindow();

aura::Window* new_root_window = GetCurrentRootWindow();
if (new_root_window != window)
    SwitchTargetRootWindow(new_root_window);
}
",[4],    SwitchTargetRootWindow(new_root_window);
368,"static struct vm_area_struct *vma_to_resize(unsigned long addr,
unsigned long old_len, unsigned long new_len, unsigned long *p)
{
struct mm_struct *mm = current->mm;
struct vm_area_struct *vma = find_vma(mm, addr);

if (!vma || vma->vm_start > addr)
goto Efault;

if (is_vm_hugetlb_page(vma))
goto Einval;

/* We can't remap across vm area boundaries */
if (old_len > vma->vm_end - addr)
goto Efault;

	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {
		if (new_len > old_len)
goto Efault;
}

if (vma->vm_flags & VM_LOCKED) {
unsigned long locked, lock_limit;
locked = mm->locked_vm << PAGE_SHIFT;
lock_limit = rlimit(RLIMIT_MEMLOCK);
locked += new_len - old_len;
if (locked > lock_limit && !capable(CAP_IPC_LOCK))
goto Eagain;
}

if (!may_expand_vm(mm, (new_len - old_len) >> PAGE_SHIFT))
goto Enomem;

if (vma->vm_flags & VM_ACCOUNT) {
unsigned long charged = (new_len - old_len) >> PAGE_SHIFT;
if (security_vm_enough_memory(charged))
goto Efault;
*p = charged;
}

return vma;

Efault:	/* very odd choice for most of the cases, but... */
return ERR_PTR(-EFAULT);
Einval:
return ERR_PTR(-EINVAL);
Enomem:
return ERR_PTR(-ENOMEM);
Eagain:
return ERR_PTR(-EAGAIN);
}
","[12, 13]",	if (vma->vm_flags & (VM_DONTEXPAND | VM_PFNMAP)) {/~/		if (new_len > old_len)
369,"ImageBitmapFactories::ImageBitmapLoader::ImageBitmapLoader(
ImageBitmapFactories& factory,
base::Optional<IntRect> crop_rect,
ScriptState* script_state,
const ImageBitmapOptions* options)
    : loader_(
FileReaderLoader::Create(FileReaderLoader::kReadAsArrayBuffer, this)),
factory_(&factory),
resolver_(ScriptPromiseResolver::Create(script_state)),
crop_rect_(crop_rect),
options_(options) {}
",[5],    : loader_(
370,"xfs_attr_rmtval_set(
struct xfs_da_args	*args)
{
struct xfs_inode	*dp = args->dp;
struct xfs_mount	*mp = dp->i_mount;
struct xfs_bmbt_irec	map;
xfs_dablk_t		lblkno;
xfs_fileoff_t		lfileoff = 0;
__uint8_t		*src = args->value;
int			blkcnt;
int			valuelen;
int			nmap;
int			error;
int			offset = 0;

trace_xfs_attr_rmtval_set(args);

/*
* Find a ""hole"" in the attribute address space large enough for
* us to drop the new attribute's value into. Because CRC enable
* attributes have headers, we can't just do a straight byte to FSB
* conversion and have to take the header space into account.
*/
	blkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);
error = xfs_bmap_first_unused(args->trans, args->dp, blkcnt, &lfileoff,
XFS_ATTR_FORK);
if (error)
return error;

args->rmtblkno = lblkno = (xfs_dablk_t)lfileoff;
args->rmtblkcnt = blkcnt;

/*
* Roll through the ""value"", allocating blocks on disk as required.
*/
while (blkcnt > 0) {
int	committed;

/*
* Allocate a single extent, up to the size of the value.
*/
xfs_bmap_init(args->flist, args->firstblock);
nmap = 1;
error = xfs_bmapi_write(args->trans, dp, (xfs_fileoff_t)lblkno,
blkcnt,
XFS_BMAPI_ATTRFORK | XFS_BMAPI_METADATA,
args->firstblock, args->total, &map, &nmap,
args->flist);
if (!error) {
error = xfs_bmap_finish(&args->trans, args->flist,
&committed);
}
if (error) {
ASSERT(committed);
args->trans = NULL;
xfs_bmap_cancel(args->flist);
return(error);
}

/*
* bmap_finish() may have committed the last trans and started
* a new one.  We need the inode to be in all transactions.
*/
if (committed)
xfs_trans_ijoin(args->trans, dp, 0);

ASSERT(nmap == 1);
ASSERT((map.br_startblock != DELAYSTARTBLOCK) &&
(map.br_startblock != HOLESTARTBLOCK));
lblkno += map.br_blockcount;
blkcnt -= map.br_blockcount;

/*
* Start the next trans in the chain.
*/
error = xfs_trans_roll(&args->trans, dp);
if (error)
return (error);
}

/*
* Roll through the ""value"", copying the attribute value to the
* already-allocated blocks.  Blocks are written synchronously
* so that we can know they are all on disk before we turn off
* the INCOMPLETE flag.
*/
lblkno = args->rmtblkno;
blkcnt = args->rmtblkcnt;
	valuelen = args->valuelen;
while (valuelen > 0) {
struct xfs_buf	*bp;
xfs_daddr_t	dblkno;
int		dblkcnt;

ASSERT(blkcnt > 0);

xfs_bmap_init(args->flist, args->firstblock);
nmap = 1;
error = xfs_bmapi_read(dp, (xfs_fileoff_t)lblkno,
blkcnt, &map, &nmap,
XFS_BMAPI_ATTRFORK);
if (error)
return(error);
ASSERT(nmap == 1);
ASSERT((map.br_startblock != DELAYSTARTBLOCK) &&
(map.br_startblock != HOLESTARTBLOCK));

dblkno = XFS_FSB_TO_DADDR(mp, map.br_startblock),
dblkcnt = XFS_FSB_TO_BB(mp, map.br_blockcount);

bp = xfs_buf_get(mp->m_ddev_targp, dblkno, dblkcnt, 0);
if (!bp)
return ENOMEM;
bp->b_ops = &xfs_attr3_rmt_buf_ops;

xfs_attr_rmtval_copyin(mp, bp, args->dp->i_ino, &offset,
&valuelen, &src);

error = xfs_bwrite(bp);	/* GROT: NOTE: synchronous write */
xfs_buf_relse(bp);
if (error)
return error;


/* roll attribute extent map forwards */
lblkno += map.br_blockcount;
blkcnt -= map.br_blockcount;
}
ASSERT(valuelen == 0);
return 0;
}
",[33],"	blkcnt = xfs_attr3_rmt_blocks(mp, args->valuelen);/~/	valuelen = args->valuelen;"
371,"xmlParseConditionalSections(xmlParserCtxtPtr ctxt) {
int id = ctxt->input->id;

SKIP(3);
SKIP_BLANKS;
if (CMP7(CUR_PTR, 'I', 'N', 'C', 'L', 'U', 'D', 'E')) {
SKIP(7);
SKIP_BLANKS;
if (RAW != '[') {
xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
} else {
if (ctxt->input->id != id) {
xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
""All markup of the conditional section is not in the same entity\n"",
NULL, NULL);
}
NEXT;
}
if (xmlParserDebugEntities) {
if ((ctxt->input != NULL) && (ctxt->input->filename))
xmlGenericError(xmlGenericErrorContext,
""%s(%d): "", ctxt->input->filename,
ctxt->input->line);
xmlGenericError(xmlGenericErrorContext,
""Entering INCLUDE Conditional Section\n"");
}

	while ((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||
	       (NXT(2) != '>'))) {
const xmlChar *check = CUR_PTR;
unsigned int cons = ctxt->input->consumed;

if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
xmlParseConditionalSections(ctxt);
} else if (IS_BLANK_CH(CUR)) {
NEXT;
} else if (RAW == '%') {
xmlParsePEReference(ctxt);
} else
xmlParseMarkupDecl(ctxt);

/*
* Pop-up of finished entities.
*/
while ((RAW == 0) && (ctxt->inputNr > 1))
xmlPopInput(ctxt);

if ((CUR_PTR == check) && (cons == ctxt->input->consumed)) {
xmlFatalErr(ctxt, XML_ERR_EXT_SUBSET_NOT_FINISHED, NULL);
break;
}
}
if (xmlParserDebugEntities) {
if ((ctxt->input != NULL) && (ctxt->input->filename))
xmlGenericError(xmlGenericErrorContext,
""%s(%d): "", ctxt->input->filename,
ctxt->input->line);
xmlGenericError(xmlGenericErrorContext,
""Leaving INCLUDE Conditional Section\n"");
}

} else if (CMP6(CUR_PTR, 'I', 'G', 'N', 'O', 'R', 'E')) {
int state;
xmlParserInputState instate;
int depth = 0;

SKIP(6);
SKIP_BLANKS;
if (RAW != '[') {
xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID, NULL);
} else {
if (ctxt->input->id != id) {
xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
""All markup of the conditional section is not in the same entity\n"",
NULL, NULL);
}
NEXT;
}
if (xmlParserDebugEntities) {
if ((ctxt->input != NULL) && (ctxt->input->filename))
xmlGenericError(xmlGenericErrorContext,
""%s(%d): "", ctxt->input->filename,
ctxt->input->line);
xmlGenericError(xmlGenericErrorContext,
""Entering IGNORE Conditional Section\n"");
}

/*
* Parse up to the end of the conditional section
* But disable SAX event generating DTD building in the meantime
*/
state = ctxt->disableSAX;
instate = ctxt->instate;
if (ctxt->recovery == 0) ctxt->disableSAX = 1;
ctxt->instate = XML_PARSER_IGNORE;

	while ((depth >= 0) && (RAW != 0)) {
if ((RAW == '<') && (NXT(1) == '!') && (NXT(2) == '[')) {
depth++;
SKIP(3);
continue;
}
if ((RAW == ']') && (NXT(1) == ']') && (NXT(2) == '>')) {
if (--depth >= 0) SKIP(3);
continue;
}
NEXT;
continue;
}

ctxt->disableSAX = state;
ctxt->instate = instate;

if (xmlParserDebugEntities) {
if ((ctxt->input != NULL) && (ctxt->input->filename))
xmlGenericError(xmlGenericErrorContext,
""%s(%d): "", ctxt->input->filename,
ctxt->input->line);
xmlGenericError(xmlGenericErrorContext,
""Leaving IGNORE Conditional Section\n"");
}

} else {
xmlFatalErr(ctxt, XML_ERR_CONDSEC_INVALID_KEYWORD, NULL);
}

if (RAW == 0)
SHRINK;

if (RAW == 0) {
xmlFatalErr(ctxt, XML_ERR_CONDSEC_NOT_FINISHED, NULL);
} else {
if (ctxt->input->id != id) {
xmlValidityError(ctxt, XML_ERR_ENTITY_BOUNDARY,
""All markup of the conditional section is not in the same entity\n"",
NULL, NULL);
}
SKIP(3);
}
}
","[25, 26]",	while ((RAW != 0) && ((RAW != ']') || (NXT(1) != ']') ||/~/	       (NXT(2) != '>'))) {/~/	while ((depth >= 0) && (RAW != 0)) {
372,"void BluetoothDeviceChromeOS::UnregisterAgent() {
  if (!agent_.get())
    return;
  DCHECK(pairing_delegate_);
  DCHECK(pincode_callback_.is_null());
  DCHECK(passkey_callback_.is_null());
  DCHECK(confirmation_callback_.is_null());
  pairing_delegate_->DismissDisplayOrConfirm();
  pairing_delegate_ = NULL;
  agent_.reset();
  // Clean up after ourselves.
  VLOG(1) << object_path_.value() << "": Unregistering pairing agent"";
  DBusThreadManager::Get()->GetBluetoothAgentManagerClient()->
      UnregisterAgent(
          dbus::ObjectPath(kAgentPath),
          base::Bind(&base::DoNothing),
          base::Bind(&BluetoothDeviceChromeOS::OnUnregisterAgentError,
                     weak_ptr_factory_.GetWeakPtr()));
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18]","  if (!agent_.get())/~/    return;/~/  DCHECK(pairing_delegate_);/~/  DCHECK(pincode_callback_.is_null());/~/  DCHECK(passkey_callback_.is_null());/~/  DCHECK(confirmation_callback_.is_null());/~/  pairing_delegate_->DismissDisplayOrConfirm();/~/  pairing_delegate_ = NULL;/~/  agent_.reset();/~/  // Clean up after ourselves./~/  VLOG(1) << object_path_.value() << "": Unregistering pairing agent"";/~/  DBusThreadManager::Get()->GetBluetoothAgentManagerClient()->/~/      UnregisterAgent(/~/          dbus::ObjectPath(kAgentPath),/~/          base::Bind(&base::DoNothing),/~/          base::Bind(&BluetoothDeviceChromeOS::OnUnregisterAgentError,/~/                     weak_ptr_factory_.GetWeakPtr()));/~/}"
373,"OMX_ERRORTYPE  omx_vdec::get_config(OMX_IN OMX_HANDLETYPE      hComp,
OMX_IN OMX_INDEXTYPE configIndex,
OMX_INOUT OMX_PTR     configData)
{
(void) hComp;
OMX_ERRORTYPE eRet = OMX_ErrorNone;

if (m_state == OMX_StateInvalid) {
DEBUG_PRINT_ERROR(""Get Config in Invalid State"");
return OMX_ErrorInvalidState;
}


switch ((unsigned long)configIndex) {
case OMX_QcomIndexConfigInterlaced: {
OMX_QCOM_CONFIG_INTERLACETYPE *configFmt =
(OMX_QCOM_CONFIG_INTERLACETYPE *) configData;
if (configFmt->nPortIndex == 1) {
if (configFmt->nIndex == 0) {
configFmt->eInterlaceType = OMX_QCOM_InterlaceFrameProgressive;
} else if (configFmt->nIndex == 1) {
configFmt->eInterlaceType =
OMX_QCOM_InterlaceInterleaveFrameTopFieldFirst;
} else if (configFmt->nIndex == 2) {
configFmt->eInterlaceType =
OMX_QCOM_InterlaceInterleaveFrameBottomFieldFirst;
} else {
DEBUG_PRINT_ERROR(""get_config: OMX_QcomIndexConfigInterlaced:""
"" NoMore Interlaced formats"");
eRet = OMX_ErrorNoMore;
}

} else {
DEBUG_PRINT_ERROR(""get_config: Bad port index %d queried on only o/p port"",
(int)configFmt->nPortIndex);
eRet = OMX_ErrorBadPortIndex;
}

break;
}
case OMX_QcomIndexQueryNumberOfVideoDecInstance: {
QOMX_VIDEO_QUERY_DECODER_INSTANCES *decoderinstances =
(QOMX_VIDEO_QUERY_DECODER_INSTANCES*)configData;
decoderinstances->nNumOfInstances = 16;
/*TODO: How to handle this case */
break;

}
case OMX_QcomIndexConfigVideoFramePackingArrangement: {
if (drv_ctx.decoder_format == VDEC_CODECTYPE_H264) {
OMX_QCOM_FRAME_PACK_ARRANGEMENT *configFmt =
(OMX_QCOM_FRAME_PACK_ARRANGEMENT *) configData;
memcpy(configFmt, &m_frame_pack_arrangement,
sizeof(OMX_QCOM_FRAME_PACK_ARRANGEMENT));
} else {
DEBUG_PRINT_ERROR(""get_config: Framepack data not supported for non H264 codecs"");
}

break;
}
case OMX_IndexConfigCommonOutputCrop: {
OMX_CONFIG_RECTTYPE *rect = (OMX_CONFIG_RECTTYPE *) configData;
memcpy(rect, &rectangle, sizeof(OMX_CONFIG_RECTTYPE));
DEBUG_PRINT_HIGH(""get_config: crop info: L: %u, T: %u, R: %u, B: %u"",
rectangle.nLeft, rectangle.nTop,
rectangle.nWidth, rectangle.nHeight);

break;
}
case OMX_QcomIndexConfigPerfLevel: {
struct v4l2_control control;
OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *perf =
(OMX_QCOM_VIDEO_CONFIG_PERF_LEVEL *)configData;

control.id = V4L2_CID_MPEG_VIDC_SET_PERF_LEVEL;
if (ioctl(drv_ctx.video_driver_fd, VIDIOC_G_CTRL, &control) < 0) {
DEBUG_PRINT_ERROR(""Failed getting performance level: %d"", errno);
eRet = OMX_ErrorHardware;
}

if (eRet == OMX_ErrorNone) {
switch (control.value) {
case V4L2_CID_MPEG_VIDC_PERF_LEVEL_TURBO:
perf->ePerfLevel = OMX_QCOM_PerfLevelTurbo;
break;
default:
DEBUG_PRINT_HIGH(""Unknown perf level %d, reporting Nominal instead"", control.value);
/* Fall through */
case V4L2_CID_MPEG_VIDC_PERF_LEVEL_NOMINAL:
perf->ePerfLevel = OMX_QCOM_PerfLevelNominal;
break;
}

}

break;
                              }
default: {
DEBUG_PRINT_ERROR(""get_config: unknown param %d"",configIndex);
eRet = OMX_ErrorBadParameter;
}

}

return eRet;
}
","[9, 27, 32, 34]",                              }
374,"image_transform_png_set_expand_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(colour_type)

this->next = *that;
*that = this;

/* expand_16 does something unless the bit depth is already 16. */
return bit_depth < 16;
}
",[1],"    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)"
375,"process_open(u_int32_t id)
{
u_int32_t pflags;
Attrib a;
char *name;
int r, handle, fd, flags, mode, status = SSH2_FX_FAILURE;

if ((r = sshbuf_get_cstring(iqueue, &name, NULL)) != 0 ||
(r = sshbuf_get_u32(iqueue, &pflags)) != 0 || /* portable flags */
(r = decode_attrib(iqueue, &a)) != 0)
fatal(""%s: buffer error: %s"", __func__, ssh_err(r));

debug3(""request %u: open flags %d"", id, pflags);
flags = flags_from_portable(pflags);
mode = (a.flags & SSH2_FILEXFER_ATTR_PERMISSIONS) ? a.perm : 0666;
logit(""open \""%s\"" flags %s mode 0%o"",
name, string_from_portable(pflags), mode);
if (readonly &&
	    ((flags & O_ACCMODE) == O_WRONLY ||
	    (flags & O_ACCMODE) == O_RDWR)) {
verbose(""Refusing open request in read-only mode"");
status = SSH2_FX_PERMISSION_DENIED;
} else {
fd = open(name, flags, mode);
if (fd < 0) {
status = errno_to_portable(errno);
} else {
handle = handle_new(HANDLE_FILE, name, fd, flags, NULL);
if (handle < 0) {
close(fd);
} else {
send_handle(id, handle);
status = SSH2_FX_OK;
}
}
}
if (status != SSH2_FX_OK)
send_status(id, status);
free(name);
}
","[16, 17]",	    ((flags & O_ACCMODE) == O_WRONLY ||/~/	    (flags & O_ACCMODE) == O_RDWR)) {
376,"void CrosLibrary::TestApi::SetBrightnessLibrary(
    BrightnessLibrary* library, bool own) {
  library_->brightness_lib_.SetImpl(library, own);
}
","[1, 2, 3]","    BrightnessLibrary* library, bool own) {/~/  library_->brightness_lib_.SetImpl(library, own);/~/}"
377,"static int sctp_wait_for_sndbuf(struct sctp_association *asoc, long *timeo_p,
size_t msg_len)
{
struct sock *sk = asoc->base.sk;
int err = 0;
long current_timeo = *timeo_p;
DEFINE_WAIT(wait);

pr_debug(""%s: asoc:%p, timeo:%ld, msg_len:%zu\n"", __func__, asoc,
*timeo_p, msg_len);

/* Increment the association's refcnt.  */
sctp_association_hold(asoc);

/* Wait on the association specific sndbuf space. */
for (;;) {
prepare_to_wait_exclusive(&asoc->wait, &wait,
TASK_INTERRUPTIBLE);
if (!*timeo_p)
goto do_nonblock;
if (sk->sk_err || asoc->state >= SCTP_STATE_SHUTDOWN_PENDING ||
asoc->base.dead)
goto do_error;
if (signal_pending(current))
goto do_interrupted;
if (msg_len <= sctp_wspace(asoc))
break;

/* Let another process have a go.  Since we are going
* to sleep anyway.
*/
release_sock(sk);
current_timeo = schedule_timeout(current_timeo);
		BUG_ON(sk != asoc->base.sk);
lock_sock(sk);

*timeo_p = current_timeo;
}

out:
finish_wait(&asoc->wait, &wait);

/* Release the association's refcnt.  */
sctp_association_put(asoc);

return err;

do_error:
err = -EPIPE;
goto out;

do_interrupted:
err = sock_intr_errno(*timeo_p);
goto out;

do_nonblock:
err = -EAGAIN;
goto out;
}
",[29],		BUG_ON(sk != asoc->base.sk);
378,"get_control(png_const_structrp png_ptr)
{

/* This just returns the (file*).  The chunk and idat control structures
* don't always exist.
*/
   struct control *control = png_voidcast(struct control*,
png_get_error_ptr(png_ptr));
return &control->file;
}
",[5],"   struct control *control = png_voidcast(struct control*,"
379,"DecodeNumberField(int len, char *str, int fmask,
int *tmask, struct tm * tm, fsec_t *fsec, int *is2digits)
{
char	   *cp;

/*
* Have a decimal point? Then this is a date or something with a seconds
* field...
*/
if ((cp = strchr(str, '.')) != NULL)
{
#ifdef HAVE_INT64_TIMESTAMP
		char		fstr[MAXDATELEN + 1];

/*
* OK, we have at most six digits to care about. Let's construct a
		 * string and then do the conversion to an integer.
*/
		strcpy(fstr, (cp + 1));
		strcpy(fstr + strlen(fstr), ""000000"");
		*(fstr + 6) = '\0';
*fsec = strtol(fstr, NULL, 10);
#else
*fsec = strtod(cp, NULL);
#endif
*cp = '\0';
len = strlen(str);
}
/* No decimal point and no complete date yet? */
else if ((fmask & DTK_DATE_M) != DTK_DATE_M)
{
/* yyyymmdd? */
if (len == 8)
{
*tmask = DTK_DATE_M;

tm->tm_mday = atoi(str + 6);
*(str + 6) = '\0';
tm->tm_mon = atoi(str + 4);
*(str + 4) = '\0';
tm->tm_year = atoi(str + 0);

return DTK_DATE;
}
/* yymmdd? */
else if (len == 6)
{
*tmask = DTK_DATE_M;
tm->tm_mday = atoi(str + 4);
*(str + 4) = '\0';
tm->tm_mon = atoi(str + 2);
*(str + 2) = '\0';
tm->tm_year = atoi(str + 0);
*is2digits = TRUE;

return DTK_DATE;
}
/* yyddd? */
else if (len == 5)
{
*tmask = DTK_DATE_M;
tm->tm_mday = atoi(str + 2);
*(str + 2) = '\0';
tm->tm_mon = 1;
tm->tm_year = atoi(str + 0);
*is2digits = TRUE;

return DTK_DATE;
}
}

/* not all time fields are specified? */
if ((fmask & DTK_TIME_M) != DTK_TIME_M)
{
/* hhmmss */
if (len == 6)
{
*tmask = DTK_TIME_M;
tm->tm_sec = atoi(str + 4);
*(str + 4) = '\0';
tm->tm_min = atoi(str + 2);
*(str + 2) = '\0';
tm->tm_hour = atoi(str + 0);

return DTK_TIME;
}
/* hhmm? */
else if (len == 4)
{
*tmask = DTK_TIME_M;
tm->tm_sec = 0;
tm->tm_min = atoi(str + 2);
*(str + 2) = '\0';
tm->tm_hour = atoi(str + 0);

return DTK_TIME;
}
}

return -1;
}	/* DecodeNumberField() */
","[16, 18, 19, 20]","		char		fstr[MAXDATELEN + 1];/~/		 * string and then do the conversion to an integer./~/		strcpy(fstr, (cp + 1));/~/		strcpy(fstr + strlen(fstr), ""000000"");/~/		*(fstr + 6) = '\0';"
380,"Chapters::Display::~Display()
{
}
","[1, 2]",{/~/}
381,"CCLayerTreeHostTest()
: m_beginning(false)
, m_endWhenBeginReturns(false)
        , m_running(false)
, m_timedOut(false)
{
m_webThread = adoptPtr(webKitPlatformSupport()->createThread(""CCLayerTreeHostTest""));
WebCompositor::setThread(m_webThread.get());
#if USE(THREADED_COMPOSITING)
        m_settings.enableCompositorThread = true;
#else
        m_settings.enableCompositorThread = false;
#endif
}
","[3, 8, 9, 10, 11]","        , m_running(false)/~/#if USE(THREADED_COMPOSITING)/~/        m_settings.enableCompositorThread = true;/~/#else/~/        m_settings.enableCompositorThread = false;"
382,"freeimage(Image *image)
{
freebuffer(image);
png_image_free(&image->image);

if (image->input_file != NULL)
{
fclose(image->input_file);
image->input_file = NULL;
}

if (image->input_memory != NULL)
{
free(image->input_memory);
image->input_memory = NULL;
image->input_memory_size = 0;
}


if (image->tmpfile_name[0] != 0 && (image->opts & KEEP_TMPFILES) == 0)
{
      remove(image->tmpfile_name);
image->tmpfile_name[0] = 0;
}
}
",[17],      remove(image->tmpfile_name);
383,"void SkiaOutputSurfaceImpl::Reshape(const gfx::Size& size,
float device_scale_factor,
const gfx::ColorSpace& color_space,
bool has_alpha,
bool use_stencil) {
DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
if (initialize_waitable_event_) {
initialize_waitable_event_->Wait();
    initialize_waitable_event_ = nullptr;
}

SkSurfaceCharacterization* characterization = nullptr;
if (characterization_.isValid()) {
    // TODO(weiliang): support color space. https://crbug.com/795132
    characterization_ =
        characterization_.createResized(size.width(), size.height());
RecreateRootRecorder();
} else {
characterization = &characterization_;
initialize_waitable_event_ = std::make_unique<base::WaitableEvent>(
base::WaitableEvent::ResetPolicy::MANUAL,
base::WaitableEvent::InitialState::NOT_SIGNALED);
}

// impl_on_gpu_ is released on the GPU thread by a posted task from
// SkiaOutputSurfaceImpl::dtor. So it is safe to use base::Unretained.
  auto callback = base::BindOnce(
      &SkiaOutputSurfaceImplOnGpu::Reshape,
      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,
      std::move(color_space), has_alpha, use_stencil, pre_transform_,
      characterization, initialize_waitable_event_.get());
  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());
}
","[8, 12, 13, 14, 24, 25, 26, 27, 28, 29]","    initialize_waitable_event_ = nullptr;/~/    // TODO(weiliang): support color space. https://crbug.com/795132/~/    characterization_ =/~/        characterization_.createResized(size.width(), size.height());/~/  auto callback = base::BindOnce(/~/      &SkiaOutputSurfaceImplOnGpu::Reshape,/~/      base::Unretained(impl_on_gpu_.get()), size, device_scale_factor,/~/      std::move(color_space), has_alpha, use_stencil, pre_transform_,/~/      characterization, initialize_waitable_event_.get());/~/  ScheduleGpuTask(std::move(callback), std::vector<gpu::SyncToken>());"
384,"bool BaseAudioContext::WouldTaintOrigin(const KURL& url) const {
  // Data URLs don't taint the origin.
  if (url.ProtocolIsData()) {
    return false;
  }
  Document* document = GetDocument();
  if (document && document->GetSecurityOrigin()) {
    // The origin is tainted if and only if we cannot read content from the URL.
    return !document->GetSecurityOrigin()->CanRequest(url);
  }
  // Be conservative and assume it's tainted if it's not a data url and if we
  // can't get the security origin of the document.
  return true;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]",  // Data URLs don't taint the origin./~/  if (url.ProtocolIsData()) {/~/    return false;/~/  }/~/  Document* document = GetDocument();/~/  if (document && document->GetSecurityOrigin()) {/~/    // The origin is tainted if and only if we cannot read content from the URL./~/    return !document->GetSecurityOrigin()->CanRequest(url);/~/  }/~/  // Be conservative and assume it's tainted if it's not a data url and if we/~/  // can't get the security origin of the document./~/  return true;/~/}
385,"void ide_dma_cb(void *opaque, int ret)
{
IDEState *s = opaque;
int n;
int64_t sector_num;
bool stay_active = false;

if (ret == -ECANCELED) {
return;
}
if (ret < 0) {
int op = IDE_RETRY_DMA;

if (s->dma_cmd == IDE_DMA_READ)
op |= IDE_RETRY_READ;
else if (s->dma_cmd == IDE_DMA_TRIM)
op |= IDE_RETRY_TRIM;

if (ide_handle_rw_error(s, -ret, op)) {
return;
}
}

n = s->io_buffer_size >> 9;
if (n > s->nsector) {
/* The PRDs were longer than needed for this request. Shorten them so
* we don't get a negative remainder. The Active bit must remain set
* after the request completes. */
n = s->nsector;
stay_active = true;
}

sector_num = ide_get_sector(s);
if (n > 0) {
assert(s->io_buffer_size == s->sg.size);
dma_buf_commit(s, s->io_buffer_size);
sector_num += n;
ide_set_sector(s, sector_num);
s->nsector -= n;
}

/* end of transfer ? */
if (s->nsector == 0) {
s->status = READY_STAT | SEEK_STAT;
ide_set_irq(s->bus);
goto eot;
}

/* launch next transfer */
n = s->nsector;
s->io_buffer_index = 0;
s->io_buffer_size = n * 512;
    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {
/* The PRDs were too short. Reset the Active bit, but don't raise an
* interrupt. */
s->status = READY_STAT | SEEK_STAT;
goto eot;
}

printf(""ide_dma_cb: sector_num=%"" PRId64 "" n=%d, cmd_cmd=%d\n"",
sector_num, n, s->dma_cmd);
#endif

if ((s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) &&
!ide_sect_range_ok(s, sector_num, n)) {
ide_dma_error(s);
return;
}

switch (s->dma_cmd) {
case IDE_DMA_READ:
s->bus->dma->aiocb = dma_blk_read(s->blk, &s->sg, sector_num,
ide_dma_cb, s);
break;
case IDE_DMA_WRITE:
s->bus->dma->aiocb = dma_blk_write(s->blk, &s->sg, sector_num,
ide_dma_cb, s);
break;
case IDE_DMA_TRIM:
s->bus->dma->aiocb = dma_blk_io(s->blk, &s->sg, sector_num,
ide_issue_trim, ide_dma_cb, s,
DMA_DIRECTION_TO_DEVICE);
break;
}
return;

eot:
if (s->dma_cmd == IDE_DMA_READ || s->dma_cmd == IDE_DMA_WRITE) {
block_acct_done(blk_get_stats(s->blk), &s->acct);
}
ide_set_inactive(s, stay_active);
}
",[45],"    if (s->bus->dma->ops->prepare_buf(s->bus->dma, ide_cmd_is_read(s)) == 0) {"
386,"TemplateURLRef::SearchTermsArgs::ContextualSearchParams::ContextualSearchParams(
int version,
const std::string& selection,
const std::string& base_page_url,
    int now_on_tap_version)
: version(version),
start(base::string16::npos),
end(base::string16::npos),
selection(selection),
base_page_url(base_page_url),
      now_on_tap_version(now_on_tap_version) {}
","[4, 10]",    int now_on_tap_version)/~/      now_on_tap_version(now_on_tap_version) {}
387,"static int parse_token(char **name, char **value, char **cp)
{
char *end;

if (!name || !value || !cp)
return -BLKID_ERR_PARAM;

if (!(*value = strchr(*cp, '=')))
return 0;

**value = '\0';
*name = strip_line(*cp);
*value = skip_over_blank(*value + 1);

if (**value == '""') {
		end = strchr(*value + 1, '""');
		if (!end) {
DBG(READ, ul_debug(""unbalanced quotes at: %s"", *value));
*cp = *value;
return -BLKID_ERR_CACHE;
}
(*value)++;
*end = '\0';
		end++;
} else {
end = skip_over_word(*value);
if (*end) {
*end = '\0';
end++;
}
}
*cp = end;

return 1;
}
","[11, 12, 19, 24]","		end = strchr(*value + 1, '""');/~/		if (!end) {/~/		end++;"
388,"RenderFrameObserverNatives::RenderFrameObserverNatives(ScriptContext* context)
    : ObjectBackedNativeHandler(context) {
RouteFunction(
""OnDocumentElementCreated"",
base::Bind(&RenderFrameObserverNatives::OnDocumentElementCreated,
base::Unretained(this)));
}
",[1],    : ObjectBackedNativeHandler(context) {
389,"virtual void SetImePropertyActivated(const std::string& key,
bool activated) {
if (!initialized_successfully_)
return;

DCHECK(!key.empty());
    chromeos::SetImePropertyActivated(
        input_method_status_connection_, key.c_str(), activated);
}
","[5, 6]","    chromeos::SetImePropertyActivated(/~/        input_method_status_connection_, key.c_str(), activated);"
390,"static void copy_asoundrc(void) {
// copy XAUTHORITY_FILE in the new home directory
char *src = RUN_ASOUNDRC_FILE ;
char *dest;
if (asprintf(&dest, ""%s/.asoundrc"", cfg.homedir) == -1)
errExit(""asprintf"");
// if destination is a symbolic link, exit the sandbox!!!
if (is_link(dest)) {
fprintf(stderr, ""Error: %s is a symbolic link\n"", dest);
exit(1);
}

	pid_t child = fork();
	if (child < 0)
		errExit(""fork"");
	if (child == 0) {
		// drop privileges
		drop_privs(0);
		// copy, set permissions and ownership
		int rv = copy_file(src, dest);
		if (rv)
			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");
		else {
			fs_logger2(""clone"", dest);
		}
		_exit(0);
	}
	// wait for the child to finish
	waitpid(child, NULL, 0);
	// set permissions and ownership
	if (chown(dest, getuid(), getgid()) < 0)
		errExit(""chown"");
	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)
		errExit(""chmod"");

// delete the temporary file
unlink(src);
}
","[10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 35]","	pid_t child = fork();/~/	if (child < 0)/~/		errExit(""fork"");/~/	if (child == 0) {/~/		// drop privileges/~/		drop_privs(0);/~/		// copy, set permissions and ownership/~/		int rv = copy_file(src, dest);/~/		if (rv)/~/			fprintf(stderr, ""Warning: cannot transfer .asoundrc in private home directory\n"");/~/		else {/~/			fs_logger2(""clone"", dest);/~/		}/~/		_exit(0);/~/	}/~/	// wait for the child to finish/~/	waitpid(child, NULL, 0);/~/	// set permissions and ownership/~/	if (chown(dest, getuid(), getgid()) < 0)/~/		errExit(""chown"");/~/	if (chmod(dest, S_IRUSR | S_IWUSR) < 0)/~/		errExit(""chmod"");"
391,"static jboolean enableNative(JNIEnv* env, jobject obj) {
ALOGV(""%s:"",__FUNCTION__);

jboolean result = JNI_FALSE;
if (!sBluetoothInterface) return result;
    int ret = sBluetoothInterface->enable();
result = (ret == BT_STATUS_SUCCESS || ret == BT_STATUS_DONE) ? JNI_TRUE : JNI_FALSE;
return result;
}
",[4],    int ret = sBluetoothInterface->enable();
392,"void FrameSelection::MoveRangeSelection(const VisiblePosition& base_position,
const VisiblePosition& extent_position,
TextGranularity granularity) {
SelectionInDOMTree new_selection =
SelectionInDOMTree::Builder()
.SetBaseAndExtentDeprecated(base_position.DeepEquivalent(),
extent_position.DeepEquivalent())
.SetAffinity(base_position.Affinity())
          .SetIsHandleVisible(IsHandleVisible())
.Build();

if (new_selection.IsNone())
return;

const VisibleSelection& visible_selection =
CreateVisibleSelectionWithGranularity(new_selection, granularity);
if (visible_selection.IsNone())
return;

SelectionInDOMTree::Builder builder;
if (visible_selection.IsBaseFirst()) {
builder.SetBaseAndExtent(visible_selection.Start(),
visible_selection.End());
} else {
builder.SetBaseAndExtent(visible_selection.End(),
visible_selection.Start());
}
builder.SetAffinity(visible_selection.Affinity());
  builder.SetIsHandleVisible(IsHandleVisible());
SetSelection(builder.Build(), SetSelectionData::Builder()
.SetShouldCloseTyping(true)
.SetShouldClearTypingStyle(true)
.SetGranularity(granularity)
.Build());
}
","[8, 25]",          .SetIsHandleVisible(IsHandleVisible())/~/  builder.SetIsHandleVisible(IsHandleVisible());
393,"static netdev_tx_t hns_nic_net_xmit(struct sk_buff *skb,
struct net_device *ndev)
{
struct hns_nic_priv *priv = netdev_priv(ndev);
	int ret;

assert(skb->queue_mapping < ndev->ae_handle->q_num);
	ret = hns_nic_net_xmit_hw(ndev, skb,
				  &tx_ring_data(priv, skb->queue_mapping));
	if (ret == NETDEV_TX_OK) {
		netif_trans_update(ndev);
		ndev->stats.tx_bytes += skb->len;
		ndev->stats.tx_packets++;
	}
	return (netdev_tx_t)ret;
}
","[4, 6, 7, 8, 9, 10, 11, 12, 13, 14]","	int ret;/~/	ret = hns_nic_net_xmit_hw(ndev, skb,/~/				  &tx_ring_data(priv, skb->queue_mapping));/~/	if (ret == NETDEV_TX_OK) {/~/		netif_trans_update(ndev);/~/		ndev->stats.tx_bytes += skb->len;/~/		ndev->stats.tx_packets++;/~/	}/~/	return (netdev_tx_t)ret;"
394,"void NavigationController::GoToIndex(int index) {
if (index < 0 || index >= static_cast<int>(entries_.size())) {
NOTREACHED();
return;
}

if (transient_entry_index_ != -1) {
if (index == transient_entry_index_) {
// Nothing to do when navigating to the transient.
return;
}
if (index > transient_entry_index_) {
// Removing the transient is goint to shift all entries by 1.
index--;
}
}

  // If an interstitial page is showing, the previous renderer is blocked and
  // cannot make new requests.
  if (tab_contents_->interstitial_page()) {
    if (index == GetCurrentEntryIndex() - 1) {
      // Going back one entry is equivalent to hiding the interstitial.
      tab_contents_->interstitial_page()->DontProceed();
      return;
    } else {
      // Unblock the renderer (and disable the interstitial) to allow this
      // navigation to succeed.  The interstitial will stay visible until the
      // resulting DidNavigate.
      tab_contents_->interstitial_page()->CancelForNavigation();
    }
  }
DiscardNonCommittedEntries();

pending_entry_index_ = index;
entries_[pending_entry_index_]->set_transition_type(
content::PageTransitionFromInt(
entries_[pending_entry_index_]->transition_type() |
content::PAGE_TRANSITION_FORWARD_BACK));
NavigateToPendingEntry(NO_RELOAD);
}
","[3, 4, 8, 9, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 36]","  // If an interstitial page is showing, the previous renderer is blocked and/~/  // cannot make new requests./~/  if (tab_contents_->interstitial_page()) {/~/    if (index == GetCurrentEntryIndex() - 1) {/~/      // Going back one entry is equivalent to hiding the interstitial./~/      tab_contents_->interstitial_page()->DontProceed();/~/      return;/~/    } else {/~/      // Unblock the renderer (and disable the interstitial) to allow this/~/      // navigation to succeed.  The interstitial will stay visible until the/~/      // resulting DidNavigate./~/      tab_contents_->interstitial_page()->CancelForNavigation();/~/    }/~/  }"
395,"int svc_rdma_map_xdr(struct svcxprt_rdma *xprt,
		     struct xdr_buf *xdr,
		     struct svc_rdma_req_map *vec,
		     bool write_chunk_present)
{
	int sge_no;
	u32 sge_bytes;
	u32 page_bytes;
	u32 page_off;
	int page_no;
	if (xdr->len !=
	    (xdr->head[0].iov_len + xdr->page_len + xdr->tail[0].iov_len)) {
		pr_err(""svcrdma: %s: XDR buffer length error\n"", __func__);
		return -EIO;
	}

	/* Skip the first sge, this is for the RPCRDMA header *
	sge_no = 1;

	/* Head SGE *
	vec->sge[sge_no].iov_base = xdr->head[0].iov_base;
	vec->sge[sge_no].iov_len = xdr->head[0].iov_len;
	sge_no++;
	/* pages SGE *
	page_no = 0;
	page_bytes = xdr->page_len;
	page_off = xdr->page_base;
	while (page_bytes) {
		vec->sge[sge_no].iov_base =
			page_address(xdr->pages[page_no]) + page_off;
		sge_bytes = min_t(u32, page_bytes, (PAGE_SIZE - page_off));
		page_bytes -= sge_bytes;
		vec->sge[sge_no].iov_len = sge_bytes;
		sge_no++;
		page_no++;
		page_off = 0; /* reset for next time through loop *
}

	/* Tail SGE *
	if (xdr->tail[0].iov_len) {
		unsigned char *base = xdr->tail[0].iov_base;
		size_t len = xdr->tail[0].iov_len;
		u32 xdr_pad = xdr_padsize(xdr->page_len);

		if (write_chunk_present && xdr_pad) {
			base += xdr_pad;
			len -= xdr_pad;
		}

		if (len) {
			vec->sge[sge_no].iov_base = base;
			vec->sge[sge_no].iov_len = len;
			sge_no++;
}
	}

	dprintk(""svcrdma: %s: sge_no %d page_no %d ""
		""page_base %u page_len %u head_len %zu tail_len %zu\n"",
		__func__, sge_no, page_no, xdr->page_base, xdr->page_len,
		xdr->head[0].iov_len, xdr->tail[0].iov_len);

	vec->count = sge_no;
	return 0;
}
","[1, 2, 3, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36]","		     struct xdr_buf *xdr,/~/		     struct svc_rdma_req_map *vec,/~/		     bool write_chunk_present)/~/	int sge_no;/~/	u32 sge_bytes;/~/	u32 page_bytes;/~/	u32 page_off;/~/	int page_no;/~/	if (xdr->len !=/~/	    (xdr->head[0].iov_len + xdr->page_len + xdr->tail[0].iov_len)) {/~/		pr_err(""svcrdma: %s: XDR buffer length error\n"", __func__);/~/		return -EIO;/~/	}/~/	/* Skip the first sge, this is for the RPCRDMA header */~/	sge_no = 1;/~/	/* Head SGE */~/	vec->sge[sge_no].iov_base = xdr->head[0].iov_base;/~/	vec->sge[sge_no].iov_len = xdr->head[0].iov_len;/~/	sge_no++;/~/	/* pages SGE */~/	page_no = 0;/~/	page_bytes = xdr->page_len;/~/	page_off = xdr->page_base;/~/	while (page_bytes) {/~/		vec->sge[sge_no].iov_base =/~/			page_address(xdr->pages[page_no]) + page_off;/~/		sge_bytes = min_t(u32, page_bytes, (PAGE_SIZE - page_off));/~/		page_bytes -= sge_bytes;/~/		vec->sge[sge_no].iov_len = sge_bytes;/~/		sge_no++;/~/		page_no++;/~/		page_off = 0; /* reset for next time through loop */~/	/* Tail SGE */~/	if (xdr->tail[0].iov_len) {/~/		unsigned char *base = xdr->tail[0].iov_base;/~/		size_t len = xdr->tail[0].iov_len;/~/		u32 xdr_pad = xdr_padsize(xdr->page_len);/~/		if (write_chunk_present && xdr_pad) {/~/			base += xdr_pad;/~/			len -= xdr_pad;/~/		}/~/		if (len) {/~/			vec->sge[sge_no].iov_base = base;/~/			vec->sge[sge_no].iov_len = len;/~/			sge_no++;/~/	}/~/	dprintk(""svcrdma: %s: sge_no %d page_no %d ""/~/		""page_base %u page_len %u head_len %zu tail_len %zu\n"",/~/		__func__, sge_no, page_no, xdr->page_base, xdr->page_len,/~/		xdr->head[0].iov_len, xdr->tail[0].iov_len);/~/	vec->count = sge_no;/~/	return 0;"
396,"static int dnxhd_find_frame_end(DNXHDParserContext *dctx,
const uint8_t *buf, int buf_size)
{
ParseContext *pc = &dctx->pc;
uint64_t state = pc->state64;
int pic_found = pc->frame_start_found;
int i = 0;

if (!pic_found) {
for (i = 0; i < buf_size; i++) {
state = (state << 8) | buf[i];
if (ff_dnxhd_check_header_prefix(state & 0xffffffffff00LL) != 0) {
i++;
pic_found = 1;
dctx->cur_byte = 0;
dctx->remaining = 0;
break;
}
}
}

if (pic_found && !dctx->remaining) {
if (!buf_size) /* EOF considered as end of frame */
return 0;
for (; i < buf_size; i++) {
dctx->cur_byte++;
state = (state << 8) | buf[i];

if (dctx->cur_byte == 24) {
dctx->h = (state >> 32) & 0xFFFF;
} else if (dctx->cur_byte == 26) {
dctx->w = (state >> 32) & 0xFFFF;
} else if (dctx->cur_byte == 42) {
int cid = (state >> 32) & 0xFFFFFFFF;

if (cid <= 0)
continue;

                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);
                if (dctx->remaining <= 0) {
                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);
                    if (dctx->remaining <= 0)
                        return dctx->remaining;
}
if (buf_size - i + 47 >= dctx->remaining) {
int remaining = dctx->remaining;

pc->frame_start_found = 0;
pc->state64 = -1;
dctx->cur_byte = 0;
dctx->remaining = 0;
return remaining;
} else {
dctx->remaining -= buf_size;
}
}
}
} else if (pic_found) {
if (dctx->remaining > buf_size) {
dctx->remaining -= buf_size;
} else {
int remaining = dctx->remaining;

pc->frame_start_found = 0;
pc->state64 = -1;
dctx->cur_byte = 0;
dctx->remaining = 0;
return remaining;
}
}
pc->frame_start_found = pic_found;
pc->state64 = state;
return END_NOT_FOUND;
}
","[33, 34, 35, 36]","                dctx->remaining = avpriv_dnxhd_get_frame_size(cid);/~/                if (dctx->remaining <= 0) {/~/                    dctx->remaining = dnxhd_get_hr_frame_size(cid, dctx->w, dctx->h);/~/                    if (dctx->remaining <= 0)/~/                        return dctx->remaining;"
397,"static struct nfs4_opendata *nfs4_opendata_alloc(struct path *path,
		struct nfs4_state_owner *sp, int flags,
const struct iattr *attrs)
{
struct dentry *parent = dget_parent(path->dentry);
struct inode *dir = parent->d_inode;
struct nfs_server *server = NFS_SERVER(dir);
struct nfs4_opendata *p;

p = kzalloc(sizeof(*p), GFP_KERNEL);
if (p == NULL)
goto err;
p->o_arg.seqid = nfs_alloc_seqid(&sp->so_seqid);
if (p->o_arg.seqid == NULL)
goto err_free;
p->path.mnt = mntget(path->mnt);
p->path.dentry = dget(path->dentry);
p->dir = parent;
p->owner = sp;
atomic_inc(&sp->so_count);
p->o_arg.fh = NFS_FH(dir);
	p->o_arg.open_flags = flags,
p->o_arg.clientid = server->nfs_client->cl_clientid;
p->o_arg.id = sp->so_owner_id.id;
p->o_arg.name = &p->path.dentry->d_name;
p->o_arg.server = server;
p->o_arg.bitmask = server->attr_bitmask;
p->o_arg.claim = NFS4_OPEN_CLAIM_NULL;
if (flags & O_EXCL) {
u32 *s = (u32 *) p->o_arg.u.verifier.data;
s[0] = jiffies;
s[1] = current->pid;
} else if (flags & O_CREAT) {
p->o_arg.u.attrs = &p->attrs;
memcpy(&p->attrs, attrs, sizeof(p->attrs));
}
p->c_arg.fh = &p->o_res.fh;
p->c_arg.stateid = &p->o_res.stateid;
p->c_arg.seqid = p->o_arg.seqid;
nfs4_init_opendata_res(p);
kref_init(&p->kref);
return p;
err_free:
kfree(p);
err:
dput(parent);
return NULL;
}
","[1, 20]","		struct nfs4_state_owner *sp, int flags,/~/	p->o_arg.open_flags = flags,"
398,"bool SiteInstanceImpl::ShouldLockToOrigin(BrowserContext* browser_context,
GURL site_url) {
// Don't lock to origin in --single-process mode, since this mode puts
// cross-site pages into the same process.
if (RenderProcessHost::run_renderer_in_process())
return false;

if (!DoesSiteRequireDedicatedProcess(browser_context, site_url))
return false;

// Guest processes cannot be locked to their site because guests always have
// a fixed SiteInstance. The site of GURLs a guest loads doesn't match that
// SiteInstance. So we skip locking the guest process to the site.
// TODO(ncarter): Remove this exclusion once we can make origin lock per
// RenderFrame routing id.
if (site_url.SchemeIs(content::kGuestScheme))
return false;

  // TODO(creis, nick) https://crbug.com/510588 Chrome UI pages use the same
  // site (chrome://chrome), so they can't be locked because the site being
  // loaded doesn't match the SiteInstance.
  if (site_url.SchemeIs(content::kChromeUIScheme))
    return false;
// TODO(creis, nick): Until we can handle sites with effective URLs at the
// call sites of ChildProcessSecurityPolicy::CanAccessDataForOrigin, we
// must give the embedder a chance to exempt some sites to avoid process
// kills.
if (!GetContentClient()->browser()->ShouldLockToOrigin(browser_context,
site_url)) {
return false;
}

return true;
}
","[5, 7, 14, 15, 16, 17, 18, 19, 26]","  // TODO(creis, nick) https://crbug.com/510588 Chrome UI pages use the same/~/  // site (chrome://chrome), so they can't be locked because the site being/~/  // loaded doesn't match the SiteInstance./~/  if (site_url.SchemeIs(content::kChromeUIScheme))/~/    return false;"
399,"void DownloadResourceHandler::OnRequestRedirected(
const net::RedirectInfo& redirect_info,
network::ResourceResponse* response,
std::unique_ptr<ResourceController> controller) {
url::Origin new_origin(url::Origin::Create(redirect_info.new_url));
if (!follow_cross_origin_redirects_ &&
!first_origin_.IsSameOriginWith(new_origin)) {
base::PostTaskWithTraits(
FROM_HERE, {BrowserThread::UI},
base::BindOnce(
&NavigateOnUIThread, redirect_info.new_url, request()->url_chain(),
Referrer(GURL(redirect_info.new_referrer),
Referrer::NetReferrerPolicyToBlinkReferrerPolicy(
redirect_info.new_referrer_policy)),
GetRequestInfo()->HasUserGesture(),
            GetRequestInfo()->GetWebContentsGetterForRequest()));
controller->Cancel();
return;
}
if (core_.OnRequestRedirected()) {
controller->Resume();
} else {
controller->Cancel();
}
}
",[15],            GetRequestInfo()->GetWebContentsGetterForRequest()));
400,"_zip_cdir_new(int nentry, struct zip_error *error)
{
struct zip_cdir *cd;

if ((cd=(struct zip_cdir *)malloc(sizeof(*cd))) == NULL) {
_zip_error_set(error, ZIP_ER_MEMORY, 0);
return NULL;
}

    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
== NULL) {
_zip_error_set(error, ZIP_ER_MEMORY, 0);
free(cd);
return NULL;
}

/* entries must be initialized by caller */

cd->nentry = nentry;
cd->size = cd->offset = 0;
cd->comment = NULL;
cd->comment_len = 0;

return cd;
}
",[7],    if ((cd->entry=(struct zip_dirent *)malloc(sizeof(*(cd->entry))*nentry))
401,"void flush_tlb_mm_range(struct mm_struct *mm, unsigned long start,
unsigned long end, unsigned long vmflag)
{
unsigned long addr;
/* do a global flush by default */
unsigned long base_pages_to_flush = TLB_FLUSH_ALL;

preempt_disable();
	if (current->active_mm != mm)
goto out;

if (!current->mm) {
leave_mm(smp_processor_id());
goto out;
}

if ((end != TLB_FLUSH_ALL) && !(vmflag & VM_HUGETLB))
base_pages_to_flush = (end - start) >> PAGE_SHIFT;

if (base_pages_to_flush > tlb_single_page_flush_ceiling) {
base_pages_to_flush = TLB_FLUSH_ALL;
count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ALL);
local_flush_tlb();
} else {
/* flush range by one by one 'invlpg' */
for (addr = start; addr < end;	addr += PAGE_SIZE) {
count_vm_tlb_event(NR_TLB_LOCAL_FLUSH_ONE);
__flush_tlb_single(addr);
}
}
trace_tlb_flush(TLB_LOCAL_MM_SHOOTDOWN, base_pages_to_flush);
out:
if (base_pages_to_flush == TLB_FLUSH_ALL) {
start = 0UL;
end = TLB_FLUSH_ALL;
}
if (cpumask_any_but(mm_cpumask(mm), smp_processor_id()) < nr_cpu_ids)
flush_tlb_others(mm_cpumask(mm), mm, start, end);
preempt_enable();
}
",[7],	if (current->active_mm != mm)
402,"PageInfoUI::IdentityInfo::IdentityInfo()
: identity_status(PageInfo::SITE_IDENTITY_STATUS_UNKNOWN),
      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),
connection_status(PageInfo::SITE_CONNECTION_STATUS_UNKNOWN),
show_ssl_decision_revoke_button(false),
show_change_password_buttons(false) {}
",[2],"      safe_browsing_status(PageInfo::SAFE_BROWSING_STATUS_NONE),"
403,"static void add_bytes_c(uint8_t *dst, uint8_t *src, int w){
long i;
    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
long a = *(long*)(src+i);
long b = *(long*)(dst+i);
*(long*)(dst+i) = ((a&pb_7f) + (b&pb_7f)) ^ ((a^b)&pb_80);
}
for(; i<w; i++)
dst[i+0] += src[i+0];
}
",[2],    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){
404,"Load_SBit_Png( FT_GlyphSlot     slot,
FT_Int           x_offset,
FT_Int           y_offset,
FT_Int           pix_bits,
TT_SBit_Metrics  metrics,
FT_Memory        memory,
FT_Byte*         data,
FT_UInt          png_len,
FT_Bool          populate_map_and_metrics )
{
FT_Bitmap    *map   = &slot->bitmap;
FT_Error      error = FT_Err_Ok;
FT_StreamRec  stream;

png_structp  png;
png_infop    info;
png_uint_32  imgWidth, imgHeight;

int         bitdepth, color_type, interlace;
FT_Int      i;
png_byte*  *rows = NULL; /* pacify compiler */


if ( x_offset < 0 ||
y_offset < 0 )
{
error = FT_THROW( Invalid_Argument );
goto Exit;
}

    if ( !populate_map_and_metrics                   &&
         ( x_offset + metrics->width  > map->width ||
           y_offset + metrics->height > map->rows  ||
           pix_bits != 32                          ||
           map->pixel_mode != FT_PIXEL_MODE_BGRA   ) )
{
error = FT_THROW( Invalid_Argument );
goto Exit;
}

FT_Stream_OpenMemory( &stream, data, png_len );

png = png_create_read_struct( PNG_LIBPNG_VER_STRING,
&error,
error_callback,
warning_callback );
if ( !png )
{
error = FT_THROW( Out_Of_Memory );
goto Exit;
}

info = png_create_info_struct( png );
if ( !info )
{
error = FT_THROW( Out_Of_Memory );
png_destroy_read_struct( &png, NULL, NULL );
goto Exit;
}

if ( ft_setjmp( png_jmpbuf( png ) ) )
{
error = FT_THROW( Invalid_File_Format );
goto DestroyExit;
}

png_set_read_fn( png, &stream, read_data_from_FT_Stream );

png_read_info( png, info );
png_get_IHDR( png, info,
&imgWidth, &imgHeight,
&bitdepth, &color_type, &interlace,
NULL, NULL );

if ( error                                        ||
( !populate_map_and_metrics                &&
( (FT_Int)imgWidth  != metrics->width  ||
(FT_Int)imgHeight != metrics->height ) ) )
goto DestroyExit;

if ( populate_map_and_metrics )
{
FT_Long  size;


metrics->width  = (FT_Int)imgWidth;
metrics->height = (FT_Int)imgHeight;

map->width      = metrics->width;
map->rows       = metrics->height;
map->pixel_mode = FT_PIXEL_MODE_BGRA;
map->pitch      = map->width * 4;
map->num_grays  = 256;

/* reject too large bitmaps similarly to the rasterizer */
if ( map->rows > 0x7FFF || map->width > 0x7FFF )
{
error = FT_THROW( Array_Too_Large );
goto DestroyExit;
}

size = map->rows * map->pitch;

error = ft_glyphslot_alloc_bitmap( slot, size );
if ( error )
goto DestroyExit;
}

/* convert palette/gray image to rgb */
if ( color_type == PNG_COLOR_TYPE_PALETTE )
png_set_palette_to_rgb( png );

/* expand gray bit depth if needed */
if ( color_type == PNG_COLOR_TYPE_GRAY )
{
#if PNG_LIBPNG_VER >= 10209
png_set_expand_gray_1_2_4_to_8( png );
#else
png_set_gray_1_2_4_to_8( png );
#endif
}

/* transform transparency to alpha */
if ( png_get_valid(png, info, PNG_INFO_tRNS ) )
png_set_tRNS_to_alpha( png );

if ( bitdepth == 16 )
png_set_strip_16( png );

if ( bitdepth < 8 )
png_set_packing( png );

/* convert grayscale to RGB */
if ( color_type == PNG_COLOR_TYPE_GRAY       ||
color_type == PNG_COLOR_TYPE_GRAY_ALPHA )
png_set_gray_to_rgb( png );

if ( interlace != PNG_INTERLACE_NONE )
png_set_interlace_handling( png );

png_set_filler( png, 0xFF, PNG_FILLER_AFTER );

/* recheck header after setting EXPAND options */
png_read_update_info(png, info );
png_get_IHDR( png, info,
&imgWidth, &imgHeight,
&bitdepth, &color_type, &interlace,
NULL, NULL );

if ( bitdepth != 8                              ||
!( color_type == PNG_COLOR_TYPE_RGB       ||
color_type == PNG_COLOR_TYPE_RGB_ALPHA ) )
{
error = FT_THROW( Invalid_File_Format );
goto DestroyExit;
}

switch ( color_type )
{
default:
/* Shouldn't happen, but fall through. */

case PNG_COLOR_TYPE_RGB_ALPHA:
png_set_read_user_transform_fn( png, premultiply_data );
break;

case PNG_COLOR_TYPE_RGB:
/* Humm, this smells.  Carry on though. */
png_set_read_user_transform_fn( png, convert_bytes_to_data );
break;
}

if ( FT_NEW_ARRAY( rows, imgHeight ) )
{
error = FT_THROW( Out_Of_Memory );
goto DestroyExit;
}

for ( i = 0; i < (FT_Int)imgHeight; i++ )
rows[i] = map->buffer + ( y_offset + i ) * map->pitch + x_offset * 4;

png_read_image( png, rows );

FT_FREE( rows );

png_read_end( png, info );

DestroyExit:
png_destroy_read_struct( &png, &info, NULL );
FT_Stream_Close( &stream );

Exit:
return error;
}
","[25, 26, 27, 28, 29]",    if ( !populate_map_and_metrics                   &&/~/         ( x_offset + metrics->width  > map->width ||/~/           y_offset + metrics->height > map->rows  ||/~/           pix_bits != 32                          ||/~/           map->pixel_mode != FT_PIXEL_MODE_BGRA   ) )
405,"bool ClipboardUtil::HasFilenames(IDataObject* data_object) {
DCHECK(data_object);
  return HasData(data_object, Clipboard::GetCFHDropFormatType());
}
",[2],"  return HasData(data_object, Clipboard::GetCFHDropFormatType());"
406,"bool RendererPermissionsPolicyDelegate::IsRestrictedUrl(
const GURL& document_url,
std::string* error) {
if (dispatcher_->IsExtensionActive(kWebStoreAppId)) {
if (error)
*error = errors::kCannotScriptGallery;
return true;
}

  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
if (error)
*error = errors::kCannotScriptNtp;
return true;
}

return false;
}
",[8],  if (SearchBouncer::GetInstance()->IsNewTabPage(document_url)) {
407,"void RTCPeerConnection::setRemoteDescription(PassRefPtr<RTCSessionDescription> prpSessionDescription, PassRefPtr<VoidCallback> successCallback, PassRefPtr<RTCErrorCallback> errorCallback, ExceptionCode& ec)
{
    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {
        ec = INVALID_STATE_ERR;
        return;
    }
    RefPtr<RTCSessionDescription> sessionDescription = prpSessionDescription;
    if (!sessionDescription) {
        ec = TYPE_MISMATCH_ERR;
        return;
    }
    RefPtr<RTCVoidRequestImpl> request = RTCVoidRequestImpl::create(scriptExecutionContext(), successCallback, errorCallback);
    m_peerHandler->setRemoteDescription(request.release(), sessionDescription->descriptor());
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13]","{/~/    if (m_readyState == ReadyStateClosing || m_readyState == ReadyStateClosed) {/~/        ec = INVALID_STATE_ERR;/~/        return;/~/    }/~/    RefPtr<RTCSessionDescription> sessionDescription = prpSessionDescription;/~/    if (!sessionDescription) {/~/        ec = TYPE_MISMATCH_ERR;/~/        return;/~/    }/~/    RefPtr<RTCVoidRequestImpl> request = RTCVoidRequestImpl::create(scriptExecutionContext(), successCallback, errorCallback);/~/    m_peerHandler->setRemoteDescription(request.release(), sessionDescription->descriptor());/~/}"
408,"int DecodeTeredo(ThreadVars *tv, DecodeThreadVars *dtv, Packet *p, uint8_t *pkt, uint16_t len, PacketQueue *pq)
{
if (!g_teredo_enabled)
return TM_ECODE_FAILED;

uint8_t *start = pkt;

/* Is this packet to short to contain an IPv6 packet ? */
if (len < IPV6_HEADER_LEN)
return TM_ECODE_FAILED;

/* Teredo encapsulate IPv6 in UDP and can add some custom message
* part before the IPv6 packet. In our case, we just want to get
* over an ORIGIN indication. So we just make one offset if needed. */
if (start[0] == 0x0) {
switch (start[1]) {
/* origin indication: compatible with tunnel */
case 0x0:
/* offset is coherent with len and presence of an IPv6 header */
if (len >= TEREDO_ORIG_INDICATION_LENGTH + IPV6_HEADER_LEN)
start += TEREDO_ORIG_INDICATION_LENGTH;
else
return TM_ECODE_FAILED;
break;
/* authentication: negotiation not real tunnel */
case 0x1:
return TM_ECODE_FAILED;
/* this case is not possible in Teredo: not that protocol */
default:
return TM_ECODE_FAILED;
}
}

/* There is no specific field that we can check to prove that the packet
* is a Teredo packet. We've zapped here all the possible Teredo header
* and we should have an IPv6 packet at the start pointer.
     * We then can only do two checks before sending the encapsulated packets
* to decoding:
*  - The packet has a protocol version which is IPv6.
*  - The IPv6 length of the packet matches what remains in buffer.
*/
if (IP_GET_RAW_VER(start) == 6) {
IPV6Hdr *thdr = (IPV6Hdr *)start;
if (len ==  IPV6_HEADER_LEN +
IPV6_GET_RAW_PLEN(thdr) + (start - pkt)) {
if (pq != NULL) {
int blen = len - (start - pkt);
/* spawn off tunnel packet */
Packet *tp = PacketTunnelPktSetup(tv, dtv, p, start, blen,
                                                  DECODE_TUNNEL_IPV6, pq);
if (tp != NULL) {
PKT_SET_SRC(tp, PKT_SRC_DECODER_TEREDO);
/* add the tp to the packet queue. */
PacketEnqueue(pq,tp);
StatsIncr(tv, dtv->counter_teredo);
return TM_ECODE_OK;
}
}
}
return TM_ECODE_FAILED;
}

return TM_ECODE_FAILED;
}
",[32],"     * We then can only do two checks before sending the encapsulated packets/~/                                                  DECODE_TUNNEL_IPV6, pq);"
409,"virtual void SetUp() {
video_ = new libvpx_test::WebMVideoSource(kVP9TestFile);
ASSERT_TRUE(video_ != NULL);

video_->Init();
video_->Begin();

    vpx_codec_dec_cfg_t cfg = {0};
decoder_ = new libvpx_test::VP9Decoder(cfg, 0);
ASSERT_TRUE(decoder_ != NULL);
}
",[5],    vpx_codec_dec_cfg_t cfg = {0};
410,"void EnterpriseEnrollmentScreen::OnPolicyStateChanged(
policy::CloudPolicySubsystem::PolicySubsystemState state,
policy::CloudPolicySubsystem::ErrorDetails error_details) {

if (is_showing_) {
switch (state) {
case policy::CloudPolicySubsystem::UNENROLLED:
// Still working...
return;
case policy::CloudPolicySubsystem::BAD_GAIA_TOKEN:
case policy::CloudPolicySubsystem::LOCAL_ERROR:
actor_->ShowFatalEnrollmentError();
break;
case policy::CloudPolicySubsystem::UNMANAGED:
actor_->ShowAccountError();
break;
case policy::CloudPolicySubsystem::NETWORK_ERROR:
actor_->ShowNetworkEnrollmentError();
break;
case policy::CloudPolicySubsystem::TOKEN_FETCHED:
WriteInstallAttributesData();
return;
case policy::CloudPolicySubsystem::SUCCESS:
// Success!
registrar_.reset();
UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,
policy::kMetricEnrollmentOK,
policy::kMetricEnrollmentSize);
actor_->ShowConfirmationScreen();
return;
}
// We have an error.
if (state == policy::CloudPolicySubsystem::UNMANAGED) {
UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,
policy::kMetricEnrollmentNotSupported,
policy::kMetricEnrollmentSize);
} else {
UMA_HISTOGRAM_ENUMERATION(policy::kMetricEnrollment,
policy::kMetricEnrollmentPolicyFailed,
policy::kMetricEnrollmentSize);
}
LOG(WARNING) << ""Policy subsystem error during enrollment: "" << state
<< "" details: "" << error_details;
}

// Stop the policy infrastructure.
registrar_.reset();
  g_browser_process->browser_policy_connector()->DeviceStopAutoRetry();
}
",[45],  g_browser_process->browser_policy_connector()->DeviceStopAutoRetry();
411,"Document* LocalDOMWindow::InstallNewDocument(const String& mime_type,
const DocumentInit& init,
bool force_xhtml) {
DCHECK_EQ(init.GetFrame(), GetFrame());

ClearDocument();

document_ = CreateDocument(mime_type, init, force_xhtml);
event_queue_ = DOMWindowEventQueue::Create(document_.Get());
document_->Initialize();

if (!GetFrame())
return document_;

GetFrame()->GetScriptController().UpdateDocument();
document_->UpdateViewportDescription();

if (GetFrame()->GetPage() && GetFrame()->View()) {
GetFrame()->GetPage()->GetChromeClient().InstallSupplements(*GetFrame());

if (ScrollingCoordinator* scrolling_coordinator =
GetFrame()->GetPage()->GetScrollingCoordinator()) {
scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
GetFrame()->View(), kHorizontalScrollbar);
scrolling_coordinator->ScrollableAreaScrollbarLayerDidChange(
GetFrame()->View(), kVerticalScrollbar);
scrolling_coordinator->ScrollableAreaScrollLayerDidChange(
GetFrame()->View());
}
}

  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
if (GetFrame()->IsCrossOriginSubframe())
document_->RecordDeferredLoadReason(WouldLoadReason::kCreated);

return document_;
}
",[24],  GetFrame()->Selection().UpdateSecureKeyboardEntryIfActive();
412,"txid_snapshot_recv(PG_FUNCTION_ARGS)
{
StringInfo	buf = (StringInfo) PG_GETARG_POINTER(0);
TxidSnapshot *snap;
txid		last = 0;
int			nxip;
int			i;
	int			avail;
	int			expect;
txid		xmin,
xmax;

	/*
	 * load nxip and check for nonsense.
	 *
	 * (nxip > avail) check is against int overflows in 'expect'.
	 *
nxip = pq_getmsgint(buf, 4);
	avail = buf->len - buf->cursor;
	expect = 8 + 8 + nxip * 8;
	if (nxip < 0 || nxip > avail || expect > avail)
goto bad_format;

xmin = pq_getmsgint64(buf);
xmax = pq_getmsgint64(buf);
if (xmin == 0 || xmax == 0 || xmin > xmax || xmax > MAX_TXID)
goto bad_format;

snap = palloc(TXID_SNAPSHOT_SIZE(nxip));
snap->xmin = xmin;
snap->xmax = xmax;
snap->nxip = nxip;
SET_VARSIZE(snap, TXID_SNAPSHOT_SIZE(nxip));

for (i = 0; i < nxip; i++)
{
txid		cur = pq_getmsgint64(buf);

if (cur <= last || cur < xmin || cur >= xmax)
goto bad_format;
snap->xip[i] = cur;
last = cur;
}
PG_RETURN_POINTER(snap);

bad_format:
elog(ERROR, ""invalid snapshot data"");
return (Datum) NULL;
}
","[18, 19, 20, 21, 22, 24, 25, 26]",	int			avail;/~/	int			expect;/~/	/*/~/	 * load nxip and check for nonsense./~/	 */~/	 * (nxip > avail) check is against int overflows in 'expect'./~/	 */~/	avail = buf->len - buf->cursor;/~/	expect = 8 + 8 + nxip * 8;/~/	if (nxip < 0 || nxip > avail || expect > avail)
413,"TEE_Result tee_mmu_check_access_rights(const struct user_ta_ctx *utc,
uint32_t flags, uaddr_t uaddr,
size_t len)
{
uaddr_t a;
size_t addr_incr = MIN(CORE_MMU_USER_CODE_SIZE,
CORE_MMU_USER_PARAM_SIZE);

	if (ADD_OVERFLOW(uaddr, len, &a))
return TEE_ERROR_ACCESS_DENIED;

if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
(flags & TEE_MEMORY_ACCESS_SECURE))
return TEE_ERROR_ACCESS_DENIED;

/*
* Rely on TA private memory test to check if address range is private
* to TA or not.
*/
if (!(flags & TEE_MEMORY_ACCESS_ANY_OWNER) &&
!tee_mmu_is_vbuf_inside_ta_private(utc, (void *)uaddr, len))
return TEE_ERROR_ACCESS_DENIED;

	for (a = uaddr; a < (uaddr + len); a += addr_incr) {
uint32_t attr;
TEE_Result res;

res = tee_mmu_user_va2pa_attr(utc, (void *)a, NULL, &attr);
if (res != TEE_SUCCESS)
return res;

if ((flags & TEE_MEMORY_ACCESS_NONSECURE) &&
(attr & TEE_MATTR_SECURE))
return TEE_ERROR_ACCESS_DENIED;

if ((flags & TEE_MEMORY_ACCESS_SECURE) &&
!(attr & TEE_MATTR_SECURE))
return TEE_ERROR_ACCESS_DENIED;

if ((flags & TEE_MEMORY_ACCESS_WRITE) && !(attr & TEE_MATTR_UW))
return TEE_ERROR_ACCESS_DENIED;
if ((flags & TEE_MEMORY_ACCESS_READ) && !(attr & TEE_MATTR_UR))
return TEE_ERROR_ACCESS_DENIED;
}

return TEE_SUCCESS;
}
","[7, 19]","	if (ADD_OVERFLOW(uaddr, len, &a))/~/	for (a = uaddr; a < (uaddr + len); a += addr_incr) {"
414,"static int futex_wait_requeue_pi(u32 __user *uaddr, int fshared,
u32 val, ktime_t *abs_time, u32 bitset,
int clockrt, u32 __user *uaddr2)
{
struct hrtimer_sleeper timeout, *to = NULL;
struct rt_mutex_waiter rt_waiter;
struct rt_mutex *pi_mutex = NULL;
struct futex_hash_bucket *hb;
union futex_key key2;
struct futex_q q;
int res, ret;

if (!bitset)
return -EINVAL;

if (abs_time) {
to = &timeout;
hrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :
CLOCK_MONOTONIC, HRTIMER_MODE_ABS);
hrtimer_init_sleeper(to, current);
hrtimer_set_expires_range_ns(&to->timer, *abs_time,
current->timer_slack_ns);
}

/*
* The waiter is allocated on our stack, manipulated by the requeue
* code while we sleep on uaddr.
*/
debug_rt_mutex_init_waiter(&rt_waiter);
rt_waiter.task = NULL;

key2 = FUTEX_KEY_INIT;
ret = get_futex_key(uaddr2, fshared, &key2);
if (unlikely(ret != 0))
goto out;

q.pi_state = NULL;
q.bitset = bitset;
q.rt_waiter = &rt_waiter;
q.requeue_pi_key = &key2;

	/* Prepare to wait on uaddr. *
ret = futex_wait_setup(uaddr, val, fshared, &q, &hb);
if (ret)
goto out_key2;

/* Queue the futex_q, drop the hb lock, wait for wakeup. */
futex_wait_queue_me(hb, &q, to);

spin_lock(&hb->lock);
ret = handle_early_requeue_pi_wakeup(hb, &q, &key2, to);
spin_unlock(&hb->lock);
if (ret)
goto out_put_keys;

/*
* In order for us to be here, we know our q.key == key2, and since
* we took the hb->lock above, we also know that futex_requeue() has
* completed and we no longer have to concern ourselves with a wakeup
	 * race with the atomic proxy lock acquition by the requeue code.
*/

/* Check if the requeue code acquired the second futex for us. */
if (!q.rt_waiter) {
/*
* Got the lock. We might not be the anticipated owner if we
* did a lock-steal - fix up the PI-state in that case.
*/
if (q.pi_state && (q.pi_state->owner != current)) {
spin_lock(q.lock_ptr);
ret = fixup_pi_state_owner(uaddr2, &q, current,
fshared);
spin_unlock(q.lock_ptr);
}
} else {
/*
* We have been woken up by futex_unlock_pi(), a timeout, or a
* signal.  futex_unlock_pi() will not destroy the lock_ptr nor
* the pi_state.
*/
WARN_ON(!&q.pi_state);
pi_mutex = &q.pi_state->pi_mutex;
ret = rt_mutex_finish_proxy_lock(pi_mutex, to, &rt_waiter, 1);
debug_rt_mutex_free_waiter(&rt_waiter);

spin_lock(q.lock_ptr);
/*
* Fixup the pi_state owner and possibly acquire the lock if we
* haven't already.
*/
res = fixup_owner(uaddr2, fshared, &q, !ret);
/*
* If fixup_owner() returned an error, proprogate that.  If it
* acquired the lock, clear -ETIMEDOUT or -EINTR.
*/
if (res)
ret = (res < 0) ? res : 0;

/* Unqueue and drop the lock. */
unqueue_me_pi(&q);
}

/*
* If fixup_pi_state_owner() faulted and was unable to handle the
* fault, unlock the rt_mutex and return the fault to userspace.
*/
if (ret == -EFAULT) {
if (rt_mutex_owner(pi_mutex) == current)
rt_mutex_unlock(pi_mutex);
} else if (ret == -EINTR) {
/*
* We've already been requeued, but cannot restart by calling
* futex_lock_pi() directly. We could restart this syscall, but
* it would detect that the user space ""val"" changed and return
* -EWOULDBLOCK.  Save the overhead of the restart and return
* -EWOULDBLOCK directly.
*/
ret = -EWOULDBLOCK;
}

out_put_keys:
put_futex_key(fshared, &q.key);
out_key2:
put_futex_key(fshared, &key2);

out:
if (to) {
hrtimer_cancel(&to->timer);
destroy_hrtimer_on_stack(&to->timer);
}
return ret;
}
",[35],	/* Prepare to wait on uaddr. */~/	 * race with the atomic proxy lock acquition by the requeue code.
415,"horDiff8(TIFF* tif, uint8* cp0, tmsize_t cc)
{
TIFFPredictorState* sp = PredictorState(tif);
tmsize_t stride = sp->stride;
unsigned char* cp = (unsigned char*) cp0;

	assert((cc%stride)==0);

if (cc > stride) {
cc -= stride;
/*
* Pipeline the most common cases.
*/
if (stride == 3) {
unsigned int r1, g1, b1;
unsigned int r2 = cp[0];
unsigned int g2 = cp[1];
unsigned  int b2 = cp[2];
do {
r1 = cp[3]; cp[3] = (unsigned char)((r1-r2)&0xff); r2 = r1;
g1 = cp[4]; cp[4] = (unsigned char)((g1-g2)&0xff); g2 = g1;
b1 = cp[5]; cp[5] = (unsigned char)((b1-b2)&0xff); b2 = b1;
cp += 3;
} while ((cc -= 3) > 0);
} else if (stride == 4) {
unsigned int r1, g1, b1, a1;
unsigned int r2 = cp[0];
unsigned int g2 = cp[1];
unsigned int b2 = cp[2];
unsigned int a2 = cp[3];
do {
r1 = cp[4]; cp[4] = (unsigned char)((r1-r2)&0xff); r2 = r1;
g1 = cp[5]; cp[5] = (unsigned char)((g1-g2)&0xff); g2 = g1;
b1 = cp[6]; cp[6] = (unsigned char)((b1-b2)&0xff); b2 = b1;
a1 = cp[7]; cp[7] = (unsigned char)((a1-a2)&0xff); a2 = a1;
cp += 4;
} while ((cc -= 4) > 0);
} else {
cp += cc - 1;
do {
REPEAT4(stride, cp[stride] = (unsigned char)((cp[stride] - cp[0])&0xff); cp--)
} while ((cc -= stride) > 0);
}
}
}
",[5],	assert((cc%stride)==0);
416,"acc_ctx_cont(OM_uint32 *minstat,
gss_buffer_t buf,
gss_ctx_id_t *ctx,
gss_buffer_t *responseToken,
gss_buffer_t *mechListMIC,
OM_uint32 *negState,
send_token_flag *return_token)
{
OM_uint32 ret, tmpmin;
gss_OID supportedMech;
spnego_gss_ctx_id_t sc;
unsigned int len;
unsigned char *ptr, *bufstart;

sc = (spnego_gss_ctx_id_t)*ctx;
ret = GSS_S_DEFECTIVE_TOKEN;
*negState = REJECT;
*minstat = 0;
supportedMech = GSS_C_NO_OID;
*return_token = ERROR_TOKEN_SEND;
*responseToken = *mechListMIC = GSS_C_NO_BUFFER;

ptr = bufstart = buf->value;
#define REMAIN (buf->length - (ptr - bufstart))
	if (REMAIN > INT_MAX)
return GSS_S_DEFECTIVE_TOKEN;

/*
* Attempt to work with old Sun SPNEGO.
*/
if (*ptr == HEADER_ID) {
ret = g_verify_token_header(gss_mech_spnego,
&len, &ptr, 0, REMAIN);
if (ret) {
*minstat = ret;
return GSS_S_DEFECTIVE_TOKEN;
}
}
if (*ptr != (CONTEXT | 0x01)) {
return GSS_S_DEFECTIVE_TOKEN;
}
ret = get_negTokenResp(minstat, ptr, REMAIN,
negState, &supportedMech,
responseToken, mechListMIC);
if (ret != GSS_S_COMPLETE)
goto cleanup;

if (*responseToken == GSS_C_NO_BUFFER &&
*mechListMIC == GSS_C_NO_BUFFER) {

ret = GSS_S_DEFECTIVE_TOKEN;
goto cleanup;
}
if (supportedMech != GSS_C_NO_OID) {
ret = GSS_S_DEFECTIVE_TOKEN;
goto cleanup;
}
sc->firstpass = 0;
*negState = ACCEPT_INCOMPLETE;
*return_token = CONT_TOKEN_SEND;
cleanup:
if (supportedMech != GSS_C_NO_OID) {
generic_gss_release_oid(&tmpmin, &supportedMech);
}
return ret;
#undef REMAIN
}
",[22],	if (REMAIN > INT_MAX)
417,"static int raw_cmd_copyin(int cmd, void __user *param,
struct floppy_raw_cmd **rcmd)
{
struct floppy_raw_cmd *ptr;
int ret;
int i;

*rcmd = NULL;

loop:
ptr = kmalloc(sizeof(struct floppy_raw_cmd), GFP_USER);
if (!ptr)
return -ENOMEM;
*rcmd = ptr;
ret = copy_from_user(ptr, param, sizeof(*ptr));
	if (ret)
		return -EFAULT;
ptr->next = NULL;
ptr->buffer_length = 0;
param += sizeof(struct floppy_raw_cmd);
if (ptr->cmd_count > 33)
/* the command may now also take up the space
* initially intended for the reply & the
* reply count. Needed for long 82078 commands
* such as RESTORE, which takes ... 17 command
* bytes. Murphy's law #137: When you reserve
* 16 bytes for a structure, you'll one day
* discover that you really need 17...
*/
return -EINVAL;

for (i = 0; i < 16; i++)
ptr->reply[i] = 0;
ptr->resultcode = 0;
	ptr->kernel_data = NULL;

if (ptr->flags & (FD_RAW_READ | FD_RAW_WRITE)) {
if (ptr->length <= 0)
return -EINVAL;
ptr->kernel_data = (char *)fd_dma_mem_alloc(ptr->length);
fallback_on_nodma_alloc(&ptr->kernel_data, ptr->length);
if (!ptr->kernel_data)
return -ENOMEM;
ptr->buffer_length = ptr->length;
}
if (ptr->flags & FD_RAW_WRITE) {
ret = fd_copyin(ptr->data, ptr->kernel_data, ptr->length);
if (ret)
return ret;
}

if (ptr->flags & FD_RAW_MORE) {
rcmd = &(ptr->next);
ptr->rate &= 0x43;
goto loop;
}

return 0;
}
","[13, 14, 31, 43]",	if (ret)/~/		return -EFAULT;/~/	ptr->kernel_data = NULL;
418,"static ps_sd *ps_sd_new(ps_mm *data, const char *key)
{
php_uint32 hv, slot;
ps_sd *sd;
int keylen;

keylen = strlen(key);

sd = mm_malloc(data->mm, sizeof(ps_sd) + keylen);
if (!sd) {
TSRMLS_FETCH();

               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mm_malloc failed, avail %d, err %s"", mm_available(data->mm), mm_error());
return NULL;
}

hv = ps_sd_hash(key, keylen);
slot = hv & data->hash_max;

sd->ctime = 0;
sd->hv = hv;
sd->data = NULL;
sd->alloclen = sd->datalen = 0;

memcpy(sd->key, key, keylen + 1);

sd->next = data->hash[slot];
data->hash[slot] = sd;

data->hash_cnt++;

if (!sd->next) {
if (data->hash_cnt >= data->hash_max) {
hash_split(data);
}
}

ps_mm_debug((""inserting %s(%p) into slot %d\n"", key, sd, slot));

return sd;
}
",[9],"               php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mm_malloc failed, avail %d, err %s"", mm_available(data->mm), mm_error());"
419,"static int adjust_scalar_min_max_vals(struct bpf_verifier_env *env,
struct bpf_insn *insn,
struct bpf_reg_state *dst_reg,
struct bpf_reg_state src_reg)
{
struct bpf_reg_state *regs = cur_regs(env);
u8 opcode = BPF_OP(insn->code);
bool src_known, dst_known;
s64 smin_val, smax_val;
u64 umin_val, umax_val;

if (BPF_CLASS(insn->code) != BPF_ALU64) {
/* 32-bit ALU ops are (32,32)->64 */
		coerce_reg_to_32(dst_reg);
		coerce_reg_to_32(&src_reg);
}
smin_val = src_reg.smin_value;
smax_val = src_reg.smax_value;
umin_val = src_reg.umin_value;
umax_val = src_reg.umax_value;
src_known = tnum_is_const(src_reg.var_off);
dst_known = tnum_is_const(dst_reg->var_off);

switch (opcode) {
case BPF_ADD:
if (signed_add_overflows(dst_reg->smin_value, smin_val) ||
signed_add_overflows(dst_reg->smax_value, smax_val)) {
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value += smin_val;
dst_reg->smax_value += smax_val;
}
if (dst_reg->umin_value + umin_val < umin_val ||
dst_reg->umax_value + umax_val < umax_val) {
dst_reg->umin_value = 0;
dst_reg->umax_value = U64_MAX;
} else {
dst_reg->umin_value += umin_val;
dst_reg->umax_value += umax_val;
}
dst_reg->var_off = tnum_add(dst_reg->var_off, src_reg.var_off);
break;
case BPF_SUB:
if (signed_sub_overflows(dst_reg->smin_value, smax_val) ||
signed_sub_overflows(dst_reg->smax_value, smin_val)) {
/* Overflow possible, we know nothing */
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value -= smax_val;
dst_reg->smax_value -= smin_val;
}
if (dst_reg->umin_value < umax_val) {
/* Overflow possible, we know nothing */
dst_reg->umin_value = 0;
dst_reg->umax_value = U64_MAX;
} else {
/* Cannot overflow (as long as bounds are consistent) */
dst_reg->umin_value -= umax_val;
dst_reg->umax_value -= umin_val;
}
dst_reg->var_off = tnum_sub(dst_reg->var_off, src_reg.var_off);
break;
case BPF_MUL:
dst_reg->var_off = tnum_mul(dst_reg->var_off, src_reg.var_off);
if (smin_val < 0 || dst_reg->smin_value < 0) {
/* Ain't nobody got time to multiply that sign */
__mark_reg_unbounded(dst_reg);
__update_reg_bounds(dst_reg);
break;
}
/* Both values are positive, so we can work with unsigned and
* copy the result to signed (unless it exceeds S64_MAX).
*/
if (umax_val > U32_MAX || dst_reg->umax_value > U32_MAX) {
/* Potential overflow, we know nothing */
__mark_reg_unbounded(dst_reg);
/* (except what we can learn from the var_off) */
__update_reg_bounds(dst_reg);
break;
}
dst_reg->umin_value *= umin_val;
dst_reg->umax_value *= umax_val;
if (dst_reg->umax_value > S64_MAX) {
/* Overflow possible, we know nothing */
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
dst_reg->smin_value = dst_reg->umin_value;
dst_reg->smax_value = dst_reg->umax_value;
}
break;
case BPF_AND:
if (src_known && dst_known) {
__mark_reg_known(dst_reg, dst_reg->var_off.value &
src_reg.var_off.value);
break;
}
/* We get our minimum from the var_off, since that's inherently
* bitwise.  Our maximum is the minimum of the operands' maxima.
*/
dst_reg->var_off = tnum_and(dst_reg->var_off, src_reg.var_off);
dst_reg->umin_value = dst_reg->var_off.value;
dst_reg->umax_value = min(dst_reg->umax_value, umax_val);
if (dst_reg->smin_value < 0 || smin_val < 0) {
/* Lose signed bounds when ANDing negative numbers,
* ain't nobody got time for that.
*/
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
/* ANDing two positives gives a positive, so safe to
* cast result into s64.
*/
dst_reg->smin_value = dst_reg->umin_value;
dst_reg->smax_value = dst_reg->umax_value;
}
/* We may learn something more from the var_off */
__update_reg_bounds(dst_reg);
break;
case BPF_OR:
if (src_known && dst_known) {
__mark_reg_known(dst_reg, dst_reg->var_off.value |
src_reg.var_off.value);
break;
}
/* We get our maximum from the var_off, and our minimum is the
* maximum of the operands' minima
*/
dst_reg->var_off = tnum_or(dst_reg->var_off, src_reg.var_off);
dst_reg->umin_value = max(dst_reg->umin_value, umin_val);
dst_reg->umax_value = dst_reg->var_off.value |
dst_reg->var_off.mask;
if (dst_reg->smin_value < 0 || smin_val < 0) {
/* Lose signed bounds when ORing negative numbers,
* ain't nobody got time for that.
*/
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
} else {
/* ORing two positives gives a positive, so safe to
* cast result into s64.
*/
dst_reg->smin_value = dst_reg->umin_value;
dst_reg->smax_value = dst_reg->umax_value;
}
/* We may learn something more from the var_off */
__update_reg_bounds(dst_reg);
break;
case BPF_LSH:
if (umax_val > 63) {
/* Shifts greater than 63 are undefined.  This includes
* shifts by a negative number.
*/
mark_reg_unknown(env, regs, insn->dst_reg);
break;
}
/* We lose all sign bit information (except what we can pick
* up from var_off)
*/
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
/* If we might shift our top bit out, then we know nothing */
if (dst_reg->umax_value > 1ULL << (63 - umax_val)) {
dst_reg->umin_value = 0;
dst_reg->umax_value = U64_MAX;
} else {
dst_reg->umin_value <<= umin_val;
dst_reg->umax_value <<= umax_val;
}
if (src_known)
dst_reg->var_off = tnum_lshift(dst_reg->var_off, umin_val);
else
dst_reg->var_off = tnum_lshift(tnum_unknown, umin_val);
/* We may learn something more from the var_off */
__update_reg_bounds(dst_reg);
break;
case BPF_RSH:
if (umax_val > 63) {
/* Shifts greater than 63 are undefined.  This includes
* shifts by a negative number.
*/
mark_reg_unknown(env, regs, insn->dst_reg);
break;
}
/* BPF_RSH is an unsigned shift.  If the value in dst_reg might
* be negative, then either:
* 1) src_reg might be zero, so the sign bit of the result is
*    unknown, so we lose our signed bounds
* 2) it's known negative, thus the unsigned bounds capture the
*    signed bounds
* 3) the signed bounds cross zero, so they tell us nothing
*    about the result
* If the value in dst_reg is known nonnegative, then again the
* unsigned bounts capture the signed bounds.
* Thus, in all cases it suffices to blow away our signed bounds
* and rely on inferring new ones from the unsigned bounds and
* var_off of the result.
*/
dst_reg->smin_value = S64_MIN;
dst_reg->smax_value = S64_MAX;
if (src_known)
dst_reg->var_off = tnum_rshift(dst_reg->var_off,
umin_val);
else
dst_reg->var_off = tnum_rshift(tnum_unknown, umin_val);
dst_reg->umin_value >>= umax_val;
dst_reg->umax_value >>= umin_val;
/* We may learn something more from the var_off */
__update_reg_bounds(dst_reg);
break;
default:
mark_reg_unknown(env, regs, insn->dst_reg);
break;
}

__reg_deduce_bounds(dst_reg);
__reg_bound_offset(dst_reg);
return 0;
}
","[12, 13]",		coerce_reg_to_32(dst_reg);/~/		coerce_reg_to_32(&src_reg);
420,"static void php_wddx_pop_element(void *user_data, const XML_Char *name)
{
st_entry 			*ent1, *ent2;
wddx_stack 			*stack = (wddx_stack *)user_data;
HashTable 			*target_hash;
zend_class_entry 	**pce;
zval				*obj;
zval				*tmp;
TSRMLS_FETCH();

/* OBJECTS_FIXME */
if (stack->top == 0) {
return;
}

if (!strcmp(name, EL_STRING) || !strcmp(name, EL_NUMBER) ||
!strcmp(name, EL_BOOLEAN) || !strcmp(name, EL_NULL) ||
!strcmp(name, EL_ARRAY) || !strcmp(name, EL_STRUCT) ||
!strcmp(name, EL_RECORDSET) || !strcmp(name, EL_BINARY) ||
!strcmp(name, EL_DATETIME)) {
wddx_stack_top(stack, (void**)&ent1);

if (!ent1->data) {
if (stack->top > 1) {
stack->top--;
} else {
stack->done = 1;
}
			efree(ent1);
return;
}

if (!strcmp(name, EL_BINARY)) {
int new_len=0;
unsigned char *new_str;

new_str = php_base64_decode(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data), &new_len);
STR_FREE(Z_STRVAL_P(ent1->data));
if (new_str) {
Z_STRVAL_P(ent1->data) = new_str;
Z_STRLEN_P(ent1->data) = new_len;
} else {
ZVAL_EMPTY_STRING(ent1->data);
}
}

/* Call __wakeup() method on the object. */
if (Z_TYPE_P(ent1->data) == IS_OBJECT) {
zval *fname, *retval = NULL;

MAKE_STD_ZVAL(fname);
ZVAL_STRING(fname, ""__wakeup"", 1);

call_user_function_ex(NULL, &ent1->data, fname, &retval, 0, 0, 0, NULL TSRMLS_CC);

zval_dtor(fname);
FREE_ZVAL(fname);
if (retval) {
zval_ptr_dtor(&retval);
}
}

if (stack->top > 1) {
stack->top--;
wddx_stack_top(stack, (void**)&ent2);

/* if non-existent field */
			if (ent2->type == ST_FIELD && ent2->data == NULL) {
zval_ptr_dtor(&ent1->data);
efree(ent1);
return;
}

if (Z_TYPE_P(ent2->data) == IS_ARRAY || Z_TYPE_P(ent2->data) == IS_OBJECT) {
target_hash = HASH_OF(ent2->data);

if (ent1->varname) {
if (!strcmp(ent1->varname, PHP_CLASS_NAME_VAR) &&
Z_TYPE_P(ent1->data) == IS_STRING && Z_STRLEN_P(ent1->data) &&
ent2->type == ST_STRUCT && Z_TYPE_P(ent2->data) == IS_ARRAY) {
zend_bool incomplete_class = 0;

zend_str_tolower(Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
if (zend_hash_find(EG(class_table), Z_STRVAL_P(ent1->data),
Z_STRLEN_P(ent1->data)+1, (void **) &pce)==FAILURE) {
incomplete_class = 1;
pce = &PHP_IC_ENTRY;
}

/* Initialize target object */
MAKE_STD_ZVAL(obj);
object_init_ex(obj, *pce);

/* Merge current hashtable with object's default properties */
zend_hash_merge(Z_OBJPROP_P(obj),
Z_ARRVAL_P(ent2->data),
(void (*)(void *)) zval_add_ref,
(void *) &tmp, sizeof(zval *), 0);

if (incomplete_class) {
php_store_class_name(obj, Z_STRVAL_P(ent1->data), Z_STRLEN_P(ent1->data));
}

/* Clean up old array entry */
zval_ptr_dtor(&ent2->data);

/* Set stack entry to point to the newly created object */
ent2->data = obj;

/* Clean up class name var entry */
zval_ptr_dtor(&ent1->data);
} else if (Z_TYPE_P(ent2->data) == IS_OBJECT) {
zend_class_entry *old_scope = EG(scope);

EG(scope) = Z_OBJCE_P(ent2->data);
Z_DELREF_P(ent1->data);
add_property_zval(ent2->data, ent1->varname, ent1->data);
EG(scope) = old_scope;
} else {
zend_symtable_update(target_hash, ent1->varname, strlen(ent1->varname)+1, &ent1->data, sizeof(zval *), NULL);
}
efree(ent1->varname);
} else	{
zend_hash_next_index_insert(target_hash, &ent1->data, sizeof(zval *), NULL);
}
}
efree(ent1);
} else {
stack->done = 1;
}
} else if (!strcmp(name, EL_VAR) && stack->varname) {
efree(stack->varname);
stack->varname = NULL;
} else if (!strcmp(name, EL_FIELD)) {
st_entry *ent;
wddx_stack_top(stack, (void **)&ent);
efree(ent);
stack->top--;
}
}
",[31],			efree(ent1);/~/			if (ent2->type == ST_FIELD && ent2->data == NULL) {
421,"void DevToolsDownloadManagerDelegate::OnDownloadPathGenerated(
uint32_t download_id,
const content::DownloadTargetCallback& callback,
const base::FilePath& suggested_path) {
DCHECK_CURRENTLY_ON(content::BrowserThread::UI);

callback.Run(suggested_path,
content::DownloadItem::TARGET_DISPOSITION_OVERWRITE,
               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,
suggested_path.AddExtension(FILE_PATH_LITERAL("".crdownload"")),
content::DOWNLOAD_INTERRUPT_REASON_NONE);
}
",[7],"               download::DOWNLOAD_DANGER_TYPE_NOT_DANGEROUS,"
422,"set_text_distance(gs_point *pdist, double dx, double dy, const gs_matrix *pmat)
{
    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);
double rounded;

if (code == gs_error_undefinedresult) {
/* The CTM is degenerate.
Can't know the distance in user space.
} else if (code < 0)
return code;
/* If the distance is very close to integers, round it. */
if (fabs(pdist->x - (rounded = floor(pdist->x + 0.5))) < 0.0005)
pdist->x = rounded;
if (fabs(pdist->y - (rounded = floor(pdist->y + 0.5))) < 0.0005)
pdist->y = rounded;
return 0;
}
",[2],"    int code = gs_distance_transform_inverse(dx, dy, pmat, pdist);"
423,"parse_field(netdissect_options *ndo, const char **pptr, int *len)
{
const char *s;

    if (*len <= 0 || !pptr || !*pptr)
	return NULL;
    if (*pptr > (const char *) ndo->ndo_snapend)
	return NULL;
s = *pptr;
    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {
(*pptr)++;
(*len)--;
}
(*pptr)++;
(*len)--;
    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)
	return NULL;
return s;
}
","[3, 4, 5, 6, 8, 14, 15]",    if (*len <= 0 || !pptr || !*pptr)/~/	return NULL;/~/    if (*pptr > (const char *) ndo->ndo_snapend)/~/	return NULL;/~/    while (*pptr <= (const char *) ndo->ndo_snapend && *len >= 0 && **pptr) {/~/    if (*len < 0 || *pptr > (const char *) ndo->ndo_snapend)/~/	return NULL;
424,"static int crypto_report_one(struct crypto_alg *alg,
struct crypto_user_alg *ualg, struct sk_buff *skb)
{
	strlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));
	strlcpy(ualg->cru_driver_name, alg->cra_driver_name,
sizeof(ualg->cru_driver_name));
	strlcpy(ualg->cru_module_name, module_name(alg->cra_module),
sizeof(ualg->cru_module_name));

ualg->cru_type = 0;
ualg->cru_mask = 0;
ualg->cru_flags = alg->cra_flags;
ualg->cru_refcnt = refcount_read(&alg->cra_refcnt);

if (nla_put_u32(skb, CRYPTOCFGA_PRIORITY_VAL, alg->cra_priority))
goto nla_put_failure;
if (alg->cra_flags & CRYPTO_ALG_LARVAL) {
struct crypto_report_larval rl;

		strlcpy(rl.type, ""larval"", sizeof(rl.type));
if (nla_put(skb, CRYPTOCFGA_REPORT_LARVAL,
sizeof(struct crypto_report_larval), &rl))
goto nla_put_failure;
goto out;
}

if (alg->cra_type && alg->cra_type->report) {
if (alg->cra_type->report(skb, alg))
goto nla_put_failure;

goto out;
}

switch (alg->cra_flags & (CRYPTO_ALG_TYPE_MASK | CRYPTO_ALG_LARVAL)) {
case CRYPTO_ALG_TYPE_CIPHER:
if (crypto_report_cipher(skb, alg))
goto nla_put_failure;

break;
case CRYPTO_ALG_TYPE_COMPRESS:
if (crypto_report_comp(skb, alg))
goto nla_put_failure;

break;
case CRYPTO_ALG_TYPE_ACOMPRESS:
if (crypto_report_acomp(skb, alg))
goto nla_put_failure;

break;
case CRYPTO_ALG_TYPE_AKCIPHER:
if (crypto_report_akcipher(skb, alg))
goto nla_put_failure;

break;
case CRYPTO_ALG_TYPE_KPP:
if (crypto_report_kpp(skb, alg))
goto nla_put_failure;
break;
}

out:
return 0;

nla_put_failure:
return -EMSGSIZE;
}
","[3, 4, 6, 16]","	strlcpy(ualg->cru_name, alg->cra_name, sizeof(ualg->cru_name));/~/	strlcpy(ualg->cru_driver_name, alg->cra_driver_name,/~/	strlcpy(ualg->cru_module_name, module_name(alg->cra_module),/~/		strlcpy(rl.type, ""larval"", sizeof(rl.type));"
425,"EffectPaintPropertyNode* EffectPaintPropertyNode::Root() {
  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,
                    (EffectPaintPropertyNode::Create(
                        nullptr, State{TransformPaintPropertyNode::Root(),
                                       ClipPaintPropertyNode::Root()})));
return root;
}
","[1, 2, 3, 4]","  DEFINE_STATIC_REF(EffectPaintPropertyNode, root,/~/                    (EffectPaintPropertyNode::Create(/~/                        nullptr, State{TransformPaintPropertyNode::Root(),/~/                                       ClipPaintPropertyNode::Root()})));"
426,"void WebGL2RenderingContextBase::deleteVertexArray(
WebGLVertexArrayObject* vertex_array) {
  if (isContextLost() || !vertex_array)
return;

if (!vertex_array->IsDefaultObject() &&
vertex_array == bound_vertex_array_object_)
SetBoundVertexArrayObject(nullptr);

vertex_array->DeleteObject(ContextGL());
}
",[2],  if (isContextLost() || !vertex_array)
427,"my_object_str_hash_len (MyObject *obj, GHashTable *table, guint *len, GError **error)
{
  *len = 0;
  g_hash_table_foreach (table, hash_foreach, len);
  return TRUE;
}
","[1, 2, 3, 4, 5]","{/~/  *len = 0;/~/  g_hash_table_foreach (table, hash_foreach, len);/~/  return TRUE;/~/}"
428,"bool AutofillDownloadManager::StartUploadRequest(
const FormStructure& form,
bool form_was_autofilled,
const FieldTypeSet& available_field_types) {
if (next_upload_request_ > base::Time::Now()) {
// We are in back-off mode: do not do the request.
VLOG(1) << ""AutofillDownloadManager: Upload request is throttled."";
return false;
}

// Flip a coin to see if we should upload this form.
double upload_rate = form_was_autofilled ? GetPositiveUploadRate() :
GetNegativeUploadRate();
  if (base::RandDouble() > upload_rate) {
VLOG(1) << ""AutofillDownloadManager: Upload request is ignored."";
// If we ever need notification that upload was skipped, add it here.
return false;
}

std::string form_xml;
if (!form.EncodeUploadRequest(available_field_types, form_was_autofilled,
&form_xml))
return false;

FormRequestData request_data;
request_data.form_signatures.push_back(form.FormSignature());
request_data.request_type = AutofillDownloadManager::REQUEST_UPLOAD;

return StartRequest(form_xml, request_data);
}
",[12],  if (base::RandDouble() > upload_rate) {
429,"XGetDeviceControl(
register Display	*dpy,
XDevice		*dev,
int			 control)
{
XDeviceControl *Device = NULL;
XDeviceControl *Sav = NULL;
xDeviceState *d = NULL;
xDeviceState *sav = NULL;
xGetDeviceControlReq *req;
xGetDeviceControlReply rep;
XExtDisplayInfo *info = XInput_find_display(dpy);

LockDisplay(dpy);
if (_XiCheckExtInit(dpy, XInput_Add_XChangeDeviceControl, info) == -1)
return NULL;

GetReq(GetDeviceControl, req);
req->reqType = info->codes->major_opcode;
req->ReqType = X_GetDeviceControl;
req->deviceid = dev->device_id;
req->control = control;

if (!_XReply(dpy, (xReply *) & rep, 0, xFalse))
goto out;

if (rep.length > 0) {
unsigned long nbytes;
size_t size = 0;
	if (rep.length < (INT_MAX >> 2)) {
nbytes = (unsigned long) rep.length << 2;
d = Xmalloc(nbytes);
}
_XEatDataWords(dpy, rep.length);
goto out;
}
sav = d;
_XRead(dpy, (char *)d, nbytes);

/* In theory, we should just be able to use d->length to get the size.
* Turns out that a number of X servers (up to and including server
* 1.4) sent the wrong length value down the wire. So to not break
* apps that run against older servers, we have to calculate the size
* manually.
*/
switch (d->control) {
case DEVICE_RESOLUTION:
{
xDeviceResolutionState *r;
size_t val_size;
size_t val_size;

r = (xDeviceResolutionState *) d;
	    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))
goto out;
val_size = 3 * sizeof(int) * r->num_valuators;
if ((sizeof(xDeviceResolutionState) + val_size) > nbytes)
break;
}
case DEVICE_ABS_CALIB:
{
if (sizeof(xDeviceAbsCalibState) > nbytes)
goto out;
size = sizeof(XDeviceAbsCalibState);
break;
}
case DEVICE_ABS_AREA:
{
if (sizeof(xDeviceAbsAreaState) > nbytes)
goto out;
size = sizeof(XDeviceAbsAreaState);
break;
}
case DEVICE_CORE:
{
if (sizeof(xDeviceCoreState) > nbytes)
goto out;
size = sizeof(XDeviceCoreState);
break;
}
default:
if (d->length > nbytes)
goto out;
size = d->length;
break;
}

Device = Xmalloc(size);
if (!Device)
goto out;

Sav = Device;

d = sav;
switch (control) {
case DEVICE_RESOLUTION:
{
int *iptr, *iptr2;
xDeviceResolutionState *r;
XDeviceResolutionState *R;
unsigned int i;

r = (xDeviceResolutionState *) d;
R = (XDeviceResolutionState *) Device;

R->control = DEVICE_RESOLUTION;
R->length = sizeof(XDeviceResolutionState);
R->num_valuators = r->num_valuators;
iptr = (int *)(R + 1);
iptr2 = (int *)(r + 1);
R->resolutions = iptr;
R->min_resolutions = iptr + R->num_valuators;
R->max_resolutions = iptr + (2 * R->num_valuators);
for (i = 0; i < (3 * R->num_valuators); i++)
*iptr++ = *iptr2++;
break;
}
case DEVICE_ABS_CALIB:
{
xDeviceAbsCalibState *c = (xDeviceAbsCalibState *) d;
XDeviceAbsCalibState *C = (XDeviceAbsCalibState *) Device;

C->control = DEVICE_ABS_CALIB;
C->length = sizeof(XDeviceAbsCalibState);
C->min_x = c->min_x;
C->max_x = c->max_x;
C->min_y = c->min_y;
C->max_y = c->max_y;
C->flip_x = c->flip_x;
C->flip_y = c->flip_y;
C->rotation = c->rotation;
C->button_threshold = c->button_threshold;

break;
}
case DEVICE_ABS_AREA:
{
xDeviceAbsAreaState *a = (xDeviceAbsAreaState *) d;
XDeviceAbsAreaState *A = (XDeviceAbsAreaState *) Device;

A->control = DEVICE_ABS_AREA;
A->length = sizeof(XDeviceAbsAreaState);
A->offset_x = a->offset_x;
A->offset_y = a->offset_y;
A->width = a->width;
A->height = a->height;
A->screen = a->screen;
A->following = a->following;

break;
}
case DEVICE_CORE:
{
xDeviceCoreState *c = (xDeviceCoreState *) d;
XDeviceCoreState *C = (XDeviceCoreState *) Device;

C->control = DEVICE_CORE;
C->length = sizeof(XDeviceCoreState);
C->status = c->status;
C->iscore = c->iscore;

break;
}
case DEVICE_ENABLE:
{
xDeviceEnableState *e = (xDeviceEnableState *) d;
XDeviceEnableState *E = (XDeviceEnableState *) Device;

E->control = DEVICE_ENABLE;
E->length = sizeof(E);
E->enable = e->enable;

break;
}
default:
break;
}
}
","[28, 50]",	if (rep.length < (INT_MAX >> 2)) {/~/	    if (r->num_valuators >= (INT_MAX / (3 * sizeof(int))))
430,"status_t OMXNodeInstance::allocateBufferWithBackup(
OMX_U32 portIndex, const sp<IMemory> &params,
OMX::buffer_id *buffer, OMX_U32 allottedSize) {
Mutex::Autolock autoLock(mLock);
if (allottedSize > params->size()) {

return BAD_VALUE;
}

    BufferMeta *buffer_meta = new BufferMeta(params, true);

OMX_BUFFERHEADERTYPE *header;

OMX_ERRORTYPE err = OMX_AllocateBuffer(
mHandle, &header, portIndex, buffer_meta, allottedSize);
if (err != OMX_ErrorNone) {
CLOG_ERROR(allocateBufferWithBackup, err,
SIMPLE_BUFFER(portIndex, (size_t)allottedSize, params->pointer()));
delete buffer_meta;
buffer_meta = NULL;

*buffer = 0;

return StatusFromOMXError(err);
}

CHECK_EQ(header->pAppPrivate, buffer_meta);

*buffer = makeBufferID(header);

addActiveBuffer(portIndex, *buffer);

sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
if (bufferSource != NULL && portIndex == kPortIndexInput) {
bufferSource->addCodecBuffer(header);
}

CLOG_BUFFER(allocateBufferWithBackup, NEW_BUFFER_FMT(*buffer, portIndex, ""%zu@%p :> %u@%p"",
params->size(), params->pointer(), allottedSize, header->pBuffer));

return OK;
}
",[7],"    BufferMeta *buffer_meta = new BufferMeta(params, true);"
431,"static zval *xml_call_handler(xml_parser *parser, zval *handler, zend_function *function_ptr, int argc, zval **argv)
{
       int i;  
TSRMLS_FETCH();

if (parser && handler && !EG(exception)) {
zval ***args;
zval *retval;
int result;
zend_fcall_info fci;

args = safe_emalloc(sizeof(zval **), argc, 0);
for (i = 0; i < argc; i++) {
args[i] = &argv[i];
}
               
fci.size = sizeof(fci);
fci.function_table = EG(function_table);
fci.function_name = handler;
fci.symbol_table = NULL;
fci.object_ptr = parser->object;
fci.retval_ptr_ptr = &retval;
fci.param_count = argc;
fci.params = args;
fci.no_separation = 0;
/*fci.function_handler_cache = &function_ptr;*/

result = zend_call_function(&fci, NULL TSRMLS_CC);
if (result == FAILURE) {
zval **method;
zval **obj;

if (Z_TYPE_P(handler) == IS_STRING) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call handler %s()"", Z_STRVAL_P(handler));
} else if (zend_hash_index_find(Z_ARRVAL_P(handler), 0, (void **) &obj) == SUCCESS &&
zend_hash_index_find(Z_ARRVAL_P(handler), 1, (void **) &method) == SUCCESS &&
Z_TYPE_PP(obj) == IS_OBJECT &&
Z_TYPE_PP(method) == IS_STRING) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call handler %s::%s()"", Z_OBJCE_PP(obj)->name, Z_STRVAL_PP(method));
                       } else 
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call handler"");
}

for (i = 0; i < argc; i++) {
zval_ptr_dtor(args[i]);
}
efree(args);

if (result == FAILURE) {
return NULL;
} else {
return EG(exception) ? NULL : retval;
}
} else {
for (i = 0; i < argc; i++) {
zval_ptr_dtor(&argv[i]);
}
return NULL;
}
}
","[2, 13]",       int i;  /~/               /~/                       } else 
432,"bool Vp9Parser::ParseUncompressedHeader(const uint8_t* stream,
                                        off_t frame_size,
                                        Vp9FrameHeader* fhdr) {
  reader_.Initialize(stream, frame_size);
  fhdr->data = stream;
  fhdr->frame_size = frame_size;

// frame marker
if (reader_.ReadLiteral(2) != 0x2)
return false;

fhdr->profile = ReadProfile();
if (fhdr->profile >= kVp9MaxProfile) {
DVLOG(1) << ""Unsupported bitstream profile"";
return false;
}

fhdr->show_existing_frame = reader_.ReadBool();
if (fhdr->show_existing_frame) {
fhdr->frame_to_show = reader_.ReadLiteral(3);
fhdr->show_frame = true;

if (!reader_.IsValid()) {
DVLOG(1) << ""parser reads beyond the end of buffer"";
return false;
}
fhdr->uncompressed_header_size = reader_.GetBytesRead();
return true;
}

fhdr->frame_type = static_cast<Vp9FrameHeader::FrameType>(reader_.ReadBool());
fhdr->show_frame = reader_.ReadBool();
fhdr->error_resilient_mode = reader_.ReadBool();

if (fhdr->IsKeyframe()) {
if (!VerifySyncCode())
return false;

if (!ReadBitDepthColorSpaceSampling(fhdr))
return false;

    fhdr->refresh_flags = 0xff;

ReadFrameSize(fhdr);
ReadDisplayFrameSize(fhdr);
} else {
if (!fhdr->show_frame)
fhdr->intra_only = reader_.ReadBool();

if (!fhdr->error_resilient_mode)
fhdr->reset_context = reader_.ReadLiteral(2);

if (fhdr->intra_only) {
if (!VerifySyncCode())
return false;

if (fhdr->profile > 0) {
if (!ReadBitDepthColorSpaceSampling(fhdr))
return false;
} else {
fhdr->bit_depth = 8;
fhdr->color_space = Vp9ColorSpace::BT_601;
fhdr->subsampling_x = fhdr->subsampling_y = 1;
}

      fhdr->refresh_flags = reader_.ReadLiteral(8);
ReadFrameSize(fhdr);
ReadDisplayFrameSize(fhdr);
} else {
      fhdr->refresh_flags = reader_.ReadLiteral(8);

for (size_t i = 0; i < kVp9NumRefsPerFrame; i++) {
fhdr->frame_refs[i] = reader_.ReadLiteral(kVp9NumRefFramesLog2);
fhdr->ref_sign_biases[i] = reader_.ReadBool();
}

if (!ReadFrameSizeFromRefs(fhdr))
return false;
ReadDisplayFrameSize(fhdr);

fhdr->allow_high_precision_mv = reader_.ReadBool();
fhdr->interp_filter = ReadInterpFilter();
}
}

if (fhdr->error_resilient_mode) {
fhdr->frame_parallel_decoding_mode = true;
} else {
fhdr->refresh_frame_context = reader_.ReadBool();
fhdr->frame_parallel_decoding_mode = reader_.ReadBool();
}

fhdr->frame_context_idx = reader_.ReadLiteral(2);

  if (fhdr->IsKeyframe() || fhdr->intra_only)
    SetupPastIndependence();
  ReadLoopFilter();
ReadQuantization(&fhdr->quant_params);
  ReadSegmentation();

ReadTiles(fhdr);

fhdr->first_partition_size = reader_.ReadLiteral(16);
if (fhdr->first_partition_size == 0) {
DVLOG(1) << ""invalid header size"";
return false;
}

if (!reader_.IsValid()) {
DVLOG(1) << ""parser reads beyond the end of buffer"";
return false;
}
fhdr->uncompressed_header_size = reader_.GetBytesRead();

  SetupSegmentationDequant(fhdr->quant_params);
  SetupLoopFilter();
  UpdateSlots(fhdr);
return true;
}
","[1, 2, 3, 4, 5, 33]","                                        off_t frame_size,/~/                                        Vp9FrameHeader* fhdr) {/~/  reader_.Initialize(stream, frame_size);/~/  fhdr->data = stream;/~/  fhdr->frame_size = frame_size;/~/    fhdr->refresh_flags = 0xff;/~/      fhdr->refresh_flags = reader_.ReadLiteral(8);/~/      fhdr->refresh_flags = reader_.ReadLiteral(8);/~/  if (fhdr->IsKeyframe() || fhdr->intra_only)/~/    SetupPastIndependence();/~/  ReadLoopFilter();/~/  ReadSegmentation();/~/  SetupSegmentationDequant(fhdr->quant_params);/~/  SetupLoopFilter();/~/  UpdateSlots(fhdr);"
433,"UpdateLibrary* CrosLibrary::GetUpdateLibrary() {
  return update_lib_.GetDefaultImpl(use_stub_impl_);
}
","[1, 2]",  return update_lib_.GetDefaultImpl(use_stub_impl_);/~/}
434,"static int netlink_recvmsg(struct kiocb *kiocb, struct socket *sock,
struct msghdr *msg, size_t len,
int flags)
{
struct sock_iocb *siocb = kiocb_to_siocb(kiocb);
struct scm_cookie scm;
struct sock *sk = sock->sk;
struct netlink_sock *nlk = nlk_sk(sk);
int noblock = flags&MSG_DONTWAIT;
size_t copied;
struct sk_buff *skb, *data_skb;
int err, ret;

if (flags&MSG_OOB)
return -EOPNOTSUPP;

copied = 0;

skb = skb_recv_datagram(sk, flags, noblock, &err);
if (skb == NULL)
goto out;

data_skb = skb;

#ifdef CONFIG_COMPAT_NETLINK_MESSAGES
if (unlikely(skb_shinfo(skb)->frag_list)) {
/*
* If this skb has a frag_list, then here that means that we
* will have to use the frag_list skb's data for compat tasks
* and the regular skb's data for normal (non-compat) tasks.
*
* If we need to send the compat skb, assign it to the
* 'data_skb' variable so that it will be used below for data
* copying. We keep 'skb' for everything else, including
* freeing both later.
*/
if (flags & MSG_CMSG_COMPAT)
data_skb = skb_shinfo(skb)->frag_list;
}
#endif

	msg->msg_namelen = 0;
copied = data_skb->len;
if (len < copied) {
msg->msg_flags |= MSG_TRUNC;
copied = len;
}

skb_reset_transport_header(data_skb);
err = skb_copy_datagram_iovec(data_skb, 0, msg->msg_iov, copied);

if (msg->msg_name) {
struct sockaddr_nl *addr = (struct sockaddr_nl *)msg->msg_name;
addr->nl_family = AF_NETLINK;
addr->nl_pad    = 0;
addr->nl_pid	= NETLINK_CB(skb).portid;
addr->nl_groups	= netlink_group_mask(NETLINK_CB(skb).dst_group);
msg->msg_namelen = sizeof(*addr);
}

if (nlk->flags & NETLINK_RECV_PKTINFO)
netlink_cmsg_recv_pktinfo(msg, skb);

if (NULL == siocb->scm) {
memset(&scm, 0, sizeof(scm));
siocb->scm = &scm;
}
siocb->scm->creds = *NETLINK_CREDS(skb);
if (flags & MSG_TRUNC)
copied = data_skb->len;

skb_free_datagram(sk, skb);

if (nlk->cb_running &&
atomic_read(&sk->sk_rmem_alloc) <= sk->sk_rcvbuf / 2) {
ret = netlink_dump(sk);
if (ret) {
sk->sk_err = ret;
sk->sk_error_report(sk);
}
}

scm_recv(sock, msg, siocb->scm, flags);
out:
netlink_rcv_wake(sk);
return err ? : copied;
}
",[35],	msg->msg_namelen = 0;
435,"pimv1_print(netdissect_options *ndo,
register const u_char *bp, register u_int len)
{
	register const u_char *ep;
register u_char type;

	ep = (const u_char *)ndo->ndo_snapend;
	if (bp >= ep)
		return;
ND_TCHECK(bp[1]);
type = bp[1];

ND_PRINT((ndo, "" %s"", tok2str(pimv1_type_str, ""[type %u]"", type)));
switch (type) {
case PIMV1_TYPE_QUERY:
if (ND_TTEST(bp[8])) {
switch (bp[8] >> 4) {
case 0:
ND_PRINT((ndo, "" Dense-mode""));
break;
case 1:
ND_PRINT((ndo, "" Sparse-mode""));
break;
case 2:
ND_PRINT((ndo, "" Sparse-Dense-mode""));
break;
default:
ND_PRINT((ndo, "" mode-%d"", bp[8] >> 4));
break;
}
}
if (ndo->ndo_vflag) {
ND_TCHECK2(bp[10],2);
ND_PRINT((ndo, "" (Hold-time ""));
unsigned_relts_print(ndo, EXTRACT_16BITS(&bp[10]));
ND_PRINT((ndo, "")""));
}
break;

case PIMV1_TYPE_REGISTER:
ND_TCHECK2(bp[8], 20);			/* ip header */
ND_PRINT((ndo, "" for %s > %s"", ipaddr_string(ndo, &bp[20]),
ipaddr_string(ndo, &bp[24])));
break;
case PIMV1_TYPE_REGISTER_STOP:
ND_TCHECK2(bp[12], sizeof(struct in_addr));
ND_PRINT((ndo, "" for %s > %s"", ipaddr_string(ndo, &bp[8]),
ipaddr_string(ndo, &bp[12])));
break;
case PIMV1_TYPE_RP_REACHABILITY:
if (ndo->ndo_vflag) {
ND_TCHECK2(bp[22], 2);
ND_PRINT((ndo, "" group %s"", ipaddr_string(ndo, &bp[8])));
if (EXTRACT_32BITS(&bp[12]) != 0xffffffff)
ND_PRINT((ndo, ""/%s"", ipaddr_string(ndo, &bp[12])));
ND_PRINT((ndo, "" RP %s hold "", ipaddr_string(ndo, &bp[16])));
unsigned_relts_print(ndo, EXTRACT_16BITS(&bp[22]));
}
break;
case PIMV1_TYPE_ASSERT:
ND_TCHECK2(bp[16], sizeof(struct in_addr));
ND_PRINT((ndo, "" for %s > %s"", ipaddr_string(ndo, &bp[16]),
ipaddr_string(ndo, &bp[8])));
if (EXTRACT_32BITS(&bp[12]) != 0xffffffff)
ND_PRINT((ndo, ""/%s"", ipaddr_string(ndo, &bp[12])));
ND_TCHECK2(bp[24], 4);
ND_PRINT((ndo, "" %s pref %d metric %d"",
(bp[20] & 0x80) ? ""RP-tree"" : ""SPT"",
EXTRACT_32BITS(&bp[20]) & 0x7fffffff,
EXTRACT_32BITS(&bp[24])));
break;
case PIMV1_TYPE_JOIN_PRUNE:
case PIMV1_TYPE_GRAFT:
case PIMV1_TYPE_GRAFT_ACK:
		if (ndo->ndo_vflag)
pimv1_join_prune_print(ndo, &bp[8], len - 8);
break;
}
ND_TCHECK(bp[4]);
if ((bp[4] >> 4) != 1)
ND_PRINT((ndo, "" [v%d]"", bp[4] >> 4));
return;

trunc:
ND_PRINT((ndo, ""[|pim]""));
return;
}
","[3, 5, 6, 7]",	register const u_char *ep;/~/	ep = (const u_char *)ndo->ndo_snapend;/~/	if (bp >= ep)/~/		return;/~/		if (ndo->ndo_vflag)
436,"void HostPortAllocatorSession::OnSessionRequestDone(
    UrlFetcher* url_fetcher,
    const net::URLRequestStatus& status,
    int response_code,
    const std::string& response) {
  url_fetchers_.erase(url_fetcher);
  delete url_fetcher;

  if (response_code != net::HTTP_OK) {
LOG(WARNING) << ""Received error when allocating relay session: ""
                 << response_code;
TryCreateRelaySession();
return;
}

ReceiveSessionResponse(response);
}
","[1, 2, 3, 4, 5, 6, 7, 9]","    UrlFetcher* url_fetcher,/~/    const net::URLRequestStatus& status,/~/    int response_code,/~/    const std::string& response) {/~/  url_fetchers_.erase(url_fetcher);/~/  delete url_fetcher;/~/  if (response_code != net::HTTP_OK) {/~/                 << response_code;"
437,"void AppLauncherHandler::FillAppDictionary(base::DictionaryValue* dictionary) {
// CreateAppInfo and ClearOrdinals can change the extension prefs.
base::AutoReset<bool> auto_reset(&ignore_changes_, true);

base::ListValue* list = new base::ListValue();
Profile* profile = Profile::FromWebUI(web_ui());
PrefService* prefs = profile->GetPrefs();

for (std::set<std::string>::iterator it = visible_apps_.begin();
it != visible_apps_.end(); ++it) {
const Extension* extension = extension_service_->GetInstalledExtension(*it);
if (extension && extensions::ui_util::ShouldDisplayInNewTabPage(
extension, profile)) {
base::DictionaryValue* app_info = GetAppInfo(extension);
list->Append(app_info);
}
}

dictionary->Set(""apps"", list);

  // TODO(estade): remove these settings when the old NTP is removed. The new
  // NTP does it in js.
#if defined(OS_MACOSX)
  // App windows are not yet implemented on mac.
  dictionary->SetBoolean(""disableAppWindowLaunch"", true);
  dictionary->SetBoolean(""disableCreateAppShortcut"", true);
#endif
#if defined(OS_CHROMEOS)
  // Making shortcut does not make sense on ChromeOS because it does not have
  // a desktop.
  dictionary->SetBoolean(""disableCreateAppShortcut"", true);
#endif
const base::ListValue* app_page_names =
prefs->GetList(prefs::kNtpAppPageNames);
if (!app_page_names || !app_page_names->GetSize()) {
ListPrefUpdate update(prefs, prefs::kNtpAppPageNames);
base::ListValue* list = update.Get();
list->Set(0, new base::StringValue(
l10n_util::GetStringUTF16(IDS_APP_DEFAULT_PAGE_NAME)));
dictionary->Set(""appPageNames"",
static_cast<base::ListValue*>(list->DeepCopy()));
} else {
dictionary->Set(""appPageNames"",
static_cast<base::ListValue*>(app_page_names->DeepCopy()));
}
}
","[16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27]","  // TODO(estade): remove these settings when the old NTP is removed. The new/~/  // NTP does it in js./~/#if defined(OS_MACOSX)/~/  // App windows are not yet implemented on mac./~/  dictionary->SetBoolean(""disableAppWindowLaunch"", true);/~/  dictionary->SetBoolean(""disableCreateAppShortcut"", true);/~/#endif/~/#if defined(OS_CHROMEOS)/~/  // Making shortcut does not make sense on ChromeOS because it does not have/~/  // a desktop./~/  dictionary->SetBoolean(""disableCreateAppShortcut"", true);/~/#endif"
438,"void ServiceWorkerPaymentInstrument::OnPaymentAppInvoked(
mojom::PaymentHandlerResponsePtr response) {
  DCHECK(delegate_);
if (delegate_ != nullptr) {
delegate_->OnInstrumentDetailsReady(response->method_name,
response->stringified_details);
delegate_ = nullptr;
}
}
",[2],  DCHECK(delegate_);
439,"lldp_private_8021_print(netdissect_options *ndo,
const u_char *tptr, u_int tlv_len)
{
int subtype, hexdump = FALSE;
u_int sublen;
u_int tval;
    uint8_t i;

if (tlv_len < 4) {
return hexdump;
}
subtype = *(tptr+3);

ND_PRINT((ndo, ""\n\t  %s Subtype (%u)"",
tok2str(lldp_8021_subtype_values, ""unknown"", subtype),
subtype));

switch (subtype) {
case LLDP_PRIVATE_8021_SUBTYPE_PORT_VLAN_ID:
if (tlv_len < 6) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    port vlan id (PVID): %u"",
EXTRACT_16BITS(tptr + 4)));
break;
case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_VLAN_ID:
if (tlv_len < 7) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    port and protocol vlan id (PPVID): %u, flags [%s] (0x%02x)"",
EXTRACT_16BITS(tptr+5),
bittok2str(lldp_8021_port_protocol_id_values, ""none"", *(tptr+4)),
*(tptr + 4)));
break;
case LLDP_PRIVATE_8021_SUBTYPE_VLAN_NAME:
if (tlv_len < 6) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    vlan id (VID): %u"", EXTRACT_16BITS(tptr + 4)));
if (tlv_len < 7) {
return hexdump;
}
sublen = *(tptr+6);
if (tlv_len < 7+sublen) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    vlan name: ""));
safeputs(ndo, tptr + 7, sublen);
break;
case LLDP_PRIVATE_8021_SUBTYPE_PROTOCOL_IDENTITY:
if (tlv_len < 5) {
return hexdump;
}
sublen = *(tptr+4);
if (tlv_len < 5+sublen) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    protocol identity: ""));
safeputs(ndo, tptr + 5, sublen);
break;
case LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CONGESTION_NOTIFICATION_LENGTH){
return hexdump;
}
tval=*(tptr+4);
ND_PRINT((ndo, ""\n\t    Pre-Priority CNPV Indicator""));
ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
ND_PRINT((ndo, ""\n\t     Value    : ""));
for(i=0;i<NO_OF_BITS;i++)
ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
tval=*(tptr+5);
ND_PRINT((ndo, ""\n\t    Pre-Priority Ready Indicator""));
ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
ND_PRINT((ndo, ""\n\t     Value    : ""));
for(i=0;i<NO_OF_BITS;i++)
ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
break;

case LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_CONFIGURATION_LENGTH) {
return hexdump;
}
tval=*(tptr+4);
ND_PRINT((ndo, ""\n\t    Willing:%d, CBS:%d, RES:%d, Max TCs:%d"",
tval >> 7, (tval >> 6) & 0x02, (tval >> 3) & 0x07, tval & 0x07));

/*Print Priority Assignment Table*/
print_ets_priority_assignment_table(ndo, tptr + 5);

/*Print TC Bandwidth Table*/
print_tc_bandwidth_table(ndo, tptr + 9);

/* Print TSA Assignment Table */
print_tsa_assignment_table(ndo, tptr + 17);

break;

case LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_ETS_RECOMMENDATION_LENGTH) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
/*Print Priority Assignment Table */
print_ets_priority_assignment_table(ndo, tptr + 5);
/*Print TC Bandwidth Table */
print_tc_bandwidth_table(ndo, tptr + 9);
/* Print TSA Assignment Table */
print_tsa_assignment_table(ndo, tptr + 17);
break;

case LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_PFC_CONFIGURATION_LENGTH) {
return hexdump;
}
tval=*(tptr+4);
ND_PRINT((ndo, ""\n\t    Willing: %d, MBC: %d, RES: %d, PFC cap:%d "",
tval >> 7, (tval >> 6) & 0x01, (tval >> 4) & 0x03, (tval & 0x0f)));
ND_PRINT((ndo, ""\n\t    PFC Enable""));
tval=*(tptr+5);
ND_PRINT((ndo, ""\n\t     Priority : 0  1  2  3  4  5  6  7""));
ND_PRINT((ndo, ""\n\t     Value    : ""));
for(i=0;i<NO_OF_BITS;i++)
ND_PRINT((ndo, ""%-2d "", (tval >> i) & 0x01));
break;

case LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH) {
return hexdump;
}
ND_PRINT((ndo, ""\n\t    RES: %d"", *(tptr + 4)));
if(tlv_len<=LLDP_PRIVATE_8021_SUBTYPE_APPLICATION_PRIORITY_MIN_LENGTH){
return hexdump;
}
/*  Length of Application Priority Table */
sublen=tlv_len-5;
if(sublen%3!=0){
return hexdump;
}
i=0;
ND_PRINT((ndo, ""\n\t    Application Priority Table""));
while(i<sublen) {
tval=*(tptr+i+5);
        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",
        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));
        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));
i=i+3;
}
break;
case LLDP_PRIVATE_8021_SUBTYPE_EVB:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_EVB_LENGTH){
return hexdump;
}
ND_PRINT((ndo, ""\n\t    EVB Bridge Status""));
tval=*(tptr+4);
ND_PRINT((ndo, ""\n\t      RES: %d, BGID: %d, RRCAP: %d, RRCTR: %d"",
tval >> 3, (tval >> 2) & 0x01, (tval >> 1) & 0x01, tval & 0x01));
ND_PRINT((ndo, ""\n\t    EVB Station Status""));
tval=*(tptr+5);
ND_PRINT((ndo, ""\n\t      RES: %d, SGID: %d, RRREQ: %d,RRSTAT: %d"",
tval >> 4, (tval >> 3) & 0x01, (tval >> 2) & 0x01, tval & 0x03));
tval=*(tptr+6);
ND_PRINT((ndo, ""\n\t    R: %d, RTE: %d, "",tval >> 5, tval & 0x1f));
tval=*(tptr+7);
ND_PRINT((ndo, ""EVB Mode: %s [%d]"",
tok2str(lldp_evb_mode_values, ""unknown"", tval >> 6), tval >> 6));
ND_PRINT((ndo, ""\n\t    ROL: %d, RWD: %d, "", (tval >> 5) & 0x01, tval & 0x1f));
tval=*(tptr+8);
ND_PRINT((ndo, ""RES: %d, ROL: %d, RKA: %d"", tval >> 6, (tval >> 5) & 0x01, tval & 0x1f));
break;

case LLDP_PRIVATE_8021_SUBTYPE_CDCP:
if(tlv_len<LLDP_PRIVATE_8021_SUBTYPE_CDCP_MIN_LENGTH){
return hexdump;
}
tval=*(tptr+4);
ND_PRINT((ndo, ""\n\t    Role: %d, RES: %d, Scomp: %d "",
tval >> 7, (tval >> 4) & 0x07, (tval >> 3) & 0x01));
ND_PRINT((ndo, ""ChnCap: %d"", EXTRACT_16BITS(tptr + 6) & 0x0fff));
sublen=tlv_len-8;
if(sublen%3!=0) {
return hexdump;
}
i=0;
while(i<sublen) {
tval=EXTRACT_24BITS(tptr+i+8);
ND_PRINT((ndo, ""\n\t    SCID: %d, SVID: %d"",
tval >> 12, tval & 0x000fff));
i=i+3;
}
break;

default:
hexdump = TRUE;
break;
}

return hexdump;
}
",[6],"    uint8_t i;/~/        	ND_PRINT((ndo, ""\n\t      Priority: %d, RES: %d, Sel: %d"",/~/        		 tval >> 5, (tval >> 3) & 0x03, (tval & 0x07)));/~/        	ND_PRINT((ndo, ""Protocol ID: %d"", EXTRACT_16BITS(tptr + i + 5)));"
440,"asmlinkage long compat_sys_recvmmsg(int fd, struct compat_mmsghdr __user *mmsg,
unsigned int vlen, unsigned int flags,
struct compat_timespec __user *timeout)
{
int datagrams;
struct timespec ktspec;

if (flags & MSG_CMSG_COMPAT)
return -EINVAL;

	if (COMPAT_USE_64BIT_TIME)
		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
				      flags | MSG_CMSG_COMPAT,
				      (struct timespec *) timeout);
if (timeout == NULL)
return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
flags | MSG_CMSG_COMPAT, NULL);

	if (get_compat_timespec(&ktspec, timeout))
return -EFAULT;

datagrams = __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,
flags | MSG_CMSG_COMPAT, &ktspec);
	if (datagrams > 0 && put_compat_timespec(&ktspec, timeout))
datagrams = -EFAULT;

return datagrams;
}
","[8, 9, 10, 11, 13, 15, 19]","	if (COMPAT_USE_64BIT_TIME)/~/		return __sys_recvmmsg(fd, (struct mmsghdr __user *)mmsg, vlen,/~/				      flags | MSG_CMSG_COMPAT,/~/				      (struct timespec *) timeout);/~/	if (get_compat_timespec(&ktspec, timeout))/~/	if (datagrams > 0 && put_compat_timespec(&ktspec, timeout))"
441,"SplashPath *Splash::makeDashedPath(SplashPath *path) {
SplashPath *dPath;
SplashCoord lineDashTotal;
SplashCoord lineDashStartPhase, lineDashDist, segLen;
SplashCoord x0, y0, x1, y1, xa, ya;
GBool lineDashStartOn, lineDashOn, newPath;
int lineDashStartIdx, lineDashIdx;
int i, j, k;

lineDashTotal = 0;
for (i = 0; i < state->lineDashLength; ++i) {
lineDashTotal += state->lineDash[i];
}
// Acrobat simply draws nothing if the dash array is [0]
if (lineDashTotal == 0) {
return new SplashPath();
}
lineDashStartPhase = state->lineDashPhase;
i = splashFloor(lineDashStartPhase / lineDashTotal);
lineDashStartPhase -= (SplashCoord)i * lineDashTotal;
lineDashStartOn = gTrue;
lineDashStartIdx = 0;
if (lineDashStartPhase > 0) {
    while (lineDashStartPhase >= state->lineDash[lineDashStartIdx]) {
lineDashStartOn = !lineDashStartOn;
lineDashStartPhase -= state->lineDash[lineDashStartIdx];
++lineDashStartIdx;
}
}

dPath = new SplashPath();
while (i < path->length) {

// find the end of the subpath
for (j = i;
j < path->length - 1 && !(path->flags[j] & splashPathLast);
++j) ;

// initialize the dash parameters
lineDashOn = lineDashStartOn;
lineDashIdx = lineDashStartIdx;
lineDashDist = state->lineDash[lineDashIdx] - lineDashStartPhase;

// process each segment of the subpath
newPath = gTrue;
for (k = i; k < j; ++k) {

// grab the segment
x0 = path->pts[k].x;
y0 = path->pts[k].y;
x1 = path->pts[k+1].x;
y1 = path->pts[k+1].y;
segLen = splashDist(x0, y0, x1, y1);

// process the segment
while (segLen > 0) {

if (lineDashDist >= segLen) {
if (lineDashOn) {
if (newPath) {
dPath->moveTo(x0, y0);
newPath = gFalse;
}
dPath->lineTo(x1, y1);
}
lineDashDist -= segLen;
segLen = 0;

} else {
xa = x0 + (lineDashDist / segLen) * (x1 - x0);
ya = y0 + (lineDashDist / segLen) * (y1 - y0);
if (lineDashOn) {
if (newPath) {
dPath->moveTo(x0, y0);
newPath = gFalse;
}
dPath->lineTo(xa, ya);
}
x0 = xa;
y0 = ya;
segLen -= lineDashDist;
lineDashDist = 0;
}

// get the next entry in the dash array
if (lineDashDist <= 0) {
lineDashOn = !lineDashOn;
if (++lineDashIdx == state->lineDashLength) {
lineDashIdx = 0;
}
lineDashDist = state->lineDash[lineDashIdx];
newPath = gTrue;
}
}
}
i = j + 1;
}

if (dPath->length == 0) {
GBool allSame = gTrue;
for (int i = 0; allSame && i < path->length - 1; ++i) {
allSame = path->pts[i].x == path->pts[i + 1].x && path->pts[i].y == path->pts[i + 1].y;
}
if (allSame) {
x0 = path->pts[0].x;
y0 = path->pts[0].y;
dPath->moveTo(x0, y0);
dPath->lineTo(x0, y0);
}
}

return dPath;
}
",[22],    while (lineDashStartPhase >= state->lineDash[lineDashStartIdx]) {
442,"ossl_cipher_initialize(VALUE self, VALUE str)
{
EVP_CIPHER_CTX *ctx;
const EVP_CIPHER *cipher;
char *name;
    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };

name = StringValueCStr(str);
GetCipherInit(self, ctx);
if (ctx) {
ossl_raise(rb_eRuntimeError, ""Cipher already inititalized!"");
}
AllocCipher(self, ctx);
if (!(cipher = EVP_get_cipherbyname(name))) {
ossl_raise(rb_eRuntimeError, ""unsupported cipher algorithm (%""PRIsVALUE"")"", str);
}
    /*
     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some
     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]
     *
     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows
     * uninitialized key, but other EVPs (such as AES) does not allow it.
     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we
     * set the data filled with ""\0"" as the key by default.
     *
    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)
ossl_raise(eCipherError, NULL);

return self;
}
","[5, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24]","    unsigned char dummy_key[EVP_MAX_KEY_LENGTH] = { 0 };/~/    /*/~/     * EVP_CipherInit_ex() allows to specify NULL to key and IV, however some/~/     * ciphers don't handle well (OpenSSL's bug). [Bug #2768]/~/     */~/     * The EVP which has EVP_CIPH_RAND_KEY flag (such as DES3) allows/~/     * uninitialized key, but other EVPs (such as AES) does not allow it./~/     * Calling EVP_CipherUpdate() without initializing key causes SEGV so we/~/     * set the data filled with ""\0"" as the key by default./~/     */~/    if (EVP_CipherInit_ex(ctx, cipher, NULL, dummy_key, NULL, -1) != 1)"
443,"void TestPlaybackRate(double playback_rate) {
    static const int kDefaultBufferSize = kSamplesPerSecond / 10;
    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;

TestPlaybackRate(playback_rate, kDefaultBufferSize,
kDefaultFramesRequested);
}
","[1, 2]",    static const int kDefaultBufferSize = kSamplesPerSecond / 10;/~/    static const int kDefaultFramesRequested = 5 * kSamplesPerSecond;
444,"Platform::IntPoint InRegionScrollableArea::calculateMaximumScrollPosition(const Platform::IntSize& viewportSize, const Platform::IntSize& contentsSize, float overscrollLimitFactor) const
{
    // FIXME: Eventually we should support overscroll like iOS5 does.
    ASSERT(!allowsOverscroll());
    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,
                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);
}
","[1, 2, 3, 4, 5, 6]","{/~/    // FIXME: Eventually we should support overscroll like iOS5 does./~/    ASSERT(!allowsOverscroll());/~/    return Platform::IntPoint(std::max(contentsSize.width() - viewportSize.width(), 0) + overscrollLimitFactor,/~/                              std::max(contentsSize.height() - viewportSize.height(), 0) + overscrollLimitFactor);/~/}"
445,"static int __init big_key_crypto_init(void)
{
	int ret = -EINVAL;

	/* init RNG *
	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);
	if (IS_ERR(big_key_rng)) {
		big_key_rng = NULL;
		return -EFAULT;
}

/* seed RNG */
	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));
	if (ret)
		goto error;

/* init block cipher */
	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,
						 0, CRYPTO_ALG_ASYNC);
	if (IS_ERR(big_key_skcipher)) {
		big_key_skcipher = NULL;
		ret = -EFAULT;
		goto error;
}

return 0;

error:
crypto_free_rng(big_key_rng);
	big_key_rng = NULL;
return ret;
}
","[1, 2, 3, 4, 5, 6, 7, 10, 11, 12, 14, 15, 16, 17, 18, 19, 22, 24]","{/~/	int ret = -EINVAL;/~/	/* init RNG */~/	big_key_rng = crypto_alloc_rng(big_key_rng_name, 0, 0);/~/	if (IS_ERR(big_key_rng)) {/~/		big_key_rng = NULL;/~/		return -EFAULT;/~/	ret = crypto_rng_reset(big_key_rng, NULL, crypto_rng_seedsize(big_key_rng));/~/	if (ret)/~/		goto error;/~/	big_key_skcipher = crypto_alloc_skcipher(big_key_alg_name,/~/						 0, CRYPTO_ALG_ASYNC);/~/	if (IS_ERR(big_key_skcipher)) {/~/		big_key_skcipher = NULL;/~/		ret = -EFAULT;/~/		goto error;/~/error:/~/	big_key_rng = NULL;"
446,"UserCloudPolicyManagerChromeOS::UserCloudPolicyManagerChromeOS(
scoped_ptr<CloudPolicyStore> store,
scoped_ptr<CloudExternalDataManager> external_data_manager,
const base::FilePath& component_policy_cache_path,
bool wait_for_policy_fetch,
base::TimeDelta initial_policy_fetch_timeout,
const scoped_refptr<base::SequencedTaskRunner>& task_runner,
const scoped_refptr<base::SequencedTaskRunner>& file_task_runner,
const scoped_refptr<base::SequencedTaskRunner>& io_task_runner)
: CloudPolicyManager(
PolicyNamespaceKey(dm_protocol::kChromeUserPolicyType, std::string()),
store.get(),
task_runner,
file_task_runner,
io_task_runner),
store_(store.Pass()),
external_data_manager_(external_data_manager.Pass()),
component_policy_cache_path_(component_policy_cache_path),
wait_for_policy_fetch_(wait_for_policy_fetch),
policy_fetch_timeout_(false, false) {
time_init_started_ = base::Time::Now();
  if (wait_for_policy_fetch_) {
policy_fetch_timeout_.Start(
FROM_HERE,
initial_policy_fetch_timeout,
base::Bind(&UserCloudPolicyManagerChromeOS::OnBlockingFetchTimeout,
base::Unretained(this)));
}
}
",[21],  if (wait_for_policy_fetch_) {
447,"void WebPagePrivate::didComposite()
{
if (!m_page->settings()->developerExtrasEnabled())
return;
    InspectorInstrumentation::didComposite(m_page);
}
",[4],    InspectorInstrumentation::didComposite(m_page);
448,"static int __rds_rdma_map(struct rds_sock *rs, struct rds_get_mr_args *args,
u64 *cookie_ret, struct rds_mr **mr_ret)
{
struct rds_mr *mr = NULL, *found;
unsigned int nr_pages;
struct page **pages = NULL;
struct scatterlist *sg;
void *trans_private;
unsigned long flags;
rds_rdma_cookie_t cookie;
unsigned int nents;
long i;
int ret;

	if (rs->rs_bound_addr == 0) {
ret = -ENOTCONN; /* XXX not a great errno */
goto out;
}

if (!rs->rs_transport->get_mr) {
ret = -EOPNOTSUPP;
goto out;
}

nr_pages = rds_pages_in_vec(&args->vec);
if (nr_pages == 0) {
ret = -EINVAL;
goto out;
}

/* Restrict the size of mr irrespective of underlying transport
* To account for unaligned mr regions, subtract one from nr_pages
*/
if ((nr_pages - 1) > (RDS_MAX_MSG_SIZE >> PAGE_SHIFT)) {
ret = -EMSGSIZE;
goto out;
}

rdsdebug(""RDS: get_mr addr %llx len %llu nr_pages %u\n"",
args->vec.addr, args->vec.bytes, nr_pages);

/* XXX clamp nr_pages to limit the size of this alloc? */
pages = kcalloc(nr_pages, sizeof(struct page *), GFP_KERNEL);
if (!pages) {
ret = -ENOMEM;
goto out;
}

mr = kzalloc(sizeof(struct rds_mr), GFP_KERNEL);
if (!mr) {
ret = -ENOMEM;
goto out;
}

refcount_set(&mr->r_refcount, 1);
RB_CLEAR_NODE(&mr->r_rb_node);
mr->r_trans = rs->rs_transport;
mr->r_sock = rs;

if (args->flags & RDS_RDMA_USE_ONCE)
mr->r_use_once = 1;
if (args->flags & RDS_RDMA_INVALIDATE)
mr->r_invalidate = 1;
if (args->flags & RDS_RDMA_READWRITE)
mr->r_write = 1;

/*
* Pin the pages that make up the user buffer and transfer the page
* pointers to the mr's sg array.  We check to see if we've mapped
* the whole region after transferring the partial page references
* to the sg array so that we can have one page ref cleanup path.
*
* For now we have no flag that tells us whether the mapping is
* r/o or r/w. We need to assume r/w, or we'll do a lot of RDMA to
* the zero page.
*/
ret = rds_pin_pages(args->vec.addr, nr_pages, pages, 1);
if (ret < 0)
goto out;

nents = ret;
sg = kcalloc(nents, sizeof(*sg), GFP_KERNEL);
if (!sg) {
ret = -ENOMEM;
goto out;
}
WARN_ON(!nents);
sg_init_table(sg, nents);

/* Stick all pages into the scatterlist */
for (i = 0 ; i < nents; i++)
sg_set_page(&sg[i], pages[i], PAGE_SIZE, 0);

rdsdebug(""RDS: trans_private nents is %u\n"", nents);

/* Obtain a transport specific MR. If this succeeds, the
* s/g list is now owned by the MR.
* Note that dma_map() implies that pending writes are
* flushed to RAM, so no dma_sync is needed here. */
trans_private = rs->rs_transport->get_mr(sg, nents, rs,
&mr->r_key);

if (IS_ERR(trans_private)) {
for (i = 0 ; i < nents; i++)
put_page(sg_page(&sg[i]));
kfree(sg);
ret = PTR_ERR(trans_private);
goto out;
}

mr->r_trans_private = trans_private;

rdsdebug(""RDS: get_mr put_user key is %x cookie_addr %p\n"",
mr->r_key, (void *)(unsigned long) args->cookie_addr);

/* The user may pass us an unaligned address, but we can only
* map page aligned regions. So we keep the offset, and build
* a 64bit cookie containing <R_Key, offset> and pass that
* around. */
cookie = rds_rdma_make_cookie(mr->r_key, args->vec.addr & ~PAGE_MASK);
if (cookie_ret)
*cookie_ret = cookie;

if (args->cookie_addr && put_user(cookie, (u64 __user *)(unsigned long) args->cookie_addr)) {
ret = -EFAULT;
goto out;
}

/* Inserting the new MR into the rbtree bumps its
* reference count. */
spin_lock_irqsave(&rs->rs_rdma_lock, flags);
found = rds_mr_tree_walk(&rs->rs_rdma_keys, mr->r_key, mr);
spin_unlock_irqrestore(&rs->rs_rdma_lock, flags);

BUG_ON(found && found != mr);

rdsdebug(""RDS: get_mr key is %x\n"", mr->r_key);
if (mr_ret) {
refcount_inc(&mr->r_refcount);
*mr_ret = mr;
}

ret = 0;
out:
kfree(pages);
if (mr)
rds_mr_put(mr);
return ret;
}
",[13],	if (rs->rs_bound_addr == 0) {
449,"const char* Track::GetLanguage() const
{
    return m_info.language;
}
","[1, 2, 3]",{/~/    return m_info.language;/~/}
450,"static struct mount *clone_mnt(struct mount *old, struct dentry *root,
int flag)
{
struct super_block *sb = old->mnt.mnt_sb;
struct mount *mnt;
int err;

mnt = alloc_vfsmnt(old->mnt_devname);
if (!mnt)
return ERR_PTR(-ENOMEM);

if (flag & (CL_SLAVE | CL_PRIVATE | CL_SHARED_TO_SLAVE))
mnt->mnt_group_id = 0; /* not a peer of original */
else
mnt->mnt_group_id = old->mnt_group_id;

if ((flag & CL_MAKE_SHARED) && !mnt->mnt_group_id) {
err = mnt_alloc_group_id(mnt);
if (err)
goto out_free;
}

mnt->mnt.mnt_flags = old->mnt.mnt_flags & ~(MNT_WRITE_HOLD|MNT_MARKED);
/* Don't allow unprivileged users to change mount flags */
	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))
		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;

/* Don't allow unprivileged users to reveal what is under a mount */
if ((flag & CL_UNPRIVILEGED) && list_empty(&old->mnt_expire))
mnt->mnt.mnt_flags |= MNT_LOCKED;

atomic_inc(&sb->s_active);
mnt->mnt.mnt_sb = sb;
mnt->mnt.mnt_root = dget(root);
mnt->mnt_mountpoint = mnt->mnt.mnt_root;
mnt->mnt_parent = mnt;
lock_mount_hash();
list_add_tail(&mnt->mnt_instance, &sb->s_mounts);
unlock_mount_hash();

if ((flag & CL_SLAVE) ||
((flag & CL_SHARED_TO_SLAVE) && IS_MNT_SHARED(old))) {
list_add(&mnt->mnt_slave, &old->mnt_slave_list);
mnt->mnt_master = old;
CLEAR_MNT_SHARED(mnt);
} else if (!(flag & CL_PRIVATE)) {
if ((flag & CL_MAKE_SHARED) || IS_MNT_SHARED(old))
list_add(&mnt->mnt_share, &old->mnt_share);
if (IS_MNT_SLAVE(old))
list_add(&mnt->mnt_slave, &old->mnt_slave);
mnt->mnt_master = old->mnt_master;
}
if (flag & CL_MAKE_SHARED)
set_mnt_shared(mnt);

/* stick the duplicate mount on the same expiry list
* as the original if that was on one */
if (flag & CL_EXPIRE) {
if (!list_empty(&old->mnt_expire))
list_add(&mnt->mnt_expire, &old->mnt_expire);
}

return mnt;

out_free:
mnt_free_id(mnt);
free_vfsmnt(mnt);
return ERR_PTR(err);
}
","[20, 21]",	if ((flag & CL_UNPRIVILEGED) && (mnt->mnt.mnt_flags & MNT_READONLY))/~/		mnt->mnt.mnt_flags |= MNT_LOCK_READONLY;
451,"void GpuVideoDecodeAccelerator::OnDecode(
    base::SharedMemoryHandle handle, int32 id, int32 size) {
DCHECK(video_decode_accelerator_.get());
video_decode_accelerator_->Decode(media::BitstreamBuffer(id, handle, size));
}
",[1],"    base::SharedMemoryHandle handle, int32 id, int32 size) {"
452,"htmlParseElementInternal(htmlParserCtxtPtr ctxt) {
const xmlChar *name;
const htmlElemDesc * info;
    htmlParserNodeInfo node_info = { 0, };
int failed;

if ((ctxt == NULL) || (ctxt->input == NULL)) {
htmlParseErr(ctxt, XML_ERR_INTERNAL_ERROR,
""htmlParseElementInternal: context error\n"", NULL, NULL);
return;
}

if (ctxt->instate == XML_PARSER_EOF)
return;

/* Capture start position */
if (ctxt->record_info) {
node_info.begin_pos = ctxt->input->consumed +
(CUR_PTR - ctxt->input->base);
node_info.begin_line = ctxt->input->line;
}

failed = htmlParseStartTag(ctxt);
name = ctxt->name;
if ((failed == -1) || (name == NULL)) {
if (CUR == '>')
NEXT;
return;
}

/*
* Lookup the info for that element.
*/
info = htmlTagLookup(name);
if (info == NULL) {
htmlParseErr(ctxt, XML_HTML_UNKNOWN_TAG,
""Tag %s invalid\n"", name, NULL);
}

/*
* Check for an Empty Element labeled the XML/SGML way
*/
if ((CUR == '/') && (NXT(1) == '>')) {
SKIP(2);
if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
ctxt->sax->endElement(ctxt->userData, name);
htmlnamePop(ctxt);
return;
}

if (CUR == '>') {
NEXT;
} else {
htmlParseErr(ctxt, XML_ERR_GT_REQUIRED,
""Couldn't find end of Start Tag %s\n"", name, NULL);

/*
* end of parsing of this node.
*/
if (xmlStrEqual(name, ctxt->name)) {
nodePop(ctxt);
htmlnamePop(ctxt);
}

if (ctxt->record_info)
htmlNodeInfoPush(ctxt, &node_info);
htmlParserFinishElementParsing(ctxt);
return;
}

/*
* Check for an Empty Element from DTD definition
*/
if ((info != NULL) && (info->empty)) {
if ((ctxt->sax != NULL) && (ctxt->sax->endElement != NULL))
ctxt->sax->endElement(ctxt->userData, name);
htmlnamePop(ctxt);
return;
}

if (ctxt->record_info)
htmlNodeInfoPush(ctxt, &node_info);
}
",[3],"    htmlParserNodeInfo node_info = { 0, };"
453,"dns_resolver_match(const struct key *key,
		   const struct key_match_data *match_data)
{
int slen, dlen, ret = 0;
const char *src = key->description, *dsp = match_data->raw_data;

kenter(""%s,%s"", src, dsp);

if (!src || !dsp)
goto no_match;

if (strcasecmp(src, dsp) == 0)
goto matched;

slen = strlen(src);
dlen = strlen(dsp);
if (slen <= 0 || dlen <= 0)
goto no_match;
if (src[slen - 1] == '.')
slen--;
if (dsp[dlen - 1] == '.')
dlen--;
if (slen != dlen || strncasecmp(src, dsp, slen) != 0)
goto no_match;

matched:
ret = 1;
no_match:
kleave("" = %d"", ret);
return ret;
}
",[1],		   const struct key_match_data *match_data)
454,"status_t OMXNodeInstance::useBuffer(
OMX_U32 portIndex, const sp<IMemory> &params,
OMX::buffer_id *buffer, OMX_U32 allottedSize) {
if (params == NULL || buffer == NULL) {
ALOGE(""b/25884056"");
return BAD_VALUE;

}

Mutex::Autolock autoLock(mLock);
    if (allottedSize > params->size()) {
return BAD_VALUE;
}

    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);

OMX_BUFFERHEADERTYPE *header;

OMX_ERRORTYPE err = OMX_UseBuffer(
mHandle, &header, portIndex, buffer_meta,
            allottedSize, static_cast<OMX_U8 *>(params->pointer()));

if (err != OMX_ErrorNone) {
CLOG_ERROR(useBuffer, err, SIMPLE_BUFFER(
                portIndex, (size_t)allottedSize, params->pointer()));

delete buffer_meta;
buffer_meta = NULL;

*buffer = 0;

return StatusFromOMXError(err);
}

CHECK_EQ(header->pAppPrivate, buffer_meta);

*buffer = makeBufferID(header);

addActiveBuffer(portIndex, *buffer);

sp<GraphicBufferSource> bufferSource(getGraphicBufferSource());
if (bufferSource != NULL && portIndex == kPortIndexInput) {
bufferSource->addCodecBuffer(header);
}

CLOG_BUFFER(useBuffer, NEW_BUFFER_FMT(
*buffer, portIndex, ""%u(%zu)@%p"", allottedSize, params->size(), params->pointer()));
return OK;
}
","[8, 11, 15, 18]","    if (allottedSize > params->size()) {/~/    BufferMeta *buffer_meta = new BufferMeta(params, portIndex);/~/            allottedSize, static_cast<OMX_U8 *>(params->pointer()));/~/                portIndex, (size_t)allottedSize, params->pointer()));"
455,"bgp_nlri_parse_vpnv4 (struct peer *peer, struct attr *attr,
struct bgp_nlri *packet)
{
u_char *pnt;
u_char *lim;
struct prefix p;
int psize;
int prefixlen;
u_int16_t type;
struct rd_as rd_as;
struct rd_ip rd_ip;
struct prefix_rd prd;
u_char *tagpnt;

/* Check peer status. */
if (peer->status != Established)
return 0;

/* Make prefix_rd */
prd.family = AF_UNSPEC;
prd.prefixlen = 64;

pnt = packet->nlri;
lim = pnt + packet->length;

for (; pnt < lim; pnt += psize)
{
/* Clear prefix structure. */


/* Fetch prefix length. */
prefixlen = *pnt++;
      p.family = AF_INET;
psize = PSIZE (prefixlen);
      if (prefixlen < 88)
	{
	  zlog_err (""prefix length is less than 88: %d"", prefixlen);
	  return -1;
	}
/* Copyr label to prefix. */
      tagpnt = pnt;;

/* Copy routing distinguisher to rd. */
memcpy (&prd.val, pnt + 3, 8);
else if (type == RD_TYPE_IP)
zlog_info (""prefix %ld:%s:%ld:%s/%d"", label, inet_ntoa (rd_ip.ip),
rd_ip.val, inet_ntoa (p.u.prefix4), p.prefixlen);
#endif /* 0 */

if (pnt + psize > lim)
return -1;

if (attr)
bgp_update (peer, &p, attr, AFI_IP, SAFI_MPLS_VPN,
ZEBRA_ROUTE_BGP, BGP_ROUTE_NORMAL, &prd, tagpnt, 0);
else
return -1;
}

      p.prefixlen = prefixlen - 88;
      memcpy (&p.u.prefix, pnt + 11, psize - 11);

#if 0
if (type == RD_TYPE_AS)
}
","[2, 22, 26, 28, 29, 30, 31, 32, 34, 42]","      p.family = AF_INET;/~/      if (prefixlen < 88)/~/	{/~/	  zlog_err (""prefix length is less than 88: %d"", prefixlen);/~/	  return -1;/~/	}/~/      tagpnt = pnt;;/~/      p.prefixlen = prefixlen - 88;/~/      memcpy (&p.u.prefix, pnt + 11, psize - 11);"
456,"void BluetoothDeviceChromeOS::RequestPinCode(
    const dbus::ObjectPath& device_path,
    const PinCodeCallback& callback) {
  DCHECK(agent_.get());
  DCHECK(device_path == object_path_);
  VLOG(1) << object_path_.value() << "": RequestPinCode"";
  UMA_HISTOGRAM_ENUMERATION(""Bluetooth.PairingMethod"",
                            UMA_PAIRING_METHOD_REQUEST_PINCODE,
                            UMA_PAIRING_METHOD_COUNT);
  DCHECK(pairing_delegate_);
  DCHECK(pincode_callback_.is_null());
  pincode_callback_ = callback;
  pairing_delegate_->RequestPinCode(this);
  pairing_delegate_used_ = true;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14]","    const dbus::ObjectPath& device_path,/~/    const PinCodeCallback& callback) {/~/  DCHECK(agent_.get());/~/  DCHECK(device_path == object_path_);/~/  VLOG(1) << object_path_.value() << "": RequestPinCode"";/~/  UMA_HISTOGRAM_ENUMERATION(""Bluetooth.PairingMethod"",/~/                            UMA_PAIRING_METHOD_REQUEST_PINCODE,/~/                            UMA_PAIRING_METHOD_COUNT);/~/  DCHECK(pairing_delegate_);/~/  DCHECK(pincode_callback_.is_null());/~/  pincode_callback_ = callback;/~/  pairing_delegate_->RequestPinCode(this);/~/  pairing_delegate_used_ = true;/~/}"
457,"SchedulerHelper::SchedulerHelper(
scoped_refptr<NestableSingleThreadTaskRunner> main_task_runner,
const char* tracing_category,
const char* disabled_by_default_tracing_category,
size_t total_task_queue_count)
: task_queue_selector_(new PrioritizingTaskQueueSelector()),
task_queue_manager_(
new TaskQueueManager(total_task_queue_count,
main_task_runner,
task_queue_selector_.get(),
disabled_by_default_tracing_category)),
quiescence_monitored_task_queue_mask_(
((1ull << total_task_queue_count) - 1ull) &
~(1ull << QueueId::CONTROL_TASK_QUEUE) &
~(1ull << QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)),
control_task_runner_(
task_queue_manager_->TaskRunnerForQueue(QueueId::CONTROL_TASK_QUEUE)),
control_after_wakeup_task_runner_(task_queue_manager_->TaskRunnerForQueue(
QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE)),
default_task_runner_(
task_queue_manager_->TaskRunnerForQueue(QueueId::DEFAULT_TASK_QUEUE)),
      time_source_(new TimeSource),
tracing_category_(tracing_category),
disabled_by_default_tracing_category_(
disabled_by_default_tracing_category) {
DCHECK_GE(total_task_queue_count,
static_cast<size_t>(QueueId::TASK_QUEUE_COUNT));
task_queue_selector_->SetQueuePriority(
QueueId::CONTROL_TASK_QUEUE,
PrioritizingTaskQueueSelector::CONTROL_PRIORITY);
task_queue_manager_->SetWakeupPolicy(
QueueId::CONTROL_TASK_QUEUE,
TaskQueueManager::WakeupPolicy::DONT_WAKE_OTHER_QUEUES);

task_queue_selector_->SetQueuePriority(
QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE,
PrioritizingTaskQueueSelector::CONTROL_PRIORITY);
task_queue_manager_->SetPumpPolicy(
QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE,
TaskQueueManager::PumpPolicy::AFTER_WAKEUP);
task_queue_manager_->SetWakeupPolicy(
QueueId::CONTROL_TASK_AFTER_WAKEUP_QUEUE,
TaskQueueManager::WakeupPolicy::DONT_WAKE_OTHER_QUEUES);

for (size_t i = 0; i < TASK_QUEUE_COUNT; i++) {
task_queue_manager_->SetQueueName(
i, TaskQueueIdToString(static_cast<QueueId>(i)));
}

// TODO(skyostil): Increase this to 4 (crbug.com/444764).
task_queue_manager_->SetWorkBatchSize(1);
}
",[21],"      time_source_(new TimeSource),"
458,"static int pn_recvmsg(struct kiocb *iocb, struct sock *sk,
struct msghdr *msg, size_t len, int noblock,
int flags, int *addr_len)
{
struct sk_buff *skb = NULL;
struct sockaddr_pn sa;
int rval = -EOPNOTSUPP;
int copylen;

if (flags & ~(MSG_PEEK|MSG_TRUNC|MSG_DONTWAIT|MSG_NOSIGNAL|
MSG_CMSG_COMPAT))
goto out_nofree;

	if (addr_len)
		*addr_len = sizeof(sa);
skb = skb_recv_datagram(sk, flags, noblock, &rval);
if (skb == NULL)
goto out_nofree;

pn_skb_get_src_sockaddr(skb, &sa);

copylen = skb->len;
if (len < copylen) {
msg->msg_flags |= MSG_TRUNC;
copylen = len;
}

rval = skb_copy_datagram_iovec(skb, 0, msg->msg_iov, copylen);
if (rval) {
rval = -EFAULT;
goto out;
}

rval = (flags & MSG_TRUNC) ? skb->len : copylen;

	if (msg->msg_name != NULL)
		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));

out:
skb_free_datagram(sk, skb);

out_nofree:
return rval;
}
","[11, 12, 28, 29]","	if (addr_len)/~/		*addr_len = sizeof(sa);/~/	if (msg->msg_name != NULL)/~/		memcpy(msg->msg_name, &sa, sizeof(struct sockaddr_pn));"
459,"void ath_tx_aggr_sleep(struct ieee80211_sta *sta, struct ath_softc *sc,
struct ath_node *an)
{
struct ath_atx_tid *tid;
struct ath_atx_ac *ac;
struct ath_txq *txq;
bool buffered;
int tidno;

for (tidno = 0, tid = &an->tid[tidno];
tidno < IEEE80211_NUM_TIDS; tidno++, tid++) {

		if (!tid->sched)
			continue;
ac = tid->ac;
txq = ac->txq;

ath_txq_lock(sc, txq);

buffered = ath_tid_has_buffered(tid);

tid->sched = false;
list_del(&tid->list);

if (ac->sched) {
ac->sched = false;
list_del(&ac->list);
}

ath_txq_unlock(sc, txq);

ieee80211_sta_set_buffered(sta, tidno, buffered);
}
}
","[10, 11]",		if (!tid->sched)/~/			continue;
460,"static inline ogg_uint32_t decode_packed_entry_number(codebook *book,
						      oggpack_buffer *b){
ogg_uint32_t chase=0;
int  read=book->dec_maxlength;
long lok = oggpack_look(b,read),i;

while(lok<0 && read>1)
lok = oggpack_look(b, --read);

if(lok<0){
oggpack_adv(b,1); /* force eop */
return -1;
}

/* chase the tree with the bits we got */
switch (book->dec_method)
{
case 0:
{
/* book->dec_nodeb==1, book->dec_leafw==1 */
/* 8/8 - Used */

unsigned char *t=(unsigned char *)book->dec_table;

for(i=0;i<read;i++){
	chase=t[chase*2+((lok>>i)&1)];
	if(chase&0x80UL)break;
}
chase&=0x7fUL;
break;
}
case 1:
{
/* book->dec_nodeb==1, book->dec_leafw!=1 */

/* 8/16 - Used by infile2 */
unsigned char *t=(unsigned char *)book->dec_table;
for(i=0;i<read;i++){
	int bit=(lok>>i)&1;
	int next=t[chase+bit];
	if(next&0x80){
	  chase= (next<<8) | t[chase+bit+1+(!bit || t[chase]&0x80)];
	  break;
	}
	chase=next;
}
//chase&=0x7fffUL;
chase&=~0x8000UL;
break;
}
case 2:
{

/* book->dec_nodeb==2, book->dec_leafw==1 */
/* 16/16 - Used */
for(i=0;i<read;i++){
	chase=((ogg_uint16_t *)(book->dec_table))[chase*2+((lok>>i)&1)];
	if(chase&0x8000UL)break;
}
//chase&=0x7fffUL;
chase&=~0x8000UL;
break;
}
case 3:
{
/* book->dec_nodeb==2, book->dec_leafw!=1 */

/* 16/32 - Used by infile2 */
ogg_uint16_t *t=(ogg_uint16_t *)book->dec_table;
for(i=0;i<read;i++){
	int bit=(lok>>i)&1;
	int next=t[chase+bit];
	if(next&0x8000){
	  chase= (next<<16) | t[chase+bit+1+(!bit || t[chase]&0x8000)];
	  break;
	}
	chase=next;
}
//chase&=0x7fffffffUL;
chase&=~0x80000000UL;
break;
}
case 4:

{
//Output(""32/32"");
for(i=0;i<read;i++){
	chase=((ogg_uint32_t *)(book->dec_table))[chase*2+((lok>>i)&1)];
	if(chase&0x80000000UL)break;
}
//chase&=0x7fffffffUL;
chase&=~0x80000000UL;
break;
}
}

if(i<read){
oggpack_adv(b,i+1);
return chase;
}
oggpack_adv(b,read+1);
return(-1);
}
","[1, 10, 20, 21, 22, 24, 25, 32, 33, 34, 35, 36, 37, 38, 39, 42, 43]",						      oggpack_buffer *b){/~/	chase=t[chase*2+((lok>>i)&1)];/~/	if(chase&0x80UL)break;/~/	int bit=(lok>>i)&1;/~/	int next=t[chase+bit];/~/	if(next&0x80){/~/	  chase= (next<<8) | t[chase+bit+1+(!bit || t[chase]&0x80)];/~/	  break;/~/	}/~/	chase=next;/~/	chase=((ogg_uint16_t *)(book->dec_table))[chase*2+((lok>>i)&1)];/~/	if(chase&0x8000UL)break;/~/	int bit=(lok>>i)&1;/~/	int next=t[chase+bit];/~/	if(next&0x8000){/~/	  chase= (next<<16) | t[chase+bit+1+(!bit || t[chase]&0x8000)];/~/	  break;/~/	}/~/	chase=next;/~/	chase=((ogg_uint32_t *)(book->dec_table))[chase*2+((lok>>i)&1)];/~/	if(chase&0x80000000UL)break;
461,"lookup_bytestring(netdissect_options *ndo, register const u_char *bs,
const unsigned int nlen)
{
	struct enamemem *tp;
register u_int i, j, k;

if (nlen >= 6) {
k = (bs[0] << 8) | bs[1];
j = (bs[2] << 8) | bs[3];
i = (bs[4] << 8) | bs[5];
} else if (nlen >= 4) {
k = (bs[0] << 8) | bs[1];
j = (bs[2] << 8) | bs[3];
i = 0;
} else
i = j = k = 0;

tp = &bytestringtable[(i ^ j) & (HASHNAMESIZE-1)];
	while (tp->e_nxt)
		if (tp->e_addr0 == i &&
		    tp->e_addr1 == j &&
		    tp->e_addr2 == k &&
		    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)
return tp;
else
			tp = tp->e_nxt;

	tp->e_addr0 = i;
	tp->e_addr1 = j;
	tp->e_addr2 = k;

	tp->e_bs = (u_char *) calloc(1, nlen + 1);
	if (tp->e_bs == NULL)
(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");

	memcpy(tp->e_bs, bs, nlen);
	tp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));
	if (tp->e_nxt == NULL)
(*ndo->ndo_error)(ndo, ""lookup_bytestring: calloc"");

return tp;
}
","[3, 16, 17, 18, 19, 20, 23, 24, 25, 26, 27, 28, 30, 31, 32]","	struct enamemem *tp;/~/	while (tp->e_nxt)/~/		if (tp->e_addr0 == i &&/~/		    tp->e_addr1 == j &&/~/		    tp->e_addr2 == k &&/~/		    memcmp((const char *)bs, (const char *)(tp->e_bs), nlen) == 0)/~/			tp = tp->e_nxt;/~/	tp->e_addr0 = i;/~/	tp->e_addr1 = j;/~/	tp->e_addr2 = k;/~/	tp->e_bs = (u_char *) calloc(1, nlen + 1);/~/	if (tp->e_bs == NULL)/~/	memcpy(tp->e_bs, bs, nlen);/~/	tp->e_nxt = (struct enamemem *)calloc(1, sizeof(*tp));/~/	if (tp->e_nxt == NULL)"
462,"static int i8042_start(struct serio *serio)
{
struct i8042_port *port = serio->port_data;

port->exists = true;
	mb();
return 0;
}
",[4],	mb();
463,"static int parse_report(transport_smart *transport, git_push *push)
{
git_pkt *pkt = NULL;
const char *line_end = NULL;
gitno_buffer *buf = &transport->buffer;
int error, recvd;
git_buf data_pkt_buf = GIT_BUF_INIT;

for (;;) {
if (buf->offset > 0)
error = git_pkt_parse_line(&pkt, buf->data,
&line_end, buf->offset);
else
error = GIT_EBUFS;

if (error < 0 && error != GIT_EBUFS) {
error = -1;
goto done;
}

if (error == GIT_EBUFS) {
if ((recvd = gitno_recv(buf)) < 0) {
error = recvd;
goto done;
}

if (recvd == 0) {
giterr_set(GITERR_NET, ""early EOF"");
error = GIT_EEOF;
goto done;
}
continue;
}

gitno_consume(buf, line_end);

error = 0;

		if (pkt == NULL)
			continue;
switch (pkt->type) {
case GIT_PKT_DATA:
/* This is a sideband packet which contains other packets */
error = add_push_report_sideband_pkt(push, (git_pkt_data *)pkt, &data_pkt_buf);
break;
case GIT_PKT_ERR:
giterr_set(GITERR_NET, ""report-status: Error reported: %s"",
((git_pkt_err *)pkt)->error);
error = -1;
break;
case GIT_PKT_PROGRESS:
if (transport->progress_cb) {
git_pkt_progress *p = (git_pkt_progress *) pkt;
error = transport->progress_cb(p->data, p->len, transport->message_cb_payload);
}
break;
default:
error = add_push_report_pkt(push, pkt);
break;
}

git_pkt_free(pkt);

/* add_push_report_pkt returns GIT_ITEROVER when it receives a flush */
if (error == GIT_ITEROVER) {
error = 0;
if (data_pkt_buf.size > 0) {
/* If there was data remaining in the pack data buffer,
* then the server sent a partial pkt-line */
giterr_set(GITERR_NET, ""Incomplete pack data pkt-line"");
error = GIT_ERROR;
}
goto done;
}

if (error < 0) {
goto done;
}
}
done:
git_buf_free(&data_pkt_buf);
return error;
}
","[27, 31, 32]",		if (pkt == NULL)/~/			continue;
464,"sg_common_write(Sg_fd * sfp, Sg_request * srp,
unsigned char *cmnd, int timeout, int blocking)
{
int k, at_head;
Sg_device *sdp = sfp->parentdp;
sg_io_hdr_t *hp = &srp->header;

srp->data.cmd_opcode = cmnd[0];	/* hold opcode of command */
hp->status = 0;
hp->masked_status = 0;
hp->msg_status = 0;
hp->info = 0;
hp->host_status = 0;
hp->driver_status = 0;
hp->resid = 0;
SCSI_LOG_TIMEOUT(4, sg_printk(KERN_INFO, sfp->parentdp,
""sg_common_write:  scsi opcode=0x%02x, cmd_size=%d\n"",
(int) cmnd[0], (int) hp->cmd_len));

k = sg_start_req(srp, cmnd);
if (k) {
SCSI_LOG_TIMEOUT(1, sg_printk(KERN_INFO, sfp->parentdp,
""sg_common_write: start_req err=%d\n"", k));
sg_finish_rem_req(srp);
return k;	/* probably out of space --> ENOMEM */
}
if (atomic_read(&sdp->detaching)) {
		if (srp->bio)
blk_end_request_all(srp->rq, -EIO);
sg_finish_rem_req(srp);
return -ENODEV;
}

hp->duration = jiffies_to_msecs(jiffies);
if (hp->interface_id != '\0' &&	/* v3 (or later) interface */
(SG_FLAG_Q_AT_TAIL & hp->flags))
at_head = 0;
else
at_head = 1;

srp->rq->timeout = timeout;
kref_get(&sfp->f_ref); /* sg_rq_end_io() does kref_put(). */
blk_execute_rq_nowait(sdp->device->request_queue, sdp->disk,
srp->rq, at_head, sg_rq_end_io);
return 0;
}
",[27],		if (srp->bio)
465,"void FragmentPaintPropertyTreeBuilder::UpdateClipPathClip(
bool spv1_compositing_specific_pass) {
// In SPv1*, composited path-based clip-path applies to a mask paint chunk
// instead of actual contents. We have to delay until mask clip node has been
// created first so we can parent under it.
bool is_spv1_composited =
object_.HasLayer() &&
ToLayoutBoxModelObject(object_).Layer()->GetCompositedLayerMapping();
if (is_spv1_composited != spv1_compositing_specific_pass)
return;

if (NeedsPaintPropertyUpdate()) {
if (!NeedsClipPathClip(object_)) {
OnClearClip(properties_->ClearClipPathClip());
} else {
ClipPaintPropertyNode::State state;
state.local_transform_space = context_.current.transform;
state.clip_rect =
FloatRoundedRect(FloatRect(*fragment_data_.ClipPathBoundingBox()));
state.clip_path = fragment_data_.ClipPathPath();
      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,
std::move(state)));
}
}

if (properties_->ClipPathClip() && !spv1_compositing_specific_pass) {
context_.current.clip = context_.absolute_position.clip =
context_.fixed_position.clip = properties_->ClipPathClip();
}
}
",[19],"      OnUpdateClip(properties_->UpdateClipPathClip(context_.current.clip,"
466,"static int atusb_get_and_show_revision(struct atusb *atusb)
{
struct usb_device *usb_dev = atusb->usb_dev;
	unsigned char buffer[3];
int ret;

/* Get a couple of the ATMega Firmware values */
ret = atusb_control_msg(atusb, usb_rcvctrlpipe(usb_dev, 0),
ATUSB_ID, ATUSB_REQ_FROM_DEV, 0, 0,
buffer, 3, 1000);
if (ret >= 0) {
atusb->fw_ver_maj = buffer[0];
atusb->fw_ver_min = buffer[1];
atusb->fw_hw_type = buffer[2];

dev_info(&usb_dev->dev,
""Firmware: major: %u, minor: %u, hardware type: %u\n"",
atusb->fw_ver_maj, atusb->fw_ver_min, atusb->fw_hw_type);
}
if (atusb->fw_ver_maj == 0 && atusb->fw_ver_min < 2) {
dev_info(&usb_dev->dev,
""Firmware version (%u.%u) predates our first public release."",
atusb->fw_ver_maj, atusb->fw_ver_min);
dev_info(&usb_dev->dev, ""Please update to version 0.2 or newer"");
}

return ret;
}
",[3],	unsigned char buffer[3];
467,"void HandleCompleteLogin(const base::ListValue* args) {
// TODO(guohui, xiyuan): we should investigate if it is possible to unify
// the signin-with-cookies flow across ChromeOS and Chrome.
#if defined(OS_CHROMEOS)
oauth2_delegate_.reset(new InlineLoginUIOAuth2Delegate(web_ui()));
oauth2_token_fetcher_.reset(new chromeos::OAuth2TokenFetcher(
oauth2_delegate_.get(), profile_->GetRequestContext()));
oauth2_token_fetcher_->StartExchangeFromCookies();
#elif !defined(OS_ANDROID)
const base::DictionaryValue* dict = NULL;
string16 email;
string16 password;
if (!args->GetDictionary(0, &dict) || !dict ||
!dict->GetString(""email"", &email) ||
!dict->GetString(""password"", &password)) {
NOTREACHED();
return;
}

// Call OneClickSigninSyncStarter to exchange cookies for oauth tokens.
// OneClickSigninSyncStarter will delete itself once the job is done.
// TODO(guohui): should collect from user whether they want to use
// default sync settings or configure first.
new OneClickSigninSyncStarter(
profile_, NULL, ""0"" /* session_index 0 for the default user */,
UTF16ToASCII(email), UTF16ToASCII(password),
OneClickSigninSyncStarter::SYNC_WITH_DEFAULT_SETTINGS,
true /* force_same_tab_navigation */,
        OneClickSigninSyncStarter::NO_CONFIRMATION);
web_ui()->CallJavascriptFunction(""inline.login.closeDialog"");
#endif
}
",[27],        OneClickSigninSyncStarter::NO_CONFIRMATION);
468,"static int hid_abort_transfers(int sub_api, struct usbi_transfer *itransfer)
{
	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);
	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);
	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);
	HANDLE hid_handle;
	int current_interface;
	CHECK_HID_AVAILABLE;
	current_interface = transfer_priv->interface_number;
	hid_handle = handle_priv->interface_handle[current_interface].api_handle;
	CancelIo(hid_handle);
	return LIBUSB_SUCCESS;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]",{/~/	struct libusb_transfer *transfer = USBI_TRANSFER_TO_LIBUSB_TRANSFER(itransfer);/~/	struct windows_transfer_priv *transfer_priv = (struct windows_transfer_priv*)usbi_transfer_get_os_priv(itransfer);/~/	struct windows_device_handle_priv *handle_priv = _device_handle_priv(transfer->dev_handle);/~/	HANDLE hid_handle;/~/	int current_interface;/~/	CHECK_HID_AVAILABLE;/~/	current_interface = transfer_priv->interface_number;/~/	hid_handle = handle_priv->interface_handle[current_interface].api_handle;/~/	CancelIo(hid_handle);/~/	return LIBUSB_SUCCESS;/~/}
469,"static void *__alloc_from_pool(size_t size, struct page **ret_page, gfp_t flags)
{
unsigned long val;
void *ptr = NULL;

if (!atomic_pool) {
WARN(1, ""coherent pool not initialised!\n"");
return NULL;
}

val = gen_pool_alloc(atomic_pool, size);
if (val) {
phys_addr_t phys = gen_pool_virt_to_phys(atomic_pool, val);

*ret_page = phys_to_page(phys);
ptr = (void *)val;
		if (flags & __GFP_ZERO)
			memset(ptr, 0, size);
}

return ptr;
}
","[13, 14]","		if (flags & __GFP_ZERO)/~/			memset(ptr, 0, size);"
470,"AirPDcapDecryptWPABroadcastKey(const EAPOL_RSN_KEY *pEAPKey, guint8 *decryption_key, PAIRPDCAP_SEC_ASSOCIATION sa, guint eapol_len)
{
guint8 key_version;
guint8 *key_data;
guint8  *szEncryptedKey;
guint16 key_bytes_len = 0; /* Length of the total key data field */
guint16 key_len;           /* Actual group key length */
static AIRPDCAP_KEY_ITEM dummy_key; /* needed in case AirPDcapRsnaMng() wants the key structure */
AIRPDCAP_SEC_ASSOCIATION *tmp_sa;

/* We skip verifying the MIC of the key. If we were implementing a WPA supplicant we'd want to verify, but for a sniffer it's not needed. */

/* Preparation for decrypting the group key -  determine group key data length */
/* depending on whether the pairwise key is TKIP or AES encryption key */
key_version = AIRPDCAP_EAP_KEY_DESCR_VER(pEAPKey->key_information[1]);
if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){
/* TKIP */
key_bytes_len = pntoh16(pEAPKey->key_length);
}else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){
/* AES */
key_bytes_len = pntoh16(pEAPKey->key_data_len);

/* AES keys must be at least 128 bits = 16 bytes. */
if (key_bytes_len < 16) {
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}
}

    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}

/* Encrypted key is in the information element field of the EAPOL key packet */
key_data = (guint8 *)pEAPKey + sizeof(EAPOL_RSN_KEY);
szEncryptedKey = (guint8 *)g_memdup(key_data, key_bytes_len);

DEBUG_DUMP(""Encrypted Broadcast key:"", szEncryptedKey, key_bytes_len);
DEBUG_DUMP(""KeyIV:"", pEAPKey->key_iv, 16);
DEBUG_DUMP(""decryption_key:"", decryption_key, 16);

/* We are rekeying, save old sa */
tmp_sa=(AIRPDCAP_SEC_ASSOCIATION *)g_malloc(sizeof(AIRPDCAP_SEC_ASSOCIATION));
memcpy(tmp_sa, sa, sizeof(AIRPDCAP_SEC_ASSOCIATION));
sa->next=tmp_sa;

/* As we have no concept of the prior association request at this point, we need to deduce the     */
/* group key cipher from the length of the key bytes. In WPA this is straightforward as the        */
/* keybytes just contain the GTK, and the GTK is only in the group handshake, NOT the M3.          */
/* In WPA2 its a little more tricky as the M3 keybytes contain an RSN_IE, but the group handshake  */
/* does not. Also there are other (variable length) items in the keybytes which we need to account */
/* for to determine the true key length, and thus the group cipher.                                */

if (key_version == AIRPDCAP_WPA_KEY_VER_NOT_CCMP){
guint8 new_key[32];
guint8 dummy[256];
/* TKIP key */
/* Per 802.11i, Draft 3.0 spec, section 8.5.2, p. 97, line 4-8, */
/* group key is decrypted using RC4.  Concatenate the IV with the 16 byte EK (PTK+16) to get the decryption key */

rc4_state_struct rc4_state;

/* The WPA group key just contains the GTK bytes so deducing the type is straightforward   */
/* Note - WPA M3 doesn't contain a group key so we'll only be here for the group handshake */
sa->wpa.key_ver = (key_bytes_len >=TKIP_GROUP_KEY_LEN)?AIRPDCAP_WPA_KEY_VER_NOT_CCMP:AIRPDCAP_WPA_KEY_VER_AES_CCMP;

/* Build the full decryption key based on the IV and part of the pairwise key */
memcpy(new_key, pEAPKey->key_iv, 16);
memcpy(new_key+16, decryption_key, 16);
DEBUG_DUMP(""FullDecrKey:"", new_key, 32);

crypt_rc4_init(&rc4_state, new_key, sizeof(new_key));

/* Do dummy 256 iterations of the RC4 algorithm (per 802.11i, Draft 3.0, p. 97 line 6) */
crypt_rc4(&rc4_state, dummy, 256);
crypt_rc4(&rc4_state, szEncryptedKey, key_bytes_len);

} else if (key_version == AIRPDCAP_WPA_KEY_VER_AES_CCMP){
/* AES CCMP key */

guint8 key_found;
guint8 key_length;
guint16 key_index;
guint8 *decrypted_data;

/* Unwrap the key; the result is key_bytes_len in length */
decrypted_data = AES_unwrap(decryption_key, 16, szEncryptedKey,  key_bytes_len);

/* With WPA2 what we get after Broadcast Key decryption is an actual RSN structure.
The key itself is stored as a GTK KDE
WPA2 IE (1 byte) id = 0xdd, length (1 byte), GTK OUI (4 bytes), key index (1 byte) and 1 reserved byte. Thus we have to
pass pointer to the actual key with 8 bytes offset */

key_found = FALSE;
key_index = 0;

/* Parse Key data until we found GTK KDE */
/* GTK KDE = 00-0F-AC 01 */
while(key_index < (key_bytes_len - 6) && !key_found){
guint8 rsn_id;
guint32 type;

/* Get RSN ID */
rsn_id = decrypted_data[key_index];
type = ((decrypted_data[key_index + 2] << 24) +
(decrypted_data[key_index + 3] << 16) +
(decrypted_data[key_index + 4] << 8) +
(decrypted_data[key_index + 5]));

if (rsn_id == 0xdd && type == 0x000fac01) {
key_found = TRUE;
} else {
key_index += decrypted_data[key_index+1]+2;
}
}

if (key_found){
key_length = decrypted_data[key_index+1] - 6;

if (key_index+8 >= key_bytes_len ||
key_length > key_bytes_len - key_index - 8) {
g_free(decrypted_data);
g_free(szEncryptedKey);
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}

/* Skip over the GTK header info, and don't copy past the end of the encrypted data */
memcpy(szEncryptedKey, decrypted_data+key_index+8, key_length);
} else {
g_free(decrypted_data);
g_free(szEncryptedKey);
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}

if (key_length == TKIP_GROUP_KEY_LEN)
sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_NOT_CCMP;
else
sa->wpa.key_ver = AIRPDCAP_WPA_KEY_VER_AES_CCMP;

g_free(decrypted_data);
}

key_len = (sa->wpa.key_ver==AIRPDCAP_WPA_KEY_VER_NOT_CCMP)?TKIP_GROUP_KEY_LEN:CCMP_GROUP_KEY_LEN;
if (key_len > key_bytes_len) {
/* the key required for this protocol is longer than the key that we just calculated */
g_free(szEncryptedKey);
return AIRPDCAP_RET_NO_VALID_HANDSHAKE;
}

/* Decrypted key is now in szEncryptedKey with len of key_len */
DEBUG_DUMP(""Broadcast key:"", szEncryptedKey, key_len);

/* Load the proper key material info into the SA */
sa->key = &dummy_key;  /* we just need key to be not null because it is checked in AirPDcapRsnaMng().  The WPA key materials are actually in the .wpa structure */
sa->validKey = TRUE;

/* Since this is a GTK and its size is only 32 bytes (vs. the 64 byte size of a PTK), we fake it and put it in at a 32-byte offset so the  */
/* AirPDcapRsnaMng() function will extract the right piece of the GTK for decryption. (The first 16 bytes of the GTK are used for decryption.) */
memset(sa->wpa.ptk, 0, sizeof(sa->wpa.ptk));
memcpy(sa->wpa.ptk+32, szEncryptedKey, key_len);
g_free(szEncryptedKey);
return AIRPDCAP_RET_SUCCESS_HANDSHAKE;
}
",[24],    if (key_bytes_len < GROUP_KEY_MIN_LEN || key_bytes_len > eapol_len - sizeof(EAPOL_RSN_KEY)) {
471,"bool AudioHandler::VerifyMixerConnection() {
  PulseAudioMixer::State mixer_state = mixer_->CheckState();
  if (mixer_state == PulseAudioMixer::READY)
return true;
if (connected_) {
// Something happened and the mixer is no longer valid after having been
// initialized earlier.
connected_ = false;
    LOG(ERROR) << ""Lost connection to PulseAudio"";
} else {
LOG(ERROR) << ""Mixer not valid"";
}

  if ((mixer_state == PulseAudioMixer::INITIALIZING) ||
      (mixer_state == PulseAudioMixer::SHUTTING_DOWN))
return false;

if (reconnect_tries_ < kMaxReconnectTries) {
reconnect_tries_++;
    VLOG(1) << ""Re-connecting to PulseAudio attempt "" << reconnect_tries_ << ""/""
<< kMaxReconnectTries;
    mixer_.reset(new PulseAudioMixer());
    connected_ = mixer_->InitSync();
if (connected_) {
reconnect_tries_ = 0;
return true;
}
    LOG(ERROR) << ""Unable to re-connect to PulseAudio"";
}
return false;
}
","[1, 2, 8, 12, 13, 17, 19, 20, 25]","  PulseAudioMixer::State mixer_state = mixer_->CheckState();/~/  if (mixer_state == PulseAudioMixer::READY)/~/    LOG(ERROR) << ""Lost connection to PulseAudio"";/~/  if ((mixer_state == PulseAudioMixer::INITIALIZING) ||/~/      (mixer_state == PulseAudioMixer::SHUTTING_DOWN))/~/    VLOG(1) << ""Re-connecting to PulseAudio attempt "" << reconnect_tries_ << ""/""/~/    mixer_.reset(new PulseAudioMixer());/~/    connected_ = mixer_->InitSync();/~/    LOG(ERROR) << ""Unable to re-connect to PulseAudio"";"
472,"void DriveFileStreamReader::InitializeAfterGetFileContentByPathInitialized(
const base::FilePath& drive_file_path,
const InitializeCompletionCallback& callback,
FileError error,
scoped_ptr<DriveEntryProto> entry,
const base::FilePath& local_cache_file_path) {
DCHECK(BrowserThread::CurrentlyOn(BrowserThread::IO));

if (error != FILE_ERROR_OK) {
callback.Run(error, scoped_ptr<DriveEntryProto>());
return;
}
DCHECK(entry);

if (local_cache_file_path.empty()) {
// The file is not cached, and being downloaded.
reader_proxy_.reset(
new internal::NetworkReaderProxy(
            entry->file_info().size(),
base::Bind(&internal::CancelGetFile,
drive_file_system_getter_, drive_file_path)));
callback.Run(FILE_ERROR_OK, entry.Pass());
return;
}

// Otherwise, open the stream for file.
scoped_ptr<net::FileStream> file_stream(new net::FileStream(NULL));
net::FileStream* file_stream_ptr = file_stream.get();
net::CompletionCallback open_completion_callback = base::Bind(
&DriveFileStreamReader::InitializeAfterLocalFileOpen,
weak_ptr_factory_.GetWeakPtr(),
callback,
base::Passed(&entry),
base::Passed(&file_stream));
int result = file_stream_ptr->Open(
local_cache_file_path,
base::PLATFORM_FILE_OPEN | base::PLATFORM_FILE_READ |
base::PLATFORM_FILE_ASYNC,
open_completion_callback);

if (result == net::ERR_IO_PENDING) {
// If the result ERR_IO_PENDING, the callback will be invoked later.
// Do nothing here.
return;
}

open_completion_callback.Run(result);
}
",[16],"            entry->file_info().size(),"
473,"static void unix_detach_fds(struct scm_cookie *scm, struct sk_buff *skb)
{
int i;

scm->fp = UNIXCB(skb).fp;
UNIXCB(skb).fp = NULL;

for (i = scm->fp->count-1; i >= 0; i--)
		unix_notinflight(scm->fp->fp[i]);
}
",[6],		unix_notinflight(scm->fp->fp[i]);
474,"void HeapAllocator::backingFree(void* address) {
if (!address)
return;

ThreadState* state = ThreadState::current();
if (state->sweepForbidden())
return;
ASSERT(!state->isInGC());

// Don't promptly free large objects because their page is never reused.
// Don't free backings allocated on other threads.
BasePage* page = pageFromObject(address);
if (page->isLargeObjectPage() || page->arena()->getThreadState() != state)
return;

HeapObjectHeader* header = HeapObjectHeader::fromPayload(address);
  ASSERT(header->checkHeader());
NormalPageArena* arena = static_cast<NormalPage*>(page)->arenaForNormalPage();
state->promptlyFreed(header->gcInfoIndex());
arena->promptlyFreeObject(header);
}
",[13],  ASSERT(header->checkHeader());
475,"static void perf_swevent_overflow(struct perf_event *event, u64 overflow,
				    int nmi, struct perf_sample_data *data,
struct pt_regs *regs)
{
struct hw_perf_event *hwc = &event->hw;
int throttle = 0;

data->period = event->hw.last_period;
if (!overflow)
overflow = perf_swevent_set_period(event);

if (hwc->interrupts == MAX_INTERRUPTS)
return;

for (; overflow; overflow--) {
		if (__perf_event_overflow(event, nmi, throttle,
data, regs)) {
/*
* We inhibit the overflow from happening when
* hwc->interrupts == MAX_INTERRUPTS.
*/
break;
}
throttle = 1;
}
}
","[1, 12]","				    int nmi, struct perf_sample_data *data,/~/		if (__perf_event_overflow(event, nmi, throttle,"
476,"void MediaControlsProgressView::HandleSeeking(
    const gfx::Point& location_in_bar) {
double seek_to_progress =
static_cast<double>(location_in_bar.x()) / progress_bar_->width();
seek_callback_.Run(seek_to_progress);
}
",[1],    const gfx::Point& location_in_bar) {
477,"sctp_disposition_t sctp_sf_ootb(struct net *net,
const struct sctp_endpoint *ep,
const struct sctp_association *asoc,
const sctp_subtype_t type,
void *arg,
sctp_cmd_seq_t *commands)
{
struct sctp_chunk *chunk = arg;
struct sk_buff *skb = chunk->skb;
sctp_chunkhdr_t *ch;
sctp_errhdr_t *err;
__u8 *ch_end;
int ootb_shut_ack = 0;
int ootb_cookie_ack = 0;

SCTP_INC_STATS(net, SCTP_MIB_OUTOFBLUES);

ch = (sctp_chunkhdr_t *) chunk->chunk_hdr;
do {
/* Report violation if the chunk is less then minimal */
if (ntohs(ch->length) < sizeof(sctp_chunkhdr_t))
return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
commands);

/* Now that we know we at least have a chunk header,
* do things that are type appropriate.
*/
if (SCTP_CID_SHUTDOWN_ACK == ch->type)
ootb_shut_ack = 1;

/* RFC 2960, Section 3.3.7
*   Moreover, under any circumstances, an endpoint that
*   receives an ABORT  MUST NOT respond to that ABORT by
*   sending an ABORT of its own.
*/
if (SCTP_CID_ABORT == ch->type)
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);

/* RFC 8.4, 7) If the packet contains a ""Stale cookie"" ERROR
* or a COOKIE ACK the SCTP Packet should be silently
* discarded.
*/

if (SCTP_CID_COOKIE_ACK == ch->type)
ootb_cookie_ack = 1;

if (SCTP_CID_ERROR == ch->type) {
sctp_walk_errors(err, ch) {
if (SCTP_ERROR_STALE_COOKIE == err->cause) {
ootb_cookie_ack = 1;
break;
}
}
}

		/* Report violation if chunk len overflows *
		ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));
		if (ch_end > skb_tail_pointer(skb))
			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,
						  commands);
ch = (sctp_chunkhdr_t *) ch_end;
} while (ch_end < skb_tail_pointer(skb));

if (ootb_shut_ack)
return sctp_sf_shut_8_4_5(net, ep, asoc, type, arg, commands);
else if (ootb_cookie_ack)
return sctp_sf_pdiscard(net, ep, asoc, type, arg, commands);
else
return sctp_sf_tabort_8_4_8(net, ep, asoc, type, arg, commands);
}
","[19, 20]","		/* Report violation if chunk len overflows */~/		ch_end = ((__u8 *)ch) + SCTP_PAD4(ntohs(ch->length));/~/		if (ch_end > skb_tail_pointer(skb))/~/			return sctp_sf_violation_chunklen(net, ep, asoc, type, arg,/~/						  commands);"
478,"static void webkitWebViewBaseContainerAdd(GtkContainer* container, GtkWidget* widget)
{
WebKitWebViewBase* webView = WEBKIT_WEB_VIEW_BASE(container);
WebKitWebViewBasePrivate* priv = webView->priv;

if (WEBKIT_IS_WEB_VIEW_BASE(widget)
&& WebInspectorProxy::isInspectorPage(WEBKIT_WEB_VIEW_BASE(widget)->priv->pageProxy.get())) {
ASSERT(!priv->inspectorView);
priv->inspectorView = widget;
        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;
} else {
GtkAllocation childAllocation;
gtk_widget_get_allocation(widget, &childAllocation);
priv->children.set(widget, childAllocation);
}

gtk_widget_set_parent(widget, GTK_WIDGET(container));
}
",[8],        priv->inspectorViewHeight = gMinimumAttachedInspectorHeight;
479,"ResourceDispatcherHost::~ResourceDispatcherHost() {
AsyncResourceHandler::GlobalCleanup();
STLDeleteValues(&pending_requests_);

user_script_listener_->ShutdownMainThread();
  // Clear blocked requests if any left.
  // Note that we have to do this in 2 passes as we cannot call
  // CancelBlockedRequestsForRoute while iterating over
  // blocked_requests_map_, as it modifies it.
  std::set<ProcessRouteIDs> ids;
  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();
       iter != blocked_requests_map_.end(); ++iter) {
    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =
        ids.insert(iter->first);
    // We should not have duplicates.
    DCHECK(result.second);
  }
  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();
       iter != ids.end(); ++iter) {
    CancelBlockedRequestsForRoute(iter->first, iter->second);
  }
}
","[4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]","  // Clear blocked requests if any left./~/  // Note that we have to do this in 2 passes as we cannot call/~/  // CancelBlockedRequestsForRoute while iterating over/~/  // blocked_requests_map_, as it modifies it./~/  std::set<ProcessRouteIDs> ids;/~/  for (BlockedRequestMap::const_iterator iter = blocked_requests_map_.begin();/~/       iter != blocked_requests_map_.end(); ++iter) {/~/    std::pair<std::set<ProcessRouteIDs>::iterator, bool> result =/~/        ids.insert(iter->first);/~/    // We should not have duplicates./~/    DCHECK(result.second);/~/  }/~/  for (std::set<ProcessRouteIDs>::const_iterator iter = ids.begin();/~/       iter != ids.end(); ++iter) {/~/    CancelBlockedRequestsForRoute(iter->first, iter->second);/~/  }"
480,"void ServiceWorkerDevToolsAgentHost::AttachSession(DevToolsSession* session) {
if (state_ == WORKER_READY) {
if (sessions().size() == 1) {
BrowserThread::PostTask(BrowserThread::IO, FROM_HERE,
base::BindOnce(&SetDevToolsAttachedOnIO,
context_weak_, version_id_, true));
}
    // RenderProcessHost should not be null here, but even if it _is_ null,
    // session does not depend on the process to do messaging.
    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),
                         nullptr);
session->AttachToAgent(agent_ptr_);
}
session->AddHandler(base::WrapUnique(new protocol::InspectorHandler()));
session->AddHandler(base::WrapUnique(new protocol::NetworkHandler(GetId())));
session->AddHandler(base::WrapUnique(new protocol::SchemaHandler()));
}
","[7, 8, 9, 10]","    // RenderProcessHost should not be null here, but even if it _is_ null,/~/    // session does not depend on the process to do messaging./~/    session->SetRenderer(RenderProcessHost::FromID(worker_process_id_),/~/                         nullptr);"
481,"cdf_file_summary_info(struct magic_set *ms, const cdf_header_t *h,
    const cdf_stream_t *sst, const uint64_t clsid[2])
{
cdf_summary_info_header_t si;
cdf_property_info_t *info;
size_t count;
int m;

if (cdf_unpack_summary_info(sst, h, &si, &info, &count) == -1)
return -1;

if (NOTMIME(ms)) {
const char *str;

if (file_printf(ms, ""Composite Document File V2 Document"")
== -1)
return -1;

if (file_printf(ms, "", %s Endian"",
si.si_byte_order == 0xfffe ?  ""Little"" : ""Big"") == -1)
return -2;
switch (si.si_os) {
case 2:
if (file_printf(ms, "", Os: Windows, Version %d.%d"",
si.si_os_version & 0xff,
(uint32_t)si.si_os_version >> 8) == -1)
return -2;
break;
case 1:
if (file_printf(ms, "", Os: MacOS, Version %d.%d"",
(uint32_t)si.si_os_version >> 8,
si.si_os_version & 0xff) == -1)
return -2;
break;
default:
if (file_printf(ms, "", Os %d, Version: %d.%d"", si.si_os,
si.si_os_version & 0xff,
(uint32_t)si.si_os_version >> 8) == -1)
return -2;
break;
}
		str = cdf_clsid_to_mime(clsid, clsid2desc);
		if (str)
                        if (file_printf(ms, "", %s"", str) == -1)
				return -2;
        }

        m = cdf_file_property_info(ms, info, count, clsid);
free(info);

return m == -1 ? -2 : m;
}
","[1, 16, 22, 28, 34, 36, 37, 38, 39]","    const cdf_stream_t *sst, const uint64_t clsid[2])/~/		str = cdf_clsid_to_mime(clsid, clsid2desc);/~/		if (str)/~/                        if (file_printf(ms, "", %s"", str) == -1)/~/				return -2;/~/        }/~/        m = cdf_file_property_info(ms, info, count, clsid);"
482,"PageInfoUI::GetSecurityDescription(const IdentityInfo& identity_info) const {
std::unique_ptr<PageInfoUI::SecurityDescription> security_description(
new PageInfoUI::SecurityDescription());

  switch (identity_info.safe_browsing_status) {
    case PageInfo::SAFE_BROWSING_STATUS_NONE:
      break;
    case PageInfo::SAFE_BROWSING_STATUS_MALWARE:
      return CreateSecurityDescription(SecuritySummaryColor::RED,
                                       IDS_PAGE_INFO_MALWARE_SUMMARY,
                                       IDS_PAGE_INFO_MALWARE_DETAILS);
    case PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING:
      return CreateSecurityDescription(
          SecuritySummaryColor::RED, IDS_PAGE_INFO_SOCIAL_ENGINEERING_SUMMARY,
          IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);
    case PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE:
      return CreateSecurityDescription(SecuritySummaryColor::RED,
                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_SUMMARY,
                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);
    case PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE:
#if defined(FULL_SAFE_BROWSING)
      return CreateSecurityDescriptionForPasswordReuse(
          /*is_enterprise_password=*/false);
#endif
      NOTREACHED();
      break;
    case PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE:
#if defined(FULL_SAFE_BROWSING)
      return CreateSecurityDescriptionForPasswordReuse(
          /*is_enterprise_password=*/true);
#endif
      NOTREACHED();
      break;
    case PageInfo::SAFE_BROWSING_STATUS_BILLING:
      return CreateSecurityDescription(SecuritySummaryColor::RED,
                                       IDS_PAGE_INFO_BILLING_SUMMARY,
                                       IDS_PAGE_INFO_BILLING_DETAILS);
  }
switch (identity_info.identity_status) {
case PageInfo::SITE_IDENTITY_STATUS_INTERNAL_PAGE:
#if defined(OS_ANDROID)
// We provide identical summary and detail strings for Android, which
// deduplicates them in the UI code.
return CreateSecurityDescription(SecuritySummaryColor::GREEN,
IDS_PAGE_INFO_INTERNAL_PAGE,
IDS_PAGE_INFO_INTERNAL_PAGE);
#else
// Internal pages on desktop have their own UI implementations which
// should never call this function.
NOTREACHED();
FALLTHROUGH;
#endif
case PageInfo::SITE_IDENTITY_STATUS_EV_CERT:
FALLTHROUGH;
case PageInfo::SITE_IDENTITY_STATUS_CERT:
FALLTHROUGH;
case PageInfo::SITE_IDENTITY_STATUS_CERT_REVOCATION_UNKNOWN:
FALLTHROUGH;
case PageInfo::SITE_IDENTITY_STATUS_ADMIN_PROVIDED_CERT:
switch (identity_info.connection_status) {
case PageInfo::SITE_CONNECTION_STATUS_INSECURE_ACTIVE_SUBRESOURCE:
return CreateSecurityDescription(SecuritySummaryColor::RED,
IDS_PAGE_INFO_NOT_SECURE_SUMMARY,
IDS_PAGE_INFO_NOT_SECURE_DETAILS);
case PageInfo::SITE_CONNECTION_STATUS_INSECURE_FORM_ACTION:
return CreateSecurityDescription(SecuritySummaryColor::RED,
IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,
IDS_PAGE_INFO_NOT_SECURE_DETAILS);
case PageInfo::SITE_CONNECTION_STATUS_INSECURE_PASSIVE_SUBRESOURCE:
return CreateSecurityDescription(SecuritySummaryColor::RED,
IDS_PAGE_INFO_MIXED_CONTENT_SUMMARY,
IDS_PAGE_INFO_MIXED_CONTENT_DETAILS);
default:
return CreateSecurityDescription(SecuritySummaryColor::GREEN,
IDS_PAGE_INFO_SECURE_SUMMARY,
IDS_PAGE_INFO_SECURE_DETAILS);
}
case PageInfo::SITE_IDENTITY_STATUS_DEPRECATED_SIGNATURE_ALGORITHM:
case PageInfo::SITE_IDENTITY_STATUS_UNKNOWN:
case PageInfo::SITE_IDENTITY_STATUS_NO_CERT:
default:
return CreateSecurityDescription(SecuritySummaryColor::RED,
IDS_PAGE_INFO_NOT_SECURE_SUMMARY,
IDS_PAGE_INFO_NOT_SECURE_DETAILS);
}
}
","[3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]","  switch (identity_info.safe_browsing_status) {/~/    case PageInfo::SAFE_BROWSING_STATUS_NONE:/~/      break;/~/    case PageInfo::SAFE_BROWSING_STATUS_MALWARE:/~/      return CreateSecurityDescription(SecuritySummaryColor::RED,/~/                                       IDS_PAGE_INFO_MALWARE_SUMMARY,/~/                                       IDS_PAGE_INFO_MALWARE_DETAILS);/~/    case PageInfo::SAFE_BROWSING_STATUS_SOCIAL_ENGINEERING:/~/      return CreateSecurityDescription(/~/          SecuritySummaryColor::RED, IDS_PAGE_INFO_SOCIAL_ENGINEERING_SUMMARY,/~/          IDS_PAGE_INFO_SOCIAL_ENGINEERING_DETAILS);/~/    case PageInfo::SAFE_BROWSING_STATUS_UNWANTED_SOFTWARE:/~/      return CreateSecurityDescription(SecuritySummaryColor::RED,/~/                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_SUMMARY,/~/                                       IDS_PAGE_INFO_UNWANTED_SOFTWARE_DETAILS);/~/    case PageInfo::SAFE_BROWSING_STATUS_SIGN_IN_PASSWORD_REUSE:/~/#if defined(FULL_SAFE_BROWSING)/~/      return CreateSecurityDescriptionForPasswordReuse(/~/          /*is_enterprise_password=*/false);/~/#endif/~/      NOTREACHED();/~/      break;/~/    case PageInfo::SAFE_BROWSING_STATUS_ENTERPRISE_PASSWORD_REUSE:/~/#if defined(FULL_SAFE_BROWSING)/~/      return CreateSecurityDescriptionForPasswordReuse(/~/          /*is_enterprise_password=*/true);/~/#endif/~/      NOTREACHED();/~/      break;/~/    case PageInfo::SAFE_BROWSING_STATUS_BILLING:/~/      return CreateSecurityDescription(SecuritySummaryColor::RED,/~/                                       IDS_PAGE_INFO_BILLING_SUMMARY,/~/                                       IDS_PAGE_INFO_BILLING_DETAILS);/~/  }"
483,"static int cx24116_send_diseqc_msg(struct dvb_frontend *fe,
struct dvb_diseqc_master_cmd *d)
{
struct cx24116_state *state = fe->demodulator_priv;
int i, ret;

/* Dump DiSEqC message */
if (debug) {
printk(KERN_INFO ""cx24116: %s("", __func__);
for (i = 0 ; i < d->msg_len ;) {
printk(KERN_INFO ""0x%02x"", d->msg[i]);
if (++i < d->msg_len)
printk(KERN_INFO "", "");
}
printk("") toneburst=%d\n"", toneburst);
}

	/* Validate length *
	if (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))
		return -EINVAL;
/* DiSEqC message */
for (i = 0; i < d->msg_len; i++)
state->dsec_cmd.args[CX24116_DISEQC_MSGOFS + i] = d->msg[i];

/* DiSEqC message length */
state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] = d->msg_len;

/* Command length */
state->dsec_cmd.len = CX24116_DISEQC_MSGOFS +
state->dsec_cmd.args[CX24116_DISEQC_MSGLEN];

/* DiSEqC toneburst */
if (toneburst == CX24116_DISEQC_MESGCACHE)
/* Message is cached */
return 0;

else if (toneburst == CX24116_DISEQC_TONEOFF)
/* Message is sent without burst */
state->dsec_cmd.args[CX24116_DISEQC_BURST] = 0;

else if (toneburst == CX24116_DISEQC_TONECACHE) {
/*
* Message is sent with derived else cached burst
*
* WRITE PORT GROUP COMMAND 38
*
* 0/A/A: E0 10 38 F0..F3
* 1/B/B: E0 10 38 F4..F7
* 2/C/A: E0 10 38 F8..FB
* 3/D/B: E0 10 38 FC..FF
*
* databyte[3]= 8421:8421
*              ABCD:WXYZ
*              CLR :SET
*
*              WX= PORT SELECT 0..3    (X=TONEBURST)
*              Y = VOLTAGE             (0=13V, 1=18V)
*              Z = BAND                (0=LOW, 1=HIGH(22K))
*/
if (d->msg_len >= 4 && d->msg[2] == 0x38)
state->dsec_cmd.args[CX24116_DISEQC_BURST] =
((d->msg[3] & 4) >> 2);
if (debug)
dprintk(""%s burst=%d\n"", __func__,
state->dsec_cmd.args[CX24116_DISEQC_BURST]);
}

/* Wait for LNB ready */
ret = cx24116_wait_for_lnb(fe);
if (ret != 0)
return ret;

/* Wait for voltage/min repeat delay */
msleep(100);

/* Command */
ret = cx24116_cmd_execute(fe, &state->dsec_cmd);
if (ret != 0)
return ret;
/*
* Wait for send
*
* Eutelsat spec:
* >15ms delay          + (XXX determine if FW does this, see set_tone)
*  13.5ms per byte     +
* >15ms delay          +
*  12.5ms burst        +
* >15ms delay            (XXX determine if FW does this, see set_tone)
*/
msleep((state->dsec_cmd.args[CX24116_DISEQC_MSGLEN] << 4) +
((toneburst == CX24116_DISEQC_TONEOFF) ? 30 : 60));

return 0;
}
","[15, 16, 17]",	/* Validate length */~/	if (d->msg_len > (CX24116_ARGLEN - CX24116_DISEQC_MSGOFS))/~/		return -EINVAL;
484,"gst_vorbis_tag_add_coverart (GstTagList * tags, const gchar * img_data_base64,
gint base64_len)
{
GstBuffer *img;
  guchar *img_data;
gsize img_len;
guint save = 0;
gint state = 0;

if (base64_len < 2)
goto not_enough_data;

  img_data = g_try_malloc0 (base64_len * 3 / 4);
  if (img_data == NULL)
    goto alloc_failed;
  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,
      &state, &save);

if (img_len == 0)
goto decode_failed;

  img = gst_tag_image_data_to_image_buffer (img_data, img_len,
GST_TAG_IMAGE_TYPE_NONE);

if (img == NULL)
gst_tag_list_add (tags, GST_TAG_MERGE_APPEND,
GST_TAG_PREVIEW_IMAGE, img, NULL);

GST_TAG_PREVIEW_IMAGE, img, NULL);

gst_buffer_unref (img);
  g_free (img_data);
return;

/* ERRORS */
{
GST_WARNING (""COVERART tag with too little base64-encoded data"");
GST_WARNING (""COVERART tag with too little base64-encoded data"");
return;
}
alloc_failed:
  {
    GST_WARNING (""Couldn't allocate enough memory to decode COVERART tag"");
    return;
  }
decode_failed:
{
    GST_WARNING (""Couldn't decode bas64 image data from COVERART tag"");
    g_free (img_data);
return;
}
convert_failed:
{
GST_WARNING (""Couldn't extract image or image type from COVERART tag"");
    g_free (img_data);
return;
}
}
","[2, 4, 10, 11, 12, 13, 14, 17, 24, 25, 27, 30, 31, 32, 33, 34, 35, 36, 38, 39, 40, 41, 42, 44, 46, 47]","  guchar *img_data;/~/  img_data = g_try_malloc0 (base64_len * 3 / 4);/~/  if (img_data == NULL)/~/    goto alloc_failed;/~/  img_len = g_base64_decode_step (img_data_base64, base64_len, img_data,/~/      &state, &save);/~/  img = gst_tag_image_data_to_image_buffer (img_data, img_len,/~/  g_free (img_data);/~/alloc_failed:/~/  {/~/    GST_WARNING (""Couldn't allocate enough memory to decode COVERART tag"");/~/    return;/~/  }/~/    GST_WARNING (""Couldn't decode bas64 image data from COVERART tag"");/~/    g_free (img_data);/~/    g_free (img_data);"
485,"static void bt_for_each(struct blk_mq_hw_ctx *hctx,
struct blk_mq_bitmap_tags *bt, unsigned int off,
busy_iter_fn *fn, void *data, bool reserved)
{
struct request *rq;
int bit, i;

for (i = 0; i < bt->map_nr; i++) {
struct blk_align_bitmap *bm = &bt->map[i];

for (bit = find_first_bit(&bm->word, bm->depth);
bit < bm->depth;
bit = find_next_bit(&bm->word, bm->depth, bit + 1)) {
		     	rq = blk_mq_tag_to_rq(hctx->tags, off + bit);
if (rq->q == hctx->queue)
fn(hctx, rq, data, reserved);
}

off += (1 << bt->bits_per_word);
}
}
",[12],"		     	rq = blk_mq_tag_to_rq(hctx->tags, off + bit);"
486,"InlineBoxPosition ComputeInlineBoxPositionTemplate(
const PositionTemplate<Strategy>& position,
TextAffinity affinity,
TextDirection primary_direction) {
int caret_offset = position.ComputeEditingOffset();
Node* const anchor_node = position.AnchorNode();
LayoutObject* layout_object =
anchor_node->IsShadowRoot()
? ToShadowRoot(anchor_node)->host().GetLayoutObject()
: anchor_node->GetLayoutObject();

DCHECK(layout_object) << position;

if (layout_object->IsText()) {
return ComputeInlineBoxPositionForTextNode(layout_object, caret_offset,
affinity, primary_direction);
}

  if (layout_object->IsLayoutBlockFlow()) {
    if (CanHaveChildrenForEditing(anchor_node) &&
        HasRenderedNonAnonymousDescendantsWithHeight(layout_object)) {
      // Try a visually equivalent position with possibly opposite
      // editability. This helps in case |this| is in an editable block
      // but surrounded by non-editable positions. It acts to negate the
      // logic at the beginning of
      // |LayoutObject::createPositionWithAffinity()|.
      const PositionTemplate<Strategy>& downstream_equivalent =
          DownstreamIgnoringEditingBoundaries(position);
      if (downstream_equivalent != position) {
        return ComputeInlineBoxPosition(
            downstream_equivalent, TextAffinity::kUpstream, primary_direction);
      }
      const PositionTemplate<Strategy>& upstream_equivalent =
          UpstreamIgnoringEditingBoundaries(position);
      if (upstream_equivalent == position ||
          DownstreamIgnoringEditingBoundaries(upstream_equivalent) == position)
        return InlineBoxPosition();
      return ComputeInlineBoxPosition(
          upstream_equivalent, TextAffinity::kUpstream, primary_direction);
    }
    // We can't return null here because atomic inlines can also be block flows,
    // e.g., LayoutTextControl.
    // TODO(xiaochengh): Move atomic inline handling before block flow handling
    // so that we can directly return null here.
}

  if (!layout_object->IsAtomicInlineLevel())
return InlineBoxPosition();
  if (!layout_object->IsBox())
return InlineBoxPosition();
  InlineBox* const inline_box = ToLayoutBox(layout_object)->InlineBoxWrapper();
  if (!inline_box)
return InlineBoxPosition();
  if ((caret_offset > inline_box->CaretMinOffset() &&
       caret_offset < inline_box->CaretMaxOffset()))
    return InlineBoxPosition(inline_box, caret_offset);
  return AdjustInlineBoxPositionForTextDirection(
      inline_box, caret_offset, layout_object->Style()->GetUnicodeBidi(),
      primary_direction);
}
","[14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32]","  if (layout_object->IsLayoutBlockFlow()) {/~/    if (CanHaveChildrenForEditing(anchor_node) &&/~/        HasRenderedNonAnonymousDescendantsWithHeight(layout_object)) {/~/      // Try a visually equivalent position with possibly opposite/~/      // editability. This helps in case |this| is in an editable block/~/      // but surrounded by non-editable positions. It acts to negate the/~/      // logic at the beginning of/~/      // |LayoutObject::createPositionWithAffinity()|./~/      const PositionTemplate<Strategy>& downstream_equivalent =/~/          DownstreamIgnoringEditingBoundaries(position);/~/      if (downstream_equivalent != position) {/~/        return ComputeInlineBoxPosition(/~/            downstream_equivalent, TextAffinity::kUpstream, primary_direction);/~/      }/~/      const PositionTemplate<Strategy>& upstream_equivalent =/~/          UpstreamIgnoringEditingBoundaries(position);/~/      if (upstream_equivalent == position ||/~/          DownstreamIgnoringEditingBoundaries(upstream_equivalent) == position)/~/        return InlineBoxPosition();/~/      return ComputeInlineBoxPosition(/~/          upstream_equivalent, TextAffinity::kUpstream, primary_direction);/~/    }/~/    // We can't return null here because atomic inlines can also be block flows,/~/    // e.g., LayoutTextControl./~/    // TODO(xiaochengh): Move atomic inline handling before block flow handling/~/    // so that we can directly return null here./~/  if (!layout_object->IsAtomicInlineLevel())/~/  if (!layout_object->IsBox())/~/  InlineBox* const inline_box = ToLayoutBox(layout_object)->InlineBoxWrapper();/~/  if (!inline_box)/~/  if ((caret_offset > inline_box->CaretMinOffset() &&/~/       caret_offset < inline_box->CaretMaxOffset()))/~/    return InlineBoxPosition(inline_box, caret_offset);/~/  return AdjustInlineBoxPositionForTextDirection(/~/      inline_box, caret_offset, layout_object->Style()->GetUnicodeBidi(),/~/      primary_direction);"
487,"i915_gem_execbuffer2(struct drm_device *dev, void *data,
struct drm_file *file)
{
struct drm_i915_gem_execbuffer2 *args = data;
struct drm_i915_gem_exec_object2 *exec2_list = NULL;
int ret;

	if (args->buffer_count < 1) {
DRM_DEBUG(""execbuf2 with %d buffers\n"", args->buffer_count);
return -EINVAL;
}

exec2_list = kmalloc(sizeof(*exec2_list)*args->buffer_count,
GFP_KERNEL | __GFP_NOWARN | __GFP_NORETRY);
if (exec2_list == NULL)
exec2_list = drm_malloc_ab(sizeof(*exec2_list),
args->buffer_count);
if (exec2_list == NULL) {
DRM_DEBUG(""Failed to allocate exec list for %d buffers\n"",
args->buffer_count);
return -ENOMEM;
}
ret = copy_from_user(exec2_list,
(struct drm_i915_relocation_entry __user *)
(uintptr_t) args->buffers_ptr,
sizeof(*exec2_list) * args->buffer_count);
if (ret != 0) {
DRM_DEBUG(""copy %d exec entries failed %d\n"",
args->buffer_count, ret);
drm_free_large(exec2_list);
return -EFAULT;
}

ret = i915_gem_do_execbuffer(dev, data, file, args, exec2_list);
if (!ret) {
/* Copy the new buffer offsets back to the user's exec list. */
ret = copy_to_user((struct drm_i915_relocation_entry __user *)
(uintptr_t) args->buffers_ptr,
exec2_list,
sizeof(*exec2_list) * args->buffer_count);
if (ret) {
ret = -EFAULT;
DRM_DEBUG(""failed to copy %d exec entries ""
""back to user (%d)\n"",
args->buffer_count, ret);
}
}

drm_free_large(exec2_list);
return ret;
}
",[6],	if (args->buffer_count < 1) {
488,"fbOver (CARD32 x, CARD32 y)
{
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height);

CARD32
fbOver (CARD32 x, CARD32 y)
{
CARD16  a = ~x >> 24;
CARD16  t;
CARD32  m,n,o,p;

m = FbOverU(x,y,0,a,t);
n = FbOverU(x,y,8,a,t);
o = FbOverU(x,y,16,a,t);
p = FbOverU(x,y,24,a,t);
return m|n|o|p;
}

CARD32
fbOver24 (CARD32 x, CARD32 y)
{
CARD16  a = ~x >> 24;
CARD16  t;
CARD32  m,n,o;

m = FbOverU(x,y,0,a,t);
n = FbOverU(x,y,8,a,t);
o = FbOverU(x,y,16,a,t);
return m|n|o;
}

CARD32
fbIn (CARD32 x, CARD8 y)
{
CARD16  a = y;
CARD16  t;
CARD32  m,n,o,p;

m = FbInU(x,0,a,t);
n = FbInU(x,8,a,t);
o = FbInU(x,16,a,t);
p = FbInU(x,24,a,t);
return m|n|o|p;
}

#define genericCombine24(a,b,c,d) (((a)*(c)+(b)*(d)))

/*
* This macro does src IN mask OVER dst when src and dst are 0888.
* If src has alpha, this will not work
*/
#define inOver0888(alpha, source, destval, dest) { \
CARD32 dstrb=destval&0xFF00FF; CARD32 dstag=(destval>>8)&0xFF00FF; \
CARD32 drb=((source&0xFF00FF)-dstrb)*alpha; CARD32 dag=(((source>>8)&0xFF00FF)-dstag)*alpha; \
WRITE(dest, ((((drb>>8) + dstrb) & 0x00FF00FF) | ((((dag>>8) + dstag) << 8) & 0xFF00FF00))); \
}

/*
* This macro does src IN mask OVER dst when src and dst are 0565 and
* mask is a 5-bit alpha value.  Again, if src has alpha, this will not
* work.
*/
#define inOver0565(alpha, source, destval, dest) { \
CARD16 dstrb = destval & 0xf81f; CARD16 dstg  = destval & 0x7e0; \
CARD32 drb = ((source&0xf81f)-dstrb)*alpha; CARD32 dg=((source & 0x7e0)-dstg)*alpha; \
WRITE(dest, ((((drb>>5) + dstrb)&0xf81f) | (((dg>>5)  + dstg) & 0x7e0))); \
}


#define inOver2x0565(alpha, source, destval, dest) { \
CARD32 dstrb = destval & 0x07e0f81f; CARD32 dstg  = (destval & 0xf81f07e0)>>5; \
CARD32 drb = ((source&0x07e0f81f)-dstrb)*alpha; CARD32 dg=(((source & 0xf81f07e0)>>5)-dstg)*alpha; \
WRITE(dest, ((((drb>>5) + dstrb)&0x07e0f81f) | ((((dg>>5)  + dstg)<<5) & 0xf81f07e0))); \
}


#if IMAGE_BYTE_ORDER == LSBFirst
#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \
temp=count&3; \
where-=temp; \
workingWhere=(CARD32 *)where; \
workingVal=READ(workingWhere++); \
count=4-temp; \
workingVal>>=(8*temp)
#define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)&0xff; (y)>>=8; (x)--;}
#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)
#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)
#define writePacked(what) workingoDest>>=8; workingoDest|=(what<<24); ww--; if(!ww) { ww=4; WRITE (wodst++, workingoDest); }
#else
#warning ""I havn't tested fbCompositeTrans_0888xnx0888() on big endian yet!""
#define setupPackedReader(count,temp,where,workingWhere,workingVal) count=(long)where; \
temp=count&3; \
where-=temp; \
workingWhere=(CARD32 *)where; \
workingVal=READ(workingWhere++); \
count=4-temp; \
workingVal<<=(8*temp)
#define readPacked(where,x,y,z) {if(!(x)) { (x)=4; y = READ(z++); } where=(y)>>24; (y)<<=8; (x)--;}
#define readPackedSource(where) readPacked(where,ws,workingSource,wsrc)
#define readPackedDest(where) readPacked(where,wd,workingiDest,widst)
#define writePacked(what) workingoDest<<=8; workingoDest|=what; ww--; if(!ww) { ww=4; WRITE(wodst++, workingoDest); }
#endif

/*
* Naming convention:
*
*  opSRCxMASKxDST
*/

void
fbCompositeSolidMask_nx8x8888 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	src, srca;
CARD32	*dstLine, *dst, d, dstMask;
CARD8	*maskLine, *mask, m;
FbStride	dstStride, maskStride;
CARD16	w;

fbComposeGetSolid(pSrc, src, pDst->format);

dstMask = FbFullMask (pDst->pDrawable->depth);
srca = src >> 24;
if (src == 0)
return;

fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

while (w--)
{
m = READ(mask++);
if (m == 0xff)
{
if (srca == 0xff)
WRITE(dst, src & dstMask);
else
WRITE(dst, fbOver (src, READ(dst)) & dstMask);
}
else if (m)
{
d = fbIn (src, m);
WRITE(dst, fbOver (d, READ(dst)) & dstMask);
}
dst++;
}
}

fbFinishAccess (pMask->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

void
fbCompositeSolidMask_nx8888x8888C (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	src, srca;
CARD32	*dstLine, *dst, d, dstMask;
CARD32	*maskLine, *mask, ma;
FbStride	dstStride, maskStride;
CARD16	w;
CARD32	m, n, o, p;

fbComposeGetSolid(pSrc, src, pDst->format);

dstMask = FbFullMask (pDst->pDrawable->depth);
srca = src >> 24;
if (src == 0)
return;

fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

while (w--)
{
ma = READ(mask++);
if (ma == 0xffffffff)
{
if (srca == 0xff)
WRITE(dst, src & dstMask);
else
WRITE(dst, fbOver (src, READ(dst)) & dstMask);
}
else if (ma)
{
d = READ(dst);
#define FbInOverC(src,srca,msk,dst,i,result) { \
CARD16  __a = FbGet8(msk,i); \
CARD32  __t, __ta; \
CARD32  __i; \
__t = FbIntMult (FbGet8(src,i), __a,__i); \
__ta = (CARD8) ~FbIntMult (srca, __a,__i); \
__t = __t + FbIntMult(FbGet8(dst,i),__ta,__i); \
__t = (CARD32) (CARD8) (__t | (-(__t >> 8))); \
result = __t << (i); \
}
FbInOverC (src, srca, ma, d, 0, m);
FbInOverC (src, srca, ma, d, 8, n);
FbInOverC (src, srca, ma, d, 16, o);
FbInOverC (src, srca, ma, d, 24, p);
WRITE(dst, m|n|o|p);
}
dst++;
}
}

fbFinishAccess (pMask->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

#define srcAlphaCombine24(a,b) genericCombine24(a,b,srca,srcia)
void
fbCompositeSolidMask_nx8x0888 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	src, srca, srcia;
CARD8	*dstLine, *dst, *edst;
CARD8	*maskLine, *mask, m;
FbStride	dstStride, maskStride;
CARD16	w;
CARD32 rs,gs,bs,rd,gd,bd;

fbComposeGetSolid(pSrc, src, pDst->format);

srca = src >> 24;
srcia = 255-srca;
if (src == 0)
return;

rs=src&0xff;
gs=(src>>8)&0xff;
bs=(src>>16)&0xff;

fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);
fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);

while (height--)
{
/* fixme: cleanup unused */
unsigned long wt, wd;
CARD32 workingiDest;
CARD32 *widst;

edst = dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

#ifndef NO_MASKED_PACKED_READ
setupPackedReader(wd,wt,edst,widst,workingiDest);
#endif

while (w--)
{
#ifndef NO_MASKED_PACKED_READ
readPackedDest(rd);
readPackedDest(gd);
readPackedDest(bd);
#else
rd = READ(edst++);
gd = READ(edst++);
bd = READ(edst++);
#endif
m = READ(mask++);
if (m == 0xff)
{
if (srca == 0xff)
{
WRITE(dst++, rs);
WRITE(dst++, gs);
WRITE(dst++, bs);
}
else
{
WRITE(dst++, (srcAlphaCombine24(rs, rd)>>8));
WRITE(dst++, (srcAlphaCombine24(gs, gd)>>8));
WRITE(dst++, (srcAlphaCombine24(bs, bd)>>8));
}
}
else if (m)
{
int na=(srca*(int)m)>>8;
int nia=255-na;
WRITE(dst++, (genericCombine24(rs, rd, na, nia)>>8));
WRITE(dst++, (genericCombine24(gs, gd, na, nia)>>8));
WRITE(dst++, (genericCombine24(bs, bd, na, nia)>>8));
}
else
{
dst+=3;
}
}
}

fbFinishAccess (pMask->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

void
fbCompositeSolidMask_nx8x0565 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	src, srca8, srca5;
CARD16	*dstLine, *dst;
CARD16	d;
CARD32	t;
CARD8	*maskLine, *mask, m;
FbStride	dstStride, maskStride;
CARD16	w,src16;

fbComposeGetSolid(pSrc, src, pDst->format);

if (src == 0)
return;

srca8 = (src >> 24);
srca5 = (srca8 >> 3);
src16 = cvt8888to0565(src);

fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

while (w--)
{
m = READ(mask++);
if (m == 0)
dst++;
else if (srca5 == (0xff >> 3))
{
if (m == 0xff)
WRITE(dst++, src16);
else
{
d = READ(dst);
m >>= 3;
inOver0565 (m, src16, d, dst++);
}
}
else
{
d = READ(dst);
if (m == 0xff)
{
t = fbOver24 (src, cvt0565to0888 (d));
}
else
{
t = fbIn (src, m);
t = fbOver (t, cvt0565to0888 (d));
}
WRITE(dst++, cvt8888to0565 (t));
}
}
}

fbFinishAccess (pMask->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

static void
fbCompositeSolidMask_nx8888x0565 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	src, srca8, srca5;
CARD16	*dstLine, *dst;
CARD16	d;
CARD32	*maskLine, *mask;
CARD32	t;
CARD8	m;
FbStride	dstStride, maskStride;
CARD16	w, src16;

fbComposeGetSolid(pSrc, src, pDst->format);

if (src == 0)
return;

srca8 = src >> 24;
srca5 = srca8 >> 3;
src16 = cvt8888to0565(src);

fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

while (w--)
{
m = READ(mask++) >> 24;
if (m == 0)
dst++;
else if (srca5 == (0xff >> 3))
{
if (m == 0xff)
WRITE(dst++, src16);
else
{
d = READ(dst);
m >>= 3;
inOver0565 (m, src16, d, dst++);
}
}
else
{
if (m == 0xff)
{
d = READ(dst);
t = fbOver24 (src, cvt0565to0888 (d));
WRITE(dst++, cvt8888to0565 (t));
}
else
{
d = READ(dst);
t = fbIn (src, m);
t = fbOver (t, cvt0565to0888 (d));
WRITE(dst++, cvt8888to0565 (t));
}
}
}
}
}

void
fbCompositeSolidMask_nx8888x0565C (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	src, srca;
CARD16	src16;
CARD16	*dstLine, *dst;
CARD32	d;
CARD32	*maskLine, *mask, ma;
FbStride	dstStride, maskStride;
CARD16	w;
CARD32	m, n, o;

fbComposeGetSolid(pSrc, src, pDst->format);

srca = src >> 24;
if (src == 0)
return;

src16 = cvt8888to0565(src);

fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);
fbComposeGetStart (pMask, xMask, yMask, CARD32, maskStride, maskLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

while (w--)
{
ma = READ(mask++);
if (ma == 0xffffffff)
{
if (srca == 0xff)
{
WRITE(dst, src16);
}
else
{
d = READ(dst);
d = fbOver24 (src, cvt0565to0888(d));
WRITE(dst, cvt8888to0565(d));
}
}
else if (ma)
{
d = READ(dst);
d = cvt0565to0888(d);
FbInOverC (src, srca, ma, d, 0, m);
FbInOverC (src, srca, ma, d, 8, n);
FbInOverC (src, srca, ma, d, 16, o);
d = m|n|o;
WRITE(dst, cvt8888to0565(d));
}
dst++;
}
}

fbFinishAccess (pMask->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

void
fbCompositeSrc_8888x8888 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	*dstLine, *dst, dstMask;
CARD32	*srcLine, *src, s;
FbStride	dstStride, srcStride;
CARD8	a;
CARD16	w;

fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);
fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);

dstMask = FbFullMask (pDst->pDrawable->depth);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width;

while (w--)
{
s = READ(src++);
a = s >> 24;
if (a == 0xff)
WRITE(dst, s & dstMask);
else if (a)
WRITE(dst, fbOver (s, READ(dst)) & dstMask);
dst++;
}
}

fbFinishAccess (pSrc->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

void
fbCompositeSrc_8888x0888 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD8	*dstLine, *dst;
CARD32	d;
CARD32	*srcLine, *src, s;
CARD8	a;
FbStride	dstStride, srcStride;
CARD16	w;

fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);
fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width;

while (w--)
{
s = READ(src++);
a = s >> 24;
if (a)
{
if (a == 0xff)
d = s;
else
d = fbOver24 (s, Fetch24(dst));
Store24(dst,d);
}
dst += 3;
}
}

fbFinishAccess (pSrc->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

void
fbCompositeSrc_8888x0565 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD16	*dstLine, *dst;
CARD32	d;
CARD32	*srcLine, *src, s;
CARD8	a;
FbStride	dstStride, srcStride;
CARD16	w;

fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);
fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width;

while (w--)
{
s = READ(src++);
a = s >> 24;
if (a)
{
if (a == 0xff)
d = s;
else
{
d = READ(dst);
d = fbOver24 (s, cvt0565to0888(d));
}
WRITE(dst, cvt8888to0565(d));
}
dst++;
}
}

fbFinishAccess (pDst->pDrawable);
fbFinishAccess (pSrc->pDrawable);
}

void
fbCompositeSrcAdd_8000x8000 (CARD8	op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD8	*dstLine, *dst;
CARD8	*srcLine, *src;
FbStride	dstStride, srcStride;
CARD16	w;
CARD8	s, d;
CARD16	t;

fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 1);
fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width;

while (w--)
{
s = READ(src++);
if (s)
{
if (s != 0xff)
{
d = READ(dst);
t = d + s;
s = t | (0 - (t >> 8));
}
WRITE(dst, s);
}
dst++;
}
}

fbFinishAccess (pDst->pDrawable);
fbFinishAccess (pSrc->pDrawable);
}

void
fbCompositeSrcAdd_8888x8888 (CARD8	op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32	*dstLine, *dst;
CARD32	*srcLine, *src;
FbStride	dstStride, srcStride;
CARD16	w;
CARD32	s, d;
CARD16	t;
CARD32	m,n,o,p;

fbComposeGetStart (pSrc, xSrc, ySrc, CARD32, srcStride, srcLine, 1);
fbComposeGetStart (pDst, xDst, yDst, CARD32, dstStride, dstLine, 1);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width;

while (w--)
{
s = READ(src++);
if (s)
{
if (s != 0xffffffff)
{
d = READ(dst);
if (d)
{
m = FbAdd(s,d,0,t);
n = FbAdd(s,d,8,t);
o = FbAdd(s,d,16,t);
p = FbAdd(s,d,24,t);
s = m|n|o|p;
}
}
WRITE(dst, s);
}
dst++;
}
}

fbFinishAccess (pDst->pDrawable);
fbFinishAccess (pSrc->pDrawable);
}

static void
fbCompositeSrcAdd_8888x8x8 (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD8	*dstLine, *dst;
CARD8	*maskLine, *mask;
FbStride	dstStride, maskStride;
CARD16	w;
CARD32	src;
CARD8	sa;

fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 1);
fbComposeGetStart (pMask, xMask, yMask, CARD8, maskStride, maskLine, 1);
fbComposeGetSolid (pSrc, src, pDst->format);
sa = (src >> 24);

while (height--)
{
dst = dstLine;
dstLine += dstStride;
mask = maskLine;
maskLine += maskStride;
w = width;

while (w--)
{
CARD16	tmp;
CARD16	a;
CARD32	m, d;
CARD32	r;

a = READ(mask++);
d = READ(dst);

m = FbInU (sa, 0, a, tmp);
r = FbAdd (m, d, 0, tmp);

WRITE(dst++, r);
}
}

fbFinishAccess(pDst->pDrawable);
fbFinishAccess(pMask->pDrawable);
}

void
fbCompositeSrcAdd_1000x1000 (CARD8	op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
FbBits	*dstBits, *srcBits;
FbStride	dstStride, srcStride;
int		dstBpp, srcBpp;
int		dstXoff, dstYoff;
int		srcXoff, srcYoff;

fbGetDrawable(pSrc->pDrawable, srcBits, srcStride, srcBpp, srcXoff, srcYoff);

fbGetDrawable(pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);

fbBlt (srcBits + srcStride * (ySrc + srcYoff),
srcStride,
xSrc + srcXoff,

dstBits + dstStride * (yDst + dstYoff),
dstStride,
xDst + dstXoff,

width,
height,

GXor,
FB_ALLONES,
srcBpp,

FALSE,
FALSE);

fbFinishAccess(pDst->pDrawable);
fbFinishAccess(pSrc->pDrawable);
}

void
fbCompositeSolidMask_nx1xn (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
FbBits	*dstBits;
FbStip	*maskBits;
FbStride	dstStride, maskStride;
int		dstBpp, maskBpp;
int		dstXoff, dstYoff;
int		maskXoff, maskYoff;
FbBits	src;

fbComposeGetSolid(pSrc, src, pDst->format);
fbGetStipDrawable (pMask->pDrawable, maskBits, maskStride, maskBpp, maskXoff, maskYoff);
fbGetDrawable (pDst->pDrawable, dstBits, dstStride, dstBpp, dstXoff, dstYoff);

switch (dstBpp) {
case 32:
break;
case 24:
break;
case 16:
src = cvt8888to0565(src);
break;
}

src = fbReplicatePixel (src, dstBpp);

fbBltOne (maskBits + maskStride * (yMask + maskYoff),
maskStride,
xMask + maskXoff,

dstBits + dstStride * (yDst + dstYoff),
dstStride,
(xDst + dstXoff) * dstBpp,
dstBpp,

width * dstBpp,
height,

0x0,
src,
FB_ALLONES,
0x0);

fbFinishAccess (pDst->pDrawable);
fbFinishAccess (pMask->pDrawable);
}

# define mod(a,b)	((b) == 1 ? 0 : (a) >= 0 ? (a) % (b) : (b) - (-a) % (b))

/*
* Apply a constant alpha value in an over computation
*/
static void
fbCompositeSrcSrc_nxn  (CARD8	   op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height);

static void
fbCompositeTrans_0565xnx0565(CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD16	*dstLine, *dst;
CARD16	*srcLine, *src;
FbStride	dstStride, srcStride;
CARD16	w;
FbBits	mask;
CARD8	maskAlpha;
CARD16	s_16, d_16;
CARD32	s_32, d_32;

fbComposeGetSolid (pMask, mask, pDst->format);
maskAlpha = mask >> 27;

if (!maskAlpha)
return;
if (maskAlpha == 0xff)
{
fbCompositeSrcSrc_nxn (PictOpSrc, pSrc, pMask, pDst,
xSrc, ySrc, xMask, yMask, xDst, yDst,
width, height);
return;
}

fbComposeGetStart (pSrc, xSrc, ySrc, CARD16, srcStride, srcLine, 1);
fbComposeGetStart (pDst, xDst, yDst, CARD16, dstStride, dstLine, 1);

while (height--)
{
CARD32 *isrc, *idst;
dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width;

if(((long)src&1)==1)
{
s_16 = READ(src++);
d_16 = READ(dst);
inOver0565(maskAlpha, s_16, d_16, dst++);
w--;
}
isrc=(CARD32 *)src;
if(((long)dst&1)==0)
{
idst=(CARD32 *)dst;
while (w>1)
{
s_32 = READ(isrc++);
d_32 = READ(idst);
inOver2x0565(maskAlpha, s_32, d_32, idst++);
w-=2;
}
dst=(CARD16 *)idst;
}
else
{
while (w > 1)
{
s_32 = READ(isrc++);
#if IMAGE_BYTE_ORDER == LSBFirst
s_16=s_32&0xffff;
#else
s_16=s_32>>16;
#endif
d_16 = READ(dst);
inOver0565 (maskAlpha, s_16, d_16, dst++);
#if IMAGE_BYTE_ORDER == LSBFirst
s_16=s_32>>16;
#else
s_16=s_32&0xffff;
#endif
d_16 = READ(dst);
inOver0565(maskAlpha, s_16, d_16, dst++);
w-=2;
}
}
src=(CARD16 *)isrc;
if(w!=0)
{
s_16 = READ(src);
d_16 = READ(dst);
inOver0565(maskAlpha, s_16, d_16, dst);
}
}

fbFinishAccess (pSrc->pDrawable);
fbFinishAccess (pDst->pDrawable);
}

/* macros for ""i can't believe it's not fast"" packed pixel handling */
#define alphamaskCombine24(a,b) genericCombine24(a,b,maskAlpha,maskiAlpha)

static void
fbCompositeTrans_0888xnx0888(CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD8	*dstLine, *dst,*idst;
CARD8	*srcLine, *src;
FbStride	dstStride, srcStride;
CARD16	w;
FbBits	mask;
CARD16	maskAlpha,maskiAlpha;

fbComposeGetSolid (pMask, mask, pDst->format);
maskAlpha = mask >> 24;
maskiAlpha= 255-maskAlpha;

if (!maskAlpha)
return;
/*
if (maskAlpha == 0xff)
{
fbCompositeSrc_0888x0888 (op, pSrc, pMask, pDst,
xSrc, ySrc, xMask, yMask, xDst, yDst,
width, height);
return;
}
*/

fbComposeGetStart (pSrc, xSrc, ySrc, CARD8, srcStride, srcLine, 3);
fbComposeGetStart (pDst, xDst, yDst, CARD8, dstStride, dstLine, 3);

{
unsigned long ws,wt;
CARD32 workingSource;
CARD32 *wsrc, *wdst, *widst;
CARD32 rs, rd, nd;
CARD8 *isrc;


/* are xSrc and xDst at the same alignment?  if not, we need to be complicated :) */
/* if(0==0) */
if ((((xSrc * 3) & 3) != ((xDst * 3) & 3)) ||
((srcStride & 3) != (dstStride & 3)))
{
while (height--)
{
dst = dstLine;
dstLine += dstStride;
isrc = src = srcLine;
srcLine += srcStride;
w = width*3;

setupPackedReader(ws,wt,isrc,wsrc,workingSource);

/* get to word aligned */
switch(~(long)dst&3)
{
case 1:
readPackedSource(rs);
/* *dst++=alphamaskCombine24(rs, *dst)>>8; */
rd = READ(dst);  /* make gcc happy.  hope it doens't cost us too much performance*/
WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);
w--; if(w==0) break;
case 2:
readPackedSource(rs);
rd = READ(dst);
WRITE(dst++, alphamaskCombine24(rs, rd) >> 8);
w--; if(w==0) break;
case 3:
readPackedSource(rs);
rd = READ(dst);
WRITE(dst++,alphamaskCombine24(rs, rd) >> 8);
w--; if(w==0) break;
}
wdst=(CARD32 *)dst;
while (w>3)
{
rs=READ(wsrc++);
/* FIXME: write a special readPackedWord macro, which knows how to
* halfword combine
*/
#if IMAGE_BYTE_ORDER == LSBFirst
rd=READ(wdst);
readPackedSource(nd);
readPackedSource(rs);
nd|=rs<<8;
readPackedSource(rs);
nd|=rs<<16;
readPackedSource(rs);
nd|=rs<<24;
#else
readPackedSource(nd);
nd<<=24;
readPackedSource(rs);
nd|=rs<<16;
readPackedSource(rs);
nd|=rs<<8;
readPackedSource(rs);
nd|=rs;
#endif
inOver0888(maskAlpha, nd, rd, wdst++);
w-=4;
}
src=(CARD8 *)wdst;
switch(w)
{
case 3:
readPackedSource(rs);
rd=READ(dst);
WRITE(dst++,alphamaskCombine24(rs, rd)>>8);
case 2:
readPackedSource(rs);
rd = READ(dst);
WRITE(dst++, alphamaskCombine24(rs, rd)>>8);
case 1:
readPackedSource(rs);
rd = READ(dst);
WRITE(dst++, alphamaskCombine24(rs, rd)>>8);
}
}
}
else
{
while (height--)
{
idst=dst = dstLine;
dstLine += dstStride;
src = srcLine;
srcLine += srcStride;
w = width*3;
/* get to word aligned */
switch(~(long)src&3)
{
case 1:
rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
WRITE(dst++, rd);
w--; if(w==0) break;
case 2:
rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
WRITE(dst++, rd);
w--; if(w==0) break;
case 3:
rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
WRITE(dst++, rd);
w--; if(w==0) break;
}
wsrc=(CARD32 *)src;
widst=(CARD32 *)dst;
while(w>3)
{
rs = READ(wsrc++);
rd = READ(widst);
inOver0888 (maskAlpha, rs, rd, widst++);
w-=4;
}
src=(CARD8 *)wsrc;
dst=(CARD8 *)widst;
switch(w)
{
case 3:
rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
WRITE(dst++, rd);
case 2:
rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
WRITE(dst++, rd);
case 1:
rd=alphamaskCombine24(READ(src++), READ(dst))>>8;
WRITE(dst++, rd);
}
}
}
}
}

/*
* Simple bitblt
*/

static void
fbCompositeSrcSrc_nxn  (CARD8	   op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
FbBits	*dst;
FbBits	*src;
FbStride	dstStride, srcStride;
int		srcXoff, srcYoff;
int		dstXoff, dstYoff;
int		srcBpp;
int		dstBpp;
Bool	reverse = FALSE;
Bool	upsidedown = FALSE;

fbGetDrawable(pSrc->pDrawable,src,srcStride,srcBpp,srcXoff,srcYoff);
fbGetDrawable(pDst->pDrawable,dst,dstStride,dstBpp,dstXoff,dstYoff);

fbBlt (src + (ySrc + srcYoff) * srcStride,
srcStride,
(xSrc + srcXoff) * srcBpp,

dst + (yDst + dstYoff) * dstStride,
dstStride,
(xDst + dstXoff) * dstBpp,

(width) * dstBpp,
(height),

GXcopy,
FB_ALLONES,
dstBpp,

reverse,
upsidedown);

fbFinishAccess(pSrc->pDrawable);
fbFinishAccess(pDst->pDrawable);
}

/*
* Solid fill
void
fbCompositeSolidSrc_nxn  (CARD8	op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{

}
*/

#define SCANLINE_BUFFER_LENGTH 2048

static void
fbCompositeRectWrapper  (CARD8	   op,
PicturePtr pSrc,
PicturePtr pMask,
PicturePtr pDst,
INT16      xSrc,
INT16      ySrc,
INT16      xMask,
INT16      yMask,
INT16      xDst,
INT16      yDst,
CARD16     width,
CARD16     height)
{
CARD32 _scanline_buffer[SCANLINE_BUFFER_LENGTH * 3];
CARD32 *scanline_buffer = _scanline_buffer;
FbComposeData data;

data.op = op;
data.src = pSrc;
data.mask = pMask;
data.dest = pDst;
data.xSrc = xSrc;
data.ySrc = ySrc;
data.xMask = xMask;
}

void
fbComposite (CARD8      op,
PicturePtr pSrc,
PicturePtr pMask,
case PICT_x8r8g8b8:
case PICT_a8b8g8r8:
case PICT_x8b8g8r8:
#ifdef USE_MMX
if (fbHaveMMX())
func = fbCompositeSolidMask_nx8x8888mmx;
else
CARD16     width,
CARD16     height)
{
    RegionRec	    region;
    int		    n;
    BoxPtr	    pbox;
    CompositeFunc   func = NULL;
Bool	    srcRepeat = pSrc->pDrawable && pSrc->repeatType == RepeatNormal;
Bool	    maskRepeat = FALSE;
Bool	    srcTransform = pSrc->transform != 0;
break;
Bool	    srcAlphaMap = pSrc->alphaMap != 0;
Bool	    maskAlphaMap = FALSE;
Bool	    dstAlphaMap = pDst->alphaMap != 0;
    int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;
    int		    w, h, w_this, h_this;

#ifdef USE_MMX
static Bool mmx_setup = FALSE;
func = fbCompositeSolidMask_nx8888x8888Cmmx;
else
#endif
}
#endif

    xDst += pDst->pDrawable->x;
    yDst += pDst->pDrawable->y;
    if (pSrc->pDrawable) {
        xSrc += pSrc->pDrawable->x;
        ySrc += pSrc->pDrawable->y;
    }
if (srcRepeat && srcTransform &&
pSrc->pDrawable->width == 1 &&
pSrc->pDrawable->height == 1)
else

if (pMask && pMask->pDrawable)
{
	xMask += pMask->pDrawable->x;
	yMask += pMask->pDrawable->y;
maskRepeat = pMask->repeatType == RepeatNormal;

if (pMask->filter == PictFilterConvolution)
}
else
{
switch (pDst->format) {
case PICT_r5g6b5:
func = fbCompositeSolidMask_nx8888x0565;
break;
default:
break;
}
}
break;
case PICT_a8b8g8r8:
if (pMask->componentAlpha) {
switch (pDst->format) {
case PICT_a8b8g8r8:
case PICT_x8b8g8r8:
#ifdef USE_MMX
if (fbHaveMMX())
func = fbCompositeSolidMask_nx8888x8888Cmmx;
else
#endif
func = fbCompositeSolidMask_nx8888x8888C;
break;
case PICT_b5g6r5:
#ifdef USE_MMX
if (fbHaveMMX())
func = fbCompositeSolidMask_nx8888x0565Cmmx;
else
#endif
func = fbCompositeSolidMask_nx8888x0565C;
break;
default:
break;
}
}
else
{
switch (pDst->format) {
case PICT_b5g6r5:
func = fbCompositeSolidMask_nx8888x0565;
break;
default:
break;
}
}
break;
case PICT_a1:
switch (pDst->format) {
case PICT_r5g6b5:
case PICT_b5g6r5:
case PICT_r8g8b8:
case PICT_b8g8r8:
case PICT_a8r8g8b8:
case PICT_x8r8g8b8:
case PICT_a8b8g8r8:
case PICT_x8b8g8r8:
{
FbBits src;

fbComposeGetSolid(pSrc, src, pDst->format);
if ((src & 0xff000000) == 0xff000000)
func = fbCompositeSolidMask_nx1xn;
break;
}
default:
break;
}
break;
default:
break;
}
","[22, 33, 45]","    RegionRec	    region;/~/    int		    n;/~/    BoxPtr	    pbox;/~/    CompositeFunc   func = NULL;/~/    int		    x_msk, y_msk, x_src, y_src, x_dst, y_dst;/~/    int		    w, h, w_this, h_this;/~/    xDst += pDst->pDrawable->x;/~/    yDst += pDst->pDrawable->y;/~/    if (pSrc->pDrawable) {/~/        xSrc += pSrc->pDrawable->x;/~/        ySrc += pSrc->pDrawable->y;/~/    }/~/	xMask += pMask->pDrawable->x;/~/	yMask += pMask->pDrawable->y;"
489,"void DistillerNativeJavaScript::EnsureServiceConnected() {
  if (!distiller_js_service_) {
render_frame_->GetServiceRegistry()->ConnectToRemoteService(
mojo::GetProxy(&distiller_js_service_));
}
}
",[1],  if (!distiller_js_service_) {
490,"l2tp_accm_print(netdissect_options *ndo, const u_char *dat)
{
const uint16_t *ptr = (const uint16_t *)dat;
uint16_t val_h, val_l;

ptr++;		/* skip ""Reserved"" */

	val_h = EXTRACT_16BITS(ptr); ptr++;
	val_l = EXTRACT_16BITS(ptr); ptr++;
ND_PRINT((ndo, ""send=%08x "", (val_h<<16) + val_l));

val_h = EXTRACT_16BITS(ptr); ptr++;
val_l = EXTRACT_16BITS(ptr); ptr++;
ND_PRINT((ndo, ""recv=%08x "", (val_h<<16) + val_l));
}
","[6, 7, 9, 10]",	val_h = EXTRACT_16BITS(ptr); ptr++;/~/	val_l = EXTRACT_16BITS(ptr); ptr++;
491,"report_error (const char *format, ...)
#else
report_error (format, va_alist)
const char *format;
va_dcl
#endif
{
va_list args;

error_prolog (1);

SH_VA_START (args, format);

vfprintf (stderr, format, args);
fprintf (stderr, ""\n"");

va_end (args);
if (exit_immediately_on_error)
    exit_shell (1);
}
",[14],    exit_shell (1);
492,"static int crypto_ccm_auth(struct aead_request *req, struct scatterlist *plain,
unsigned int cryptlen)
{
struct crypto_ccm_req_priv_ctx *pctx = crypto_ccm_reqctx(req);
struct crypto_aead *aead = crypto_aead_reqtfm(req);
struct crypto_ccm_ctx *ctx = crypto_aead_ctx(aead);
AHASH_REQUEST_ON_STACK(ahreq, ctx->mac);
unsigned int assoclen = req->assoclen;
struct scatterlist sg[3];
	u8 odata[16];
	u8 idata[16];
int ilen, err;

/* format control data for input */
err = format_input(odata, req, cryptlen);
if (err)
goto out;

sg_init_table(sg, 3);
sg_set_buf(&sg[0], odata, 16);

/* format associated data and compute into mac */
if (assoclen) {
ilen = format_adata(idata, assoclen);
sg_set_buf(&sg[1], idata, ilen);
sg_chain(sg, 3, req->src);
} else {
ilen = 0;
sg_chain(sg, 2, req->src);
}

ahash_request_set_tfm(ahreq, ctx->mac);
ahash_request_set_callback(ahreq, pctx->flags, NULL, NULL);
ahash_request_set_crypt(ahreq, sg, NULL, assoclen + ilen + 16);
err = crypto_ahash_init(ahreq);
if (err)
goto out;
err = crypto_ahash_update(ahreq);
if (err)
goto out;

/* we need to pad the MAC input to a round multiple of the block size */
ilen = 16 - (assoclen + ilen) % 16;
if (ilen < 16) {
memset(idata, 0, ilen);
sg_init_table(sg, 2);
sg_set_buf(&sg[0], idata, ilen);
if (plain)
sg_chain(sg, 2, plain);
plain = sg;
cryptlen += ilen;
}

ahash_request_set_crypt(ahreq, plain, pctx->odata, cryptlen);
err = crypto_ahash_finup(ahreq);
out:
return err;
}
","[9, 10]",	u8 odata[16];/~/	u8 idata[16];
493,"int ipc_addid(struct ipc_ids *ids, struct kern_ipc_perm *new, int size)
{
kuid_t euid;
kgid_t egid;
int id;
int next_id = ids->next_id;

if (size > IPCMNI)
size = IPCMNI;

if (ids->in_use >= size)
return -ENOSPC;

idr_preload(GFP_KERNEL);

spin_lock_init(&new->lock);
new->deleted = false;
rcu_read_lock();
spin_lock(&new->lock);

id = idr_alloc(&ids->ipcs_idr, new,
(next_id < 0) ? 0 : ipcid_to_idx(next_id), 0,
GFP_NOWAIT);
idr_preload_end();
if (id < 0) {
spin_unlock(&new->lock);
rcu_read_unlock();
return id;
}

ids->in_use++;

	current_euid_egid(&euid, &egid);
	new->cuid = new->uid = euid;
	new->gid = new->cgid = egid;
if (next_id < 0) {
new->seq = ids->seq++;
if (ids->seq > IPCID_SEQ_MAX)
ids->seq = 0;
} else {
new->seq = ipcid_to_seqx(next_id);
ids->next_id = -1;
}

new->id = ipc_buildid(id, new->seq);
return id;
}
","[25, 26, 27]","	current_euid_egid(&euid, &egid);/~/	new->cuid = new->uid = euid;/~/	new->gid = new->cgid = egid;"
494,"static void Sp_search(js_State *J)
{
js_Regexp *re;
const char *text;
Resub m;

text = checkstring(J, 0);

if (js_isregexp(J, 1))
js_copy(J, 1);
else if (js_isundefined(J, 1))
js_newregexp(J, """", 0);
else
js_newregexp(J, js_tostring(J, 1), 0);

re = js_toregexp(J, -1);

	if (!js_regexec(re->prog, text, &m, 0))
js_pushnumber(J, js_utfptrtoidx(text, m.sub[0].sp));
else
js_pushnumber(J, -1);
}
",[13],"	if (!js_regexec(re->prog, text, &m, 0))"
495,"bool HpackDecoder::DecodeNextIndexedHeader(HpackInputStream* input_stream) {
uint32 index = 0;
if (!input_stream->DecodeNextUint32(&index))
return false;

HpackEntry* entry = header_table_.GetByIndex(index);
if (entry == NULL)
return false;

  HandleHeaderRepresentation(entry->name(), entry->value());
  return true;
}
","[7, 8]","  HandleHeaderRepresentation(entry->name(), entry->value());/~/  return true;"
496,"PrintPreviewUI::PrintPreviewUI(content::WebUI* web_ui)
: ConstrainedWebDialogUI(web_ui),
initial_preview_start_time_(base::TimeTicks::Now()),
handler_(NULL),
source_is_modifiable_(true),
tab_closed_(false) {
// Set up the chrome://print/ data source.
Profile* profile = Profile::FromWebUI(web_ui);
ChromeURLDataManager::AddDataSource(profile, new PrintPreviewDataSource());

// WebUI owns |handler_|.
handler_ = new PrintPreviewHandler();
web_ui->AddMessageHandler(handler_);

  preview_ui_addr_str_ = GetPrintPreviewUIAddress();
  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);
}
","[12, 13]","  preview_ui_addr_str_ = GetPrintPreviewUIAddress();/~/  g_print_preview_request_id_map.Get().Set(preview_ui_addr_str_, -1);"
497,"static void vmx_complete_atomic_exit(struct vcpu_vmx *vmx)
{
u32 exit_intr_info;

if (!(vmx->exit_reason == EXIT_REASON_MCE_DURING_VMENTRY
|| vmx->exit_reason == EXIT_REASON_EXCEPTION_NMI))
return;

vmx->exit_intr_info = vmcs_read32(VM_EXIT_INTR_INFO);
exit_intr_info = vmx->exit_intr_info;

/* Handle machine checks before interrupts are enabled */
if (is_machine_check(exit_intr_info))
kvm_machine_check();

/* We need to handle NMIs before interrupts are enabled */
	if ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&
	    (exit_intr_info & INTR_INFO_VALID_MASK)) {
kvm_before_handle_nmi(&vmx->vcpu);
asm(""int $2"");
kvm_after_handle_nmi(&vmx->vcpu);
}
}
","[12, 13]",	if ((exit_intr_info & INTR_INFO_INTR_TYPE_MASK) == INTR_TYPE_NMI_INTR &&/~/	    (exit_intr_info & INTR_INFO_VALID_MASK)) {
498,"tiffcp(TIFF* in, TIFF* out)
{
	uint16 bitspersample, samplesperpixel = 1;
uint16 input_compression, input_photometric = PHOTOMETRIC_MINISBLACK;
copyFunc cf;
uint32 width, length;
struct cpTag* p;

CopyField(TIFFTAG_IMAGEWIDTH, width);
CopyField(TIFFTAG_IMAGELENGTH, length);
CopyField(TIFFTAG_BITSPERSAMPLE, bitspersample);
CopyField(TIFFTAG_SAMPLESPERPIXEL, samplesperpixel);
if (compression != (uint16)-1)
TIFFSetField(out, TIFFTAG_COMPRESSION, compression);
else
CopyField(TIFFTAG_COMPRESSION, compression);
TIFFGetFieldDefaulted(in, TIFFTAG_COMPRESSION, &input_compression);
TIFFGetFieldDefaulted(in, TIFFTAG_PHOTOMETRIC, &input_photometric);
if (input_compression == COMPRESSION_JPEG) {
/* Force conversion to RGB */
TIFFSetField(in, TIFFTAG_JPEGCOLORMODE, JPEGCOLORMODE_RGB);
} else if (input_photometric == PHOTOMETRIC_YCBCR) {
/* Otherwise, can't handle subsampled input */
uint16 subsamplinghor,subsamplingver;

TIFFGetFieldDefaulted(in, TIFFTAG_YCBCRSUBSAMPLING,
&subsamplinghor, &subsamplingver);
if (subsamplinghor!=1 || subsamplingver!=1) {
fprintf(stderr, ""tiffcp: %s: Can't copy/convert subsampled image.\n"",
TIFFFileName(in));
return FALSE;
}
}
if (compression == COMPRESSION_JPEG) {
if (input_photometric == PHOTOMETRIC_RGB &&
jpegcolormode == JPEGCOLORMODE_RGB)
TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_YCBCR);
else
TIFFSetField(out, TIFFTAG_PHOTOMETRIC, input_photometric);
}
else if (compression == COMPRESSION_SGILOG
|| compression == COMPRESSION_SGILOG24)
TIFFSetField(out, TIFFTAG_PHOTOMETRIC,
samplesperpixel == 1 ?
PHOTOMETRIC_LOGL : PHOTOMETRIC_LOGLUV);
else if (input_compression == COMPRESSION_JPEG &&
samplesperpixel == 3 ) {
/* RGB conversion was forced above
hence the output will be of the same type */
TIFFSetField(out, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
}
else
CopyTag(TIFFTAG_PHOTOMETRIC, 1, TIFF_SHORT);
if (fillorder != 0)
TIFFSetField(out, TIFFTAG_FILLORDER, fillorder);
else
CopyTag(TIFFTAG_FILLORDER, 1, TIFF_SHORT);
/*
* Will copy `Orientation' tag from input image
*/
TIFFGetFieldDefaulted(in, TIFFTAG_ORIENTATION, &orientation);
switch (orientation) {
case ORIENTATION_BOTRIGHT:
case ORIENTATION_RIGHTBOT:	/* XXX */
TIFFWarning(TIFFFileName(in), ""using bottom-left orientation"");
orientation = ORIENTATION_BOTLEFT;
/* fall thru... */
case ORIENTATION_LEFTBOT:	/* XXX */
case ORIENTATION_BOTLEFT:
break;
case ORIENTATION_TOPRIGHT:
case ORIENTATION_RIGHTTOP:	/* XXX */
default:
TIFFWarning(TIFFFileName(in), ""using top-left orientation"");
orientation = ORIENTATION_TOPLEFT;
/* fall thru... */
case ORIENTATION_LEFTTOP:	/* XXX */
case ORIENTATION_TOPLEFT:
break;
}
TIFFSetField(out, TIFFTAG_ORIENTATION, orientation);
/*
* Choose tiles/strip for the output image according to
* the command line arguments (-tiles, -strips) and the
* structure of the input image.
*/
if (outtiled == -1)
outtiled = TIFFIsTiled(in);
if (outtiled) {
/*
* Setup output file's tile width&height.  If either
* is not specified, use either the value from the
* input image or, if nothing is defined, use the
* library default.
*/
if (tilewidth == (uint32) -1)
TIFFGetField(in, TIFFTAG_TILEWIDTH, &tilewidth);
if (tilelength == (uint32) -1)
TIFFGetField(in, TIFFTAG_TILELENGTH, &tilelength);
TIFFDefaultTileSize(out, &tilewidth, &tilelength);
TIFFSetField(out, TIFFTAG_TILEWIDTH, tilewidth);
TIFFSetField(out, TIFFTAG_TILELENGTH, tilelength);
} else {
/*
* RowsPerStrip is left unspecified: use either the
* value from the input image or, if nothing is defined,
* use the library default.
*/
if (rowsperstrip == (uint32) 0) {
if (!TIFFGetField(in, TIFFTAG_ROWSPERSTRIP,
&rowsperstrip)) {
rowsperstrip =
TIFFDefaultStripSize(out, rowsperstrip);
}
if (rowsperstrip > length && rowsperstrip != (uint32)-1)
rowsperstrip = length;
}
else if (rowsperstrip == (uint32) -1)
rowsperstrip = length;
TIFFSetField(out, TIFFTAG_ROWSPERSTRIP, rowsperstrip);
}
if (config != (uint16) -1)
TIFFSetField(out, TIFFTAG_PLANARCONFIG, config);
else
CopyField(TIFFTAG_PLANARCONFIG, config);
if (samplesperpixel <= 4)
CopyTag(TIFFTAG_TRANSFERFUNCTION, 4, TIFF_SHORT);
CopyTag(TIFFTAG_COLORMAP, 4, TIFF_SHORT);
/* SMinSampleValue & SMaxSampleValue */
switch (compression) {
case COMPRESSION_JPEG:
TIFFSetField(out, TIFFTAG_JPEGQUALITY, quality);
TIFFSetField(out, TIFFTAG_JPEGCOLORMODE, jpegcolormode);
break;
case COMPRESSION_JBIG:
CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
CopyTag(TIFFTAG_FAXDCS, 1, TIFF_ASCII);
break;
case COMPRESSION_LZW:
case COMPRESSION_ADOBE_DEFLATE:
case COMPRESSION_DEFLATE:
case COMPRESSION_LZMA:
if (predictor != (uint16)-1)
TIFFSetField(out, TIFFTAG_PREDICTOR, predictor);
else
CopyField(TIFFTAG_PREDICTOR, predictor);
if (preset != -1) {
if (compression == COMPRESSION_ADOBE_DEFLATE
|| compression == COMPRESSION_DEFLATE)
TIFFSetField(out, TIFFTAG_ZIPQUALITY, preset);
else if (compression == COMPRESSION_LZMA)
TIFFSetField(out, TIFFTAG_LZMAPRESET, preset);
}
break;
case COMPRESSION_CCITTFAX3:
case COMPRESSION_CCITTFAX4:
if (compression == COMPRESSION_CCITTFAX3) {
if (g3opts != (uint32) -1)
TIFFSetField(out, TIFFTAG_GROUP3OPTIONS,
g3opts);
else
CopyField(TIFFTAG_GROUP3OPTIONS, g3opts);
} else
CopyTag(TIFFTAG_GROUP4OPTIONS, 1, TIFF_LONG);
CopyTag(TIFFTAG_BADFAXLINES, 1, TIFF_LONG);
CopyTag(TIFFTAG_CLEANFAXDATA, 1, TIFF_LONG);
CopyTag(TIFFTAG_CONSECUTIVEBADFAXLINES, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXRECVPARAMS, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXRECVTIME, 1, TIFF_LONG);
CopyTag(TIFFTAG_FAXSUBADDRESS, 1, TIFF_ASCII);
break;
}
{
uint32 len32;
void** data;
if (TIFFGetField(in, TIFFTAG_ICCPROFILE, &len32, &data))
TIFFSetField(out, TIFFTAG_ICCPROFILE, len32, data);
}
{
uint16 ninks;
const char* inknames;
if (TIFFGetField(in, TIFFTAG_NUMBEROFINKS, &ninks)) {
TIFFSetField(out, TIFFTAG_NUMBEROFINKS, ninks);
if (TIFFGetField(in, TIFFTAG_INKNAMES, &inknames)) {
int inknameslen = strlen(inknames) + 1;
const char* cp = inknames;
while (ninks > 1) {
cp = strchr(cp, '\0');
cp++;
inknameslen += (strlen(cp) + 1);
ninks--;
}
TIFFSetField(out, TIFFTAG_INKNAMES, inknameslen, inknames);
}
}
}
{
unsigned short pg0, pg1;

if (pageInSeq == 1) {
if (pageNum < 0) /* only one input file */ {
if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1))
TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
} else
TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);

} else {
if (TIFFGetField(in, TIFFTAG_PAGENUMBER, &pg0, &pg1)) {
if (pageNum < 0) /* only one input file */
TIFFSetField(out, TIFFTAG_PAGENUMBER, pg0, pg1);
else
TIFFSetField(out, TIFFTAG_PAGENUMBER, pageNum++, 0);
}
}
}

for (p = tags; p < &tags[NTAGS]; p++)
CopyTag(p->tag, p->count, p->type);

cf = pickCopyFunc(in, out, bitspersample, samplesperpixel);
return (cf ? (*cf)(in, out, length, width, samplesperpixel) : FALSE);
}
",[2],"	uint16 bitspersample, samplesperpixel = 1;"
499,"void* ipc_alloc(int size)
{
	void* out;
if(size > PAGE_SIZE)
out = vmalloc(size);
else
out = kmalloc(size, GFP_KERNEL);
return out;
}
",[2],	void* out;
500,"RenderWidgetHostViewAndroid::RenderWidgetHostViewAndroid(
RenderWidgetHostImpl* widget_host,
ContentViewCoreImpl* content_view_core)
: host_(widget_host),
is_layer_attached_(true),
content_view_core_(NULL),
ime_adapter_android_(ALLOW_THIS_IN_INITIALIZER_LIST(this)),
cached_background_color_(SK_ColorWHITE),
      texture_id_in_layer_(0) {
if (CompositorImpl::UsesDirectGL()) {
surface_texture_transport_.reset(new SurfaceTextureTransportClient());
layer_ = surface_texture_transport_->Initialize();
} else {
texture_layer_ = cc::TextureLayer::create(0);
layer_ = texture_layer_;
}

layer_->setContentsOpaque(true);
layer_->setIsDrawable(true);

host_->SetView(this);
SetContentViewCore(content_view_core);
}
",[8],      texture_id_in_layer_(0) {
501,"static void copyStereo8(
short *dst,
        const int *const *src,
unsigned nSamples,
unsigned /* nChannels */) {
for (unsigned i = 0; i < nSamples; ++i) {
*dst++ = src[0][i] << 8;
*dst++ = src[1][i] << 8;

}
}
",[2],"        const int *const *src,"
502,"static void _php_mb_regex_ereg_replace_exec(INTERNAL_FUNCTION_PARAMETERS, OnigOptionType options, int is_callable)
{
zval **arg_pattern_zval;

char *arg_pattern;
int arg_pattern_len;

char *replace;
int replace_len;

zend_fcall_info arg_replace_fci;
zend_fcall_info_cache arg_replace_fci_cache;

char *string;
int string_len;

char *p;
php_mb_regex_t *re;
OnigSyntaxType *syntax;
OnigRegion *regs = NULL;
smart_str out_buf = { 0 };
smart_str eval_buf = { 0 };
smart_str *pbuf;
int i, err, eval, n;
OnigUChar *pos;
OnigUChar *string_lim;
char *description = NULL;
char pat_buf[2];

const mbfl_encoding *enc;

{
const char *current_enc_name;
current_enc_name = _php_mb_regex_mbctype2name(MBREX(current_mbctype));
if (current_enc_name == NULL ||
(enc = mbfl_name2encoding(current_enc_name)) == NULL) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unknown error"");
RETURN_FALSE;
}
}
eval = 0;
{
char *option_str = NULL;
int option_str_len = 0;

if (!is_callable) {
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zss|s"",
&arg_pattern_zval,
&replace, &replace_len,
&string, &string_len,
&option_str, &option_str_len) == FAILURE) {
RETURN_FALSE;
}
} else {
if (zend_parse_parameters(ZEND_NUM_ARGS() TSRMLS_CC, ""Zfs|s"",
&arg_pattern_zval,
&arg_replace_fci, &arg_replace_fci_cache,
&string, &string_len,
&option_str, &option_str_len) == FAILURE) {
RETURN_FALSE;
}
}

if (option_str != NULL) {
_php_mb_regex_init_options(option_str, option_str_len, &options, &syntax, &eval);
} else {
options |= MBREX(regex_default_options);
syntax = MBREX(regex_default_syntax);
}
}
if (Z_TYPE_PP(arg_pattern_zval) == IS_STRING) {
arg_pattern = Z_STRVAL_PP(arg_pattern_zval);
arg_pattern_len = Z_STRLEN_PP(arg_pattern_zval);
} else {
/* FIXME: this code is not multibyte aware! */
convert_to_long_ex(arg_pattern_zval);
		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	
pat_buf[1] = '\0';

arg_pattern = pat_buf;
		arg_pattern_len = 1;	
}
/* create regex pattern buffer */
re = php_mbregex_compile_pattern(arg_pattern, arg_pattern_len, options, MBREX(current_mbctype), syntax TSRMLS_CC);
if (re == NULL) {
RETURN_FALSE;
}

if (eval || is_callable) {
pbuf = &eval_buf;
description = zend_make_compiled_string_description(""mbregex replace"" TSRMLS_CC);
} else {
pbuf = &out_buf;
description = NULL;
}

if (is_callable) {
if (eval) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Option 'e' cannot be used with replacement callback"");
RETURN_FALSE;
}
}

/* do the actual work */
err = 0;
pos = (OnigUChar *)string;
string_lim = (OnigUChar*)(string + string_len);
regs = onig_region_new();
while (err >= 0) {
err = onig_search(re, (OnigUChar *)string, (OnigUChar *)string_lim, pos, (OnigUChar *)string_lim, regs, 0);
if (err <= -2) {
OnigUChar err_str[ONIG_MAX_ERROR_MESSAGE_LEN];
onig_error_code_to_str(err_str, err);
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""mbregex search failure in php_mbereg_replace_exec(): %s"", err_str);
break;
}
if (err >= 0) {
#if moriyoshi_0
if (regs->beg[0] == regs->end[0]) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Empty regular expression"");
break;
}
#endif
/* copy the part of the string before the match */
smart_str_appendl(&out_buf, pos, (size_t)((OnigUChar *)(string + regs->beg[0]) - pos));

if (!is_callable) {
/* copy replacement and backrefs */
i = 0;
p = replace;
while (i < replace_len) {
int fwd = (int) php_mb_mbchar_bytes_ex(p, enc);
n = -1;
if ((replace_len - i) >= 2 && fwd == 1 &&
p[0] == '\\' && p[1] >= '0' && p[1] <= '9') {
n = p[1] - '0';
}
if (n >= 0 && n < regs->num_regs) {
if (regs->beg[n] >= 0 && regs->beg[n] < regs->end[n] && regs->end[n] <= string_len) {
smart_str_appendl(pbuf, string + regs->beg[n], regs->end[n] - regs->beg[n]);
}
p += 2;
i += 2;
} else {
smart_str_appendl(pbuf, p, fwd);
p += fwd;
i += fwd;
}
}
}
				
if (eval) {
zval v;
/* null terminate buffer */
smart_str_0(&eval_buf);
/* do eval */
if (zend_eval_stringl(eval_buf.c, eval_buf.len, &v, description TSRMLS_CC) == FAILURE) {
efree(description);
php_error_docref(NULL TSRMLS_CC,E_ERROR, ""Failed evaluating code: %s%s"", PHP_EOL, eval_buf.c);
/* zend_error() does not return in this case */
}

/* result of eval */
convert_to_string(&v);
smart_str_appendl(&out_buf, Z_STRVAL(v), Z_STRLEN(v));
/* Clean up */
eval_buf.len = 0;
zval_dtor(&v);
} else if (is_callable) {
				zval *retval_ptr;
zval **args[1];
zval *subpats;
int i;
				
MAKE_STD_ZVAL(subpats);
array_init(subpats);
				
for (i = 0; i < regs->num_regs; i++) {
add_next_index_stringl(subpats, string + regs->beg[i], regs->end[i] - regs->beg[i], 1);
				}				
				
args[0] = &subpats;
/* null terminate buffer */
smart_str_0(&eval_buf);
				
arg_replace_fci.param_count = 1;
arg_replace_fci.params = args;
arg_replace_fci.retval_ptr_ptr = &retval_ptr;
				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {
convert_to_string_ex(&retval_ptr);
smart_str_appendl(&out_buf, Z_STRVAL_P(retval_ptr), Z_STRLEN_P(retval_ptr));
eval_buf.len = 0;
zval_ptr_dtor(&retval_ptr);
} else {
					efree(description);
if (!EG(exception)) {
php_error_docref(NULL TSRMLS_CC, E_WARNING, ""Unable to call custom replacement function"");
}
}
zval_ptr_dtor(&subpats);
}

n = regs->end[0];
if ((pos - (OnigUChar *)string) < n) {
pos = (OnigUChar *)string + n;
} else {
if (pos < string_lim) {
					smart_str_appendl(&out_buf, pos, 1); 
}
pos++;
}
} else { /* nomatch */
/* stick that last bit of string on our output */
if (string_lim - pos > 0) {
smart_str_appendl(&out_buf, pos, string_lim - pos);
}
}
onig_region_free(regs, 0);
}

if (description) {
efree(description);
}
if (regs != NULL) {
onig_region_free(regs, 1);
}
smart_str_free(&eval_buf);

if (err <= -2) {
		smart_str_free(&out_buf);	
RETVAL_FALSE;
} else {
smart_str_appendc(&out_buf, '\0');
RETVAL_STRINGL((char *)out_buf.c, out_buf.len - 1, 0);
}
}
","[31, 32, 44]","		pat_buf[0] = (char)Z_LVAL_PP(arg_pattern_zval);	/~/		arg_pattern_len = 1;	/~/				/~/				zval *retval_ptr;/~/				/~/				/~/				}				/~/				/~/				/~/				if (zend_call_function(&arg_replace_fci, &arg_replace_fci_cache TSRMLS_CC) == SUCCESS && arg_replace_fci.retval_ptr_ptr) {/~/					efree(description);/~/					smart_str_appendl(&out_buf, pos, 1); /~/		smart_str_free(&out_buf);	"
503,"static void tg3_read_vpd(struct tg3 *tp)
{
u8 *vpd_data;
unsigned int block_end, rosize, len;
u32 vpdlen;
int j, i = 0;

vpd_data = (u8 *)tg3_vpd_readblock(tp, &vpdlen);
if (!vpd_data)
goto out_no_vpd;

i = pci_vpd_find_tag(vpd_data, 0, vpdlen, PCI_VPD_LRDT_RO_DATA);
if (i < 0)
goto out_not_found;

rosize = pci_vpd_lrdt_size(&vpd_data[i]);
block_end = i + PCI_VPD_LRDT_TAG_SIZE + rosize;
i += PCI_VPD_LRDT_TAG_SIZE;

if (block_end > vpdlen)
goto out_not_found;

j = pci_vpd_find_info_keyword(vpd_data, i, rosize,
PCI_VPD_RO_KEYWORD_MFR_ID);
if (j > 0) {
len = pci_vpd_info_field_size(&vpd_data[j]);

j += PCI_VPD_INFO_FLD_HDR_SIZE;
if (j + len > block_end || len != 4 ||
memcmp(&vpd_data[j], ""1028"", 4))
goto partno;

j = pci_vpd_find_info_keyword(vpd_data, i, rosize,
PCI_VPD_RO_KEYWORD_VENDOR0);
if (j < 0)
goto partno;

len = pci_vpd_info_field_size(&vpd_data[j]);

j += PCI_VPD_INFO_FLD_HDR_SIZE;
if (j + len > block_end)
goto partno;

		memcpy(tp->fw_ver, &vpd_data[j], len);
		strncat(tp->fw_ver, "" bc "", vpdlen - len - 1);
}

partno:
i = pci_vpd_find_info_keyword(vpd_data, i, rosize,
PCI_VPD_RO_KEYWORD_PARTNO);
if (i < 0)
goto out_not_found;

len = pci_vpd_info_field_size(&vpd_data[i]);

i += PCI_VPD_INFO_FLD_HDR_SIZE;
if (len > TG3_BPN_SIZE ||
(len + i) > vpdlen)
goto out_not_found;

memcpy(tp->board_part_number, &vpd_data[i], len);

out_not_found:
kfree(vpd_data);
if (tp->board_part_number[0])
return;

out_no_vpd:
if (tg3_asic_rev(tp) == ASIC_REV_5717) {
if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717 ||
tp->pdev->device == TG3PCI_DEVICE_TIGON3_5717_C)
strcpy(tp->board_part_number, ""BCM5717"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_5718)
strcpy(tp->board_part_number, ""BCM5718"");
else
goto nomatch;
} else if (tg3_asic_rev(tp) == ASIC_REV_57780) {
if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57780)
strcpy(tp->board_part_number, ""BCM57780"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57760)
strcpy(tp->board_part_number, ""BCM57760"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57790)
strcpy(tp->board_part_number, ""BCM57790"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57788)
strcpy(tp->board_part_number, ""BCM57788"");
else
goto nomatch;
} else if (tg3_asic_rev(tp) == ASIC_REV_57765) {
if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57761)
strcpy(tp->board_part_number, ""BCM57761"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57765)
strcpy(tp->board_part_number, ""BCM57765"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57781)
strcpy(tp->board_part_number, ""BCM57781"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57785)
strcpy(tp->board_part_number, ""BCM57785"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57791)
strcpy(tp->board_part_number, ""BCM57791"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57795)
strcpy(tp->board_part_number, ""BCM57795"");
else
goto nomatch;
} else if (tg3_asic_rev(tp) == ASIC_REV_57766) {
if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57762)
strcpy(tp->board_part_number, ""BCM57762"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57766)
strcpy(tp->board_part_number, ""BCM57766"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57782)
strcpy(tp->board_part_number, ""BCM57782"");
else if (tp->pdev->device == TG3PCI_DEVICE_TIGON3_57786)
strcpy(tp->board_part_number, ""BCM57786"");
else
goto nomatch;
} else if (tg3_asic_rev(tp) == ASIC_REV_5906) {
strcpy(tp->board_part_number, ""BCM95906"");
} else {
nomatch:
strcpy(tp->board_part_number, ""none"");
}
}
",[33],"		memcpy(tp->fw_ver, &vpd_data[j], len);/~/		strncat(tp->fw_ver, "" bc "", vpdlen - len - 1);"
504,"status_t SampleTable::setTimeToSampleParams(
off64_t data_offset, size_t data_size) {
if (mTimeToSample != NULL || data_size < 8) {
return ERROR_MALFORMED;
}

uint8_t header[8];
if (mDataSource->readAt(
data_offset, header, sizeof(header)) < (ssize_t)sizeof(header)) {
return ERROR_IO;
}

if (U32_AT(header) != 0) {
// Expected version = 0, flags = 0.
return ERROR_MALFORMED;

}

mTimeToSampleCount = U32_AT(&header[4]);
    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
if (allocSize > SIZE_MAX) {
return ERROR_OUT_OF_RANGE;
}
mTimeToSample = new uint32_t[mTimeToSampleCount * 2];

size_t size = sizeof(uint32_t) * mTimeToSampleCount * 2;
if (mDataSource->readAt(
data_offset + 8, mTimeToSample, size) < (ssize_t)size) {
return ERROR_IO;
}

for (uint32_t i = 0; i < mTimeToSampleCount * 2; ++i) {
mTimeToSample[i] = ntohl(mTimeToSample[i]);
}

return OK;
}
",[15],    uint64_t allocSize = mTimeToSampleCount * 2 * sizeof(uint32_t);
505,"PasswordAutofillAgent::PasswordAutofillAgent(content::RenderFrame* render_frame)
: content::RenderFrameObserver(render_frame),
logging_state_active_(false),
was_username_autofilled_(false),
      was_password_autofilled_(false),
      weak_ptr_factory_(this) {
Send(new AutofillHostMsg_PasswordAutofillAgentConstructed(routing_id()));
}
","[4, 5]","      was_password_autofilled_(false),/~/      weak_ptr_factory_(this) {"
506,"void ChromeMockRenderThread::OnMsgOpenChannelToExtension(
    int routing_id, const std::string& source_extension_id,
const std::string& target_extension_id,
    const std::string& channel_name, int* port_id) {
*port_id = 0;
}
","[1, 3]","    int routing_id, const std::string& source_extension_id,/~/    const std::string& channel_name, int* port_id) {"
507,"static noinline void key_gc_unused_keys(struct list_head *keys)
{
while (!list_empty(keys)) {
struct key *key =
list_entry(keys->next, struct key, graveyard_link);
list_del(&key->graveyard_link);

kdebug(""- %u"", key->serial);
key_check(key);

security_key_free(key);

/* deal with the user's key tracking and quota */
if (test_bit(KEY_FLAG_IN_QUOTA, &key->flags)) {
spin_lock(&key->user->lock);
key->user->qnkeys--;
key->user->qnbytes -= key->quotalen;
spin_unlock(&key->user->lock);
}

atomic_dec(&key->user->nkeys);
if (test_bit(KEY_FLAG_INSTANTIATED, &key->flags))
atomic_dec(&key->user->nikeys);

		key_user_put(key->user);
/* now throw away the key memory */
if (key->type->destroy)
key->type->destroy(key);

kfree(key->description);

#ifdef KEY_DEBUGGING
key->magic = KEY_DEBUG_MAGIC_X;
#endif
kmem_cache_free(key_jar, key);
}
}
",[19],		key_user_put(key->user);
508,"static struct block_device *ext3_blkdev_get(dev_t dev, struct super_block *sb)
{
struct block_device *bdev;
char b[BDEVNAME_SIZE];

bdev = blkdev_get_by_dev(dev, FMODE_READ|FMODE_WRITE|FMODE_EXCL, sb);
if (IS_ERR(bdev))
goto fail;
return bdev;

fail:
	ext3_msg(sb, ""error: failed to open journal device %s: %ld"",
__bdevname(dev, b), PTR_ERR(bdev));

return NULL;
}
",[9],"	ext3_msg(sb, ""error: failed to open journal device %s: %ld"","
509,"FileEntrySync* DirectoryEntrySync::getFile(const String& path, const Dictionary& options, ExceptionState& exceptionState)
{
FileSystemFlags flags(options);
    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
m_fileSystem->getFile(this, path, flags, helper->successCallback(), helper->errorCallback(), DOMFileSystemBase::Synchronous);
return static_cast<FileEntrySync*>(helper->getResult(exceptionState));
}
",[3],    RefPtr<EntrySyncCallbackHelper> helper = EntrySyncCallbackHelper::create();
510,"bool ResourceTracker::UnrefResource(PP_Resource res) {
DLOG_IF(ERROR, !CheckIdType(res, PP_ID_TYPE_RESOURCE))
<< res << "" is not a PP_Resource."";
ResourceMap::iterator i = live_resources_.find(res);
if (i != live_resources_.end()) {
if (!--i->second.second) {
Resource* to_release = i->second.first;
// LastPluginRefWasDeleted will clear the instance pointer, so save it
// first.
PP_Instance instance = to_release->instance()->pp_instance();
      to_release->LastPluginRefWasDeleted(false);

      instance_map_[instance]->resources.erase(res);
live_resources_.erase(i);
}
return true;
} else {
return false;
}
}
","[10, 11]",      to_release->LastPluginRefWasDeleted(false);/~/      instance_map_[instance]->resources.erase(res);
511,"void RunMemCheck() {
ACMRandom rnd(ACMRandom::DeterministicSeed());
const int count_test_block = 5000;
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);
    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);

for (int i = 0; i < count_test_block; ++i) {
      // Initialize a test block with input range [-255, 255].
for (int j = 0; j < kNumCoeffs; ++j) {
        input_block[j] = rnd.Rand8() - rnd.Rand8();
        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;
}
      if (i == 0)
for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = 255;
      if (i == 1)
for (int j = 0; j < kNumCoeffs; ++j)
          input_extreme_block[j] = -255;

fwd_txfm_ref(input_extreme_block, output_ref_block, pitch_, tx_type_);
      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,
                                      output_block, pitch_));

// The minimum quant value is 4.
for (int j = 0; j < kNumCoeffs; ++j) {
EXPECT_EQ(output_block[j], output_ref_block[j]);
        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))
            << ""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";
}
}
}
","[3, 4, 5, 6, 8, 10, 11, 13, 15, 16, 18, 20, 21]","    DECLARE_ALIGNED_ARRAY(16, int16_t, input_block, kNumCoeffs);/~/    DECLARE_ALIGNED_ARRAY(16, int16_t, input_extreme_block, kNumCoeffs);/~/    DECLARE_ALIGNED_ARRAY(16, int16_t, output_ref_block, kNumCoeffs);/~/    DECLARE_ALIGNED_ARRAY(16, int16_t, output_block, kNumCoeffs);/~/      // Initialize a test block with input range [-255, 255]./~/        input_block[j] = rnd.Rand8() - rnd.Rand8();/~/        input_extreme_block[j] = rnd.Rand8() % 2 ? 255 : -255;/~/      if (i == 0)/~/          input_extreme_block[j] = 255;/~/      if (i == 1)/~/          input_extreme_block[j] = -255;/~/      REGISTER_STATE_CHECK(RunFwdTxfm(input_extreme_block,/~/                                      output_block, pitch_));/~/        EXPECT_GE(4 * DCT_MAX_VALUE, abs(output_block[j]))/~/            << ""Error: 16x16 FDCT has coefficient larger than 4*DCT_MAX_VALUE"";"
512,"int WebContentsImpl::DownloadImage(
const GURL& url,
bool is_favicon,
uint32_t max_bitmap_size,
bool bypass_cache,
const WebContents::ImageDownloadCallback& callback) {
DCHECK_CURRENTLY_ON(BrowserThread::UI);
static int next_image_download_id = 0;
const image_downloader::ImageDownloaderPtr& mojo_image_downloader =
GetMainFrame()->GetMojoImageDownloader();
const int download_id = ++next_image_download_id;
if (!mojo_image_downloader) {
// If the renderer process is dead (i.e. crash, or memory pressure on
// Android), the downloader service will be invalid. Pre-Mojo, this would
// hang the callback indefinetly since the IPC would be dropped. Now,
// respond with a 400 HTTP error code to indicate that something went wrong.
BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
        base::Bind(&WebContents::ImageDownloadCallback::Run,
                   base::Owned(new ImageDownloadCallback(callback)),
                   download_id, 400, url, std::vector<SkBitmap>(),
                   std::vector<gfx::Size>()));
return download_id;
}

image_downloader::DownloadRequestPtr req =
image_downloader::DownloadRequest::New();

req->url = mojo::String::From(url);
req->is_favicon = is_favicon;
req->max_bitmap_size = max_bitmap_size;
req->bypass_cache = bypass_cache;

mojo_image_downloader->DownloadImage(
      std::move(req),
      base::Bind(&DidDownloadImage, callback, download_id, url));
return download_id;
}
","[18, 19, 20, 21, 31, 32]","        base::Bind(&WebContents::ImageDownloadCallback::Run,/~/                   base::Owned(new ImageDownloadCallback(callback)),/~/                   download_id, 400, url, std::vector<SkBitmap>(),/~/                   std::vector<gfx::Size>()));/~/      std::move(req),/~/      base::Bind(&DidDownloadImage, callback, download_id, url));"
513,"qedi_dbg_notice(struct qedi_dbg_ctx *qedi, const char *func, u32 line,
const char *fmt, ...)
{
va_list va;
struct va_format vaf;
	char nfunc[32];
	memset(nfunc, 0, sizeof(nfunc));
	memcpy(nfunc, func, sizeof(nfunc) - 1);

va_start(va, fmt);

vaf.fmt = fmt;
vaf.va = &va;

if (!(qedi_dbg_log & QEDI_LOG_NOTICE))
goto ret;

if (likely(qedi) && likely(qedi->pdev))
pr_notice(""[%s]:[%s:%d]:%d: %pV"",
			  dev_name(&qedi->pdev->dev), nfunc, line,
qedi->host_no, &vaf);
else
		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);

ret:
va_end(va);
}
","[5, 6, 7, 15, 18]","	char nfunc[32];/~/	memset(nfunc, 0, sizeof(nfunc));/~/	memcpy(nfunc, func, sizeof(nfunc) - 1);/~/			  dev_name(&qedi->pdev->dev), nfunc, line,/~/		pr_notice(""[0000:00:00.0]:[%s:%d]: %pV"", nfunc, line, &vaf);"
514,"BOOL pnm2png (FILE *pnm_file, FILE *png_file, FILE *alpha_file, BOOL interlace, BOOL alpha)
{
png_struct    *png_ptr = NULL;
png_info      *info_ptr = NULL;
png_byte      *png_pixels = NULL;
png_byte      **row_pointers = NULL;
png_byte      *pix_ptr = NULL;
  png_uint_32   row_bytes;

char          type_token[16];
char          width_token[16];
char          height_token[16];
char          maxval_token[16];
  int           color_type;
unsigned long   ul_width=0, ul_alpha_width=0;
unsigned long   ul_height=0, ul_alpha_height=0;
unsigned long   ul_maxval=0;
  png_uint_32   width, alpha_width;
  png_uint_32   height, alpha_height;
png_uint_32   maxval;
  int           bit_depth = 0;
  int           channels;
int           alpha_depth = 0;
  int           alpha_present;
int           row, col;
BOOL          raw, alpha_raw = FALSE;
#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
BOOL          packed_bitmap = FALSE;
#endif
png_uint_32   tmp16;
int           i;

/* read header of PNM file */

get_token(pnm_file, type_token);
if (type_token[0] != 'P')
{
return FALSE;
}
else if ((type_token[1] == '1') || (type_token[1] == '4'))
{
#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
raw = (type_token[1] == '4');
color_type = PNG_COLOR_TYPE_GRAY;
get_token(pnm_file, width_token);
sscanf (width_token, ""%lu"", &ul_width);
width = (png_uint_32) ul_width;
get_token(pnm_file, height_token);
sscanf (height_token, ""%lu"", &ul_height);
height = (png_uint_32) ul_height;
bit_depth = 1;
packed_bitmap = TRUE;
#else
fprintf (stderr, ""PNM2PNG built without PNG_WRITE_INVERT_SUPPORTED and \n"");
fprintf (stderr, ""PNG_WRITE_PACK_SUPPORTED can't read PBM (P1,P4) files\n"");
#endif
}
else if ((type_token[1] == '2') || (type_token[1] == '5'))
{
raw = (type_token[1] == '5');
color_type = PNG_COLOR_TYPE_GRAY;
get_token(pnm_file, width_token);
sscanf (width_token, ""%lu"", &ul_width);
width = (png_uint_32) ul_width;
get_token(pnm_file, height_token);
sscanf (height_token, ""%lu"", &ul_height);
height = (png_uint_32) ul_height;
get_token(pnm_file, maxval_token);
sscanf (maxval_token, ""%lu"", &ul_maxval);
maxval = (png_uint_32) ul_maxval;

if (maxval <= 1)
bit_depth = 1;
else if (maxval <= 3)
bit_depth = 2;
else if (maxval <= 15)
bit_depth = 4;
else if (maxval <= 255)
bit_depth = 8;
else /* if (maxval <= 65535) */
bit_depth = 16;
}
else if ((type_token[1] == '3') || (type_token[1] == '6'))
{
raw = (type_token[1] == '6');
color_type = PNG_COLOR_TYPE_RGB;
get_token(pnm_file, width_token);
sscanf (width_token, ""%lu"", &ul_width);
width = (png_uint_32) ul_width;
get_token(pnm_file, height_token);
sscanf (height_token, ""%lu"", &ul_height);
height = (png_uint_32) ul_height;
get_token(pnm_file, maxval_token);
sscanf (maxval_token, ""%lu"", &ul_maxval);
maxval = (png_uint_32) ul_maxval;
if (maxval <= 1)
bit_depth = 1;
else if (maxval <= 3)
bit_depth = 2;
else if (maxval <= 15)
bit_depth = 4;
else if (maxval <= 255)
bit_depth = 8;
else /* if (maxval <= 65535) */
bit_depth = 16;
}
else
{
return FALSE;
}

/* read header of PGM file with alpha channel */

if (alpha)
{
if (color_type == PNG_COLOR_TYPE_GRAY)
color_type = PNG_COLOR_TYPE_GRAY_ALPHA;
if (color_type == PNG_COLOR_TYPE_RGB)
color_type = PNG_COLOR_TYPE_RGB_ALPHA;

get_token(alpha_file, type_token);
if (type_token[0] != 'P')
{
return FALSE;
}
else if ((type_token[1] == '2') || (type_token[1] == '5'))
{
alpha_raw = (type_token[1] == '5');
get_token(alpha_file, width_token);
sscanf (width_token, ""%lu"", &ul_alpha_width);
alpha_width=(png_uint_32) ul_alpha_width;
if (alpha_width != width)
return FALSE;
get_token(alpha_file, height_token);
sscanf (height_token, ""%lu"", &ul_alpha_height);
alpha_height = (png_uint_32) ul_alpha_height;
if (alpha_height != height)
return FALSE;
get_token(alpha_file, maxval_token);
sscanf (maxval_token, ""%lu"", &ul_maxval);
maxval = (png_uint_32) ul_maxval;
if (maxval <= 1)
alpha_depth = 1;
else if (maxval <= 3)
alpha_depth = 2;
else if (maxval <= 15)
alpha_depth = 4;
else if (maxval <= 255)
alpha_depth = 8;
else /* if (maxval <= 65535) */
alpha_depth = 16;
if (alpha_depth != bit_depth)
return FALSE;
}
else
{
return FALSE;
}
} /* end if alpha */

/* calculate the number of channels and store alpha-presence */
if (color_type == PNG_COLOR_TYPE_GRAY)
channels = 1;
else if (color_type == PNG_COLOR_TYPE_GRAY_ALPHA)
channels = 2;
else if (color_type == PNG_COLOR_TYPE_RGB)

channels = 3;
else if (color_type == PNG_COLOR_TYPE_RGB_ALPHA)
channels = 4;
else
    channels = 0; /* should not happen *

alpha_present = (channels - 1) % 2;

#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
if (packed_bitmap)
/* row data is as many bytes as can fit width x channels x bit_depth */
row_bytes = (width * channels * bit_depth + 7) / 8;
else
#endif

/* row_bytes is the width x number of channels x (bit-depth / 8) */
row_bytes = width * channels * ((bit_depth <= 8) ? 1 : 2);

  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL)
return FALSE;

/* read data from PNM file */
pix_ptr = png_pixels;

  for (row = 0; row < height; row++)
{
#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
if (packed_bitmap) {
      for (i = 0; i < row_bytes; i++)
/* png supports this format natively so no conversion is needed */
*pix_ptr++ = get_data (pnm_file, 8);
} else
#endif
{
      for (col = 0; col < width; col++)
{
for (i = 0; i < (channels - alpha_present); i++)
{
if (raw)
*pix_ptr++ = get_data (pnm_file, bit_depth);
else
if (bit_depth <= 8)
*pix_ptr++ = get_value (pnm_file, bit_depth);
else
{
tmp16 = get_value (pnm_file, bit_depth);
*pix_ptr = (png_byte) ((tmp16 >> 8) & 0xFF);
pix_ptr++;
*pix_ptr = (png_byte) (tmp16 & 0xFF);
pix_ptr++;
}
}

if (alpha) /* read alpha-channel from pgm file */
{
if (alpha_raw)
*pix_ptr++ = get_data (alpha_file, alpha_depth);
else
if (alpha_depth <= 8)
*pix_ptr++ = get_value (alpha_file, bit_depth);
else
{
tmp16 = get_value (alpha_file, bit_depth);
*pix_ptr++ = (png_byte) ((tmp16 >> 8) & 0xFF);
*pix_ptr++ = (png_byte) (tmp16 & 0xFF);
}
} /* if alpha */
} /* if packed_bitmap */
} /* end for col */

} /* end for row */

/* prepare the standard PNG structures */
  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);
if (!png_ptr)
{
return FALSE;
}
info_ptr = png_create_info_struct (png_ptr);
if (!info_ptr)
{
png_destroy_write_struct (&png_ptr, (png_infopp) NULL);
return FALSE;
}

#if defined(PNG_WRITE_INVERT_SUPPORTED) || defined(PNG_WRITE_PACK_SUPPORTED)
if (packed_bitmap == TRUE)
{
png_set_packing (png_ptr);
png_set_invert_mono (png_ptr);
}
#endif


/* setjmp() must be called in every function that calls a PNG-reading libpng function */
if (setjmp (png_jmpbuf(png_ptr)))
{
    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);
return FALSE;
}

/* initialize the png structure */
png_init_io (png_ptr, png_file);

/* we're going to write more or less the same PNG as the input file */
png_set_IHDR (png_ptr, info_ptr, width, height, bit_depth, color_type,
(!interlace) ? PNG_INTERLACE_NONE : PNG_INTERLACE_ADAM7,
PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

/* write the file header information */
png_write_info (png_ptr, info_ptr);


/* if needed we will allocate memory for an new array of row-pointers */
if (row_pointers == (unsigned char**) NULL)
{
    if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)
{
      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);
return FALSE;
}
}

/* set the individual row_pointers to point at the correct offsets */
  for (i = 0; i < (height); i++)
row_pointers[i] = png_pixels + i * row_bytes;

/* write out the entire image data in one call */
png_write_image (png_ptr, row_pointers);

  /* write the additional chuncks to the PNG file (not really needed) *
png_write_end (png_ptr, info_ptr);

/* clean up after the write, and free any memory allocated */
  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);

if (row_pointers != (unsigned char**) NULL)
free (row_pointers);
if (png_pixels != (unsigned char*) NULL)
free (png_pixels);

return TRUE;
} /* end of pnm2png */
","[7, 12, 16, 17, 19, 20, 22]","  png_uint_32   row_bytes;/~/  int           color_type;/~/  png_uint_32   width, alpha_width;/~/  png_uint_32   height, alpha_height;/~/  int           bit_depth = 0;/~/  int           channels;/~/  int           alpha_present;/~/    channels = 0; /* should not happen */~/  if ((png_pixels = (png_byte *) malloc (row_bytes * height * sizeof (png_byte))) == NULL)/~/  for (row = 0; row < height; row++)/~/      for (i = 0; i < row_bytes; i++)/~/      for (col = 0; col < width; col++)/~/  png_ptr = png_create_write_struct (PNG_LIBPNG_VER_STRING, NULL, NULL, NULL);/~/    png_destroy_write_struct (&png_ptr, (png_infopp) NULL);/~/    if ((row_pointers = (png_byte **) malloc (height * sizeof (png_bytep))) == NULL)/~/      png_destroy_write_struct (&png_ptr, (png_infopp) NULL);/~/  for (i = 0; i < (height); i++)/~/  /* write the additional chuncks to the PNG file (not really needed) */~/  png_destroy_write_struct (&png_ptr, (png_infopp) NULL);"
515,"static inline int ip6_ufo_append_data(struct sock *sk,
int getfrag(void *from, char *to, int offset, int len,
int odd, struct sk_buff *skb),
void *from, int length, int hh_len, int fragheaderlen,
int transhdrlen, int mtu,unsigned int flags,
struct rt6_info *rt)

{
struct sk_buff *skb;
int err;

/* There is support for UDP large send offload by network
* device, so create one single skb packet containing complete
* udp datagram
*/
if ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL) {
skb = sock_alloc_send_skb(sk,
hh_len + fragheaderlen + transhdrlen + 20,
(flags & MSG_DONTWAIT), &err);
if (skb == NULL)
return err;

/* reserve space for Hardware header */
skb_reserve(skb, hh_len);

/* create space for UDP/IP header */
skb_put(skb,fragheaderlen + transhdrlen);

/* initialize network header pointer */
skb_reset_network_header(skb);

/* initialize protocol header pointer */
skb->transport_header = skb->network_header + fragheaderlen;

skb->protocol = htons(ETH_P_IPV6);
skb->ip_summed = CHECKSUM_PARTIAL;
skb->csum = 0;
	}
	err = skb_append_datato_frags(sk,skb, getfrag, from,
				      (length - transhdrlen));
	if (!err) {
		struct frag_hdr fhdr;

/* Specify the length of each IPv6 datagram fragment.
* It has to be a multiple of 8.
*/
skb_shinfo(skb)->gso_size = (mtu - fragheaderlen -
sizeof(struct frag_hdr)) & ~7;
skb_shinfo(skb)->gso_type = SKB_GSO_UDP;
ipv6_select_ident(&fhdr, rt);
skb_shinfo(skb)->ip6_frag_id = fhdr.identification;
__skb_queue_tail(&sk->sk_write_queue, skb);
		return 0;
}
	/* There is not enough support do UPD LSO,
	 * so follow normal path
	 *
	kfree_skb(skb);

	return err;
}
","[18, 30, 31, 32, 33, 34]","	}/~/	err = skb_append_datato_frags(sk,skb, getfrag, from,/~/				      (length - transhdrlen));/~/	if (!err) {/~/		struct frag_hdr fhdr;/~/		return 0;/~/	/* There is not enough support do UPD LSO,/~/	 * so follow normal path/~/	 */~/	kfree_skb(skb);/~/	return err;"
516,"static int filter_frame(AVFilterLink *inlink, AVFrame *in)
{
AVFilterContext *ctx = inlink->dst;
LutContext *s = ctx->priv;
AVFilterLink *outlink = ctx->outputs[0];
AVFrame *out;
uint8_t *inrow, *outrow, *inrow0, *outrow0;
int i, j, plane, direct = 0;

if (av_frame_is_writable(in)) {
direct = 1;
out = in;
} else {
out = ff_get_video_buffer(outlink, outlink->w, outlink->h);
if (!out) {
av_frame_free(&in);
return AVERROR(ENOMEM);
}
av_frame_copy_props(out, in);
}

if (s->is_rgb) {
/* packed */
inrow0  = in ->data[0];
outrow0 = out->data[0];

for (i = 0; i < in->height; i ++) {
int w = inlink->w;
const uint8_t (*tab)[256] = (const uint8_t (*)[256])s->lut;
inrow  = inrow0;
outrow = outrow0;
for (j = 0; j < w; j++) {
switch (s->step) {
case 4:  outrow[3] = tab[3][inrow[3]]; // Fall-through
case 3:  outrow[2] = tab[2][inrow[2]]; // Fall-through
case 2:  outrow[1] = tab[1][inrow[1]]; // Fall-through
default: outrow[0] = tab[0][inrow[0]];
}
outrow += s->step;
inrow  += s->step;
}
inrow0  += in ->linesize[0];
outrow0 += out->linesize[0];
}
} else {
/* planar */
        for (plane = 0; plane < 4 && in->data[plane]; plane++) {
int vsub = plane == 1 || plane == 2 ? s->vsub : 0;
int hsub = plane == 1 || plane == 2 ? s->hsub : 0;
int h = FF_CEIL_RSHIFT(inlink->h, vsub);
int w = FF_CEIL_RSHIFT(inlink->w, hsub);

inrow  = in ->data[plane];
outrow = out->data[plane];

for (i = 0; i < h; i++) {
const uint8_t *tab = s->lut[plane];
for (j = 0; j < w; j++)
outrow[j] = tab[inrow[j]];
inrow  += in ->linesize[plane];
outrow += out->linesize[plane];
}
}
}

if (!direct)
av_frame_free(&in);

return ff_filter_frame(outlink, out);
}
",[43],        for (plane = 0; plane < 4 && in->data[plane]; plane++) {
517,"void RenderBlock::styleWillChange(StyleDifference diff, const RenderStyle& newStyle)
{
RenderStyle* oldStyle = style();

setReplaced(newStyle.isDisplayInlineType());

    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {
if (newStyle.position() == StaticPosition)
// Clear our positioned objects list. Our absolutely positioned descendants will be
// inserted into our containing block's positioned objects list during layout.
removePositionedObjects(0, NewContainingBlock);
else if (oldStyle->position() == StaticPosition) {
// Remove our absolutely positioned descendants from their current containing block.
// They will be inserted into our positioned objects list during layout.
RenderObject* cb = parent();
while (cb && (cb->style()->position() == StaticPosition || (cb->isInline() && !cb->isReplaced())) && !cb->isRenderView()) {
if (cb->style()->position() == RelativePosition && cb->isInline() && !cb->isReplaced()) {
cb = cb->containingBlock();
break;
}
cb = cb->parent();
}

if (cb->isRenderBlock())
toRenderBlock(cb)->removePositionedObjects(this, NewContainingBlock);
}
}

RenderBox::styleWillChange(diff, newStyle);
}
",[4],    if (oldStyle && parent() && diff == StyleDifferenceLayout && oldStyle->position() != newStyle.position()) {
518,"char *path_name(const struct name_path *path, const char *name)
{
const struct name_path *p;
char *n, *m;
int nlen = strlen(name);
int len = nlen + 1;

for (p = path; p; p = p->up) {
if (p->elem_len)
len += p->elem_len + 1;
}
n = xmalloc(len);
m = n + len - (nlen + 1);
	strcpy(m, name);
for (p = path; p; p = p->up) {
if (p->elem_len) {
m -= p->elem_len + 1;
memcpy(m, p->elem, p->elem_len);
m[p->elem_len] = '/';
}
}
return n;
}
",[12],"	strcpy(m, name);"
519,"const SeekHead* Segment::GetSeekHead() const
{
    return m_pSeekHead;
}
","[1, 2, 3]",{/~/    return m_pSeekHead;/~/}
520,"void TypingCommand::insertText(Document& document,
const String& text,
Options options,
TextCompositionType composition,
const bool isIncrementalInsertion) {
LocalFrame* frame = document.frame();
DCHECK(frame);

if (!text.isEmpty())
document.frame()->spellChecker().updateMarkersForWordsAffectedByEditing(
isSpaceOrNewline(text[0]));

  insertText(document, text,
             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),
             options, composition, isIncrementalInsertion);
}
","[10, 11, 12]","  insertText(document, text,/~/             frame->selection().computeVisibleSelectionInDOMTreeDeprecated(),/~/             options, composition, isIncrementalInsertion);"
521,"parse_group_prop_ntr_selection_method(struct ofpbuf *payload,
enum ofp11_group_type group_type,
enum ofp15_group_mod_command group_cmd,
struct ofputil_group_props *gp)
{
struct ntr_group_prop_selection_method *prop = payload->data;
size_t fields_len, method_len;
enum ofperr error;

switch (group_type) {
case OFPGT11_SELECT:
break;
case OFPGT11_ALL:
case OFPGT11_INDIRECT:
case OFPGT11_FF:
OFPPROP_LOG(&bad_ofmsg_rl, false, ""ntr selection method property is ""
""only allowed for select groups"");
return OFPERR_OFPBPC_BAD_VALUE;
default:
        OVS_NOT_REACHED();
}

switch (group_cmd) {
case OFPGC15_ADD:
case OFPGC15_MODIFY:
case OFPGC15_ADD_OR_MOD:
break;
case OFPGC15_DELETE:
case OFPGC15_INSERT_BUCKET:
case OFPGC15_REMOVE_BUCKET:
OFPPROP_LOG(&bad_ofmsg_rl, false, ""ntr selection method property is ""
""only allowed for add and delete group modifications"");
return OFPERR_OFPBPC_BAD_VALUE;
default:
        OVS_NOT_REACHED();
}

if (payload->size < sizeof *prop) {
OFPPROP_LOG(&bad_ofmsg_rl, false, ""ntr selection method property ""
""length %u is not valid"", payload->size);
return OFPERR_OFPBPC_BAD_LEN;
}

method_len = strnlen(prop->selection_method, NTR_MAX_SELECTION_METHOD_LEN);

if (method_len == NTR_MAX_SELECTION_METHOD_LEN) {
OFPPROP_LOG(&bad_ofmsg_rl, false,
""ntr selection method is not null terminated"");
return OFPERR_OFPBPC_BAD_VALUE;
}

if (strcmp(""hash"", prop->selection_method)
&& strcmp(""dp_hash"", prop->selection_method)) {
OFPPROP_LOG(&bad_ofmsg_rl, false,
""ntr selection method '%s' is not supported"",
prop->selection_method);
return OFPERR_OFPBPC_BAD_VALUE;
}
/* 'method_len' is now non-zero. */

strcpy(gp->selection_method, prop->selection_method);
gp->selection_method_param = ntohll(prop->selection_method_param);

ofpbuf_pull(payload, sizeof *prop);

fields_len = ntohs(prop->length) - sizeof *prop;
if (fields_len && strcmp(""hash"", gp->selection_method)) {
OFPPROP_LOG(&bad_ofmsg_rl, false, ""ntr selection method %s ""
""does not support fields"", gp->selection_method);
return OFPERR_OFPBPC_BAD_VALUE;
}

error = oxm_pull_field_array(payload->data, fields_len,
&gp->fields);
if (error) {
OFPPROP_LOG(&bad_ofmsg_rl, false,
""ntr selection method fields are invalid"");
return error;
}

return 0;
}
","[18, 32]",        OVS_NOT_REACHED();/~/        OVS_NOT_REACHED();
522,"void CheckNodeValue(const BaseNode& node, const DictionaryValue& value,
bool is_detailed) {
ExpectInt64Value(node.GetId(), value, ""id"");
{
bool is_folder = false;
EXPECT_TRUE(value.GetBoolean(""isFolder"", &is_folder));
EXPECT_EQ(node.GetIsFolder(), is_folder);
}
ExpectDictStringValue(node.GetTitle(), value, ""title"");
{
ModelType expected_model_type = node.GetModelType();
std::string type_str;
EXPECT_TRUE(value.GetString(""type"", &type_str));
if (expected_model_type >= syncable::FIRST_REAL_MODEL_TYPE) {
ModelType model_type =
syncable::ModelTypeFromString(type_str);
EXPECT_EQ(expected_model_type, model_type);
} else if (expected_model_type == syncable::TOP_LEVEL_FOLDER) {
EXPECT_EQ(""Top-level folder"", type_str);
} else if (expected_model_type == syncable::UNSPECIFIED) {
EXPECT_EQ(""Unspecified"", type_str);
} else {
ADD_FAILURE();
}
}
if (is_detailed) {
ExpectInt64Value(node.GetParentId(), value, ""parentId"");
    ExpectTimeValue(node.GetModificationTime(), value, ""modificationTime"");
ExpectInt64Value(node.GetExternalId(), value, ""externalId"");
ExpectInt64Value(node.GetPredecessorId(), value, ""predecessorId"");
ExpectInt64Value(node.GetSuccessorId(), value, ""successorId"");
ExpectInt64Value(node.GetFirstChildId(), value, ""firstChildId"");
{
scoped_ptr<DictionaryValue> expected_entry(node.GetEntry()->ToValue());
Value* entry = NULL;
EXPECT_TRUE(value.Get(""entry"", &entry));
EXPECT_TRUE(Value::Equals(entry, expected_entry.get()));
}
EXPECT_EQ(11u, value.size());
} else {
EXPECT_EQ(4u, value.size());
}
}
",[27],"    ExpectTimeValue(node.GetModificationTime(), value, ""modificationTime"");"
523,"static long ion_ioctl(struct file *filp, unsigned int cmd, unsigned long arg)
{
struct ion_client *client = filp->private_data;
struct ion_device *dev = client->dev;
struct ion_handle *cleanup_handle = NULL;
int ret = 0;
unsigned int dir;

union {
struct ion_fd_data fd;
struct ion_allocation_data allocation;
struct ion_handle_data handle;
struct ion_custom_data custom;
} data;

dir = ion_ioctl_dir(cmd);

if (_IOC_SIZE(cmd) > sizeof(data))
return -EINVAL;

if (dir & _IOC_WRITE)
if (copy_from_user(&data, (void __user *)arg, _IOC_SIZE(cmd)))
return -EFAULT;

switch (cmd) {
case ION_IOC_ALLOC:
{
struct ion_handle *handle;

handle = ion_alloc(client, data.allocation.len,
data.allocation.align,
data.allocation.heap_id_mask,
data.allocation.flags);
if (IS_ERR(handle))
return PTR_ERR(handle);

data.allocation.handle = handle->id;

cleanup_handle = handle;
break;
}
case ION_IOC_FREE:
{
struct ion_handle *handle;

		handle = ion_handle_get_by_id(client, data.handle.handle);
		if (IS_ERR(handle))
return PTR_ERR(handle);
		ion_free(client, handle);
		ion_handle_put(handle);
break;
}
case ION_IOC_SHARE:
case ION_IOC_MAP:
{
struct ion_handle *handle;

handle = ion_handle_get_by_id(client, data.handle.handle);
if (IS_ERR(handle))
return PTR_ERR(handle);
data.fd.fd = ion_share_dma_buf_fd(client, handle);
ion_handle_put(handle);
if (data.fd.fd < 0)
ret = data.fd.fd;
break;
}
case ION_IOC_IMPORT:
{
struct ion_handle *handle;

handle = ion_import_dma_buf_fd(client, data.fd.fd);
if (IS_ERR(handle))
ret = PTR_ERR(handle);
else
data.handle.handle = handle->id;
break;
}
case ION_IOC_SYNC:
{
ret = ion_sync_for_device(client, data.fd.fd);
break;
}
case ION_IOC_CUSTOM:
{
if (!dev->custom_ioctl)
return -ENOTTY;
ret = dev->custom_ioctl(client, data.custom.cmd,
data.custom.arg);
break;
}
default:
return -ENOTTY;
}

if (dir & _IOC_READ) {
if (copy_to_user((void __user *)arg, &data, _IOC_SIZE(cmd))) {
if (cleanup_handle)
ion_free(client, cleanup_handle);
return -EFAULT;
}
}
return ret;
}
","[27, 36, 37, 39, 40, 47, 48]","		handle = ion_handle_get_by_id(client, data.handle.handle);/~/		if (IS_ERR(handle))/~/		ion_free(client, handle);/~/		ion_handle_put(handle);"
524,"ScreenLockLibrary* CrosLibrary::GetScreenLockLibrary() {
  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);
}
","[1, 2]",  return screen_lock_lib_.GetDefaultImpl(use_stub_impl_);/~/}
525,"void UpdateNetworkManagerStatus() {
// Make sure we run on UI thread.
if (!BrowserThread::CurrentlyOn(BrowserThread::UI)) {
BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
NewRunnableMethod(this,
&NetworkLibraryImpl::UpdateNetworkManagerStatus));
return;
}

SystemInfo* system = GetSystemInfo();
if (!system)
return;


std::string prev_cellular_service_path = cellular_ ?
cellular_->service_path() : std::string();

ClearNetworks();

ParseSystem(system, &ethernet_, &wifi_networks_, &cellular_networks_,
&remembered_wifi_networks_);

wifi_ = NULL;
for (size_t i = 0; i < wifi_networks_.size(); i++) {
if (wifi_networks_[i]->connecting_or_connected()) {
wifi_ = wifi_networks_[i];
break;  // There is only one connected or connecting wifi network.
}
}
cellular_ = NULL;
for (size_t i = 0; i < cellular_networks_.size(); i++) {
if (cellular_networks_[i]->connecting_or_connected()) {
cellular_ = cellular_networks_[i];
        // If new cellular, then update data plan list.
if (cellular_networks_[i]->service_path() !=
prev_cellular_service_path) {
          CellularDataPlanList* list = RetrieveCellularDataPlans(
              cellular_->service_path().c_str());
          UpdateCellularDataPlan(list);
          FreeCellularDataPlanList(list);
}
break;  // There is only one connected or connecting cellular network.
}
}

available_devices_ = system->available_technologies;
enabled_devices_ = system->enabled_technologies;
connected_devices_ = system->connected_technologies;
offline_mode_ = system->offline_mode;

NotifyNetworkManagerChanged();
FreeSystemInfo(system);
}
","[28, 31, 32, 33, 34]","        // If new cellular, then update data plan list./~/          CellularDataPlanList* list = RetrieveCellularDataPlans(/~/              cellular_->service_path().c_str());/~/          UpdateCellularDataPlan(list);/~/          FreeCellularDataPlanList(list);"
526,"static int set_register(pegasus_t *pegasus, __u16 indx, __u8 data)
{
int ret;

ret = usb_control_msg(pegasus->usb, usb_sndctrlpipe(pegasus->usb, 0),
PEGASUS_REQ_SET_REG, PEGASUS_REQT_WRITE, data,
			      indx, &data, 1, 1000);
if (ret < 0)
netif_dbg(pegasus, drv, pegasus->net,
""%s returned %d\n"", __func__, ret);
return ret;
}
",[5],"			      indx, &data, 1, 1000);"
527,"static int snd_timer_user_open(struct inode *inode, struct file *file)
{
struct snd_timer_user *tu;
int err;

err = nonseekable_open(inode, file);
if (err < 0)
return err;

tu = kzalloc(sizeof(*tu), GFP_KERNEL);
if (tu == NULL)
return -ENOMEM;
spin_lock_init(&tu->qlock);
init_waitqueue_head(&tu->qchange_sleep);
	mutex_init(&tu->tread_sem);
tu->ticks = 1;
tu->queue_size = 128;
tu->queue = kmalloc(tu->queue_size * sizeof(struct snd_timer_read),
GFP_KERNEL);
if (tu->queue == NULL) {
kfree(tu);
return -ENOMEM;
}
file->private_data = tu;
return 0;
}
",[12],	mutex_init(&tu->tread_sem);
528,"static void build_l4proto_sctp(const struct nf_conntrack *ct, struct nethdr *n)
{
	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,
		      sizeof(struct nfct_attr_grp_port));
if (!nfct_attr_is_set(ct, ATTR_SCTP_STATE))
return;

ct_build_u8(ct, ATTR_SCTP_STATE, n, NTA_SCTP_STATE);
ct_build_u32(ct, ATTR_SCTP_VTAG_ORIG, n, NTA_SCTP_VTAG_ORIG);
ct_build_u32(ct, ATTR_SCTP_VTAG_REPL, n, NTA_SCTP_VTAG_REPL);
}
","[2, 3]","	ct_build_group(ct, ATTR_GRP_ORIG_PORT, n, NTA_PORT,/~/		      sizeof(struct nfct_attr_grp_port));"
529,"static int dynamicGetbuf(gdIOCtxPtr ctx, void *buf, int len)
{
int rlen, remain;
dpIOCtxPtr dctx;
dynamicPtr *dp;

dctx = (dpIOCtxPtr) ctx;
dp = dctx->dp;

remain = dp->logicalSize - dp->pos;
if(remain >= len) {
rlen = len;
} else {
		if(remain == 0) {
/* 2.0.34: EOF is incorrect. We use 0 for
* errors and EOF, just like fileGetbuf,
* which is a simple fread() wrapper.
* TBB. Original bug report: Daniel Cowgill. */
return 0; /* NOT EOF */
}

rlen = remain;
}

memcpy(buf, (void *) ((char *)dp->data + dp->pos), rlen);
dp->pos += rlen;

return rlen;
}
",[11],		if(remain == 0) {
530,"WebContents* TabsCaptureVisibleTabFunction::GetWebContentsForID(
int window_id,
std::string* error) {
Browser* browser = NULL;
if (!GetBrowserFromWindowID(chrome_details_, window_id, &browser, error))
return nullptr;

WebContents* contents = browser->tab_strip_model()->GetActiveWebContents();
if (!contents) {
*error = ""No active web contents to capture"";
return nullptr;
}

if (!extension()->permissions_data()->CanCaptureVisiblePage(
contents->GetLastCommittedURL(),
          SessionTabHelper::IdForTab(contents).id(), error)) {
return nullptr;
}
return contents;
}
",[13],"          SessionTabHelper::IdForTab(contents).id(), error)) {"
531,"static inline void sem_getref_and_unlock(struct sem_array *sma)
{
	ipc_rcu_getref(sma);
	ipc_unlock(&(sma)->sem_perm);
}
","[2, 3]",	ipc_rcu_getref(sma);/~/	ipc_unlock(&(sma)->sem_perm);
532,"static ssize_t f_hidg_write(struct file *file, const char __user *buffer,
size_t count, loff_t *offp)
{
struct f_hidg *hidg  = file->private_data;
struct usb_request *req;
unsigned long flags;
ssize_t status = -ENOMEM;

if (!access_ok(buffer, count))
return -EFAULT;

spin_lock_irqsave(&hidg->write_spinlock, flags);

#define WRITE_COND (!hidg->write_pending)
try_again:
/* write queue */
while (!WRITE_COND) {
spin_unlock_irqrestore(&hidg->write_spinlock, flags);
if (file->f_flags & O_NONBLOCK)
return -EAGAIN;

if (wait_event_interruptible_exclusive(
hidg->write_queue, WRITE_COND))
return -ERESTARTSYS;

spin_lock_irqsave(&hidg->write_spinlock, flags);
}

hidg->write_pending = 1;
req = hidg->req;
count  = min_t(unsigned, count, hidg->report_length);

spin_unlock_irqrestore(&hidg->write_spinlock, flags);
status = copy_from_user(req->buf, buffer, count);

if (status != 0) {
ERROR(hidg->func.config->cdev,
""copy_from_user error\n"");
status = -EINVAL;
goto release_write_pending;
}

spin_lock_irqsave(&hidg->write_spinlock, flags);

/* when our function has been disabled by host */
if (!hidg->req) {
free_ep_req(hidg->in_ep, req);
/*
* TODO
* Should we fail with error here?
*/
goto try_again;
}

req->status   = 0;
req->zero     = 0;
req->length   = count;
req->complete = f_hidg_req_complete;
req->context  = hidg;

status = usb_ep_queue(hidg->in_ep, req, GFP_ATOMIC);
if (status < 0) {
ERROR(hidg->func.config->cdev,
""usb_ep_queue error on int endpoint %zd\n"", status);
		goto release_write_pending_unlocked;
} else {
status = count;
}
	spin_unlock_irqrestore(&hidg->write_spinlock, flags);

return status;
release_write_pending:
spin_lock_irqsave(&hidg->write_spinlock, flags);
release_write_pending_unlocked:
hidg->write_pending = 0;
spin_unlock_irqrestore(&hidg->write_spinlock, flags);

wake_up(&hidg->write_queue);

return status;
}
","[14, 25]","		goto release_write_pending_unlocked;/~/	spin_unlock_irqrestore(&hidg->write_spinlock, flags);/~/release_write_pending_unlocked:"
533,"void FragmentPaintPropertyTreeBuilder::UpdateFragmentClip() {
DCHECK(properties_);

if (NeedsPaintPropertyUpdate()) {
if (context_.fragment_clip) {
OnUpdateClip(properties_->UpdateFragmentClip(
          context_.current.clip,
ClipPaintPropertyNode::State{context_.current.transform,
ToClipRect(*context_.fragment_clip)}));
} else {
OnClearClip(properties_->ClearFragmentClip());
}
}

if (properties_->FragmentClip())
context_.current.clip = properties_->FragmentClip();
}
",[5],"          context_.current.clip,"
534,"int ceph_set_acl(struct inode *inode, struct posix_acl *acl, int type)
{
int ret = 0, size = 0;
const char *name = NULL;
char *value = NULL;
struct iattr newattrs;
umode_t new_mode = inode->i_mode, old_mode = inode->i_mode;

switch (type) {
case ACL_TYPE_ACCESS:
name = XATTR_NAME_POSIX_ACL_ACCESS;
if (acl) {
			ret = posix_acl_equiv_mode(acl, &new_mode);
			if (ret < 0)
goto out;
			if (ret == 0)
				acl = NULL;
}
break;
case ACL_TYPE_DEFAULT:
if (!S_ISDIR(inode->i_mode)) {
ret = acl ? -EINVAL : 0;
goto out;
}
name = XATTR_NAME_POSIX_ACL_DEFAULT;
break;
default:
ret = -EINVAL;
goto out;
}

if (acl) {
size = posix_acl_xattr_size(acl->a_count);
value = kmalloc(size, GFP_NOFS);
if (!value) {
ret = -ENOMEM;
goto out;
}

ret = posix_acl_to_xattr(&init_user_ns, acl, value, size);
if (ret < 0)
goto out_free;
}

if (new_mode != old_mode) {
newattrs.ia_mode = new_mode;
newattrs.ia_valid = ATTR_MODE;
ret = __ceph_setattr(inode, &newattrs);
if (ret)
goto out_free;
}

ret = __ceph_setxattr(inode, name, value, size, 0);
if (ret) {
if (new_mode != old_mode) {
newattrs.ia_mode = old_mode;
newattrs.ia_valid = ATTR_MODE;
__ceph_setattr(inode, &newattrs);
}
goto out_free;
}

ceph_set_cached_acl(inode, type, acl);

out_free:
kfree(value);
out:
return ret;
}
","[11, 12, 14, 15, 37]","			ret = posix_acl_equiv_mode(acl, &new_mode);/~/			if (ret < 0)/~/			if (ret == 0)/~/				acl = NULL;"
535,"void CachingPermutedEntropyProvider::RegisterPrefs(
PrefRegistrySimple* registry) {
  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,
                               std::string());
}
","[2, 3]","  registry->RegisterStringPref(prefs::kVariationsPermutedEntropyCache,/~/                               std::string());"
536,"static int sh_op(RAnal *anal, RAnalOp *op, ut64 addr, const ut8 *data, int len) {
ut8 op_MSB,op_LSB;
int ret;
	if (!data)
return 0;
memset (op, '\0', sizeof (RAnalOp));
op->addr = addr;
op->type = R_ANAL_OP_TYPE_UNK;
op->jump = op->fail = -1;
op->ptr = op->val = -1;

op->size = 2;

op_MSB = anal->big_endian? data[0]: data[1];
op_LSB = anal->big_endian? data[1]: data[0];
ret =  first_nibble_decode[(op_MSB>>4) & 0x0F](anal, op, (ut16)(op_MSB<<8 | op_LSB));
return ret;
}
",[3],	if (!data)
537,"static void unregisterBlobURLTask(void* context)
{
OwnPtr<BlobRegistryContext> blobRegistryContext = adoptPtr(static_cast<BlobRegistryContext*>(context));
    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
}
",[3],    blobRegistry().unregisterBlobURL(blobRegistryContext->url);
538,"SQLWCHAR* _multi_string_alloc_and_expand( LPCSTR in )
{
SQLWCHAR *chr;
int len = 0;

if ( !in )
{
        return in;
}

while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
{
len ++;
}

chr = malloc(sizeof( SQLWCHAR ) * ( len + 2 ));

len = 0;
while ( in[ len ] != 0 || in[ len + 1 ] != 0 )
{
chr[ len ] = in[ len ];
len ++;
}
chr[ len ++ ] = 0;
chr[ len ++ ] = 0;

return chr;
}
",[6],        return in;
539,"static int attach_child_main(void* data)
{
struct attach_clone_payload* payload = (struct attach_clone_payload*)data;
int ipc_socket = payload->ipc_socket;
	int procfd = payload->procfd;
lxc_attach_options_t* options = payload->options;
struct lxc_proc_context_info* init_ctx = payload->init_ctx;
#if HAVE_SYS_PERSONALITY_H
long new_personality;
#endif
int ret;
int status;
int expected;
long flags;
int fd;
uid_t new_uid;
gid_t new_gid;

/* wait for the initial thread to signal us that it's ready
* for us to start initializing
*/
expected = 0;
status = -1;
ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
if (ret <= 0) {
		ERROR(""error using IPC to receive notification from initial process (0)"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}

/* A description of the purpose of this functionality is
* provided in the lxc-attach(1) manual page. We have to
* remount here and not in the parent process, otherwise
* /proc may not properly reflect the new pid namespace.
*/
if (!(options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_REMOUNT_PROC_SYS)) {
ret = lxc_attach_remount_sys_proc();
if (ret < 0) {
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}
}

/* now perform additional attachments*/
#if HAVE_SYS_PERSONALITY_H
if (options->personality < 0)
new_personality = init_ctx->personality;
else
new_personality = options->personality;

if (options->attach_flags & LXC_ATTACH_SET_PERSONALITY) {
ret = personality(new_personality);
if (ret < 0) {
SYSERROR(""could not ensure correct architecture"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}
}
#endif

if (options->attach_flags & LXC_ATTACH_DROP_CAPABILITIES) {
ret = lxc_attach_drop_privs(init_ctx);
if (ret < 0) {
ERROR(""could not drop privileges"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}
}

/* always set the environment (specify (LXC_ATTACH_KEEP_ENV, NULL, NULL) if you want this to be a no-op) */
ret = lxc_attach_set_environment(options->env_policy, options->extra_env_vars, options->extra_keep_env);
if (ret < 0) {
ERROR(""could not set initial environment for attached process"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}

/* set user / group id */
new_uid = 0;
new_gid = 0;
/* ignore errors, we will fall back to root in that case
* (/proc was not mounted etc.)
*/
if (options->namespaces & CLONE_NEWUSER)
lxc_attach_get_init_uidgid(&new_uid, &new_gid);

if (options->uid != (uid_t)-1)
new_uid = options->uid;
if (options->gid != (gid_t)-1)
new_gid = options->gid;

/* setup the control tty */
if (options->stdin_fd && isatty(options->stdin_fd)) {
if (setsid() < 0) {
SYSERROR(""unable to setsid"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}

if (ioctl(options->stdin_fd, TIOCSCTTY, (char *)NULL) < 0) {
SYSERROR(""unable to TIOCSTTY"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}
}

/* try to set the uid/gid combination */
if ((new_gid != 0 || options->namespaces & CLONE_NEWUSER)) {
if (setgid(new_gid) || setgroups(0, NULL)) {
SYSERROR(""switching to container gid"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}
}
if ((new_uid != 0 || options->namespaces & CLONE_NEWUSER) && setuid(new_uid)) {
SYSERROR(""switching to container uid"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}

/* tell initial process it may now put us into the cgroups */
status = 1;
ret = lxc_write_nointr(ipc_socket, &status, sizeof(status));
if (ret != sizeof(status)) {
		ERROR(""error using IPC to notify initial process for initialization (1)"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}

/* wait for the initial thread to signal us that it has done
* everything for us when it comes to cgroups etc.
*/
expected = 2;
status = -1;
ret = lxc_read_nointr_expect(ipc_socket, &status, sizeof(status), &expected);
if (ret <= 0) {
		ERROR(""error using IPC to receive final notification from initial process (2)"");
shutdown(ipc_socket, SHUT_RDWR);
rexit(-1);
}

	shutdown(ipc_socket, SHUT_RDWR);
	close(ipc_socket);
if ((init_ctx->container && init_ctx->container->lxc_conf &&
init_ctx->container->lxc_conf->no_new_privs) ||
(options->attach_flags & LXC_ATTACH_NO_NEW_PRIVS)) {
if (prctl(PR_SET_NO_NEW_PRIVS, 1, 0, 0, 0) < 0) {
SYSERROR(""PR_SET_NO_NEW_PRIVS could not be set. ""
""Process can use execve() gainable ""
""privileges."");
rexit(-1);
}
INFO(""PR_SET_NO_NEW_PRIVS is set. Process cannot use execve() ""
""gainable privileges."");
}

	/* set new apparmor profile/selinux context *
if ((options->namespaces & CLONE_NEWNS) && (options->attach_flags & LXC_ATTACH_LSM) && init_ctx->lsm_label) {
int on_exec;

on_exec = options->attach_flags & LXC_ATTACH_LSM_EXEC ? 1 : 0;
		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {
rexit(-1);
}
}
if (init_ctx->container && init_ctx->container->lxc_conf &&
init_ctx->container->lxc_conf->seccomp &&
(lxc_seccomp_load(init_ctx->container->lxc_conf) != 0)) {
ERROR(""Loading seccomp policy"");
rexit(-1);
}
lxc_proc_put_context_info(init_ctx);

/* The following is done after the communication socket is
* shut down. That way, all errors that might (though
* unlikely) occur up until this point will have their messages
* printed to the original stderr (if logging is so configured)
* and not the fd the user supplied, if any.
*/

/* fd handling for stdin, stdout and stderr;
* ignore errors here, user may want to make sure
* the fds are closed, for example */
if (options->stdin_fd >= 0 && options->stdin_fd != 0)
dup2(options->stdin_fd, 0);
if (options->stdout_fd >= 0 && options->stdout_fd != 1)
dup2(options->stdout_fd, 1);
if (options->stderr_fd >= 0 && options->stderr_fd != 2)
dup2(options->stderr_fd, 2);

/* close the old fds */
if (options->stdin_fd > 2)
close(options->stdin_fd);
if (options->stdout_fd > 2)
close(options->stdout_fd);
if (options->stderr_fd > 2)
close(options->stderr_fd);

/* try to remove CLOEXEC flag from stdin/stdout/stderr,
* but also here, ignore errors */
for (fd = 0; fd <= 2; fd++) {
flags = fcntl(fd, F_GETFL);
if (flags < 0)
continue;
if (flags & FD_CLOEXEC)
if (fcntl(fd, F_SETFL, flags & ~FD_CLOEXEC) < 0)
SYSERROR(""Unable to clear CLOEXEC from fd"");
}

	/* we don't need proc anymore *
	close(procfd);
/* we're done, so we can now do whatever the user intended us to do */
rexit(payload->exec_function(payload->exec_payload));
}
","[4, 24, 25, 36]","	int procfd = payload->procfd;/~/		ERROR(""error using IPC to receive notification from initial process (0)"");/~/		ERROR(""error using IPC to notify initial process for initialization (1)"");/~/		ERROR(""error using IPC to receive final notification from initial process (2)"");/~/	shutdown(ipc_socket, SHUT_RDWR);/~/	close(ipc_socket);/~/	/* set new apparmor profile/selinux context */~/		if (lsm_set_label_at(procfd, on_exec, init_ctx->lsm_label) < 0) {/~/	/* we don't need proc anymore */~/	close(procfd);"
540,"vips_tracked_malloc( size_t size )
{
void *buf;

vips_tracked_init();

/* Need an extra sizeof(size_t) bytes to track
* size of this block. Ask for an extra 16 to make sure we don't break
* alignment rules.
*/
size += 16;

        if( !(buf = g_try_malloc( size )) ) {
#ifdef DEBUG
g_assert_not_reached();
#endif /*DEBUG*/

vips_error( ""vips_tracked"",
_( ""out of memory --- size == %dMB"" ),
(int) (size / (1024.0 * 1024.0))  );
g_warning( _( ""out of memory --- size == %dMB"" ),
(int) (size / (1024.0 * 1024.0))  );

return( NULL );
}

g_mutex_lock( vips_tracked_mutex );

*((size_t *)buf) = size;
buf = (void *) ((char *)buf + 16);

vips_tracked_mem += size;
if( vips_tracked_mem > vips_tracked_mem_highwater )
vips_tracked_mem_highwater = vips_tracked_mem;
vips_tracked_allocs += 1;

#ifdef DEBUG_VERBOSE
printf( ""vips_tracked_malloc: %p, %zd bytes\n"", buf, size );
#endif /*DEBUG_VERBOSE*/

g_mutex_unlock( vips_tracked_mutex );

VIPS_GATE_MALLOC( size );

return( buf );
}
",[9],        if( !(buf = g_try_malloc( size )) ) {
541,"static int update_open_stateid(struct nfs4_state *state, nfs4_stateid *open_stateid, nfs4_stateid *delegation, int open_flags)
{
struct nfs_inode *nfsi = NFS_I(state->inode);
struct nfs_delegation *deleg_cur;
int ret = 0;

	open_flags &= (FMODE_READ|FMODE_WRITE);

rcu_read_lock();
deleg_cur = rcu_dereference(nfsi->delegation);
if (deleg_cur == NULL)
goto no_delegation;

spin_lock(&deleg_cur->lock);
if (nfsi->delegation != deleg_cur ||
	    (deleg_cur->type & open_flags) != open_flags)
goto no_delegation_unlock;

if (delegation == NULL)
delegation = &deleg_cur->stateid;
else if (memcmp(deleg_cur->stateid.data, delegation->data, NFS4_STATEID_SIZE) != 0)
goto no_delegation_unlock;

nfs_mark_delegation_referenced(deleg_cur);
	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);
ret = 1;
no_delegation_unlock:
spin_unlock(&deleg_cur->lock);
no_delegation:
rcu_read_unlock();

if (!ret && open_stateid != NULL) {
		__update_open_stateid(state, open_stateid, NULL, open_flags);
ret = 1;
}

return ret;
}
","[5, 12, 19, 26]","	open_flags &= (FMODE_READ|FMODE_WRITE);/~/	    (deleg_cur->type & open_flags) != open_flags)/~/	__update_open_stateid(state, open_stateid, &deleg_cur->stateid, open_flags);/~/		__update_open_stateid(state, open_stateid, NULL, open_flags);"
542,"static int hash_recvmsg(struct kiocb *unused, struct socket *sock,
struct msghdr *msg, size_t len, int flags)
{
struct sock *sk = sock->sk;
struct alg_sock *ask = alg_sk(sk);
struct hash_ctx *ctx = ask->private;
unsigned ds = crypto_ahash_digestsize(crypto_ahash_reqtfm(&ctx->req));
int err;

if (len > ds)
len = ds;
else if (len < ds)
msg->msg_flags |= MSG_TRUNC;

	msg->msg_namelen = 0;
lock_sock(sk);
if (ctx->more) {
ctx->more = 0;
ahash_request_set_crypt(&ctx->req, NULL, ctx->result, 0);
err = af_alg_wait_for_completion(crypto_ahash_final(&ctx->req),
&ctx->completion);
if (err)
goto unlock;
}

err = memcpy_toiovec(msg->msg_iov, ctx->result, len);

unlock:
release_sock(sk);

return err ?: len;
}
",[12],	msg->msg_namelen = 0;
543,"void LinkChangeSerializerMarkupAccumulator::appendAttribute(StringBuilder& result, Element* element, const Attribute& attribute, Namespaces* namespaces)
{
    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {
        String completeURL = m_document->completeURL(attribute.value());
        if (m_replaceLinks->contains(completeURL)) {
            // FIXME: Refactor MarkupAccumulator so it is easier to append an attribute like this.
            result.append(' ');
            result.append(attribute.name().toString());
            result.appendLiteral(""=\"""");
            if (!m_directoryName.isEmpty()) {
                result.appendLiteral(""./"");
                result.append(m_directoryName);
                result.append('/');
            }
            result.append(m_replaceLinks->get(completeURL));
            result.appendLiteral(""\"""");
            return;
        }
    }
    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]","{/~/    if (m_replaceLinks && element->isURLAttribute(attribute) && !element->isJavaScriptURLAttribute(attribute)) {/~/        String completeURL = m_document->completeURL(attribute.value());/~/        if (m_replaceLinks->contains(completeURL)) {/~/            // FIXME: Refactor MarkupAccumulator so it is easier to append an attribute like this./~/            result.append(' ');/~/            result.append(attribute.name().toString());/~/            result.appendLiteral(""=\"""");/~/            if (!m_directoryName.isEmpty()) {/~/                result.appendLiteral(""./"");/~/                result.append(m_directoryName);/~/                result.append('/');/~/            }/~/            result.append(m_replaceLinks->get(completeURL));/~/            result.appendLiteral(""\"""");/~/            return;/~/        }/~/    }/~/    MarkupAccumulator::appendAttribute(result, element, attribute, namespaces);/~/}"
544,"static v8::Handle<v8::Value> acceptTransferListCallback(const v8::Arguments& args)
{
INC_STATS(""DOM.TestSerializedScriptValueInterface.acceptTransferList"");
if (args.Length() < 1)
        return V8Proxy::throwNotEnoughArgumentsError();
TestSerializedScriptValueInterface* imp = V8TestSerializedScriptValueInterface::toNative(args.Holder());
MessagePortArray messagePortArrayTransferList;
ArrayBufferArray arrayBufferArrayTransferList;
if (args.Length() > 1) {
if (!extractTransferables(args[1], messagePortArrayTransferList, arrayBufferArrayTransferList))
return V8Proxy::throwTypeError(""Could not extract transferables"");
}
bool dataDidThrow = false;
RefPtr<SerializedScriptValue> data = SerializedScriptValue::create(args[0], &messagePortArrayTransferList, &arrayBufferArrayTransferList, dataDidThrow, args.GetIsolate());
if (dataDidThrow)
return v8::Undefined();
if (args.Length() <= 1) {
imp->acceptTransferList(data);
return v8::Handle<v8::Value>();
}
imp->acceptTransferList(data, messagePortArrayTransferList);
return v8::Handle<v8::Value>();
}
",[4],        return V8Proxy::throwNotEnoughArgumentsError();
545,"static void br_multicast_del_pg(struct net_bridge *br,
struct net_bridge_port_group *pg)
{
struct net_bridge_mdb_htable *mdb;
struct net_bridge_mdb_entry *mp;
struct net_bridge_port_group *p;
struct net_bridge_port_group __rcu **pp;

mdb = mlock_dereference(br->mdb, br);

mp = br_mdb_ip_get(mdb, &pg->addr);
if (WARN_ON(!mp))
return;

for (pp = &mp->ports;
(p = mlock_dereference(*pp, br)) != NULL;
pp = &p->next) {
if (p != pg)
continue;

rcu_assign_pointer(*pp, p->next);
hlist_del_init(&p->mglist);
del_timer(&p->timer);
call_rcu_bh(&p->rcu, br_multicast_free_pg);

		if (!mp->ports && !mp->mglist &&
netif_running(br->dev))
mod_timer(&mp->timer, jiffies);

return;
}

WARN_ON(1);
}
",[20],		if (!mp->ports && !mp->mglist &&
546,"void LocalFileSystem::fileSystemNotAllowedInternal(
PassRefPtrWillBeRawPtr<ExecutionContext> context,
    PassRefPtr<CallbackWrapper> callbacks)
{
context->postTask(createCrossThreadTask(&reportFailure, callbacks->release(), FileError::ABORT_ERR));
}
",[2],    PassRefPtr<CallbackWrapper> callbacks)
547,"void install_local_socket(asocket* s) {
    adb_mutex_lock(&socket_list_lock);

s->id = local_socket_next_id++;

// Socket ids should never be 0.
if (local_socket_next_id == 0) {
        local_socket_next_id = 1;
}

insert_local_socket(s, &local_socket_list);
    adb_mutex_unlock(&socket_list_lock);
}
","[1, 5, 8]",    adb_mutex_lock(&socket_list_lock);/~/        local_socket_next_id = 1;/~/    adb_mutex_unlock(&socket_list_lock);
548,"static void shm_destroy(struct ipc_namespace *ns, struct shmid_kernel *shp)
{
ns->shm_tot -= (shp->shm_segsz + PAGE_SIZE - 1) >> PAGE_SHIFT;
shm_rmid(ns, shp);
shm_unlock(shp);
	if (!is_file_hugepages(shp->shm_file))
		shmem_lock(shp->shm_file, 0, shp->mlock_user);
else if (shp->mlock_user)
		user_shm_unlock(file_inode(shp->shm_file)->i_size,
						shp->mlock_user);
	fput (shp->shm_file);
ipc_rcu_putref(shp, shm_rcu_free);
}
","[5, 6, 8, 9, 10]","	if (!is_file_hugepages(shp->shm_file))/~/		shmem_lock(shp->shm_file, 0, shp->mlock_user);/~/		user_shm_unlock(file_inode(shp->shm_file)->i_size,/~/						shp->mlock_user);/~/	fput (shp->shm_file);"
549,"int SoundPool::load(int fd, int64_t offset, int64_t length, int priority __unused)
{
ALOGV(""load: fd=%d, offset=%"" PRId64 "", length=%"" PRId64 "", priority=%d"",
fd, offset, length, priority);
    Mutex::Autolock lock(&mLock);
    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);
    mSamples.add(sample->sampleID(), sample);
    doLoad(sample);
    return sample->sampleID();
}
","[4, 5, 6, 7, 8, 9]","    Mutex::Autolock lock(&mLock);/~/    sp<Sample> sample = new Sample(++mNextSampleID, fd, offset, length);/~/    mSamples.add(sample->sampleID(), sample);/~/    doLoad(sample);/~/    return sample->sampleID();/~/}"
550,"long Cluster::CreateBlock(
    long long id,
    long long pos,   //absolute pos of payload
    long long size,
    long long discard_padding)
{
    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock
    if (m_entries_count < 0)  //haven't parsed anything yet
    {
        assert(m_entries == NULL);
        assert(m_entries_size == 0);
        m_entries_size = 1024;
        m_entries = new BlockEntry*[m_entries_size];
        m_entries_count = 0;
    }
    else
    {
        assert(m_entries);
        assert(m_entries_size > 0);
        assert(m_entries_count <= m_entries_size);
        if (m_entries_count >= m_entries_size)
        {
            const long entries_size = 2 * m_entries_size;
            BlockEntry** const entries = new BlockEntry*[entries_size];
            assert(entries);
            BlockEntry** src = m_entries;
            BlockEntry** const src_end = src + m_entries_count;
            BlockEntry** dst = entries;
            while (src != src_end)
                *dst++ = *src++;
            delete[] m_entries;
            m_entries = entries;
            m_entries_size = entries_size;
        }
}

    if (id == 0x20)  //BlockGroup ID
        return CreateBlockGroup(pos, size, discard_padding);
    else  //SimpleBlock ID
        return CreateSimpleBlock(pos, size);
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]","    long long id,/~/    long long pos,   //absolute pos of payload/~/    long long size,/~/    long long discard_padding)/~/{/~/    assert((id == 0x20) || (id == 0x23));  //BlockGroup or SimpleBlock/~/    if (m_entries_count < 0)  //haven't parsed anything yet/~/    {/~/        assert(m_entries == NULL);/~/        assert(m_entries_size == 0);/~/        m_entries_size = 1024;/~/        m_entries = new BlockEntry*[m_entries_size];/~/        m_entries_count = 0;/~/    }/~/    else/~/    {/~/        assert(m_entries);/~/        assert(m_entries_size > 0);/~/        assert(m_entries_count <= m_entries_size);/~/        if (m_entries_count >= m_entries_size)/~/        {/~/            const long entries_size = 2 * m_entries_size;/~/            BlockEntry** const entries = new BlockEntry*[entries_size];/~/            assert(entries);/~/            BlockEntry** src = m_entries;/~/            BlockEntry** const src_end = src + m_entries_count;/~/            BlockEntry** dst = entries;/~/            while (src != src_end)/~/                *dst++ = *src++;/~/            delete[] m_entries;/~/            m_entries = entries;/~/            m_entries_size = entries_size;/~/        }/~/    if (id == 0x20)  //BlockGroup ID/~/        return CreateBlockGroup(pos, size, discard_padding);/~/    else  //SimpleBlock ID/~/        return CreateSimpleBlock(pos, size);"
551,"void CompileFromResponseCallback(
const v8::FunctionCallbackInfo<v8::Value>& args) {
ExceptionState exception_state(args.GetIsolate(),
ExceptionState::kExecutionContext,
""WebAssembly"", ""compile"");
ExceptionToRejectPromiseScope reject_promise_scope(args, exception_state);

  ScriptState* script_state = ScriptState::ForRelevantRealm(args);
if (!ExecutionContext::From(script_state)) {
V8SetReturnValue(args, ScriptPromise().V8Value());
return;
}

if (args.Length() < 1 || !args[0]->IsObject() ||
!V8Response::hasInstance(args[0], args.GetIsolate())) {
V8SetReturnValue(
args,
ScriptPromise::Reject(
script_state, V8ThrowException::CreateTypeError(
script_state->GetIsolate(),
                              ""An argument must be provided, which must be a""
""Response or Promise<Response> object""))
.V8Value());
return;
}

Response* response = V8Response::ToImpl(v8::Local<v8::Object>::Cast(args[0]));
if (response->MimeType() != ""application/wasm"") {
V8SetReturnValue(
args,
ScriptPromise::Reject(
script_state,
V8ThrowException::CreateTypeError(
script_state->GetIsolate(),
""Incorrect response MIME type. Expected 'application/wasm'.""))
.V8Value());
return;
}
v8::Local<v8::Value> promise;
if (response->IsBodyLocked() || response->bodyUsed()) {
promise = ScriptPromise::Reject(script_state,
V8ThrowException::CreateTypeError(
script_state->GetIsolate(),
""Cannot compile WebAssembly.Module ""
""from an already read Response""))
.V8Value();
} else {
if (response->BodyBuffer()) {
FetchDataLoaderAsWasmModule* loader =
new FetchDataLoaderAsWasmModule(script_state);

promise = loader->GetPromise();
response->BodyBuffer()->StartLoading(loader, new WasmDataLoaderClient());
} else {
promise = ScriptPromise::Reject(script_state,
V8ThrowException::CreateTypeError(
script_state->GetIsolate(),
""Response object has a null body.""))
.V8Value();
}
}
V8SetReturnValue(args, promise);
}
","[6, 18]","  ScriptState* script_state = ScriptState::ForRelevantRealm(args);/~/                              ""An argument must be provided, which must be a"""
552,"void DecoderTest::RunLoop(CompressedVideoSource *video) {
  vpx_codec_dec_cfg_t dec_cfg = {0};
  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);
ASSERT_TRUE(decoder != NULL);

// Decode frames.
  for (video->Begin(); video->cxdata(); video->Next()) {
PreDecodeFrameHook(*video, decoder);
    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),
                                                   video->frame_size());
    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();

DxDataIterator dec_iter = decoder->GetDxData();
const vpx_image_t *img = NULL;

// Get decompressed data

while ((img = dec_iter.Next()))
DecompressedFrameHook(*img, video->frame_number());
}
delete decoder;
}
","[1, 2, 5, 7, 8, 9]","  vpx_codec_dec_cfg_t dec_cfg = {0};/~/  Decoder* const decoder = codec_->CreateDecoder(dec_cfg, 0);/~/  for (video->Begin(); video->cxdata(); video->Next()) {/~/    vpx_codec_err_t res_dec = decoder->DecodeFrame(video->cxdata(),/~/                                                   video->frame_size());/~/    ASSERT_EQ(VPX_CODEC_OK, res_dec) << decoder->DecodeError();"
553,"static enum integrity_status evm_verify_hmac(struct dentry *dentry,
const char *xattr_name,
char *xattr_value,
size_t xattr_value_len,
struct integrity_iint_cache *iint)
{
struct evm_ima_xattr_data *xattr_data = NULL;
struct evm_ima_xattr_data calc;
enum integrity_status evm_status = INTEGRITY_PASS;
int rc, xattr_len;

if (iint && iint->evm_status == INTEGRITY_PASS)
return iint->evm_status;

/* if status is not PASS, try to check again - against -ENOMEM */

/* first need to know the sig type */
rc = vfs_getxattr_alloc(dentry, XATTR_NAME_EVM, (char **)&xattr_data, 0,
GFP_NOFS);
if (rc <= 0) {
evm_status = INTEGRITY_FAIL;
if (rc == -ENODATA) {
rc = evm_find_protected_xattrs(dentry);
if (rc > 0)
evm_status = INTEGRITY_NOLABEL;
else if (rc == 0)
evm_status = INTEGRITY_NOXATTRS; /* new file */
} else if (rc == -EOPNOTSUPP) {
evm_status = INTEGRITY_UNKNOWN;
}
goto out;
}

xattr_len = rc;

/* check value type */
switch (xattr_data->type) {
case EVM_XATTR_HMAC:
rc = evm_calc_hmac(dentry, xattr_name, xattr_value,
xattr_value_len, calc.digest);
if (rc)
break;
		rc = memcmp(xattr_data->digest, calc.digest,
sizeof(calc.digest));
if (rc)
rc = -EINVAL;
break;
case EVM_IMA_XATTR_DIGSIG:
rc = evm_calc_hash(dentry, xattr_name, xattr_value,
xattr_value_len, calc.digest);
if (rc)
break;
rc = integrity_digsig_verify(INTEGRITY_KEYRING_EVM,
(const char *)xattr_data, xattr_len,
calc.digest, sizeof(calc.digest));
if (!rc) {
/* Replace RSA with HMAC if not mounted readonly and
* not immutable
*/
if (!IS_RDONLY(d_backing_inode(dentry)) &&
!IS_IMMUTABLE(d_backing_inode(dentry)))
evm_update_evmxattr(dentry, xattr_name,
xattr_value,
xattr_value_len);
}
break;
default:
rc = -EINVAL;
break;
}

if (rc)
evm_status = (rc == -ENODATA) ?
INTEGRITY_NOXATTRS : INTEGRITY_FAIL;
out:
if (iint)
iint->evm_status = evm_status;
kfree(xattr_data);
return evm_status;
}
",[37],"		rc = memcmp(xattr_data->digest, calc.digest,"
554,"void makeCurrent()
{
#if PLATFORM(QT)
        m_detachedContext = QOpenGLContext::currentContext();
        if (m_detachedContext)
            m_detachedSurface = m_detachedContext->surface();
        if (m_surface && m_glContext)
            m_glContext->makeCurrent(m_surface.get());
#elif PLATFORM(EFL)
m_detachedContext = glXGetCurrentContext();
m_detachedSurface = glXGetCurrentDrawable();
if (m_surface && m_glContext)
glXMakeCurrent(m_display, m_surface, m_glContext);
#endif
}
","[2, 3, 4, 5, 6, 7, 8, 11, 13]",#if PLATFORM(QT)/~/        m_detachedContext = QOpenGLContext::currentContext();/~/        if (m_detachedContext)/~/            m_detachedSurface = m_detachedContext->surface();/~/        if (m_surface && m_glContext)/~/            m_glContext->makeCurrent(m_surface.get());/~/#elif PLATFORM(EFL)/~/#endif
555,"bool GpuProcessPolicy::PreSandboxHook() {
// Warm up resources needed by the policy we're about to enable and
// eventually start a broker process.
const bool chromeos_arm_gpu = IsChromeOS() && IsArchitectureArm();
// This policy is for x86 or Desktop.
DCHECK(!chromeos_arm_gpu);

DCHECK(!broker_process());
// Create a new broker process.
InitGpuBrokerProcess(
GpuBrokerProcessPolicy::Create,
std::vector<BrokerFilePermission>());  // No extra files in whitelist.

if (IsArchitectureX86_64() || IsArchitectureI386()) {
// Accelerated video dlopen()'s some shared objects
// inside the sandbox, so preload them now.
if (IsAcceleratedVaapiVideoEncodeEnabled() ||
IsAcceleratedVideoDecodeEnabled()) {
const char* I965DrvVideoPath = NULL;
      const char* I965HybridDrvVideoPath = NULL;

if (IsArchitectureX86_64()) {
I965DrvVideoPath = ""/usr/lib64/va/drivers/i965_drv_video.so"";
        I965HybridDrvVideoPath = ""/usr/lib64/va/drivers/hybrid_drv_video.so"";
} else if (IsArchitectureI386()) {
I965DrvVideoPath = ""/usr/lib/va/drivers/i965_drv_video.so"";
}

dlopen(I965DrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);
      if (I965HybridDrvVideoPath)
        dlopen(I965HybridDrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);
dlopen(""libva.so.1"", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);
#if defined(USE_OZONE)
dlopen(""libva-drm.so.1"", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);
#elif defined(USE_X11)
dlopen(""libva-x11.so.1"", RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);
#endif
}
}

return true;
}
","[17, 20, 25, 26]","      const char* I965HybridDrvVideoPath = NULL;/~/        I965HybridDrvVideoPath = ""/usr/lib64/va/drivers/hybrid_drv_video.so"";/~/      if (I965HybridDrvVideoPath)/~/        dlopen(I965HybridDrvVideoPath, RTLD_NOW|RTLD_GLOBAL|RTLD_NODELETE);"
556,"int res_inverse(vorbis_dsp_state *vd,vorbis_info_residue *info,
		ogg_int32_t **in,int *nonzero,int ch){

int i,j,k,s,used=0;
codec_setup_info     *ci=(codec_setup_info *)vd->vi->codec_setup;
codebook *phrasebook=ci->book_param+info->groupbook;
int samples_per_partition=info->grouping;
int partitions_per_word=phrasebook->dim;
int pcmend=ci->blocksizes[vd->W];

if(info->type<2){
int max=pcmend>>1;
int end=(info->end<max?info->end:max);
int n=end-info->begin;

if(n>0){
int partvals=n/samples_per_partition;

int partwords=(partvals+partitions_per_word-1)/partitions_per_word;

for(i=0;i<ch;i++)
	if(nonzero[i])
	  in[used++]=in[i];
ch=used;

if(used){

	char **partword=(char **)alloca(ch*sizeof(*partword));
	for(j=0;j<ch;j++)
	  partword[j]=(char *)alloca(partwords*partitions_per_word*
				     sizeof(*partword[j]));

	for(s=0;s<info->stages;s++){

	  for(i=0;i<partvals;){
	    if(s==0){
	      /* fetch the partition word for each channel *

	      partword[0][i+partitions_per_word-1]=1;
	      for(k=partitions_per_word-2;k>=0;k--)
		partword[0][i+k]=partword[0][i+k+1]*info->partitions;

	      for(j=1;j<ch;j++)
		for(k=partitions_per_word-1;k>=0;k--)
		  partword[j][i+k]=partword[j-1][i+k];

	      for(j=0;j<ch;j++){
		int temp=vorbis_book_decode(phrasebook,&vd->opb);
		if(temp==-1)goto eopbreak;

		/* this can be done quickly in assembly due to the quotient
		   always being at most six bits *
		for(k=0;k<partitions_per_word;k++){
		  ogg_uint32_t div=partword[j][i+k];
		  partword[j][i+k]=temp/div;
		  temp-=partword[j][i+k]*div;
		}

	      }
	    }

	    /* now we decode residual values for the partitions *
	    for(k=0;k<partitions_per_word && i<partvals;k++,i++)
	      for(j=0;j<ch;j++){
		long offset=info->begin+i*samples_per_partition;
		if(info->stagemasks[(int)partword[j][i]]&(1<<s)){
		  codebook *stagebook=ci->book_param+
		    info->stagebooks[(partword[j][i]<<3)+s];
		  if(info->type){
		    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,
					       samples_per_partition,-8)==-1)
		      goto eopbreak;
		  }else{
		    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,
						samples_per_partition,-8)==-1)
		      goto eopbreak;
		  }
		}
	      }
	  }
	}
}
}
}else{
int max=(pcmend*ch)>>1;
int end=(info->end<max?info->end:max);
int n=end-info->begin;

if(n>0){
int partvals=n/samples_per_partition;

int partwords=(partvals+partitions_per_word-1)/partitions_per_word;

char *partword=
	(char *)alloca(partwords*partitions_per_word*sizeof(*partword));
int beginoff=info->begin/ch;

for(i=0;i<ch;i++)if(nonzero[i])break;
if(i==ch)return(0); /* no nonzero vectors */

samples_per_partition/=ch;

for(s=0;s<info->stages;s++){
for(i=0;i<partvals;){

if(s==0){
int temp;
partword[i+partitions_per_word-1]=1;
for(k=partitions_per_word-2;k>=0;k--)
partword[i+k]=partword[i+k+1]*info->partitions;

/* fetch the partition word */
temp=vorbis_book_decode(phrasebook,&vd->opb);
if(temp==-1)goto eopbreak;

/* this can be done quickly in assembly due to the quotient
always being at most six bits */
for(k=0;k<partitions_per_word;k++){
ogg_uint32_t div=partword[i+k];
partword[i+k]=temp/div;
temp-=partword[i+k]*div;
}
}

/* now we decode residual values for the partitions */
for(k=0;k<partitions_per_word && i<partvals;k++,i++)
if(info->stagemasks[(int)partword[i]]&(1<<s)){
codebook *stagebook=ci->book_param+
info->stagebooks[(partword[i]<<3)+s];
if(vorbis_book_decodevv_add(stagebook,in,
i*samples_per_partition+beginoff,ch,
&vd->opb,
samples_per_partition,-8)==-1)
goto eopbreak;
}
}
}
}
}
eopbreak:

return 0;
}
","[1, 16, 17, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]","		ogg_int32_t **in,int *nonzero,int ch){/~/	if(nonzero[i])/~/	  in[used++]=in[i];/~/	char **partword=(char **)alloca(ch*sizeof(*partword));/~/	for(j=0;j<ch;j++)/~/	  partword[j]=(char *)alloca(partwords*partitions_per_word*/~/				     sizeof(*partword[j]));/~/	for(s=0;s<info->stages;s++){/~/	  for(i=0;i<partvals;){/~/	    if(s==0){/~/	      /* fetch the partition word for each channel */~/	      partword[0][i+partitions_per_word-1]=1;/~/	      for(k=partitions_per_word-2;k>=0;k--)/~/		partword[0][i+k]=partword[0][i+k+1]*info->partitions;/~/	      for(j=1;j<ch;j++)/~/		for(k=partitions_per_word-1;k>=0;k--)/~/		  partword[j][i+k]=partword[j-1][i+k];/~/	      for(j=0;j<ch;j++){/~/		int temp=vorbis_book_decode(phrasebook,&vd->opb);/~/		if(temp==-1)goto eopbreak;/~/		/* this can be done quickly in assembly due to the quotient/~/		   always being at most six bits */~/		for(k=0;k<partitions_per_word;k++){/~/		  ogg_uint32_t div=partword[j][i+k];/~/		  partword[j][i+k]=temp/div;/~/		  temp-=partword[j][i+k]*div;/~/		}/~/	      }/~/	    }/~/	    /* now we decode residual values for the partitions */~/	    for(k=0;k<partitions_per_word && i<partvals;k++,i++)/~/	      for(j=0;j<ch;j++){/~/		long offset=info->begin+i*samples_per_partition;/~/		if(info->stagemasks[(int)partword[j][i]]&(1<<s)){/~/		  codebook *stagebook=ci->book_param+/~/		    info->stagebooks[(partword[j][i]<<3)+s];/~/		  if(info->type){/~/		    if(vorbis_book_decodev_add(stagebook,in[j]+offset,&vd->opb,/~/					       samples_per_partition,-8)==-1)/~/		      goto eopbreak;/~/		  }else{/~/		    if(vorbis_book_decodevs_add(stagebook,in[j]+offset,&vd->opb,/~/						samples_per_partition,-8)==-1)/~/		      goto eopbreak;/~/		  }/~/		}/~/	      }/~/	  }/~/	}/~/	(char *)alloca(partwords*partitions_per_word*sizeof(*partword));"
557,"image_transform_png_set_scale_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(colour_type)

this->next = *that;
*that = this;

return bit_depth > 8;
}
",[1],"    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)"
558,"void AppCacheGroup::RemoveCache(AppCache* cache) {
DCHECK(cache->associated_hosts().empty());
if (cache == newest_complete_cache_) {
    CancelUpdate();
AppCache* tmp_cache = newest_complete_cache_;
newest_complete_cache_ = nullptr;
tmp_cache->set_owning_group(nullptr);  // may cause this group to be deleted
} else {
scoped_refptr<AppCacheGroup> protect(this);

Caches::iterator it =
std::find(old_caches_.begin(), old_caches_.end(), cache);
if (it != old_caches_.end()) {
AppCache* tmp_cache = *it;
old_caches_.erase(it);
tmp_cache->set_owning_group(nullptr);  // may cause group to be released
}

if (!is_obsolete() && old_caches_.empty() &&
!newly_deletable_response_ids_.empty()) {
storage_->DeleteResponses(manifest_url_, newly_deletable_response_ids_);
newly_deletable_response_ids_.clear();
}
}
}
",[3],    CancelUpdate();
559,"image_transform_png_set_expand_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(bit_depth)

this->next = *that;
*that = this;

/* 'expand' should do nothing for RGBA or GA input - no tRNS and the bit
* depth is at least 8 already.
*/
return (colour_type & PNG_COLOR_MASK_ALPHA) == 0;
}
",[1],"    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)"
560,"long arch_ptrace(struct task_struct *child, long request,
unsigned long addr, unsigned long data)
{
int ret;
unsigned long __user *datap = (unsigned long __user *) data;

switch (request) {
case PTRACE_PEEKUSR:
ret = ptrace_read_user(child, addr, datap);
break;

case PTRACE_POKEUSR:
ret = ptrace_write_user(child, addr, data);
break;

case PTRACE_GETREGS:
ret = copy_regset_to_user(child,
&user_arm_view, REGSET_GPR,
0, sizeof(struct pt_regs),
datap);
break;

case PTRACE_SETREGS:
ret = copy_regset_from_user(child,
&user_arm_view, REGSET_GPR,
0, sizeof(struct pt_regs),
datap);
break;

case PTRACE_GETFPREGS:
ret = copy_regset_to_user(child,
&user_arm_view, REGSET_FPR,
0, sizeof(union fp_state),
datap);
break;

case PTRACE_SETFPREGS:
ret = copy_regset_from_user(child,
&user_arm_view, REGSET_FPR,
0, sizeof(union fp_state),
datap);
break;

#ifdef CONFIG_IWMMXT
case PTRACE_GETWMMXREGS:
ret = ptrace_getwmmxregs(child, datap);
break;

case PTRACE_SETWMMXREGS:
ret = ptrace_setwmmxregs(child, datap);
break;
#endif

case PTRACE_GET_THREAD_AREA:
			ret = put_user(task_thread_info(child)->tp_value,
datap);
break;

case PTRACE_SET_SYSCALL:
task_thread_info(child)->syscall = data;
ret = 0;
break;

#ifdef CONFIG_CRUNCH
case PTRACE_GETCRUNCHREGS:
ret = ptrace_getcrunchregs(child, datap);
break;

case PTRACE_SETCRUNCHREGS:
ret = ptrace_setcrunchregs(child, datap);
break;
#endif

#ifdef CONFIG_VFP
case PTRACE_GETVFPREGS:
ret = copy_regset_to_user(child,
&user_arm_view, REGSET_VFP,
0, ARM_VFPREGS_SIZE,
datap);
break;

case PTRACE_SETVFPREGS:
ret = copy_regset_from_user(child,
&user_arm_view, REGSET_VFP,
0, ARM_VFPREGS_SIZE,
datap);
break;
#endif

#ifdef CONFIG_HAVE_HW_BREAKPOINT
case PTRACE_GETHBPREGS:
if (ptrace_get_breakpoints(child) < 0)
return -ESRCH;

ret = ptrace_gethbpregs(child, addr,
(unsigned long __user *)data);
ptrace_put_breakpoints(child);
break;
case PTRACE_SETHBPREGS:
if (ptrace_get_breakpoints(child) < 0)
return -ESRCH;

ret = ptrace_sethbpregs(child, addr,
(unsigned long __user *)data);
ptrace_put_breakpoints(child);
break;
#endif

default:
ret = ptrace_request(child, request, addr, data);
break;
}

return ret;
}
",[45],"			ret = put_user(task_thread_info(child)->tp_value,"
561,"void SpeechRecognitionManagerImpl::RecognitionAllowedCallback(int session_id,
bool ask_user,
bool is_allowed) {
DCHECK_CURRENTLY_ON(BrowserThread::IO);

auto iter = sessions_.find(session_id);
if (iter == sessions_.end())
return;

Session* session = iter->second.get();

if (session->abort_requested)
return;

if (ask_user) {
SpeechRecognitionSessionContext& context = session->context;
context.label = media_stream_manager_->MakeMediaAccessRequest(
        context.render_process_id, context.render_frame_id, session_id,
        StreamControls(true, false), context.security_origin,
base::BindOnce(
&SpeechRecognitionManagerImpl::MediaRequestPermissionCallback,
weak_factory_.GetWeakPtr(), session_id));
return;
}

if (is_allowed) {
base::ThreadTaskRunnerHandle::Get()->PostTask(
FROM_HERE,
base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,
weak_factory_.GetWeakPtr(), session_id, EVENT_START));
} else {
OnRecognitionError(
session_id, blink::mojom::SpeechRecognitionError(
blink::mojom::SpeechRecognitionErrorCode::kNotAllowed,
blink::mojom::SpeechAudioErrorDetails::kNone));
base::ThreadTaskRunnerHandle::Get()->PostTask(
FROM_HERE,
base::BindOnce(&SpeechRecognitionManagerImpl::DispatchEvent,
weak_factory_.GetWeakPtr(), session_id, EVENT_ABORT));
}
}
","[13, 14]","        context.render_process_id, context.render_frame_id, session_id,/~/        StreamControls(true, false), context.security_origin,"
562,"static void update_open_stateflags(struct nfs4_state *state, mode_t open_flags)
{
	switch (open_flags) {
case FMODE_WRITE:
state->n_wronly++;
break;
case FMODE_READ:
state->n_rdonly++;
break;
case FMODE_READ|FMODE_WRITE:
state->n_rdwr++;
}
	nfs4_state_set_mode_locked(state, state->state | open_flags);
}
","[2, 12]","	switch (open_flags) {/~/	nfs4_state_set_mode_locked(state, state->state | open_flags);"
563,"void HTMLFormControlElement::parseAttribute(const QualifiedName& name, const AtomicString& value)
{
if (name == formAttr) {
formAttributeChanged();
UseCounter::count(document(), UseCounter::FormAttribute);
} else if (name == disabledAttr) {
bool oldDisabled = m_disabled;
m_disabled = !value.isNull();
if (oldDisabled != m_disabled)
disabledAttributeChanged();
} else if (name == readonlyAttr) {
bool wasReadOnly = m_isReadOnly;
m_isReadOnly = !value.isNull();
if (wasReadOnly != m_isReadOnly) {
setNeedsWillValidateCheck();
            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));
if (layoutObject())
LayoutTheme::theme().controlStateChanged(*layoutObject(), ReadOnlyControlState);
}
} else if (name == requiredAttr) {
bool wasRequired = m_isRequired;
m_isRequired = !value.isNull();
if (wasRequired != m_isRequired)
requiredAttributeChanged();
UseCounter::count(document(), UseCounter::RequiredAttribute);
} else if (name == autofocusAttr) {
HTMLElement::parseAttribute(name, value);
UseCounter::count(document(), UseCounter::AutoFocusAttribute);
} else {
HTMLElement::parseAttribute(name, value);
}
}
",[15],"            setNeedsStyleRecalc(SubtreeStyleChange, StyleChangeReasonForTracing::fromAttribute(name));"
564,"get_endpoints(struct usbtest_dev *dev, struct usb_interface *intf)
{
int				tmp;
struct usb_host_interface	*alt;
struct usb_host_endpoint	*in, *out;
struct usb_host_endpoint	*iso_in, *iso_out;
struct usb_host_endpoint	*int_in, *int_out;
struct usb_device		*udev;

for (tmp = 0; tmp < intf->num_altsetting; tmp++) {
unsigned	ep;

in = out = NULL;
iso_in = iso_out = NULL;
int_in = int_out = NULL;
alt = intf->altsetting + tmp;

if (override_alt >= 0 &&
override_alt != alt->desc.bAlternateSetting)
continue;

/* take the first altsetting with in-bulk + out-bulk;
* ignore other endpoints and altsettings.
*/
for (ep = 0; ep < alt->desc.bNumEndpoints; ep++) {
struct usb_host_endpoint	*e;
int edi;

e = alt->endpoint + ep;
edi = usb_endpoint_dir_in(&e->desc);

switch (usb_endpoint_type(&e->desc)) {
case USB_ENDPOINT_XFER_BULK:
endpoint_update(edi, &in, &out, e);
continue;
case USB_ENDPOINT_XFER_INT:
if (dev->info->intr)
endpoint_update(edi, &int_in, &int_out, e);
continue;
case USB_ENDPOINT_XFER_ISOC:
if (dev->info->iso)
endpoint_update(edi, &iso_in, &iso_out, e);
/* FALLTHROUGH */
default:
continue;
}
}
if ((in && out)  ||  iso_in || iso_out || int_in || int_out)
goto found;
}
return -EINVAL;

found:
udev = testdev_to_usbdev(dev);
dev->info->alt = alt->desc.bAlternateSetting;
if (alt->desc.bAlternateSetting != 0) {
tmp = usb_set_interface(udev,
alt->desc.bInterfaceNumber,
alt->desc.bAlternateSetting);
if (tmp < 0)
return tmp;
}

	if (in) {
dev->in_pipe = usb_rcvbulkpipe(udev,
in->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
dev->out_pipe = usb_sndbulkpipe(udev,
out->desc.bEndpointAddress & USB_ENDPOINT_NUMBER_MASK);
	}
if (iso_in) {
dev->iso_in = &iso_in->desc;
dev->in_iso_pipe = usb_rcvisocpipe(udev,
iso_in->desc.bEndpointAddress
& USB_ENDPOINT_NUMBER_MASK);
}

if (iso_out) {
dev->iso_out = &iso_out->desc;
dev->out_iso_pipe = usb_sndisocpipe(udev,
iso_out->desc.bEndpointAddress
& USB_ENDPOINT_NUMBER_MASK);
}

if (int_in) {
dev->int_in = &int_in->desc;
dev->in_int_pipe = usb_rcvintpipe(udev,
int_in->desc.bEndpointAddress
& USB_ENDPOINT_NUMBER_MASK);
}

if (int_out) {
dev->int_out = &int_out->desc;
dev->out_int_pipe = usb_sndintpipe(udev,
int_out->desc.bEndpointAddress
& USB_ENDPOINT_NUMBER_MASK);
}
return 0;
}
","[47, 48, 51]",	if (in) {/~/	}
565,"int validate_camera_metadata_structure(const camera_metadata_t *metadata,
const size_t *expected_size) {

if (metadata == NULL) {
ALOGE(""%s: metadata is null!"", __FUNCTION__);
return ERROR;
}

// Check that the metadata pointer is well-aligned first.
{
static const struct {
const char *name;
size_t alignment;
} alignments[] = {
{
.name = ""camera_metadata"",
.alignment = METADATA_ALIGNMENT
},
{
.name = ""camera_metadata_buffer_entry"",
.alignment = ENTRY_ALIGNMENT
},
{
.name = ""camera_metadata_data"",
.alignment = DATA_ALIGNMENT
},
};

for (size_t i = 0; i < sizeof(alignments)/sizeof(alignments[0]); ++i) {
uintptr_t aligned_ptr = ALIGN_TO(metadata, alignments[i].alignment);

if ((uintptr_t)metadata != aligned_ptr) {
ALOGE(""%s: Metadata pointer is not aligned (actual %p, ""
""expected %p) to type %s"",
__FUNCTION__, metadata,
(void*)aligned_ptr, alignments[i].name);
return ERROR;
}
}
}

/**
* Check that the metadata contents are correct
*/

if (expected_size != NULL && metadata->size > *expected_size) {
ALOGE(""%s: Metadata size (%"" PRIu32 "") should be <= expected size (%zu)"",
__FUNCTION__, metadata->size, *expected_size);
return ERROR;
}

if (metadata->entry_count > metadata->entry_capacity) {
ALOGE(""%s: Entry count (%"" PRIu32 "") should be <= entry capacity ""
""(%"" PRIu32 "")"",
__FUNCTION__, metadata->entry_count, metadata->entry_capacity);

return ERROR;
}

    const metadata_uptrdiff_t entries_end =
        metadata->entries_start + metadata->entry_capacity;
if (entries_end < metadata->entries_start || // overflow check
entries_end > metadata->data_start) {

ALOGE(""%s: Entry start + capacity (%"" PRIu32 "") should be <= data start ""
""(%"" PRIu32 "")"",
__FUNCTION__,
(metadata->entries_start + metadata->entry_capacity),
metadata->data_start);
return ERROR;
}

const metadata_uptrdiff_t data_end =
metadata->data_start + metadata->data_capacity;
if (data_end < metadata->data_start || // overflow check
data_end > metadata->size) {

ALOGE(""%s: Data start + capacity (%"" PRIu32 "") should be <= total size ""
""(%"" PRIu32 "")"",
__FUNCTION__,
(metadata->data_start + metadata->data_capacity),
metadata->size);
return ERROR;
}

// Validate each entry
const metadata_size_t entry_count = metadata->entry_count;
camera_metadata_buffer_entry_t *entries = get_entries(metadata);

for (size_t i = 0; i < entry_count; ++i) {

if ((uintptr_t)&entries[i] != ALIGN_TO(&entries[i], ENTRY_ALIGNMENT)) {
ALOGE(""%s: Entry index %zu had bad alignment (address %p),""
"" expected alignment %zu"",
__FUNCTION__, i, &entries[i], ENTRY_ALIGNMENT);
return ERROR;
}

camera_metadata_buffer_entry_t entry = entries[i];

if (entry.type >= NUM_TYPES) {
ALOGE(""%s: Entry index %zu had a bad type %d"",
__FUNCTION__, i, entry.type);
return ERROR;
}

// TODO: fix vendor_tag_ops across processes so we don't need to special
//       case vendor-specific tags
uint32_t tag_section = entry.tag >> 16;
int tag_type = get_camera_metadata_tag_type(entry.tag);
if (tag_type != (int)entry.type && tag_section < VENDOR_SECTION) {
ALOGE(""%s: Entry index %zu had tag type %d, but the type was %d"",
__FUNCTION__, i, tag_type, entry.type);
return ERROR;
}

size_t data_size;
if (validate_and_calculate_camera_metadata_entry_data_size(&data_size, entry.type,
entry.count) != OK) {
ALOGE(""%s: Entry data size is invalid. type: %u count: %u"", __FUNCTION__, entry.type,
entry.count);
return ERROR;
}

if (data_size != 0) {
camera_metadata_data_t *data =
(camera_metadata_data_t*) (get_data(metadata) +
entry.data.offset);

if ((uintptr_t)data != ALIGN_TO(data, DATA_ALIGNMENT)) {
ALOGE(""%s: Entry index %zu had bad data alignment (address %p),""
"" expected align %zu, (tag name %s, data size %zu)"",
__FUNCTION__, i, data, DATA_ALIGNMENT,
get_camera_metadata_tag_name(entry.tag) ?: ""unknown"",
data_size);
return ERROR;
}

size_t data_entry_end = entry.data.offset + data_size;
if (data_entry_end < entry.data.offset || // overflow check
data_entry_end > metadata->data_capacity) {

ALOGE(""%s: Entry index %zu data ends (%zu) beyond the capacity ""
""%"" PRIu32, __FUNCTION__, i, data_entry_end,
metadata->data_capacity);
return ERROR;
}

} else if (entry.count == 0) {
if (entry.data.offset != 0) {
ALOGE(""%s: Entry index %zu had 0 items, but offset was non-0 ""
""(%"" PRIu32 ""), tag name: %s"", __FUNCTION__, i, entry.data.offset,
get_camera_metadata_tag_name(entry.tag) ?: ""unknown"");
return ERROR;
}
} // else data stored inline, so we look at value which can be anything.
}

return OK;
}
",[50],    const metadata_uptrdiff_t entries_end =/~/        metadata->entries_start + metadata->entry_capacity;
566,"static int ocfs2_dio_get_block(struct inode *inode, sector_t iblock,
struct buffer_head *bh_result, int create)
{
struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
struct ocfs2_inode_info *oi = OCFS2_I(inode);
struct ocfs2_write_ctxt *wc;
struct ocfs2_write_cluster_desc *desc = NULL;
struct ocfs2_dio_write_ctxt *dwc = NULL;
struct buffer_head *di_bh = NULL;
u64 p_blkno;
loff_t pos = iblock << inode->i_sb->s_blocksize_bits;
unsigned len, total_len = bh_result->b_size;
int ret = 0, first_get_block = 0;

len = osb->s_clustersize - (pos & (osb->s_clustersize - 1));
len = min(total_len, len);

mlog(0, ""get block of %lu at %llu:%u req %u\n"",
inode->i_ino, pos, len, total_len);

/*
* Because we need to change file size in ocfs2_dio_end_io_write(), or
* we may need to add it to orphan dir. So can not fall to fast path
* while file size will be changed.
*/
if (pos + total_len <= i_size_read(inode)) {
		down_read(&oi->ip_alloc_sem);
		/* This is the fast path for re-write. *
		ret = ocfs2_get_block(inode, iblock, bh_result, create);
		up_read(&oi->ip_alloc_sem);

if (buffer_mapped(bh_result) &&
!buffer_new(bh_result) &&
ret == 0)
goto out;

/* Clear state set by ocfs2_get_block. */
bh_result->b_state = 0;
}

dwc = ocfs2_dio_alloc_write_ctx(bh_result, &first_get_block);
if (unlikely(dwc == NULL)) {
ret = -ENOMEM;
mlog_errno(ret);
goto out;
}

if (ocfs2_clusters_for_bytes(inode->i_sb, pos + total_len) >
ocfs2_clusters_for_bytes(inode->i_sb, i_size_read(inode)) &&
!dwc->dw_orphaned) {
/*
* when we are going to alloc extents beyond file size, add the
* inode to orphan dir, so we can recall those spaces when
* system crashed during write.
*/
ret = ocfs2_add_inode_to_orphan(osb, inode);
if (ret < 0) {
mlog_errno(ret);
goto out;
}
dwc->dw_orphaned = 1;
}

ret = ocfs2_inode_lock(inode, &di_bh, 1);
if (ret) {
mlog_errno(ret);
goto out;
}

down_write(&oi->ip_alloc_sem);

if (first_get_block) {
if (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))
ret = ocfs2_zero_tail(inode, di_bh, pos);
else
ret = ocfs2_expand_nonsparse_inode(inode, di_bh, pos,
total_len, NULL);
if (ret < 0) {
mlog_errno(ret);
goto unlock;
}
}

ret = ocfs2_write_begin_nolock(inode->i_mapping, pos, len,
OCFS2_WRITE_DIRECT, NULL,
(void **)&wc, di_bh, NULL);
if (ret) {
mlog_errno(ret);
goto unlock;
}

desc = &wc->w_desc[0];

p_blkno = ocfs2_clusters_to_blocks(inode->i_sb, desc->c_phys);
BUG_ON(p_blkno == 0);
p_blkno += iblock & (u64)(ocfs2_clusters_to_blocks(inode->i_sb, 1) - 1);

map_bh(bh_result, inode->i_sb, p_blkno);
bh_result->b_size = len;
if (desc->c_needs_zero)
set_buffer_new(bh_result);

/* May sleep in end_io. It should not happen in a irq context. So defer
* it to dio work queue. */
set_buffer_defer_completion(bh_result);

if (!list_empty(&wc->w_unwritten_list)) {
struct ocfs2_unwritten_extent *ue = NULL;

ue = list_first_entry(&wc->w_unwritten_list,
struct ocfs2_unwritten_extent,
ue_node);
BUG_ON(ue->ue_cpos != desc->c_cpos);
/* The physical address may be 0, fill it. */
ue->ue_phys = desc->c_phys;

list_splice_tail_init(&wc->w_unwritten_list, &dwc->dw_zero_list);
dwc->dw_zero_count++;
}

ret = ocfs2_write_end_nolock(inode->i_mapping, pos, len, len, wc);
BUG_ON(ret != len);
ret = 0;
unlock:
up_write(&oi->ip_alloc_sem);
ocfs2_inode_unlock(inode, 1);
brelse(di_bh);
out:
if (ret < 0)
ret = -EIO;
return ret;
}
","[23, 24, 25, 26]","		down_read(&oi->ip_alloc_sem);/~/		/* This is the fast path for re-write. */~/		ret = ocfs2_get_block(inode, iblock, bh_result, create);/~/		up_read(&oi->ip_alloc_sem);"
567,"int ff_mms_asf_header_parser(MMSContext *mms)
{
uint8_t *p = mms->asf_header;
uint8_t *end;
int flags, stream_id;
mms->stream_num = 0;

if (mms->asf_header_size < sizeof(ff_asf_guid) * 2 + 22 ||
memcmp(p, ff_asf_header, sizeof(ff_asf_guid))) {
av_log(NULL, AV_LOG_ERROR,
""Corrupt stream (invalid ASF header, size=%d)\n"",
mms->asf_header_size);
return AVERROR_INVALIDDATA;
}

end = mms->asf_header + mms->asf_header_size;

p += sizeof(ff_asf_guid) + 14;
while(end - p >= sizeof(ff_asf_guid) + 8) {
uint64_t chunksize;
if (!memcmp(p, ff_asf_data_header, sizeof(ff_asf_guid))) {
chunksize = 50; // see Reference [2] section 5.1
} else {
chunksize = AV_RL64(p + sizeof(ff_asf_guid));
}
if (!chunksize || chunksize > end - p) {
av_log(NULL, AV_LOG_ERROR,
""Corrupt stream (header chunksize %""PRId64"" is invalid)\n"",
chunksize);
return AVERROR_INVALIDDATA;
}
if (!memcmp(p, ff_asf_file_header, sizeof(ff_asf_guid))) {
/* read packet size */
if (end - p > sizeof(ff_asf_guid) * 2 + 68) {
mms->asf_packet_len = AV_RL32(p + sizeof(ff_asf_guid) * 2 + 64);
if (mms->asf_packet_len <= 0 || mms->asf_packet_len > sizeof(mms->in_buffer)) {
av_log(NULL, AV_LOG_ERROR,
""Corrupt stream (too large pkt_len %d)\n"",
mms->asf_packet_len);
return AVERROR_INVALIDDATA;
}
}
} else if (!memcmp(p, ff_asf_stream_header, sizeof(ff_asf_guid))) {
            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);
            stream_id = flags & 0x7F;
            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,
            //we can calculate the packet size by stream_num.
            //Please see function send_stream_selection_request().
            if (mms->stream_num < MMS_MAX_STREAMS &&
                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {
                mms->streams = av_fast_realloc(mms->streams,
                                   &mms->nb_streams_allocated,
                                   (mms->stream_num + 1) * sizeof(MMSStream));
                if (!mms->streams)
                    return AVERROR(ENOMEM);
                mms->streams[mms->stream_num].id = stream_id;
                mms->stream_num++;
            } else {
                av_log(NULL, AV_LOG_ERROR,
                       ""Corrupt stream (too many A/V streams)\n"");
                return AVERROR_INVALIDDATA;
}
} else if (!memcmp(p, ff_asf_ext_stream_header, sizeof(ff_asf_guid))) {
if (end - p >= 88) {
int stream_count = AV_RL16(p + 84), ext_len_count = AV_RL16(p + 86);
uint64_t skip_bytes = 88;
while (stream_count--) {
if (end - p < skip_bytes + 4) {
av_log(NULL, AV_LOG_ERROR,
""Corrupt stream (next stream name length is not in the buffer)\n"");
return AVERROR_INVALIDDATA;
}
skip_bytes += 4 + AV_RL16(p + skip_bytes + 2);
}
while (ext_len_count--) {
if (end - p < skip_bytes + 22) {
av_log(NULL, AV_LOG_ERROR,
""Corrupt stream (next extension system info length is not in the buffer)\n"");
return AVERROR_INVALIDDATA;
}
skip_bytes += 22 + AV_RL32(p + skip_bytes + 18);
}
if (end - p < skip_bytes) {
av_log(NULL, AV_LOG_ERROR,
""Corrupt stream (the last extension system info length is invalid)\n"");
return AVERROR_INVALIDDATA;
}
if (chunksize - skip_bytes > 24)
chunksize = skip_bytes;
}
} else if (!memcmp(p, ff_asf_head1_guid, sizeof(ff_asf_guid))) {
chunksize = 46; // see references [2] section 3.4. This should be set 46.
}
p += chunksize;
}

return 0;
}
","[8, 11, 19, 23, 26]","            flags     = AV_RL16(p + sizeof(ff_asf_guid)*3 + 24);/~/            stream_id = flags & 0x7F;/~/            //The second condition is for checking CS_PKT_STREAM_ID_REQUEST packet size,/~/            //we can calculate the packet size by stream_num./~/            //Please see function send_stream_selection_request()./~/            if (mms->stream_num < MMS_MAX_STREAMS &&/~/                    46 + mms->stream_num * 6 < sizeof(mms->out_buffer)) {/~/                mms->streams = av_fast_realloc(mms->streams,/~/                                   &mms->nb_streams_allocated,/~/                                   (mms->stream_num + 1) * sizeof(MMSStream));/~/                if (!mms->streams)/~/                    return AVERROR(ENOMEM);/~/                mms->streams[mms->stream_num].id = stream_id;/~/                mms->stream_num++;/~/            } else {/~/                av_log(NULL, AV_LOG_ERROR,/~/                       ""Corrupt stream (too many A/V streams)\n"");/~/                return AVERROR_INVALIDDATA;"
568,"static bool cgroupfs_mount_cgroup(void *hdata, const char *root, int type)
{
size_t bufsz = strlen(root) + sizeof(""/sys/fs/cgroup"");
char *path = NULL;
char **parts = NULL;
char *dirname = NULL;
char *abs_path = NULL;
char *abs_path2 = NULL;
struct cgfs_data *cgfs_d;
struct cgroup_process_info *info, *base_info;
int r, saved_errno = 0;

cgfs_d = hdata;
if (!cgfs_d)
return false;
base_info = cgfs_d->info;

/* If we get passed the _NOSPEC types, we default to _MIXED, since we don't
* have access to the lxc_conf object at this point. It really should be up
* to the caller to fix this, but this doesn't really hurt.
*/
if (type == LXC_AUTO_CGROUP_FULL_NOSPEC)
type = LXC_AUTO_CGROUP_FULL_MIXED;
else if (type == LXC_AUTO_CGROUP_NOSPEC)
type = LXC_AUTO_CGROUP_MIXED;

if (type < LXC_AUTO_CGROUP_RO || type > LXC_AUTO_CGROUP_FULL_MIXED) {
ERROR(""could not mount cgroups into container: invalid type specified internally"");
errno = EINVAL;
return false;
}

path = calloc(1, bufsz);
if (!path)
return false;
snprintf(path, bufsz, ""%s/sys/fs/cgroup"", root);
	r = mount(""cgroup_root"", path, ""tmpfs"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, ""size=10240k,mode=755"");
if (r < 0) {
SYSERROR(""could not mount tmpfs to /sys/fs/cgroup in the container"");
return false;
}

/* now mount all the hierarchies we care about */
for (info = base_info; info; info = info->next) {
size_t subsystem_count, i;
struct cgroup_mount_point *mp = info->designated_mount_point;
if (!mp)
mp = lxc_cgroup_find_mount_point(info->hierarchy, info->cgroup_path, true);
if (!mp) {
SYSERROR(""could not find original mount point for cgroup hierarchy while trying to mount cgroup filesystem"");
goto out_error;
}

subsystem_count = lxc_array_len((void **)info->hierarchy->subsystems);
parts = calloc(subsystem_count + 1, sizeof(char *));
if (!parts)
goto out_error;

for (i = 0; i < subsystem_count; i++) {
if (!strncmp(info->hierarchy->subsystems[i], ""name="", 5))
parts[i] = info->hierarchy->subsystems[i] + 5;
else
parts[i] = info->hierarchy->subsystems[i];
}
dirname = lxc_string_join("","", (const char **)parts, false);
if (!dirname)
goto out_error;

/* create subsystem directory */
abs_path = lxc_append_paths(path, dirname);
if (!abs_path)
goto out_error;
r = mkdir_p(abs_path, 0755);
if (r < 0 && errno != EEXIST) {
SYSERROR(""could not create cgroup subsystem directory /sys/fs/cgroup/%s"", dirname);
goto out_error;
}

abs_path2 = lxc_append_paths(abs_path, info->cgroup_path);
if (!abs_path2)
goto out_error;

if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_RW || type == LXC_AUTO_CGROUP_FULL_MIXED) {
/* bind-mount the cgroup entire filesystem there */
if (strcmp(mp->mount_prefix, ""/"") != 0) {
/* FIXME: maybe we should just try to remount the entire hierarchy
*        with a regular mount command? may that works? */
ERROR(""could not automatically mount cgroup-full to /sys/fs/cgroup/%s: host has no mount point for this cgroup filesystem that has access to the root cgroup"", dirname);
goto out_error;
}
r = mount(mp->mount_point, abs_path, ""none"", MS_BIND, 0);
if (r < 0) {
SYSERROR(""error bind-mounting %s to %s"", mp->mount_point, abs_path);
goto out_error;
}
/* main cgroup path should be read-only */
if (type == LXC_AUTO_CGROUP_FULL_RO || type == LXC_AUTO_CGROUP_FULL_MIXED) {
r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
if (r < 0) {
SYSERROR(""error re-mounting %s readonly"", abs_path);
goto out_error;
}
}
/* own cgroup should be read-write */
if (type == LXC_AUTO_CGROUP_FULL_MIXED) {
r = mount(abs_path2, abs_path2, NULL, MS_BIND, NULL);
if (r < 0) {
SYSERROR(""error bind-mounting %s onto itself"", abs_path2);
goto out_error;
}
r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND, NULL);
if (r < 0) {
SYSERROR(""error re-mounting %s readwrite"", abs_path2);
goto out_error;
}
}
} else {
/* create path for container's cgroup */
r = mkdir_p(abs_path2, 0755);
if (r < 0 && errno != EEXIST) {
SYSERROR(""could not create cgroup directory /sys/fs/cgroup/%s%s"", dirname, info->cgroup_path);
goto out_error;
}

/* for read-only and mixed cases, we have to bind-mount the tmpfs directory
* that points to the hierarchy itself (i.e. /sys/fs/cgroup/cpu etc.) onto
* itself and then bind-mount it read-only, since we keep the tmpfs itself
* read-write (see comment below)
*/
if (type == LXC_AUTO_CGROUP_MIXED || type == LXC_AUTO_CGROUP_RO) {
r = mount(abs_path, abs_path, NULL, MS_BIND, NULL);
if (r < 0) {
SYSERROR(""error bind-mounting %s onto itself"", abs_path);
goto out_error;
}
r = mount(NULL, abs_path, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
if (r < 0) {
SYSERROR(""error re-mounting %s readonly"", abs_path);
goto out_error;
}
}

free(abs_path);
abs_path = NULL;

/* bind-mount container's cgroup to that directory */
abs_path = cgroup_to_absolute_path(mp, info->cgroup_path, NULL);
if (!abs_path)
goto out_error;
r = mount(abs_path, abs_path2, ""none"", MS_BIND, 0);
if (r < 0) {
SYSERROR(""error bind-mounting %s to %s"", abs_path, abs_path2);
goto out_error;
}
if (type == LXC_AUTO_CGROUP_RO) {
r = mount(NULL, abs_path2, NULL, MS_REMOUNT|MS_BIND|MS_RDONLY, NULL);
if (r < 0) {
SYSERROR(""error re-mounting %s readonly"", abs_path2);
goto out_error;
}
}
}

free(abs_path);
free(abs_path2);
abs_path = NULL;
abs_path2 = NULL;

/* add symlinks for every single subsystem */
if (subsystem_count > 1) {
for (i = 0; i < subsystem_count; i++) {
abs_path = lxc_append_paths(path, parts[i]);
if (!abs_path)
goto out_error;
r = symlink(dirname, abs_path);
if (r < 0)
WARN(""could not create symlink %s -> %s in /sys/fs/cgroup of container"", parts[i], dirname);
free(abs_path);
abs_path = NULL;
}
}
free(dirname);
free(parts);
dirname = NULL;
parts = NULL;
}

/* We used to remount the entire tmpfs readonly if any :ro or
* :mixed mode was specified. However, Ubuntu's mountall has the
* unfortunate behavior to block bootup if /sys/fs/cgroup is
* mounted read-only and cannot be remounted read-write.
* (mountall reads /lib/init/fstab and tries to (re-)mount all of
* these if they are not already mounted with the right options;
* it contains an entry for /sys/fs/cgroup. In case it can't do
* that, it prompts for the user to either manually fix it or
* boot anyway. But without user input, booting of the container
* hangs.)
*
* Instead of remounting the entire tmpfs readonly, we only
* remount the paths readonly that are part of the cgroup
* hierarchy.
*/

free(path);

return true;

out_error:
saved_errno = errno;
free(path);
free(dirname);
free(parts);
free(abs_path);
free(abs_path2);
errno = saved_errno;
return false;
}
",[32],"	r = mount(""cgroup_root"", path, ""tmpfs"", MS_NOSUID|MS_NODEV|MS_NOEXEC|MS_RELATIME, ""size=10240k,mode=755"");"
569,"~OffScreenRootWindow()
{
if (!--refCount) {
#if PLATFORM(QT)
            delete window;
            window = 0;
#elif PLATFORM(EFL)
XUnmapWindow(display, window);
XDestroyWindow(display, window);
#endif
}
}
","[3, 4, 5, 6, 9]",#if PLATFORM(QT)/~/            delete window;/~/            window = 0;/~/#elif PLATFORM(EFL)/~/#endif
570,"int hugetlb_reserve_pages(struct inode *inode,
long from, long to,
struct vm_area_struct *vma,
vm_flags_t vm_flags)
{
long ret, chg;
struct hstate *h = hstate_inode(inode);
struct hugepage_subpool *spool = subpool_inode(inode);

/*
* Only apply hugepage reservation if asked. At fault time, an
* attempt will be made for VM_NORESERVE to allocate a page
* without using reserves
*/
if (vm_flags & VM_NORESERVE)
return 0;

/*
* Shared mappings base their reservation on the number of pages that
* are already allocated on behalf of the file. Private mappings need
* to reserve the full area even if read-only as mprotect() may be
* called to make the mapping read-write. Assume !vma is a shm mapping
*/
if (!vma || vma->vm_flags & VM_MAYSHARE)
chg = region_chg(&inode->i_mapping->private_list, from, to);
else {
struct resv_map *resv_map = resv_map_alloc();
if (!resv_map)
return -ENOMEM;

chg = to - from;

set_vma_resv_map(vma, resv_map);
set_vma_resv_flags(vma, HPAGE_RESV_OWNER);
}

	if (chg < 0)
		return chg;

/* There must be enough pages in the subpool for the mapping */
	if (hugepage_subpool_get_pages(spool, chg))
		return -ENOSPC;

/*
* Check enough hugepages are available for the reservation.
* Hand the pages back to the subpool if there are not
*/
ret = hugetlb_acct_memory(h, chg);
if (ret < 0) {
hugepage_subpool_put_pages(spool, chg);
		return ret;
}

/*
* Account for the reservations made. Shared mappings record regions
* that have reservations as they are shared by multiple VMAs.
* When the last VMA disappears, the region map says how much
* the reservation was and the page cache tells how much of
* the reservation was consumed. Private mappings are per-VMA and
* only the consumed reservations are tracked. When the VMA
* disappears, the original reservation is the VMA size and the
* consumed reservations are stored in the map. Hence, nothing
* else has to be done for private mappings here
*/
if (!vma || vma->vm_flags & VM_MAYSHARE)
region_add(&inode->i_mapping->private_list, from, to);
return 0;
}
","[31, 32, 34, 35, 43]","	if (chg < 0)/~/		return chg;/~/	if (hugepage_subpool_get_pages(spool, chg))/~/		return -ENOSPC;/~/		return ret;"
571,"void ExtensionOptionsGuest::DidNavigateMainFrame(
const content::LoadCommittedDetails& details,
const content::FrameNavigateParams& params) {
if (attached()) {
auto guest_zoom_controller =
ui_zoom::ZoomController::FromWebContents(web_contents());
guest_zoom_controller->SetZoomMode(
ui_zoom::ZoomController::ZOOM_MODE_ISOLATED);
SetGuestZoomLevelToMatchEmbedder();

    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
bad_message::ReceivedBadMessage(web_contents()->GetRenderProcessHost(),
bad_message::EOG_BAD_ORIGIN);
}
}
}
",[9],    if (params.url.GetOrigin() != options_page_.GetOrigin()) {
572,"static EncodedJSValue JSC_HOST_CALL jsTestObjPrototypeFunctionOverloadedMethod6(ExecState* exec)
{
JSValue thisValue = exec->hostThisValue();
if (!thisValue.inherits(&JSTestObj::s_info))
return throwVMTypeError(exec);
JSTestObj* castedThis = jsCast<JSTestObj*>(asObject(thisValue));
ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestObj::s_info);
TestObj* impl = static_cast<TestObj*>(castedThis->impl());
if (exec->argumentCount() < 1)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
DOMStringList* listArg(toDOMStringList(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined)));
if (exec->hadException())
return JSValue::encode(jsUndefined());
impl->overloadedMethod(listArg);
return JSValue::encode(jsUndefined());
}
",[9],"        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));"
573,"XineramaXvShmPutImage(ClientPtr client)
{
REQUEST(xvShmPutImageReq);
PanoramiXRes *draw, *gc, *port;
    Bool send_event = stuff->send_event;
Bool isRoot;
int result, i, x, y;

REQUEST_SIZE_MATCH(xvShmPutImageReq);

result = dixLookupResourceByClass((void **) &draw, stuff->drawable,
XRC_DRAWABLE, client, DixWriteAccess);
if (result != Success)
result = dixLookupResourceByType((void **) &gc, stuff->gc,
XRT_GC, client, DixReadAccess);
if (result != Success)
return result;

result = dixLookupResourceByType((void **) &port, stuff->port,
XvXRTPort, client, DixReadAccess);
if (result != Success)
return result;

isRoot = (draw->type == XRT_WINDOW) && draw->u.win.root;

x = stuff->drw_x;
y = stuff->drw_y;

FOR_NSCREENS_BACKWARD(i) {
if (port->info[i].id) {
stuff->drawable = draw->info[i].id;
stuff->port = port->info[i].id;
stuff->gc = gc->info[i].id;
stuff->drw_x = x;
stuff->drw_y = y;
if (isRoot) {
stuff->drw_x -= screenInfo.screens[i]->x;
stuff->drw_y -= screenInfo.screens[i]->y;
}
stuff->send_event = (send_event && !i) ? 1 : 0;

result = ProcXvShmPutImage(client);
}
}
return result;
}
",[4],    Bool send_event = stuff->send_event;
574,"build_config(char *prefix, struct server *server)
{
char *path    = NULL;
int path_size = strlen(prefix) + strlen(server->port) + 20;

path = ss_malloc(path_size);
snprintf(path, path_size, ""%s/.shadowsocks_%s.conf"", prefix, server->port);
FILE *f = fopen(path, ""w+"");
if (f == NULL) {
if (verbose) {
LOGE(""unable to open config file"");
}
ss_free(path);
return;
}
fprintf(f, ""{\n"");
fprintf(f, ""\""server_port\"":%d,\n"", atoi(server->port));
fprintf(f, ""\""password\"":\""%s\"""", server->password);
    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);
    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);
    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);
    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);
    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);
fprintf(f, ""\n}\n"");
fclose(f);
ss_free(path);
}
","[17, 18, 19, 20, 21]","    if (server->fast_open[0]) fprintf(f, "",\n\""fast_open\"": %s"", server->fast_open);/~/    if (server->mode)   fprintf(f, "",\n\""mode\"":\""%s\"""", server->mode);/~/    if (server->method) fprintf(f, "",\n\""method\"":\""%s\"""", server->method);/~/    if (server->plugin) fprintf(f, "",\n\""plugin\"":\""%s\"""", server->plugin);/~/    if (server->plugin_opts) fprintf(f, "",\n\""plugin_opts\"":\""%s\"""", server->plugin_opts);"
575,"cJSON *cJSON_CreateString( const char *string )
{
	cJSON *item = cJSON_New_Item();
	if ( item ) {
		item->type = cJSON_String;
		item->valuestring = cJSON_strdup( string );
	}
	return item;
}
","[1, 2, 3, 4, 5, 6, 7, 8]",{/~/	cJSON *item = cJSON_New_Item();/~/	if ( item ) {/~/		item->type = cJSON_String;/~/		item->valuestring = cJSON_strdup( string );/~/	}/~/	return item;/~/}
576,"void EventBindings::AttachFilteredEvent(
const v8::FunctionCallbackInfo<v8::Value>& args) {
CHECK_EQ(2, args.Length());
CHECK(args[0]->IsString());
CHECK(args[1]->IsObject());

std::string event_name = *v8::String::Utf8Value(args[0]);
if (!context()->HasAccessOrThrowError(event_name))
return;

std::unique_ptr<base::DictionaryValue> filter;
{
std::unique_ptr<content::V8ValueConverter> converter(
content::V8ValueConverter::create());
std::unique_ptr<base::Value> filter_value(converter->FromV8Value(
v8::Local<v8::Object>::Cast(args[1]), context()->v8_context()));
if (!filter_value || !filter_value->IsType(base::Value::TYPE_DICTIONARY)) {
args.GetReturnValue().Set(static_cast<int32_t>(-1));
return;
}
filter = base::DictionaryValue::From(std::move(filter_value));
}

  // Hold onto a weak reference to |filter| so that it can be used after passing
  // ownership to |event_filter|.
  base::DictionaryValue* filter_weak = filter.get();
int id = g_event_filter.Get().AddEventMatcher(
event_name, ParseEventMatcher(std::move(filter)));
attached_matcher_ids_.insert(id);

// Only send IPCs the first time a filter gets added.
std::string extension_id = context()->GetExtensionID();
if (AddFilter(event_name, extension_id, *filter_weak)) {
bool lazy = ExtensionFrameHelper::IsContextForEventPage(context());
content::RenderThread::Get()->Send(new ExtensionHostMsg_AddFilteredListener(
extension_id, event_name, *filter_weak, lazy));
}

args.GetReturnValue().Set(static_cast<int32_t>(id));
}
","[20, 21, 22]",  // Hold onto a weak reference to |filter| so that it can be used after passing/~/  // ownership to |event_filter|./~/  base::DictionaryValue* filter_weak = filter.get();
577,"static inline bool shouldSetStrutOnBlock(const LayoutBlockFlow& block, const RootInlineBox& lineBox, LayoutUnit lineLogicalOffset, int lineIndex, LayoutUnit remainingLogicalHeight)
{
bool wantsStrutOnBlock = false;
if (!block.style()->hasAutoOrphans() && block.style()->orphans() >= lineIndex) {
// Not enough orphans here. Push the entire block to the next column / page as an
// attempt to better satisfy the orphans requirement.
wantsStrutOnBlock = true;
} else if (lineBox == block.firstRootBox() && lineLogicalOffset == block.borderAndPaddingBefore()) {
// This is the first line in the block. We can take the whole block with us to the next page
// or column, rather than keeping a content-less portion of it in the previous one. Only do
// this if the line is flush with the content edge of the block, though. If it isn't, it
// means that the line was pushed downwards by preceding floats that didn't fit beside the
// line, and we don't want to move all that, since it has already been established that it
// fits nicely where it is.
LayoutUnit lineHeight = lineBox.lineBottomWithLeading() - lineBox.lineTopWithLeading();
LayoutUnit totalLogicalHeight = lineHeight + std::max<LayoutUnit>(0, lineLogicalOffset);
LayoutUnit pageLogicalHeightAtNewOffset = block.pageLogicalHeightForOffset(lineLogicalOffset + remainingLogicalHeight);
// It's rather pointless to break before the block if the current line isn't going to
// fit in the same column or page, so check that as well.
if (totalLogicalHeight < pageLogicalHeightAtNewOffset)
wantsStrutOnBlock = true;
}
    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table
    // (which would be the case for table cell or table caption)). The reason for this limitation is
    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts
    // and handle them. We handle floats and regular in-flow children, and that's all. We could
    // handle this in other layout modes as well (and even for out-of-flow children), but currently
    // we don't.
    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())
        return false;
    LayoutBlock* containingBlock = block.containingBlock();
    return containingBlock && containingBlock->isLayoutBlockFlow();
}
","[22, 23, 24]","    // The block needs to be contained by a LayoutBlockFlow (and not by e.g. a flexbox or a table/~/    // (which would be the case for table cell or table caption)). The reason for this limitation is/~/    // simply that LayoutBlockFlow child layout code is the only place where we pick up the struts/~/    // and handle them. We handle floats and regular in-flow children, and that's all. We could/~/    // handle this in other layout modes as well (and even for out-of-flow children), but currently/~/    // we don't./~/    if (!wantsStrutOnBlock || block.isOutOfFlowPositioned())/~/        return false;/~/    LayoutBlock* containingBlock = block.containingBlock();/~/    return containingBlock && containingBlock->isLayoutBlockFlow();"
578,"virtual bool InputMethodIsActivated(const std::string& input_method_id) {
    scoped_ptr<InputMethodDescriptors> active_input_method_descriptors(
        GetActiveInputMethods());
for (size_t i = 0; i < active_input_method_descriptors->size(); ++i) {
if (active_input_method_descriptors->at(i).id == input_method_id) {
return true;
}
}
return false;
}
","[1, 2]",    scoped_ptr<InputMethodDescriptors> active_input_method_descriptors(/~/        GetActiveInputMethods());
579,"image_transform_png_set_strip_16_add(image_transform *this,
    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)
{
UNUSED(colour_type)

this->next = *that;
*that = this;

return bit_depth > 8;
}
",[1],"    PNG_CONST image_transform **that, png_byte colour_type, png_byte bit_depth)"
580,"PHP_METHOD(Phar, extractTo)
{
char *error = NULL;
php_stream *fp;
php_stream_statbuf ssb;
phar_entry_info *entry;
char *pathto, *filename;
size_t pathto_len, filename_len;
int ret, i;
int nelems;
zval *zval_files = NULL;
zend_bool overwrite = 0;

PHAR_ARCHIVE_OBJECT();

       if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|z!b"", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {
return;
}

fp = php_stream_open_wrapper(phar_obj->archive->fname, ""rb"", IGNORE_URL|STREAM_MUST_SEEK, NULL);

if (!fp) {
zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,
""Invalid argument, %s cannot be found"", phar_obj->archive->fname);
return;
}

php_stream_close(fp);

if (pathto_len < 1) {
zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,
""Invalid argument, extraction path must be non-zero length"");
return;
}

if (pathto_len >= MAXPATHLEN) {
char *tmp = estrndup(pathto, 50);
/* truncate for error message */
zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0, ""Cannot extract to \""%s...\"", destination directory is too long for filesystem"", tmp);
efree(tmp);
return;
}

if (php_stream_stat_path(pathto, &ssb) < 0) {
ret = php_stream_mkdir(pathto, 0777,  PHP_STREAM_MKDIR_RECURSIVE, NULL);
if (!ret) {
zend_throw_exception_ex(spl_ce_RuntimeException, 0,
""Unable to create path \""%s\"" for extraction"", pathto);
return;
}
} else if (!(ssb.sb.st_mode & S_IFDIR)) {
zend_throw_exception_ex(spl_ce_RuntimeException, 0,
""Unable to use path \""%s\"" for extraction, it is a file, must be a directory"", pathto);
return;
}

if (zval_files) {
switch (Z_TYPE_P(zval_files)) {
case IS_NULL:
goto all_files;
case IS_STRING:
filename = Z_STRVAL_P(zval_files);
filename_len = Z_STRLEN_P(zval_files);
break;
case IS_ARRAY:
nelems = zend_hash_num_elements(Z_ARRVAL_P(zval_files));
if (nelems == 0 ) {
RETURN_FALSE;
}
for (i = 0; i < nelems; i++) {
zval *zval_file;
if ((zval_file = zend_hash_index_find(Z_ARRVAL_P(zval_files), i)) != NULL) {
switch (Z_TYPE_P(zval_file)) {
case IS_STRING:
break;
default:
zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,
""Invalid argument, array of filenames to extract contains non-string value"");
return;
}
if (NULL == (entry = zend_hash_find_ptr(&phar_obj->archive->manifest, Z_STR_P(zval_file)))) {
zend_throw_exception_ex(phar_ce_PharException, 0,
""Phar Error: attempted to extract non-existent file \""%s\"" from phar \""%s\"""", Z_STRVAL_P(zval_file), phar_obj->archive->fname);
}
if (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {
zend_throw_exception_ex(phar_ce_PharException, 0,
""Extraction from phar \""%s\"" failed: %s"", phar_obj->archive->fname, error);
efree(error);
return;
}
}
}
RETURN_TRUE;
default:
zend_throw_exception_ex(spl_ce_InvalidArgumentException, 0,
""Invalid argument, expected a filename (string) or array of filenames"");
return;
}

if (NULL == (entry = zend_hash_str_find_ptr(&phar_obj->archive->manifest, filename, filename_len))) {
zend_throw_exception_ex(phar_ce_PharException, 0,
""Phar Error: attempted to extract non-existent file \""%s\"" from phar \""%s\"""", filename, phar_obj->archive->fname);
return;
}

if (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {
zend_throw_exception_ex(phar_ce_PharException, 0,
""Extraction from phar \""%s\"" failed: %s"", phar_obj->archive->fname, error);
efree(error);
return;
}
} else {
phar_archive_data *phar;
all_files:
phar = phar_obj->archive;
/* Extract all files */
if (!zend_hash_num_elements(&(phar->manifest))) {
RETURN_TRUE;
}

ZEND_HASH_FOREACH_PTR(&phar->manifest, entry) {
if (FAILURE == phar_extract_file(overwrite, entry, pathto, pathto_len, &error)) {
zend_throw_exception_ex(phar_ce_PharException, 0,
""Extraction from phar \""%s\"" failed: %s"", phar->fname, error);
efree(error);
return;
}
} ZEND_HASH_FOREACH_END();
}
RETURN_TRUE;
}
",[13],"       if (zend_parse_parameters(ZEND_NUM_ARGS(), ""s|z!b"", &pathto, &pathto_len, &zval_files, &overwrite) == FAILURE) {"
581,"uint32 PluginInstance::ScheduleTimer(uint32 interval,
NPBool repeat,
void (*func)(NPP id, uint32 timer_id)) {
// Use next timer id.
uint32 timer_id;
timer_id = next_timer_id_;
++next_timer_id_;
DCHECK(next_timer_id_ != 0);

// Record timer interval and repeat.
TimerInfo info;
info.interval = interval;
info.repeat = repeat;
timers_[timer_id] = info;

// Schedule the callback.
  message_loop_->PostDelayedTask(FROM_HERE,
                                 NewRunnableMethod(this,
                                                   &PluginInstance::OnTimerCall,
                                                   func,
                                                   npp_,
                                                   timer_id),
                                 interval);
return timer_id;
}
","[14, 15, 16, 17, 18, 19, 20]","  message_loop_->PostDelayedTask(FROM_HERE,/~/                                 NewRunnableMethod(this,/~/                                                   &PluginInstance::OnTimerCall,/~/                                                   func,/~/                                                   npp_,/~/                                                   timer_id),/~/                                 interval);"
582,"void VarianceTest<VarianceFunctionType>::ZeroTest() {
for (int i = 0; i <= 255; ++i) {
    memset(src_, i, block_size_);
for (int j = 0; j <= 255; ++j) {
      memset(ref_, j, block_size_);
unsigned int sse;
unsigned int var;
      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));
      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;
}
}
}
","[2, 4, 7, 8]","    memset(src_, i, block_size_);/~/      memset(ref_, j, block_size_);/~/      REGISTER_STATE_CHECK(var = variance_(src_, width_, ref_, width_, &sse));/~/      EXPECT_EQ(0u, var) << ""src values: "" << i << ""ref values: "" << j;"
583,"static NOINLINE char *xmalloc_optname_optval(uint8_t *option, const struct dhcp_optflag *optflag, const char *opt_name)
{
unsigned upper_length;
int len, type, optlen;
char *dest, *ret;

/* option points to OPT_DATA, need to go back to get OPT_LEN */
len = option[-OPT_DATA + OPT_LEN];

type = optflag->flags & OPTION_TYPE_MASK;
optlen = dhcp_option_lengths[type];
upper_length = len_of_option_as_string[type]
		* ((unsigned)(len + optlen - 1) / (unsigned)optlen);

dest = ret = xmalloc(upper_length + strlen(opt_name) + 2);
dest += sprintf(ret, ""%s="", opt_name);

while (len >= optlen) {
switch (type) {
case OPTION_IP:
case OPTION_IP_PAIR:
dest += sprint_nip(dest, """", option);
if (type == OPTION_IP)
break;
dest += sprint_nip(dest, ""/"", option + 4);
break;
//		case OPTION_BOOLEAN:
//			dest += sprintf(dest, *option ? ""yes"" : ""no"");
//			break;
case OPTION_U8:
dest += sprintf(dest, ""%u"", *option);
break;
//		case OPTION_S16:
case OPTION_U16: {
uint16_t val_u16;
move_from_unaligned16(val_u16, option);
dest += sprintf(dest, ""%u"", ntohs(val_u16));
break;
}
case OPTION_S32:
case OPTION_U32: {
uint32_t val_u32;
move_from_unaligned32(val_u32, option);
dest += sprintf(dest, type == OPTION_U32 ? ""%lu"" : ""%ld"", (unsigned long) ntohl(val_u32));
break;
}
/* Note: options which use 'return' instead of 'break'
* (for example, OPTION_STRING) skip the code which handles
* the case of list of options.
*/
case OPTION_STRING:
case OPTION_STRING_HOST:
memcpy(dest, option, len);
dest[len] = '\0';
if (type == OPTION_STRING_HOST && !good_hostname(dest))
safe_strncpy(dest, ""bad"", len);
return ret;
case OPTION_STATIC_ROUTES: {
/* Option binary format:
* mask [one byte, 0..32]
* ip [big endian, 0..4 bytes depending on mask]
* router [big endian, 4 bytes]
* may be repeated
*
* We convert it to a string ""IP/MASK ROUTER IP2/MASK2 ROUTER2""
*/
const char *pfx = """";

while (len >= 1 + 4) { /* mask + 0-byte ip + router */
uint32_t nip;
uint8_t *p;
unsigned mask;
int bytes;

mask = *option++;
if (mask > 32)
break;
len--;

nip = 0;
p = (void*) &nip;
bytes = (mask + 7) / 8; /* 0 -> 0, 1..8 -> 1, 9..16 -> 2 etc */
while (--bytes >= 0) {
*p++ = *option++;
len--;
}
if (len < 4)
break;

/* print ip/mask */
dest += sprint_nip(dest, pfx, (void*) &nip);
pfx = "" "";
dest += sprintf(dest, ""/%u "", mask);
/* print router */
dest += sprint_nip(dest, """", option);
option += 4;
len -= 4;
}

return ret;
}
case OPTION_6RD:
/* Option binary format (see RFC 5969):
*  0                   1                   2                   3
*  0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
* |  OPTION_6RD   | option-length |  IPv4MaskLen  |  6rdPrefixLen |
* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
* |                           6rdPrefix                           |
* ...                        (16 octets)                        ...
* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
* ...                   6rdBRIPv4Address(es)                    ...
* +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
* We convert it to a string
* ""IPv4MaskLen 6rdPrefixLen 6rdPrefix 6rdBRIPv4Address...""
*
* Sanity check: ensure that our length is at least 22 bytes, that
* IPv4MaskLen <= 32,
* 6rdPrefixLen <= 128,
* 6rdPrefixLen + (32 - IPv4MaskLen) <= 128
* (2nd condition need no check - it follows from 1st and 3rd).
* Else, return envvar with empty value (""optname="")
*/
if (len >= (1 + 1 + 16 + 4)
&& option[0] <= 32
&& (option[1] + 32 - option[0]) <= 128
) {
/* IPv4MaskLen */
dest += sprintf(dest, ""%u "", *option++);
/* 6rdPrefixLen */
dest += sprintf(dest, ""%u "", *option++);
/* 6rdPrefix */
dest += sprint_nip6(dest, /* """", */ option);
option += 16;
len -= 1 + 1 + 16 + 4;
/* ""+ 4"" above corresponds to the length of IPv4 addr
* we consume in the loop below */
while (1) {
/* 6rdBRIPv4Address(es) */
dest += sprint_nip(dest, "" "", option);
option += 4;
len -= 4; /* do we have yet another 4+ bytes? */
if (len < 0)
break; /* no */
}
}

return ret;
#if ENABLE_FEATURE_UDHCP_RFC3397
case OPTION_DNS_STRING:
/* unpack option into dest; use ret for prefix (i.e., ""optname="") */
dest = dname_dec(option, len, ret);
if (dest) {
free(ret);
return dest;
}
/* error. return ""optname="" string */
return ret;
case OPTION_SIP_SERVERS:
/* Option binary format:
* type: byte
* type=0: domain names, dns-compressed
* type=1: IP addrs
*/
option++;
len--;
if (option[-1] == 0) {
dest = dname_dec(option, len, ret);
if (dest) {
free(ret);
return dest;
}
} else
if (option[-1] == 1) {
const char *pfx = """";
while (1) {
len -= 4;
if (len < 0)
break;
dest += sprint_nip(dest, pfx, option);
pfx = "" "";
option += 4;
}
}
return ret;
#endif
} /* switch */

/* If we are here, try to format any remaining data
* in the option as another, similarly-formatted option
*/
option += optlen;
len -= optlen;
// TODO: it can be a list only if (optflag->flags & OPTION_LIST).
// Should we bail out/warn if we see multi-ip option which is
// not allowed to be such (for example, DHCP_BROADCAST)? -
if (len < optlen /* || !(optflag->flags & OPTION_LIST) */)
break;
*dest++ = ' ';
*dest = '\0';
} /* while */

return ret;
}
",[10],		* ((unsigned)(len + optlen - 1) / (unsigned)optlen);
584,"void xmlrpc_char_encode(char *outbuffer, const char *s1)
{
long unsigned int i;
unsigned char c;
char buf2[15];
mowgli_string_t *s = mowgli_string_create();
*buf2 = '\0';
*outbuffer = '\0';

if ((!(s1) || (*(s1) == '\0')))
{
return;
}

for (i = 0; s1[i] != '\0'; i++)
{
c = s1[i];
if (c > 127)
{
snprintf(buf2, sizeof buf2, ""&#%d;"", c);
s->append(s, buf2, strlen(buf2));
}
else if (c == '&')
{
s->append(s, ""&amp;"", 5);
}
else if (c == '<')
{
s->append(s, ""&lt;"", 4);
}
else if (c == '>')
{
s->append(s, ""&gt;"", 4);
}
else if (c == '""')
{
s->append(s, ""&quot;"", 6);
}
else
{
s->append_char(s, c);
}
}

	memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);
}
",[41],"	memcpy(outbuffer, s->str, XMLRPC_BUFSIZE);"
585,"void PrintWebViewHelper::UpdatePrintableSizeInPrintParameters(
WebFrame* frame,
WebNode* node,
ViewMsg_Print_Params* params) {
double content_width_in_points;
double content_height_in_points;
double margin_top_in_points;
double margin_right_in_points;
double margin_bottom_in_points;
double margin_left_in_points;
PrepareFrameAndViewForPrint prepare(*params, frame, node, frame->view());
PrintWebViewHelper::GetPageSizeAndMarginsInPoints(frame, 0, *params,
&content_width_in_points, &content_height_in_points,
&margin_top_in_points, &margin_right_in_points,
&margin_bottom_in_points, &margin_left_in_points);
#if defined(OS_MACOSX)
// On the Mac, the printable area is in points, don't do any scaling based
// on dpi.
int dpi = printing::kPointsPerInch;
#else
int dpi = static_cast<int>(params->dpi);
#endif  // defined(OS_MACOSX)
params->printable_size = gfx::Size(
static_cast<int>(ConvertUnitDouble(content_width_in_points,
printing::kPointsPerInch, dpi)),
static_cast<int>(ConvertUnitDouble(content_height_in_points,
printing::kPointsPerInch, dpi)));

params->page_size = gfx::Size(
      static_cast<int>(ConvertUnitDouble(content_width_in_points +
          margin_left_in_points + margin_right_in_points,
          printing::kPointsPerInch, dpi)),
      static_cast<int>(ConvertUnitDouble(content_height_in_points +
          margin_top_in_points + margin_bottom_in_points,
          printing::kPointsPerInch, dpi)));

params->margin_top = static_cast<int>(ConvertUnitDouble(
margin_top_in_points, printing::kPointsPerInch, dpi));
params->margin_left = static_cast<int>(ConvertUnitDouble(
margin_left_in_points, printing::kPointsPerInch, dpi));
}
","[24, 26, 28, 29, 30, 31, 32]","      static_cast<int>(ConvertUnitDouble(content_width_in_points +/~/          margin_left_in_points + margin_right_in_points,/~/          printing::kPointsPerInch, dpi)),/~/      static_cast<int>(ConvertUnitDouble(content_height_in_points +/~/          margin_top_in_points + margin_bottom_in_points,/~/          printing::kPointsPerInch, dpi)));"
586,"static int svc_can_register(const uint16_t *name, size_t name_len, pid_t spid, uid_t uid)

{
const char *perm = ""add"";

    if (uid >= AID_APP) {
return 0; /* Don't allow apps to register services */
}

return check_mac_perms_from_lookup(spid, uid, perm, str8(name, name_len)) ? 1 : 0;
}
",[3],    if (uid >= AID_APP) {
587,"DefragTimeoutTest(void)
{
int i;
int ret = 0;

/* Setup a small numberr of trackers. */
if (ConfSet(""defrag.trackers"", ""16"") != 1) {
printf(""ConfSet failed: "");
goto end;
}

DefragInit();

/* Load in 16 packets. */
for (i = 0; i < 16; i++) {
        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);
if (p == NULL)
goto end;

Packet *tp = Defrag(NULL, NULL, p, NULL);

SCFree(p);

if (tp != NULL) {
SCFree(tp);
goto end;
}
}

/* Build a new packet but push the timestamp out by our timeout.
* This should force our previous fragments to be timed out. */
    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);
if (p == NULL)
goto end;

p->ts.tv_sec += (defrag_context->timeout + 1);
Packet *tp = Defrag(NULL, NULL, p, NULL);

if (tp != NULL) {
SCFree(tp);
goto end;
}

DefragTracker *tracker = DefragLookupTrackerFromHash(p);
if (tracker == NULL)
goto end;

if (tracker->id != 99)
goto end;

SCFree(p);

ret = 1;
end:
DefragDestroy();
return ret;
}
","[12, 24]","        Packet *p = BuildTestPacket(i, 0, 1, 'A' + i, 16);/~/    Packet *p = BuildTestPacket(99, 0, 1, 'A' + i, 16);"
588,"int snd_timer_close(struct snd_timer_instance *timeri)
{
struct snd_timer *timer = NULL;
struct snd_timer_instance *slave, *tmp;

if (snd_BUG_ON(!timeri))
return -ENXIO;

/* force to stop the timer */
snd_timer_stop(timeri);

if (timeri->flags & SNDRV_TIMER_IFLG_SLAVE) {
/* wait, until the active callback is finished */
spin_lock_irq(&slave_active_lock);
while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
spin_unlock_irq(&slave_active_lock);
udelay(10);
spin_lock_irq(&slave_active_lock);
}
spin_unlock_irq(&slave_active_lock);
mutex_lock(&register_mutex);
list_del(&timeri->open_list);
mutex_unlock(&register_mutex);
} else {
timer = timeri->timer;
if (snd_BUG_ON(!timer))
goto out;
/* wait, until the active callback is finished */
spin_lock_irq(&timer->lock);
while (timeri->flags & SNDRV_TIMER_IFLG_CALLBACK) {
spin_unlock_irq(&timer->lock);
udelay(10);
spin_lock_irq(&timer->lock);
}
spin_unlock_irq(&timer->lock);
mutex_lock(&register_mutex);
list_del(&timeri->open_list);
if (timer && list_empty(&timer->open_list_head) &&
timer->hw.close)
timer->hw.close(timer);
/* remove slave links */
list_for_each_entry_safe(slave, tmp, &timeri->slave_list_head,
open_list) {
			spin_lock_irq(&slave_active_lock);
			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);
list_move_tail(&slave->open_list, &snd_timer_slave_list);
slave->master = NULL;
slave->timer = NULL;
			spin_unlock_irq(&slave_active_lock);
}
mutex_unlock(&register_mutex);
}
out:
if (timeri->private_free)
timeri->private_free(timeri);
kfree(timeri->owner);
kfree(timeri);
if (timer)
module_put(timer->module);
return 0;
}
","[10, 12, 14, 16, 40]","			spin_lock_irq(&slave_active_lock);/~/			_snd_timer_stop(slave, 1, SNDRV_TIMER_EVENT_RESOLUTION);/~/			spin_unlock_irq(&slave_active_lock);"
589,"static int msg_cache_check(const char *id, struct BodyCache *bcache, void *data)
{
struct Context *ctx = (struct Context *) data;
if (!ctx)
return -1;
struct PopData *pop_data = (struct PopData *) ctx->data;
if (!pop_data)
return -1;

#ifdef USE_HCACHE
/* keep hcache file if hcache == bcache */
if (strcmp(HC_FNAME ""."" HC_FEXT, id) == 0)
return 0;
#endif

for (int i = 0; i < ctx->msgcount; i++)
{
/* if the id we get is known for a header: done (i.e. keep in cache) */
if (ctx->hdrs[i]->data && (mutt_str_strcmp(ctx->hdrs[i]->data, id) == 0))
return 0;
}

/* message not found in context -> remove it from cache
* return the result of bcache, so we stop upon its first error
*/
  return mutt_bcache_del(bcache, id);
}
",[22],"  return mutt_bcache_del(bcache, id);"
590,"static void ifb_setup(struct net_device *dev)
{
/* Initialize the device structure. */
dev->destructor = free_netdev;
dev->netdev_ops = &ifb_netdev_ops;

/* Fill in device structure with ethernet-generic values. */
ether_setup(dev);
dev->tx_queue_len = TX_Q_LIMIT;

dev->features |= IFB_FEATURES;
dev->vlan_features |= IFB_FEATURES;

dev->flags |= IFF_NOARP;
dev->flags &= ~IFF_MULTICAST;
	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
random_ether_addr(dev->dev_addr);
}
",[12],	dev->priv_flags &= ~IFF_XMIT_DST_RELEASE;
591,"decompileAction(int n, SWF_ACTION *actions, int maxn)
{
	if( n > maxn ) SWF_error(""Action overflow!!"");

#ifdef DEBUG
fprintf(stderr,""%d:\tACTION[%3.3d]: %s\n"",
actions[n].SWF_ACTIONRECORD.Offset, n,
actionName(actions[n].SWF_ACTIONRECORD.ActionCode));
#endif

	switch(actions[n].SWF_ACTIONRECORD.ActionCode)
{
case SWFACTION_END:
return 0;

case SWFACTION_CONSTANTPOOL:
decompileCONSTANTPOOL(&actions[n]);
return 0;

case SWFACTION_GOTOLABEL:
return decompileGOTOFRAME(n, actions, maxn,1);

case SWFACTION_GOTOFRAME:
return decompileGOTOFRAME(n, actions, maxn,0);

case SWFACTION_GOTOFRAME2:
return decompileGOTOFRAME2(n, actions, maxn);

case SWFACTION_WAITFORFRAME:
decompileWAITFORFRAME(&actions[n]);
return 0;

case SWFACTION_GETURL2:
decompileGETURL2(&actions[n]);
return 0;

case SWFACTION_GETURL:
decompileGETURL(&actions[n]);
return 0;

case SWFACTION_PUSH:
decompilePUSH(&actions[n]);
return 0;

case SWFACTION_PUSHDUP:
decompilePUSHDUP(&actions[n]);
return 0;

case SWFACTION_STACKSWAP:
decompileSTACKSWAP(&actions[n]);
return 0;

case SWFACTION_SETPROPERTY:
decompileSETPROPERTY(n, actions, maxn);
return 0;

case SWFACTION_GETPROPERTY:
decompileGETPROPERTY(n, actions, maxn);
return 0;

case SWFACTION_GETTIME:
return decompileGETTIME(n, actions, maxn);

case SWFACTION_TRACE:
decompileTRACE(n, actions, maxn);
return 0;

case SWFACTION_CALLFRAME:
decompileCALLFRAME(n, actions, maxn);
return 0;

case SWFACTION_EXTENDS:
decompileEXTENDS(n, actions, maxn);
return 0;

case SWFACTION_INITOBJECT:
decompileINITOBJECT(n, actions, maxn);
return 0;

case SWFACTION_NEWOBJECT:
decompileNEWOBJECT(n, actions, maxn);
return 0;

case SWFACTION_NEWMETHOD:
decompileNEWMETHOD(n, actions, maxn);
return 0;

case SWFACTION_GETMEMBER:
decompileGETMEMBER(n, actions, maxn);
return 0;

case SWFACTION_SETMEMBER:
decompileSETMEMBER(n, actions, maxn);
return 0;

case SWFACTION_GETVARIABLE:
decompileGETVARIABLE(n, actions, maxn);
return 0;

case SWFACTION_SETVARIABLE:
decompileSETVARIABLE(n, actions, maxn, 0);
return 0;

case SWFACTION_DEFINELOCAL:
decompileSETVARIABLE(n, actions, maxn, 1);
return 0;

case SWFACTION_DEFINELOCAL2:
decompileDEFINELOCAL2(n, actions, maxn);
return 0;

case SWFACTION_DECREMENT:
return decompileINCR_DECR(n, actions, maxn, 0);

case SWFACTION_INCREMENT:
return decompileINCR_DECR(n, actions, maxn,1);

case SWFACTION_STOREREGISTER:
decompileSTOREREGISTER(n, actions, maxn);
return 0;

case SWFACTION_JUMP:
return decompileJUMP(n, actions, maxn);

case SWFACTION_RETURN:
decompileRETURN(n, actions, maxn);
return 0;

case SWFACTION_LOGICALNOT:
return decompileLogicalNot(n, actions, maxn);

case SWFACTION_IF:
return decompileIF(n, actions, maxn);

case SWFACTION_WITH:
decompileWITH(n, actions, maxn);
return 0;

case SWFACTION_ENUMERATE:
return decompileENUMERATE(n, actions, maxn, 0);

case SWFACTION_ENUMERATE2 :
return decompileENUMERATE(n, actions, maxn,1);

case SWFACTION_INITARRAY:
return decompileINITARRAY(n, actions, maxn);

case SWFACTION_DEFINEFUNCTION:
return decompileDEFINEFUNCTION(n, actions, maxn,0);

case SWFACTION_DEFINEFUNCTION2:
return decompileDEFINEFUNCTION(n, actions, maxn,1);

case SWFACTION_CALLFUNCTION:
return decompileCALLFUNCTION(n, actions, maxn);

case SWFACTION_CALLMETHOD:
return decompileCALLMETHOD(n, actions, maxn);

case SWFACTION_INSTANCEOF:
case SWFACTION_SHIFTLEFT:
case SWFACTION_SHIFTRIGHT:
case SWFACTION_SHIFTRIGHT2:
case SWFACTION_ADD:
case SWFACTION_ADD2:
case SWFACTION_SUBTRACT:
case SWFACTION_MULTIPLY:
case SWFACTION_DIVIDE:
case SWFACTION_MODULO:
case SWFACTION_BITWISEAND:
case SWFACTION_BITWISEOR:
case SWFACTION_BITWISEXOR:
case SWFACTION_EQUAL:
case SWFACTION_EQUALS2:
case SWFACTION_LESS2:
case SWFACTION_LOGICALAND:
case SWFACTION_LOGICALOR:
case SWFACTION_GREATER:
case SWFACTION_LESSTHAN:
case SWFACTION_STRINGEQ:
case SWFACTION_STRINGCOMPARE:
case SWFACTION_STRICTEQUALS:
return decompileArithmeticOp(n, actions, maxn);

case SWFACTION_POP:
pop();
return 0;

case SWFACTION_STARTDRAG:
return decompileSTARTDRAG(n, actions, maxn);

case SWFACTION_DELETE:
return decompileDELETE(n, actions, maxn,0);

case SWFACTION_DELETE2:
return decompileDELETE(n, actions, maxn,1);

case SWFACTION_TARGETPATH:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""targetPath"");

case SWFACTION_TYPEOF:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""typeof"");

case SWFACTION_ORD:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""ord"");

case SWFACTION_CHR:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""chr"");

case SWFACTION_INT:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""int"");

case SWFACTION_TOSTRING:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""String"");

case SWFACTION_TONUMBER:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""Number"");

case SWFACTION_RANDOMNUMBER:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""random"");

case SWFACTION_STRINGLENGTH:
return decompileSingleArgBuiltInFunctionCall(n, actions, maxn,""length"");

case SWFACTION_PLAY:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""play"");

case SWFACTION_STOP:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""stop"");

case SWFACTION_NEXTFRAME:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""nextFrame"");

case SWFACTION_PREVFRAME:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""prevFrame"");

case SWFACTION_ENDDRAG:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""stopDrag"");

case SWFACTION_STOPSOUNDS:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""stopAllSounds"");

case SWFACTION_TOGGLEQUALITY:
return decompile_Null_ArgBuiltInFunctionCall(n, actions, maxn,""toggleHighQuality"");

case SWFACTION_MBSUBSTRING:
case SWFACTION_SUBSTRING:
return decompileSUBSTRING(n, actions, maxn);

case SWFACTION_STRINGCONCAT:
return decompileSTRINGCONCAT(n, actions, maxn);

case SWFACTION_REMOVECLIP:
return decompileREMOVECLIP(n, actions, maxn);

case SWFACTION_DUPLICATECLIP:
return decompileDUPLICATECLIP(n, actions, maxn);

case SWFACTION_SETTARGET:
return decompileSETTARGET(n, actions, maxn,0);

case SWFACTION_SETTARGET2:
return decompileSETTARGET(n, actions, maxn,1);

case SWFACTION_IMPLEMENTSOP:
return decompileIMPLEMENTS(n, actions, maxn);

case SWFACTION_CASTOP:
return decompileCAST(n, actions, maxn);

case SWFACTION_THROW:
return decompileTHROW(n, actions, maxn);

case SWFACTION_TRY:
return decompileTRY(n, actions, maxn);

default:
outputSWF_ACTION(n,&actions[n]);
return 0;
}
}
","[2, 8]","	if( n > maxn ) SWF_error(""Action overflow!!"");/~/	switch(actions[n].SWF_ACTIONRECORD.ActionCode)"
592,"long keyctl_read_key(key_serial_t keyid, char __user *buffer, size_t buflen)
{
struct key *key;
key_ref_t key_ref;
long ret;

/* find the key first */
key_ref = lookup_user_key(keyid, 0, 0);
if (IS_ERR(key_ref)) {
ret = -ENOKEY;
goto error;
}

key = key_ref_to_ptr(key_ref);

/* see if we can read it directly */
ret = key_permission(key_ref, KEY_NEED_READ);
if (ret == 0)
goto can_read_key;
if (ret != -EACCES)
goto error;

/* we can't; see if it's searchable from this process's keyrings
* - we automatically take account of the fact that it may be
*   dangling off an instantiation key
*/
if (!is_key_possessed(key_ref)) {
ret = -EACCES;
goto error2;
}

/* the key is probably readable - now try to read it */
can_read_key:
	ret = key_validate(key);
	if (ret == 0) {
		ret = -EOPNOTSUPP;
		if (key->type->read) {
			/* read the data with the semaphore held (since we
			 * might sleep) *
			down_read(&key->sem);
ret = key->type->read(key, buffer, buflen);
			up_read(&key->sem);
		}
}

error2:
key_put(key);
error:
return ret;
}
","[10, 25, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 43]",	ret = key_validate(key);/~/	if (ret == 0) {/~/		ret = -EOPNOTSUPP;/~/		if (key->type->read) {/~/			/* read the data with the semaphore held (since we/~/			 * might sleep) */~/			down_read(&key->sem);/~/			up_read(&key->sem);/~/		}
593,"static bool tailmatch(const char *little, const char *bigone)
{
  size_t littlelen = strlen(little);
  size_t biglen = strlen(bigone);

  if(littlelen > biglen)
return FALSE;

  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;
}
","[2, 3, 4, 6]","  size_t littlelen = strlen(little);/~/  size_t biglen = strlen(bigone);/~/  if(littlelen > biglen)/~/  return Curl_raw_equal(little, bigone+biglen-littlelen) ? TRUE : FALSE;"
594,"void ExtensionServiceBackend::LoadSingleExtension(const FilePath& path_in) {
CHECK(BrowserThread::CurrentlyOn(BrowserThread::FILE));

FilePath extension_path = path_in;
file_util::AbsolutePath(&extension_path);

int flags = Extension::ShouldAlwaysAllowFileAccess(Extension::LOAD) ?
Extension::ALLOW_FILE_ACCESS : Extension::NO_FLAGS;
if (Extension::ShouldDoStrictErrorChecking(Extension::LOAD))
flags |= Extension::STRICT_ERROR_CHECKS;
std::string error;
scoped_refptr<const Extension> extension(extension_file_util::LoadExtension(
extension_path,
Extension::LOAD,
flags,
&error));

if (!extension) {
if (!BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
NewRunnableMethod(
this,
&ExtensionServiceBackend::ReportExtensionLoadError,
extension_path, error)))
NOTREACHED() << error;
return;
}

// Report this as an installed extension so that it gets remembered in the
// prefs.
if (!BrowserThread::PostTask(
BrowserThread::UI, FROM_HERE,
NewRunnableMethod(
this,
              &ExtensionServiceBackend::OnExtensionInstalled,
extension)))
NOTREACHED();
}
",[30],"              &ExtensionServiceBackend::OnExtensionInstalled,"
595,"status_t SoundTriggerHwService::Module::startRecognition(sound_model_handle_t handle,
const sp<IMemory>& dataMemory)
{
ALOGV(""startRecognition() model handle %d"", handle);
if (!captureHotwordAllowed()) {

return PERMISSION_DENIED;
}

    if (dataMemory != 0 && dataMemory->pointer() == NULL) {
        ALOGE(""startRecognition() dataMemory is non-0 but has NULL pointer()"");
return BAD_VALUE;

}
AutoMutex lock(mLock);
if (mServiceState == SOUND_TRIGGER_STATE_DISABLED) {
return INVALID_OPERATION;
}
sp<Model> model = getModel(handle);

if (model == 0) {
return BAD_VALUE;
}
    if ((dataMemory == 0) ||
            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {
        return BAD_VALUE;
    }

if (model->mState == Model::STATE_ACTIVE) {
return INVALID_OPERATION;
}

    struct sound_trigger_recognition_config *config =
            (struct sound_trigger_recognition_config *)dataMemory->pointer();

//TODO: get capture handle and device from audio policy service
config->capture_handle = model->mCaptureIOHandle;
config->capture_device = model->mCaptureDevice;
status_t status = mHwDevice->start_recognition(mHwDevice, handle, config,
SoundTriggerHwService::recognitionCallback,
this);

if (status == NO_ERROR) {
model->mState = Model::STATE_ACTIVE;
model->mConfig = *config;
}

return status;
}
","[6, 7, 8, 9, 10, 14, 17, 18, 19, 20, 21, 22, 25, 26, 27, 37, 39]","    if (dataMemory != 0 && dataMemory->pointer() == NULL) {/~/        ALOGE(""startRecognition() dataMemory is non-0 but has NULL pointer()"");/~/    if ((dataMemory == 0) ||/~/            (dataMemory->size() < sizeof(struct sound_trigger_recognition_config))) {/~/        return BAD_VALUE;/~/    }/~/    struct sound_trigger_recognition_config *config =/~/            (struct sound_trigger_recognition_config *)dataMemory->pointer();"
596,"void PartialMagnificationController::OnWidgetDestroying(views::Widget* widget) {
  DCHECK_EQ(widget, zoom_widget_);
RemoveZoomWidgetObservers();
  zoom_widget_ = NULL;
}
","[1, 3]","  DCHECK_EQ(widget, zoom_widget_);/~/  zoom_widget_ = NULL;"
597,"void set_fat(DOS_FS * fs, uint32_t cluster, int32_t new)
{
unsigned char *data = NULL;
int size;
loff_t offs;

if (new == -1)
new = FAT_EOF(fs);
else if ((long)new == -2)
new = FAT_BAD(fs);
switch (fs->fat_bits) {
case 12:
data = fs->fat + cluster * 3 / 2;
offs = fs->fat_start + cluster * 3 / 2;
if (cluster & 1) {
FAT_ENTRY prevEntry;
get_fat(&prevEntry, fs->fat, cluster - 1, fs);
data[0] = ((new & 0xf) << 4) | (prevEntry.value >> 8);
data[1] = new >> 4;
} else {
FAT_ENTRY subseqEntry;
	    if (cluster != fs->clusters - 1)
get_fat(&subseqEntry, fs->fat, cluster + 1, fs);
else
subseqEntry.value = 0;
data[0] = new & 0xff;
data[1] = (new >> 8) | ((0xff & subseqEntry.value) << 4);
}
size = 2;
break;
case 16:
data = fs->fat + cluster * 2;
offs = fs->fat_start + cluster * 2;
*(unsigned short *)data = htole16(new);
size = 2;
break;
case 32:
{
FAT_ENTRY curEntry;
get_fat(&curEntry, fs->fat, cluster, fs);

data = fs->fat + cluster * 4;
offs = fs->fat_start + cluster * 4;
/* According to M$, the high 4 bits of a FAT32 entry are reserved and
* are not part of the cluster number. So we never touch them. */
*(uint32_t *)data = htole32((new & 0xfffffff) |
(curEntry.reserved << 28));
size = 4;
}
break;
default:
die(""Bad FAT entry size: %d bits."", fs->fat_bits);
}
fs_write(offs, size, data);
if (fs->nfats > 1) {
fs_write(offs + fs->fat_size, size, data);
}
}
",[20],	    if (cluster != fs->clusters - 1)
598,"static MagickBooleanType SkipDXTMipmaps(Image *image,DDSInfo *dds_info,
int texel_size,ExceptionInfo *exception)
{
register ssize_t
i;

MagickOffsetType
offset;

size_t
h,
w;

/*
Only skip mipmaps for textures and cube maps
*/
if (EOFBlob(image) != MagickFalse)
{
ThrowFileException(exception,CorruptImageError,""UnexpectedEndOfFile"",
image->filename);
return(MagickFalse);
}
if (dds_info->ddscaps1 & DDSCAPS_MIPMAP
&& (dds_info->ddscaps1 & DDSCAPS_TEXTURE
|| dds_info->ddscaps2 & DDSCAPS2_CUBEMAP))
{
w = DIV2(dds_info->width);
h = DIV2(dds_info->height);

/*
Mipmapcount includes the main image, so start from one
*/
for (i = 1; (i < (ssize_t) dds_info->mipmapcount) && w && h; i++)
{
offset = (MagickOffsetType) ((w + 3) / 4) * ((h + 3) / 4) * texel_size;
        (void) SeekBlob(image, offset, SEEK_CUR);
w = DIV2(w);
h = DIV2(h);
}
}
return(MagickTrue);
}
",[31],"        (void) SeekBlob(image, offset, SEEK_CUR);"
599,"void BluetoothDeviceChooserController::GetDevice(
blink::mojom::WebBluetoothRequestDeviceOptionsPtr options,
const SuccessCallback& success_callback,
const ErrorCallback& error_callback) {
DCHECK_CURRENTLY_ON(BrowserThread::UI);

// GetDevice should only be called once.
DCHECK(success_callback_.is_null());
DCHECK(error_callback_.is_null());

success_callback_ = success_callback;
error_callback_ = error_callback;
options_ = std::move(options);
LogRequestDeviceOptions(options_);

// Check blocklist to reject invalid filters and adjust optional_services.
if (options_->filters &&
BluetoothBlocklist::Get().IsExcluded(options_->filters.value())) {
RecordRequestDeviceOutcome(
UMARequestDeviceOutcome::BLOCKLISTED_SERVICE_IN_FILTER);
    PostErrorCallback(
        blink::mojom::WebBluetoothResult::REQUEST_DEVICE_WITH_BLOCKLISTED_UUID);
return;
}
BluetoothBlocklist::Get().RemoveExcludedUUIDs(options_.get());

  const url::Origin requesting_origin =
      render_frame_host_->GetLastCommittedOrigin();
  const url::Origin embedding_origin =
      web_contents_->GetMainFrame()->GetLastCommittedOrigin();
  // TODO(crbug.com/518042): Enforce correctly-delegated permissions instead of
  // matching origins. When relaxing this, take care to handle non-sandboxed
  // unique origins.
  if (!embedding_origin.IsSameOriginWith(requesting_origin)) {
    PostErrorCallback(blink::mojom::WebBluetoothResult::
                          REQUEST_DEVICE_FROM_CROSS_ORIGIN_IFRAME);
return;
}
  // The above also excludes opaque origins, which are not even same-origin with
  // themselves.
  DCHECK(!requesting_origin.opaque());

if (!adapter_->IsPresent()) {
DVLOG(1) << ""Bluetooth Adapter not present. Can't serve requestDevice."";
RecordRequestDeviceOutcome(
UMARequestDeviceOutcome::BLUETOOTH_ADAPTER_NOT_PRESENT);
    PostErrorCallback(blink::mojom::WebBluetoothResult::NO_BLUETOOTH_ADAPTER);
return;
}

  switch (GetContentClient()->browser()->AllowWebBluetooth(
      web_contents_->GetBrowserContext(), requesting_origin,
      embedding_origin)) {
    case ContentBrowserClient::AllowWebBluetoothResult::BLOCK_POLICY: {
      RecordRequestDeviceOutcome(
          UMARequestDeviceOutcome::BLUETOOTH_CHOOSER_POLICY_DISABLED);
      PostErrorCallback(blink::mojom::WebBluetoothResult::
                            CHOOSER_NOT_SHOWN_API_LOCALLY_DISABLED);
      return;
    }
    case ContentBrowserClient::AllowWebBluetoothResult::
        BLOCK_GLOBALLY_DISABLED: {
      // Log to the developer console.
      web_contents_->GetMainFrame()->AddMessageToConsole(
          blink::mojom::ConsoleMessageLevel::kInfo,
          ""Bluetooth permission has been blocked."");
      // Block requests.
      RecordRequestDeviceOutcome(
          UMARequestDeviceOutcome::BLUETOOTH_GLOBALLY_DISABLED);
      PostErrorCallback(blink::mojom::WebBluetoothResult::
                            CHOOSER_NOT_SHOWN_API_GLOBALLY_DISABLED);
      return;
    }
    case ContentBrowserClient::AllowWebBluetoothResult::ALLOW:
      break;
  }
BluetoothChooser::EventHandler chooser_event_handler =
base::Bind(&BluetoothDeviceChooserController::OnBluetoothChooserEvent,
base::Unretained(this));

if (WebContentsDelegate* delegate = web_contents_->GetDelegate()) {
chooser_ = delegate->RunBluetoothChooser(render_frame_host_,
std::move(chooser_event_handler));
}

if (!chooser_.get()) {
    PostErrorCallback(
        blink::mojom::WebBluetoothResult::WEB_BLUETOOTH_NOT_SUPPORTED);
return;
}

if (!chooser_->CanAskForScanningPermission()) {
DVLOG(1) << ""Closing immediately because Chooser cannot obtain permission."";
OnBluetoothChooserEvent(BluetoothChooser::Event::DENIED_PERMISSION,
"""" /* device_address */);
return;
}

device_ids_.clear();
PopulateConnectedDevices();
if (!chooser_.get()) {
// If the dialog's closing, no need to do any of the rest of this.
return;
}

if (!adapter_->IsPowered()) {
chooser_->SetAdapterPresence(
BluetoothChooser::AdapterPresence::POWERED_OFF);
return;
}

StartDeviceDiscovery();
}
","[15, 17, 18, 19, 20, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]","    PostErrorCallback(/~/        blink::mojom::WebBluetoothResult::REQUEST_DEVICE_WITH_BLOCKLISTED_UUID);/~/  const url::Origin requesting_origin =/~/      render_frame_host_->GetLastCommittedOrigin();/~/  const url::Origin embedding_origin =/~/      web_contents_->GetMainFrame()->GetLastCommittedOrigin();/~/  // TODO(crbug.com/518042): Enforce correctly-delegated permissions instead of/~/  // matching origins. When relaxing this, take care to handle non-sandboxed/~/  // unique origins./~/  if (!embedding_origin.IsSameOriginWith(requesting_origin)) {/~/    PostErrorCallback(blink::mojom::WebBluetoothResult::/~/                          REQUEST_DEVICE_FROM_CROSS_ORIGIN_IFRAME);/~/  // The above also excludes opaque origins, which are not even same-origin with/~/  // themselves./~/  DCHECK(!requesting_origin.opaque());/~/    PostErrorCallback(blink::mojom::WebBluetoothResult::NO_BLUETOOTH_ADAPTER);/~/  switch (GetContentClient()->browser()->AllowWebBluetooth(/~/      web_contents_->GetBrowserContext(), requesting_origin,/~/      embedding_origin)) {/~/    case ContentBrowserClient::AllowWebBluetoothResult::BLOCK_POLICY: {/~/      RecordRequestDeviceOutcome(/~/          UMARequestDeviceOutcome::BLUETOOTH_CHOOSER_POLICY_DISABLED);/~/      PostErrorCallback(blink::mojom::WebBluetoothResult::/~/                            CHOOSER_NOT_SHOWN_API_LOCALLY_DISABLED);/~/      return;/~/    }/~/    case ContentBrowserClient::AllowWebBluetoothResult::/~/        BLOCK_GLOBALLY_DISABLED: {/~/      // Log to the developer console./~/      web_contents_->GetMainFrame()->AddMessageToConsole(/~/          blink::mojom::ConsoleMessageLevel::kInfo,/~/          ""Bluetooth permission has been blocked."");/~/      // Block requests./~/      RecordRequestDeviceOutcome(/~/          UMARequestDeviceOutcome::BLUETOOTH_GLOBALLY_DISABLED);/~/      PostErrorCallback(blink::mojom::WebBluetoothResult::/~/                            CHOOSER_NOT_SHOWN_API_GLOBALLY_DISABLED);/~/      return;/~/    }/~/    case ContentBrowserClient::AllowWebBluetoothResult::ALLOW:/~/      break;/~/  }/~/    PostErrorCallback(/~/        blink::mojom::WebBluetoothResult::WEB_BLUETOOTH_NOT_SUPPORTED);"
600,"long long Segment::CreateInstance(
    IMkvReader* pReader,
    long long pos,
    Segment*& pSegment)
{
    assert(pReader);
    assert(pos >= 0);

    pSegment = NULL;

    long long total, available;

    const long status = pReader->Length(&total, &available);

    if (status < 0) //error
        return status;

    if (available < 0)
return -1;

    if ((total >= 0) && (available > total))
return -1;

    //I would assume that in practice this loop would execute
    //exactly once, but we allow for other elements (e.g. Void)
    //to immediately follow the EBML header.  This is fine for
    //the source filter case (since the entire file is available),
    //but in the splitter case over a network we should probably
    //just give up early.  We could for example decide only to
    //execute this loop a maximum of, say, 10 times.
    //TODO:
    //There is an implied ""give up early"" by only parsing up
    //to the available limit.  We do do that, but only if the
    //total file size is unknown.  We could decide to always
    //use what's available as our limit (irrespective of whether
    //we happen to know the total file length).  This would have
    //as its sense ""parse this much of the file before giving up"",
    //which a slightly different sense from ""try to parse up to
    //10 EMBL elements before giving up"".

    for (;;)
    {
        if ((total >= 0) && (pos >= total))
            return E_FILE_FORMAT_INVALID;
        //Read ID
        long len;
        long long result = GetUIntLength(pReader, pos, len);
        if (result)  //error, or too few available bytes
            return result;
        if ((total >= 0) && ((pos + len) > total))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > available)
            return pos + len;
        const long long idpos = pos;
        const long long id = ReadUInt(pReader, pos, len);
        if (id < 0)  //error
            return id;
        pos += len;  //consume ID
        //Read Size
        result = GetUIntLength(pReader, pos, len);
        if (result)  //error, or too few available bytes
            return result;
        if ((total >= 0) && ((pos + len) > total))
            return E_FILE_FORMAT_INVALID;
        if ((pos + len) > available)
            return pos + len;
        long long size = ReadUInt(pReader, pos, len);
        if (size < 0)  //error
            return size;
        pos += len;  //consume length of size of element
        //Pos now points to start of payload
        //Handle ""unknown size"" for live streaming of webm files.
        const long long unknown_size = (1LL << (7 * len)) - 1;
        if (id == 0x08538067)  //Segment ID
        {
            if (size == unknown_size)
                size = -1;
            else if (total < 0)
                size = -1;
            else if ((pos + size) > total)
                size = -1;
            pSegment = new (std::nothrow) Segment(
                                            pReader,
                                            idpos,
                                            //elem_size
                                            pos,
                                            size);
            if (pSegment == 0)
                return -1;  //generic error
            return 0;    //success
        }
        if (size == unknown_size)
            return E_FILE_FORMAT_INVALID;
        if ((total >= 0) && ((pos + size) > total))
            return E_FILE_FORMAT_INVALID;
        if ((pos + size) > available)
            return pos + size;
        pos += size;  //consume payload
    }
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 14, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37]","    IMkvReader* pReader,/~/    long long pos,/~/    Segment*& pSegment)/~/{/~/    assert(pReader);/~/    assert(pos >= 0);/~/    pSegment = NULL;/~/    long long total, available;/~/    const long status = pReader->Length(&total, &available);/~/    if (status < 0) //error/~/        return status;/~/    if (available < 0)/~/    if ((total >= 0) && (available > total))/~/    //I would assume that in practice this loop would execute/~/    //exactly once, but we allow for other elements (e.g. Void)/~/    //to immediately follow the EBML header.  This is fine for/~/    //the source filter case (since the entire file is available),/~/    //but in the splitter case over a network we should probably/~/    //just give up early.  We could for example decide only to/~/    //execute this loop a maximum of, say, 10 times./~/    //TODO:/~/    //There is an implied ""give up early"" by only parsing up/~/    //to the available limit.  We do do that, but only if the/~/    //total file size is unknown.  We could decide to always/~/    //use what's available as our limit (irrespective of whether/~/    //we happen to know the total file length).  This would have/~/    //as its sense ""parse this much of the file before giving up"",/~/    //which a slightly different sense from ""try to parse up to/~/    //10 EMBL elements before giving up""./~/    for (;;)/~/    {/~/        if ((total >= 0) && (pos >= total))/~/            return E_FILE_FORMAT_INVALID;/~/        //Read ID/~/        long len;/~/        long long result = GetUIntLength(pReader, pos, len);/~/        if (result)  //error, or too few available bytes/~/            return result;/~/        if ((total >= 0) && ((pos + len) > total))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((pos + len) > available)/~/            return pos + len;/~/        const long long idpos = pos;/~/        const long long id = ReadUInt(pReader, pos, len);/~/        if (id < 0)  //error/~/            return id;/~/        pos += len;  //consume ID/~/        //Read Size/~/        result = GetUIntLength(pReader, pos, len);/~/        if (result)  //error, or too few available bytes/~/            return result;/~/        if ((total >= 0) && ((pos + len) > total))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((pos + len) > available)/~/            return pos + len;/~/        long long size = ReadUInt(pReader, pos, len);/~/        if (size < 0)  //error/~/            return size;/~/        pos += len;  //consume length of size of element/~/        //Pos now points to start of payload/~/        //Handle ""unknown size"" for live streaming of webm files./~/        const long long unknown_size = (1LL << (7 * len)) - 1;/~/        if (id == 0x08538067)  //Segment ID/~/        {/~/            if (size == unknown_size)/~/                size = -1;/~/            else if (total < 0)/~/                size = -1;/~/            else if ((pos + size) > total)/~/                size = -1;/~/            pSegment = new (std::nothrow) Segment(/~/                                            pReader,/~/                                            idpos,/~/                                            //elem_size/~/                                            pos,/~/                                            size);/~/            if (pSegment == 0)/~/                return -1;  //generic error/~/            return 0;    //success/~/        }/~/        if (size == unknown_size)/~/            return E_FILE_FORMAT_INVALID;/~/        if ((total >= 0) && ((pos + size) > total))/~/            return E_FILE_FORMAT_INVALID;/~/        if ((pos + size) > available)/~/            return pos + size;/~/        pos += size;  //consume payload/~/    }/~/}"
601,"int read_header_tga(gdIOCtx *ctx, oTga *tga)
{

unsigned char header[18];

if (gdGetBuf(header, sizeof(header), ctx) < 18) {
gd_error(""fail to read header"");
return -1;
}

tga->identsize = header[0];
tga->colormaptype = header[1];
tga->imagetype = header[2];
tga->colormapstart = header[3] + (header[4] << 8);
tga->colormaplength = header[5] + (header[6] << 8);
tga->colormapbits = header[7];
tga->xstart = header[8] + (header[9] << 8);
tga->ystart = header[10] + (header[11] << 8);
tga->width = header[12] + (header[13] << 8);
tga->height = header[14] + (header[15] << 8);
tga->bits = header[16];
tga->alphabits = header[17] & 0x0f;
tga->fliph = (header[17] & 0x10) ? 1 : 0;
tga->flipv = (header[17] & 0x20) ? 0 : 1;

#if DEBUG
printf(""format bps: %i\n"", tga->bits);
printf(""flip h/v: %i / %i\n"", tga->fliph, tga->flipv);
printf(""alpha: %i\n"", tga->alphabits);
printf(""wxh: %i %i\n"", tga->width, tga->height);
#endif

	switch(tga->bits) {
	case 8:
	case 16:
	case 24:
	case 32:
		break;
	default:
		gd_error(""bps %i not supported"", tga->bits);
return -1;
		break;
}

tga->ident = NULL;

if (tga->identsize > 0) {
tga->ident = (char *) gdMalloc(tga->identsize * sizeof(char));
if(tga->ident == NULL) {
return -1;
}

gdGetBuf(tga->ident, tga->identsize, ctx);
}

return 1;
}
","[27, 28, 29, 30, 31, 32, 33, 34, 36]","	switch(tga->bits) {/~/	case 8:/~/	case 16:/~/	case 24:/~/	case 32:/~/		break;/~/	default:/~/		gd_error(""bps %i not supported"", tga->bits);/~/		break;"
602,"void PreconnectManager::Start(const GURL& url,
std::vector<PreconnectRequest> requests) {
DCHECK_CURRENTLY_ON(content::BrowserThread::UI);
const std::string host = url.host();
if (preresolve_info_.find(host) != preresolve_info_.end())
return;

auto iterator_and_whether_inserted = preresolve_info_.emplace(
host, std::make_unique<PreresolveInfo>(url, requests.size()));
PreresolveInfo* info = iterator_and_whether_inserted.first->second.get();

for (auto request_it = requests.begin(); request_it != requests.end();
++request_it) {
    DCHECK(request_it->origin.GetOrigin() == request_it->origin);
PreresolveJobId job_id = preresolve_jobs_.Add(
std::make_unique<PreresolveJob>(std::move(*request_it), info));
queued_jobs_.push_back(job_id);
}

TryToLaunchPreresolveJobs();
}
",[11],    DCHECK(request_it->origin.GetOrigin() == request_it->origin);
603,"pdf_show_image(fz_context *ctx, pdf_run_processor *pr, fz_image *image)
{
pdf_gstate *gstate = pr->gstate + pr->gtop;
fz_matrix image_ctm;
fz_rect bbox;
       softmask_save softmask = { NULL };

if (pr->super.hidden)
return;
break;
case PDF_MAT_SHADE:
if (gstate->fill.shade)
{
fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
bbox = fz_unit_rect;
fz_transform_rect(&bbox, &image_ctm);

       if (image->mask)
{
/* apply blend group even though we skip the soft mask */
               if (gstate->blendmode)
                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);
               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);
       }
       else
               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);

       if (!image->colorspace)
       {
               switch (gstate->fill.kind)
{
               case PDF_MAT_NONE:
                       break;
               case PDF_MAT_COLOR:
                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,
                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);
                       break;
               case PDF_MAT_PATTERN:
                       if (gstate->fill.pattern)
                       {
                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);
                               fz_pop_clip(ctx, pr->dev);
                       }
                       break;
               case PDF_MAT_SHADE:
                       if (gstate->fill.shade)
                       {
                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);
                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);
                               fz_pop_clip(ctx, pr->dev);
                       }
                       break;
}
}
       else
{
               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);
}
       if (image->mask)
{
               fz_pop_clip(ctx, pr->dev);
               if (gstate->blendmode)
                       fz_end_group(ctx, pr->dev);
}
       else
               pdf_end_group(ctx, pr, &softmask);
}

static void

if (pr->clip)
{
gstate->clip_depth++;
fz_clip_path(ctx, pr->dev, path, pr->clip_even_odd, &gstate->ctm, &bbox);
pr->clip = 0;
}

if (pr->super.hidden)
dostroke = dofill = 0;

if (dofill || dostroke)
gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);

if (dofill && dostroke)
{
/* We may need to push a knockout group */
if (gstate->stroke.alpha == 0)
{
/* No need for group, as stroke won't do anything */
}
else if (gstate->stroke.alpha == 1.0f && gstate->blendmode == FZ_BLEND_NORMAL)
{
/* No need for group, as stroke won't show up */
}
else
{
knockout_group = 1;
fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 1, FZ_BLEND_NORMAL, 1);
}
}

if (dofill)
{
switch (gstate->fill.kind)
{
case PDF_MAT_NONE:
break;
case PDF_MAT_COLOR:
fz_fill_path(ctx, pr->dev, path, even_odd, &gstate->ctm,
gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);
break;
case PDF_MAT_PATTERN:
if (gstate->fill.pattern)
{
fz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);
pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);
fz_pop_clip(ctx, pr->dev);
}
break;
case PDF_MAT_SHADE:
if (gstate->fill.shade)
{
fz_clip_path(ctx, pr->dev, path, even_odd, &gstate->ctm, &bbox);
/* The cluster and page 2 of patterns.pdf shows that fz_fill_shade should NOT be called with gstate->ctm. */
fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);
fz_pop_clip(ctx, pr->dev);
}
break;
}
}

if (dostroke)
{
switch (gstate->stroke.kind)
{
case PDF_MAT_NONE:
break;
case PDF_MAT_COLOR:
fz_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm,
gstate->stroke.colorspace, gstate->stroke.v, gstate->stroke.alpha, &gstate->stroke.color_params);
break;
case PDF_MAT_PATTERN:
if (gstate->stroke.pattern)
{
fz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);
pdf_show_pattern(ctx, pr, gstate->stroke.pattern, &pr->gstate[gstate->stroke.gstate_num], &bbox, PDF_STROKE);
fz_pop_clip(ctx, pr->dev);
}
break;
case PDF_MAT_SHADE:
if (gstate->stroke.shade)
{
fz_clip_stroke_path(ctx, pr->dev, path, gstate->stroke_state, &gstate->ctm, &bbox);
fz_fill_shade(ctx, pr->dev, gstate->stroke.shade, &pr->gstate[gstate->stroke.gstate_num].ctm, gstate->stroke.alpha, &gstate->stroke.color_params);
fz_pop_clip(ctx, pr->dev);
}
break;
}
}

if (knockout_group)
fz_end_group(ctx, pr->dev);

if (dofill || dostroke)
pdf_end_group(ctx, pr, &softmask);
}
","[1, 5, 8, 9, 10, 11, 12, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30]","       softmask_save softmask = { NULL };/~/       if (image->mask)/~/               if (gstate->blendmode)/~/                       fz_begin_group(ctx, pr->dev, &bbox, NULL, 0, 0, gstate->blendmode, 1);/~/               fz_clip_image_mask(ctx, pr->dev, image->mask, &image_ctm, &bbox);/~/       }/~/       else/~/               gstate = pdf_begin_group(ctx, pr, &bbox, &softmask);/~/       if (!image->colorspace)/~/       {/~/               switch (gstate->fill.kind)/~/               case PDF_MAT_NONE:/~/                       break;/~/               case PDF_MAT_COLOR:/~/                       fz_fill_image_mask(ctx, pr->dev, image, &image_ctm,/~/                               gstate->fill.colorspace, gstate->fill.v, gstate->fill.alpha, &gstate->fill.color_params);/~/                       break;/~/               case PDF_MAT_PATTERN:/~/                       if (gstate->fill.pattern)/~/                       {/~/                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);/~/                               pdf_show_pattern(ctx, pr, gstate->fill.pattern, &pr->gstate[gstate->fill.gstate_num], &bbox, PDF_FILL);/~/                               fz_pop_clip(ctx, pr->dev);/~/                       }/~/                       break;/~/               case PDF_MAT_SHADE:/~/                       if (gstate->fill.shade)/~/                       {/~/                               fz_clip_image_mask(ctx, pr->dev, image, &image_ctm, &bbox);/~/                               fz_fill_shade(ctx, pr->dev, gstate->fill.shade, &pr->gstate[gstate->fill.gstate_num].ctm, gstate->fill.alpha, &gstate->fill.color_params);/~/                               fz_pop_clip(ctx, pr->dev);/~/                       }/~/                       break;/~/       else/~/               fz_fill_image(ctx, pr->dev, image, &image_ctm, gstate->fill.alpha, &gstate->fill.color_params);/~/       if (image->mask)/~/               fz_pop_clip(ctx, pr->dev);/~/               if (gstate->blendmode)/~/                       fz_end_group(ctx, pr->dev);/~/       else/~/               pdf_end_group(ctx, pr, &softmask);"
604,"static int inotify_release(struct inode *ignored, struct file *file)
{
struct fsnotify_group *group = file->private_data;
	struct user_struct *user = group->inotify_data.user;

pr_debug(""%s: group=%p\n"", __func__, group);

fsnotify_clear_marks_by_group(group);

/* free this group, matching get was inotify_init->fsnotify_obtain_group */
fsnotify_put_group(group);

	atomic_dec(&user->inotify_devs);
return 0;
}
","[3, 8]",	struct user_struct *user = group->inotify_data.user;/~/	atomic_dec(&user->inotify_devs);
605,"checked_xcalloc (size_t num, size_t size)
{
    alloc_limit_assert (""checked_xcalloc"", (num *size));
return xcalloc (num, size);
}
",[2],"    alloc_limit_assert (""checked_xcalloc"", (num *size));"
606,"construct_command_line(struct manager_ctx *manager, struct server *server)
{
static char cmd[BUF_SIZE];
    char *method = manager->method;
int i;

    build_config(working_dir, server);

    if (server->method) method = server->method;
memset(cmd, 0, BUF_SIZE);
snprintf(cmd, BUF_SIZE,
             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",
             executable, method, manager->manager_address,
             working_dir, server->port, working_dir, server->port);

if (manager->acl != NULL) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --acl %s"", manager->acl);
}
if (manager->timeout != NULL) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -t %s"", manager->timeout);
}
#ifdef HAVE_SETRLIMIT
if (manager->nofile) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -n %d"", manager->nofile);
}
#endif
if (manager->user != NULL) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -a %s"", manager->user);
}
if (manager->verbose) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -v"");
}
if (server->mode == NULL && manager->mode == UDP_ONLY) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -U"");
}
if (server->mode == NULL && manager->mode == TCP_AND_UDP) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -u"");
}
if (server->fast_open[0] == 0 && manager->fast_open) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --fast-open"");
}
if (manager->ipv6first) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -6"");
}
if (manager->mtu) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --mtu %d"", manager->mtu);
}
if (server->plugin == NULL && manager->plugin) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --plugin \""%s\"""", manager->plugin);
}
if (server->plugin_opts == NULL && manager->plugin_opts) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --plugin-opts \""%s\"""", manager->plugin_opts);
}
for (i = 0; i < manager->nameserver_num; i++) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -d %s"", manager->nameservers[i]);
}
for (i = 0; i < manager->host_num; i++) {
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" -s %s"", manager->hosts[i]);
}
// Always enable reuse port
{
int len = strlen(cmd);
snprintf(cmd + len, BUF_SIZE - len, "" --reuse-port"");
}

if (verbose) {
LOGI(""cmd: %s"", cmd);
}

return cmd;
}
","[3, 5, 6, 9, 10, 11]","    char *method = manager->method;/~/    build_config(working_dir, server);/~/    if (server->method) method = server->method;/~/             ""%s -m %s --manager-address %s -f %s/.shadowsocks_%s.pid -c %s/.shadowsocks_%s.conf"",/~/             executable, method, manager->manager_address,/~/             working_dir, server->port, working_dir, server->port);"
607,"bool LayoutSVGTransformableContainer::calculateLocalTransform()
{
SVGGraphicsElement* element = toSVGGraphicsElement(this->element());
ASSERT(element);

// If we're either the layoutObject for a <use> element, or for any <g> element inside the shadow
// tree, that was created during the use/symbol/svg expansion in SVGUseElement. These containers
// need to respect the translations induced by their corresponding use elements x/y attributes.
SVGUseElement* useElement = nullptr;
if (isSVGUseElement(*element)) {
useElement = toSVGUseElement(element);
} else if (isSVGGElement(*element) && toSVGGElement(element)->inUseShadowTree()) {
SVGElement* correspondingElement = element->correspondingElement();
if (isSVGUseElement(correspondingElement))
useElement = toSVGUseElement(correspondingElement);
}

if (useElement) {
SVGLengthContext lengthContext(useElement);
FloatSize translation(
useElement->x()->currentValue()->value(lengthContext),
useElement->y()->currentValue()->value(lengthContext));
if (translation != m_additionalTranslation)
            m_needsTransformUpdate = true;
m_additionalTranslation = translation;
}

if (!m_needsTransformUpdate)
        return false;

m_localTransform = element->calculateAnimatedLocalTransform();
m_localTransform.translate(m_additionalTranslation.width(), m_additionalTranslation.height());
m_needsTransformUpdate = false;
    return true;
}
","[21, 25, 29]",            m_needsTransformUpdate = true;/~/        return false;/~/    return true;
608,"void LocalFileSystem::deleteFileSystem(ExecutionContext* context, FileSystemType type, PassOwnPtr<AsyncFileSystemCallbacks> callbacks)
{
RefPtrWillBeRawPtr<ExecutionContext> contextPtr(context);
ASSERT(context);
ASSERT_WITH_SECURITY_IMPLICATION(context->isDocument());

    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
requestFileSystemAccessInternal(context,
bind(&LocalFileSystem::deleteFileSystemInternal, this, contextPtr, type, wrapper),
bind(&LocalFileSystem::fileSystemNotAllowedInternal, this, contextPtr, wrapper));
}
",[5],    RefPtr<CallbackWrapper> wrapper = adoptRef(new CallbackWrapper(callbacks));
609,"long ssl_get_algorithm2(SSL *s)
{
long alg2 = s->s3->tmp.new_cipher->algorithm2;
       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
alg2 == (SSL_HANDSHAKE_MAC_DEFAULT|TLS1_PRF))
return SSL_HANDSHAKE_MAC_SHA256 | TLS1_PRF_SHA256;
return alg2;
}
",[3],       if (TLS1_get_version(s) >= TLS1_2_VERSION &&
610,"Blob::Blob(PassOwnPtr<BlobData> blobData, long long size)
: m_type(blobData->contentType())
, m_size(size)
{
ASSERT(blobData);
ScriptWrappable::init(this);

// Create a new internal URL and register it with the provided blob data.
m_internalURL = BlobURL::createInternalURL();
    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);
}
",[8],"    ThreadableBlobRegistry::registerBlobURL(m_internalURL, blobData);"
611,"static int auto_claim(struct libusb_transfer *transfer, int *interface_number, int api_type)
{
struct libusb_context *ctx = DEVICE_CTX(transfer->dev_handle->dev);
struct windows_device_handle_priv *handle_priv = _device_handle_priv(
transfer->dev_handle);
struct windows_device_priv *priv = _device_priv(transfer->dev_handle->dev);
int current_interface = *interface_number;
int r = LIBUSB_SUCCESS;

switch(api_type) {
case USB_API_WINUSBX:
	case USB_API_HID:
break;
default:
return LIBUSB_ERROR_INVALID_PARAM;
}

usbi_mutex_lock(&autoclaim_lock);
if (current_interface < 0)	// No serviceable interface was found
{
for (current_interface=0; current_interface<USB_MAXINTERFACES; current_interface++) {
// Must claim an interface of the same API type
if ( (priv->usb_interface[current_interface].apib->id == api_type)
&& (libusb_claim_interface(transfer->dev_handle, current_interface) == LIBUSB_SUCCESS) ) {
usbi_dbg(""auto-claimed interface %d for control request"", current_interface);
if (handle_priv->autoclaim_count[current_interface] != 0) {
usbi_warn(ctx, ""program assertion failed - autoclaim_count was nonzero"");
}
handle_priv->autoclaim_count[current_interface]++;
break;
}
}
if (current_interface == USB_MAXINTERFACES) {
usbi_err(ctx, ""could not auto-claim any interface"");
r = LIBUSB_ERROR_NOT_FOUND;
}
} else {
// If we have a valid interface that was autoclaimed, we must increment
// its autoclaim count so that we can prevent an early release.
if (handle_priv->autoclaim_count[current_interface] != 0) {
handle_priv->autoclaim_count[current_interface]++;
}
}
usbi_mutex_unlock(&autoclaim_lock);

*interface_number = current_interface;
return r;

}
",[10],	case USB_API_HID:
612,"uint64_t esp_reg_read(ESPState *s, uint32_t saddr)
{
uint32_t old_val;

trace_esp_mem_readb(saddr, s->rregs[saddr]);
switch (saddr) {
case ESP_FIFO:
        if (s->ti_size > 0) {
s->ti_size--;
            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {
                /* Data out.  *
                qemu_log_mask(LOG_UNIMP,
                              ""esp: PIO data read not implemented\n"");
                s->rregs[ESP_FIFO] = 0;
            } else {
                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];
            }
esp_raise_irq(s);
}
        if (s->ti_size == 0) {
s->ti_rptr = 0;
s->ti_wptr = 0;
}
s->ti_wptr = 0;
}
break;
case ESP_RINTR:
/* Clear sequence step, interrupt register and all status bits
except TC */
old_val = s->rregs[ESP_RINTR];
s->rregs[ESP_RINTR] = 0;
s->rregs[ESP_RSTAT] &= ~STAT_TC;
s->rregs[ESP_RSEQ] = SEQ_CD;
esp_lower_irq(s);

return old_val;
case ESP_TCHI:
/* Return the unique id if the value has never been written */
if (!s->tchi_written) {
return s->chip_id;
}
default:
break;
}
","[6, 8, 9, 10, 11, 12, 13, 14, 15, 17, 18, 21, 23]","        if (s->ti_size > 0) {/~/            if ((s->rregs[ESP_RSTAT] & STAT_PIO_MASK) == 0) {/~/                /* Data out.  */~/                qemu_log_mask(LOG_UNIMP,/~/                              ""esp: PIO data read not implemented\n"");/~/                s->rregs[ESP_FIFO] = 0;/~/            } else {/~/                s->rregs[ESP_FIFO] = s->ti_buf[s->ti_rptr++];/~/            }/~/        if (s->ti_size == 0) {"
613,"safecat_color_encoding(char *buffer, size_t bufsize, size_t pos,
   PNG_CONST color_encoding *e, double encoding_gamma)
{
if (e != 0)
{
if (encoding_gamma != 0)
pos = safecat(buffer, bufsize, pos, ""("");
pos = safecat(buffer, bufsize, pos, ""R("");
pos = safecatd(buffer, bufsize, pos, e->red.X, 4);
pos = safecat(buffer, bufsize, pos, "","");
pos = safecatd(buffer, bufsize, pos, e->red.Y, 4);
pos = safecat(buffer, bufsize, pos, "","");
pos = safecatd(buffer, bufsize, pos, e->red.Z, 4);
pos = safecat(buffer, bufsize, pos, ""),G("");
pos = safecatd(buffer, bufsize, pos, e->green.X, 4);
pos = safecat(buffer, bufsize, pos, "","");
pos = safecatd(buffer, bufsize, pos, e->green.Y, 4);
pos = safecat(buffer, bufsize, pos, "","");
pos = safecatd(buffer, bufsize, pos, e->green.Z, 4);
pos = safecat(buffer, bufsize, pos, ""),B("");
pos = safecatd(buffer, bufsize, pos, e->blue.X, 4);
pos = safecat(buffer, bufsize, pos, "","");
pos = safecatd(buffer, bufsize, pos, e->blue.Y, 4);
pos = safecat(buffer, bufsize, pos, "","");
pos = safecatd(buffer, bufsize, pos, e->blue.Z, 4);
pos = safecat(buffer, bufsize, pos, "")"");
if (encoding_gamma != 0)
pos = safecat(buffer, bufsize, pos, "")"");
}

if (encoding_gamma != 0)
{
pos = safecat(buffer, bufsize, pos, ""^"");
pos = safecatd(buffer, bufsize, pos, encoding_gamma, 5);
}


return pos;
}
",[1],"   PNG_CONST color_encoding *e, double encoding_gamma)"
614,"int main(int argc, char **argv) {
int frame_cnt = 0;
FILE *outfile = NULL;
vpx_codec_ctx_t codec;
VpxVideoReader *reader = NULL;
const VpxVideoInfo *info = NULL;
const VpxInterface *decoder = NULL;

exec_name = argv[0];

if (argc != 3)
die(""Invalid number of arguments."");

reader = vpx_video_reader_open(argv[1]);
if (!reader)
die(""Failed to open %s for reading."", argv[1]);

if (!(outfile = fopen(argv[2], ""wb"")))
die(""Failed to open %s for writing."", argv[2]);

info = vpx_video_reader_get_info(reader);

decoder = get_vpx_decoder_by_fourcc(info->codec_fourcc);

if (!decoder)
die(""Unknown input codec."");

  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));

  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))
die_codec(&codec, ""Failed to initialize decoder"");

while (vpx_video_reader_read_frame(reader)) {
vpx_codec_iter_t iter = NULL;
vpx_image_t *img = NULL;
size_t frame_size = 0;
const unsigned char *frame = vpx_video_reader_get_frame(reader,
&frame_size);
if (vpx_codec_decode(&codec, frame, (unsigned int)frame_size, NULL, 0))
die_codec(&codec, ""Failed to decode frame"");

while ((img = vpx_codec_get_frame(&codec, &iter)) != NULL) {
unsigned char digest[16];

get_image_md5(img, digest);
print_md5(outfile, digest);
fprintf(outfile, ""  img-%dx%d-%04d.i420\n"",
img->d_w, img->d_h, ++frame_cnt);
}
}

printf(""Processed %d frames.\n"", frame_cnt);
if (vpx_codec_destroy(&codec))
die_codec(&codec, ""Failed to destroy codec."");

vpx_video_reader_close(reader);

fclose(outfile);
return EXIT_SUCCESS;
}
","[19, 20]","  printf(""Using %s\n"", vpx_codec_iface_name(decoder->interface()));/~/  if (vpx_codec_dec_init(&codec, decoder->interface(), NULL, 0))"
615,"void ObjectBackedNativeHandler::Router(
const v8::FunctionCallbackInfo<v8::Value>& args) {
v8::Isolate* isolate = args.GetIsolate();
v8::HandleScope handle_scope(isolate);
v8::Local<v8::Object> data = args.Data().As<v8::Object>();
v8::Local<v8::Context> context = isolate->GetCurrentContext();

v8::Local<v8::Value> handler_function_value;
v8::Local<v8::Value> feature_name_value;
// See comment in header file for why we do this.
if (!GetPrivate(context, data, kHandlerFunction, &handler_function_value) ||
handler_function_value->IsUndefined() ||
!GetPrivate(context, data, kFeatureName, &feature_name_value) ||
!feature_name_value->IsString()) {
ScriptContext* script_context =
ScriptContextSet::GetContextByV8Context(context);
console::Error(script_context ? script_context->GetRenderFrame() : nullptr,
""Extension view no longer exists"");
return;
}

// We can't access the ScriptContextSet on a worker thread. Luckily, we also
// don't inject many bindings into worker threads.
// TODO(devlin): Figure out a way around this.
if (content::WorkerThread::GetCurrentId() == 0) {
ScriptContext* script_context =
ScriptContextSet::GetContextByV8Context(context);
v8::Local<v8::String> feature_name_string =
feature_name_value->ToString(context).ToLocalChecked();
std::string feature_name = *v8::String::Utf8Value(feature_name_string);
// TODO(devlin): Eventually, we should fail if either script_context is null
// or feature_name is empty.
    if (script_context &&
        !feature_name.empty() &&
        !script_context->GetAvailability(feature_name).is_available()) {
      return;
}
}
// This CHECK is *important*. Otherwise, we'll go around happily executing
// something random.  See crbug.com/548273.
CHECK(handler_function_value->IsExternal());
static_cast<HandlerFunction*>(
handler_function_value.As<v8::External>()->Value())->Run(args);

// Verify that the return value, if any, is accessible by the context.
v8::ReturnValue<v8::Value> ret = args.GetReturnValue();
v8::Local<v8::Value> ret_value = ret.Get();
if (ret_value->IsObject() && !ret_value->IsNull() &&
!ContextCanAccessObject(context, v8::Local<v8::Object>::Cast(ret_value),
true)) {
NOTREACHED() << ""Insecure return value"";
ret.SetUndefined();
}
}
","[17, 30, 31, 32, 33]",    if (script_context &&/~/        !feature_name.empty() &&/~/        !script_context->GetAvailability(feature_name).is_available()) {/~/      return;
616,"long long Segment::ParseHeaders() {
// Outermost (level 0) segment object has been constructed,
// and pos designates start of payload.  We need to find the
// inner (level 1) elements.
long long total, available;

const int status = m_pReader->Length(&total, &available);


if (status < 0)  // error
return status;

  assert((total < 0) || (available <= total));

const long long segment_stop = (m_size < 0) ? -1 : m_start + m_size;
  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));
  assert((segment_stop < 0) || (m_pos <= segment_stop));

for (;;) {
if ((total >= 0) && (m_pos >= total))
break;

if ((segment_stop >= 0) && (m_pos >= segment_stop))
break;


long long pos = m_pos;
const long long element_start = pos;

if ((pos + 1) > available)
return (pos + 1);

long len;
long long result = GetUIntLength(m_pReader, pos, len);


if (result < 0)  // error
return result;

    if (result > 0)  // underflow (weird)
return (pos + 1);

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > available)

return pos + len;

const long long idpos = pos;
    const long long id = ReadUInt(m_pReader, idpos, len);

    if (id < 0)  // error
      return id;

if (id == 0x0F43B675)  // Cluster ID
break;

pos += len; // consume ID

if ((pos + 1) > available)
return (pos + 1);

// Read Size
result = GetUIntLength(m_pReader, pos, len);


if (result < 0)  // error
return result;

    if (result > 0)  // underflow (weird)
return (pos + 1);

if ((segment_stop >= 0) && ((pos + len) > segment_stop))
return E_FILE_FORMAT_INVALID;

if ((pos + len) > available)
return pos + len;


const long long size = ReadUInt(m_pReader, pos, len);

    if (size < 0)  // error
return size;

pos += len;  // consume length of size of element

const long long element_size = size + pos - element_start;

// Pos now points to start of payload

if ((segment_stop >= 0) && ((pos + size) > segment_stop))
return E_FILE_FORMAT_INVALID;

// We read EBML elements either in total or nothing at all.

if ((pos + size) > available)
return pos + size;

if (id == 0x0549A966) { // Segment Info ID
if (m_pInfo)
return E_FILE_FORMAT_INVALID;

m_pInfo = new (std::nothrow)
SegmentInfo(this, pos, size, element_start, element_size);

if (m_pInfo == NULL)
return -1;

const long status = m_pInfo->Parse();

if (status)
return status;
} else if (id == 0x0654AE6B) { // Tracks ID
if (m_pTracks)
return E_FILE_FORMAT_INVALID;

m_pTracks = new (std::nothrow)
Tracks(this, pos, size, element_start, element_size);

if (m_pTracks == NULL)
return -1;

const long status = m_pTracks->Parse();

if (status)
return status;
} else if (id == 0x0C53BB6B) { // Cues ID
if (m_pCues == NULL) {
m_pCues = new (std::nothrow)
Cues(this, pos, size, element_start, element_size);

if (m_pCues == NULL)
return -1;
}
} else if (id == 0x014D9B74) { // SeekHead ID
if (m_pSeekHead == NULL) {
m_pSeekHead = new (std::nothrow)
SeekHead(this, pos, size, element_start, element_size);

if (m_pSeekHead == NULL)
return -1;

const long status = m_pSeekHead->Parse();

if (status)
return status;
}
} else if (id == 0x0043A770) { // Chapters ID
if (m_pChapters == NULL) {
m_pChapters = new (std::nothrow)
Chapters(this, pos, size, element_start, element_size);

if (m_pChapters == NULL)
return -1;

const long status = m_pChapters->Parse();


if (status)
return status;
}
}

m_pos = pos + size;  // consume payload
}

  assert((segment_stop < 0) || (m_pos <= segment_stop));

if (m_pInfo == NULL)  // TODO: liberalize this behavior
return E_FILE_FORMAT_INVALID;

if (m_pTracks == NULL)
return E_FILE_FORMAT_INVALID;

return 0; // success
}
","[8, 10, 11, 25, 32, 33, 34]","  assert((total < 0) || (available <= total));/~/  assert((segment_stop < 0) || (total < 0) || (segment_stop <= total));/~/  assert((segment_stop < 0) || (m_pos <= segment_stop));/~/    if (result > 0)  // underflow (weird)/~/    const long long id = ReadUInt(m_pReader, idpos, len);/~/    if (id < 0)  // error/~/      return id;/~/    if (result > 0)  // underflow (weird)/~/    if (size < 0)  // error/~/  assert((segment_stop < 0) || (m_pos <= segment_stop));"
617,"EncodedJSValue JSC_HOST_CALL jsTestInterfacePrototypeFunctionSupplementalMethod2(ExecState* exec)
{
JSValue thisValue = exec->hostThisValue();
if (!thisValue.inherits(&JSTestInterface::s_info))
return throwVMTypeError(exec);
JSTestInterface* castedThis = jsCast<JSTestInterface*>(asObject(thisValue));
ASSERT_GC_OBJECT_INHERITS(castedThis, &JSTestInterface::s_info);
TestInterface* impl = static_cast<TestInterface*>(castedThis->impl());
if (exec->argumentCount() < 2)
        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));
ExceptionCode ec = 0;
ScriptExecutionContext* scriptContext = jsCast<JSDOMGlobalObject*>(exec->lexicalGlobalObject())->scriptExecutionContext();
if (!scriptContext)
return JSValue::encode(jsUndefined());
const String& strArg(ustringToString(MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).isEmpty() ? UString() : MAYBE_MISSING_PARAMETER(exec, 0, DefaultIsUndefined).toString(exec)->value(exec)));
if (exec->hadException())
return JSValue::encode(jsUndefined());
TestObj* objArg(toTestObj(MAYBE_MISSING_PARAMETER(exec, 1, DefaultIsUndefined)));
if (exec->hadException())
return JSValue::encode(jsUndefined());

JSC::JSValue result = toJS(exec, castedThis->globalObject(), WTF::getPtr(TestSupplemental::supplementalMethod2(impl, scriptContext, strArg, objArg, ec)));
setDOMException(exec, ec);
return JSValue::encode(result);
}
",[9],"        return throwVMError(exec, createTypeError(exec, ""Not enough arguments""));"
618,"static void webkit_web_view_update_settings(WebKitWebView* webView)
{
WebKitWebViewPrivate* priv = webView->priv;
WebKitWebSettings* webSettings = priv->webSettings.get();
Settings* settings = core(webView)->settings();

gchar* defaultEncoding, *cursiveFontFamily, *defaultFontFamily, *fantasyFontFamily, *monospaceFontFamily, *sansSerifFontFamily, *serifFontFamily, *userStylesheetUri, *defaultSpellCheckingLanguages;
gboolean autoLoadImages, autoShrinkImages, printBackgrounds,
enableScripts, enablePlugins, enableDeveloperExtras, resizableTextAreas,
enablePrivateBrowsing, enableCaretBrowsing, enableHTML5Database, enableHTML5LocalStorage,
enableXSSAuditor, enableSpatialNavigation, enableFrameFlattening, javascriptCanOpenWindows,
javaScriptCanAccessClipboard, enableOfflineWebAppCache,
enableUniversalAccessFromFileURI, enableFileAccessFromFileURI,
enableDOMPaste, tabKeyCyclesThroughElements, enableWebGL,
enableSiteSpecificQuirks, usePageCache, enableJavaApplet,
        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;

WebKitEditingBehavior editingBehavior;

g_object_get(webSettings,
""default-encoding"", &defaultEncoding,
""cursive-font-family"", &cursiveFontFamily,
""default-font-family"", &defaultFontFamily,
""fantasy-font-family"", &fantasyFontFamily,
""monospace-font-family"", &monospaceFontFamily,
""sans-serif-font-family"", &sansSerifFontFamily,
""serif-font-family"", &serifFontFamily,
""auto-load-images"", &autoLoadImages,
""auto-shrink-images"", &autoShrinkImages,
""print-backgrounds"", &printBackgrounds,
""enable-scripts"", &enableScripts,
""enable-plugins"", &enablePlugins,
""resizable-text-areas"", &resizableTextAreas,
""user-stylesheet-uri"", &userStylesheetUri,
""enable-developer-extras"", &enableDeveloperExtras,
""enable-private-browsing"", &enablePrivateBrowsing,
""enable-caret-browsing"", &enableCaretBrowsing,
""enable-html5-database"", &enableHTML5Database,
""enable-html5-local-storage"", &enableHTML5LocalStorage,
""enable-xss-auditor"", &enableXSSAuditor,
""enable-spatial-navigation"", &enableSpatialNavigation,
""enable-frame-flattening"", &enableFrameFlattening,
""javascript-can-open-windows-automatically"", &javascriptCanOpenWindows,
""javascript-can-access-clipboard"", &javaScriptCanAccessClipboard,
""enable-offline-web-application-cache"", &enableOfflineWebAppCache,
""editing-behavior"", &editingBehavior,
""enable-universal-access-from-file-uris"", &enableUniversalAccessFromFileURI,
""enable-file-access-from-file-uris"", &enableFileAccessFromFileURI,
""enable-dom-paste"", &enableDOMPaste,
""tab-key-cycles-through-elements"", &tabKeyCyclesThroughElements,
""enable-site-specific-quirks"", &enableSiteSpecificQuirks,
""enable-page-cache"", &usePageCache,
""enable-java-applet"", &enableJavaApplet,
""enable-hyperlink-auditing"", &enableHyperlinkAuditing,
""spell-checking-languages"", &defaultSpellCheckingLanguages,
""enable-fullscreen"", &enableFullscreen,
""enable-dns-prefetching"", &enableDNSPrefetching,
""enable-webgl"", &enableWebGL,
NULL);

settings->setDefaultTextEncodingName(defaultEncoding);
settings->setCursiveFontFamily(cursiveFontFamily);
settings->setStandardFontFamily(defaultFontFamily);
settings->setFantasyFontFamily(fantasyFontFamily);
settings->setFixedFontFamily(monospaceFontFamily);
settings->setSansSerifFontFamily(sansSerifFontFamily);
settings->setSerifFontFamily(serifFontFamily);
settings->setLoadsImagesAutomatically(autoLoadImages);
settings->setShrinksStandaloneImagesToFit(autoShrinkImages);
settings->setShouldPrintBackgrounds(printBackgrounds);
settings->setJavaScriptEnabled(enableScripts);
settings->setPluginsEnabled(enablePlugins);
settings->setTextAreasAreResizable(resizableTextAreas);
settings->setUserStyleSheetLocation(KURL(KURL(), userStylesheetUri));
settings->setDeveloperExtrasEnabled(enableDeveloperExtras);
settings->setPrivateBrowsingEnabled(enablePrivateBrowsing);
settings->setCaretBrowsingEnabled(enableCaretBrowsing);
#if ENABLE(DATABASE)
AbstractDatabase::setIsAvailable(enableHTML5Database);
#endif
settings->setLocalStorageEnabled(enableHTML5LocalStorage);
settings->setXSSAuditorEnabled(enableXSSAuditor);
settings->setSpatialNavigationEnabled(enableSpatialNavigation);
settings->setFrameFlatteningEnabled(enableFrameFlattening);
settings->setJavaScriptCanOpenWindowsAutomatically(javascriptCanOpenWindows);
settings->setJavaScriptCanAccessClipboard(javaScriptCanAccessClipboard);
settings->setOfflineWebApplicationCacheEnabled(enableOfflineWebAppCache);
settings->setEditingBehaviorType(static_cast<WebCore::EditingBehaviorType>(editingBehavior));
settings->setAllowUniversalAccessFromFileURLs(enableUniversalAccessFromFileURI);
settings->setAllowFileAccessFromFileURLs(enableFileAccessFromFileURI);
settings->setDOMPasteAllowed(enableDOMPaste);
settings->setNeedsSiteSpecificQuirks(enableSiteSpecificQuirks);
settings->setUsesPageCache(usePageCache);
settings->setJavaEnabled(enableJavaApplet);
settings->setHyperlinkAuditingEnabled(enableHyperlinkAuditing);
settings->setDNSPrefetchingEnabled(enableDNSPrefetching);

#if ENABLE(FULLSCREEN_API)
settings->setFullScreenEnabled(enableFullscreen);
#endif

#if ENABLE(SPELLCHECK)
    WebKit::EditorClient* client = static_cast<WebKit::EditorClient*>(core(webView)->editorClient());
    static_cast<WebKit::TextCheckerClientEnchant*>(client->textChecker())->updateSpellCheckingLanguage(defaultSpellCheckingLanguages);
#endif

#if ENABLE(WEBGL)
settings->setWebGLEnabled(enableWebGL);
#endif

Page* page = core(webView);
if (page)
page->setTabKeyCyclesThroughElements(tabKeyCyclesThroughElements);

g_free(defaultEncoding);
g_free(cursiveFontFamily);
g_free(defaultFontFamily);
g_free(fantasyFontFamily);
g_free(monospaceFontFamily);
g_free(sansSerifFontFamily);
g_free(serifFontFamily);
g_free(userStylesheetUri);

webkit_web_view_screen_changed(GTK_WIDGET(webView), NULL);
}
",[14],"        enableHyperlinkAuditing, enableFullscreen, enableDNSPrefetching;/~/    WebKit::EditorClient* client = static_cast<WebKit::EditorClient*>(core(webView)->editorClient());/~/    static_cast<WebKit::TextCheckerClientEnchant*>(client->textChecker())->updateSpellCheckingLanguage(defaultSpellCheckingLanguages);"
619,"status_t MediaPlayer::setDataSource(
const sp<IMediaHTTPService> &httpService,
const char *url, const KeyedVector<String8, String8> *headers)
{

ALOGV(""setDataSource(%s)"", url);
status_t err = BAD_VALUE;
if (url != NULL) {
        const sp<IMediaPlayerService>& service(getMediaPlayerService());
if (service != 0) {
sp<IMediaPlayer> player(service->create(this, mAudioSessionId));
if ((NO_ERROR != doSetRetransmitEndpoint(player)) ||
(NO_ERROR != player->setDataSource(httpService, url, headers))) {
player.clear();
}
err = attachNewPlayer(player);
}
}
return err;
}
",[7],        const sp<IMediaPlayerService>& service(getMediaPlayerService());
620,"static int zrle_send_framebuffer_update(VncState *vs, int x, int y,
int w, int h)
{
    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);
size_t bytes;
int zywrle_level;

if (vs->zrle.type == VNC_ENCODING_ZYWRLE) {
if (!vs->vd->lossy || vs->tight.quality == (uint8_t)-1
|| vs->tight.quality == 9) {
zywrle_level = 0;
vs->zrle.type = VNC_ENCODING_ZRLE;
} else if (vs->tight.quality < 3) {
zywrle_level = 3;
} else if (vs->tight.quality < 6) {
zywrle_level = 2;
} else {
zywrle_level = 1;
}
} else {
zywrle_level = 0;
}

vnc_zrle_start(vs);

    switch(vs->clientds.pf.bytes_per_pixel) {
case 1:
zrle_encode_8ne(vs, x, y, w, h, zywrle_level);
break;

case 2:
        if (vs->clientds.pf.gmax > 0x1F) {
if (be) {
zrle_encode_16be(vs, x, y, w, h, zywrle_level);
} else {
zrle_encode_16le(vs, x, y, w, h, zywrle_level);
}
} else {
if (be) {
zrle_encode_15be(vs, x, y, w, h, zywrle_level);
} else {
zrle_encode_15le(vs, x, y, w, h, zywrle_level);
}
}
break;

case 4:
{
bool fits_in_ls3bytes;
bool fits_in_ms3bytes;

fits_in_ls3bytes =
            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&
             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&
             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));

        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&
                            vs->clientds.pf.gshift > 7 &&
                            vs->clientds.pf.bshift > 7);

if ((fits_in_ls3bytes && !be) || (fits_in_ms3bytes && be)) {
if (be) {
zrle_encode_24abe(vs, x, y, w, h, zywrle_level);
} else {
zrle_encode_24ale(vs, x, y, w, h, zywrle_level);
}
} else if ((fits_in_ls3bytes && be) || (fits_in_ms3bytes && !be)) {
if (be) {
zrle_encode_24bbe(vs, x, y, w, h, zywrle_level);
} else {
zrle_encode_24ble(vs, x, y, w, h, zywrle_level);
}
} else {
if (be) {
zrle_encode_32be(vs, x, y, w, h, zywrle_level);
} else {
zrle_encode_32le(vs, x, y, w, h, zywrle_level);
}
}
}
break;
}

vnc_zrle_stop(vs);
bytes = zrle_compress_data(vs, Z_DEFAULT_COMPRESSION);
vnc_framebuffer_update(vs, x, y, w, h, vs->zrle.type);
vnc_write_u32(vs, bytes);
vnc_write(vs, vs->zrle.zlib.buffer, vs->zrle.zlib.offset);
return 1;
}
","[3, 22, 27]",    bool be = !!(vs->clientds.flags & QEMU_BIG_ENDIAN_FLAG);/~/    switch(vs->clientds.pf.bytes_per_pixel) {/~/        if (vs->clientds.pf.gmax > 0x1F) {/~/            ((vs->clientds.pf.rmax << vs->clientds.pf.rshift) < (1 << 24) &&/~/             (vs->clientds.pf.gmax << vs->clientds.pf.gshift) < (1 << 24) &&/~/             (vs->clientds.pf.bmax << vs->clientds.pf.bshift) < (1 << 24));/~/        fits_in_ms3bytes = (vs->clientds.pf.rshift > 7 &&/~/                            vs->clientds.pf.gshift > 7 &&/~/                            vs->clientds.pf.bshift > 7);
621,"void WebPluginDelegateImpl::SendJavaScriptStream(const GURL& url,
const std::string& result,
bool success,
                                                 bool notify_needed,
                                                 intptr_t notify_data) {
  instance()->SendJavaScriptStream(url, result, success, notify_needed,
                                   notify_data);
}
","[3, 4, 5, 6]","                                                 bool notify_needed,/~/                                                 intptr_t notify_data) {/~/  instance()->SendJavaScriptStream(url, result, success, notify_needed,/~/                                   notify_data);"
622,"const CuePoint* Cues::GetLast() const {
  if (m_cue_points == NULL)
return NULL;

  if (m_count <= 0)
    return NULL;
#if 0
    LoadCuePoint();  //init cues
    const size_t count = m_count + m_preload_count;
    if (count == 0)  //weird
        return NULL;
    const size_t index = count - 1;
    CuePoint* const* const pp = m_cue_points;
    assert(pp);
    CuePoint* const pCP = pp[index];
    assert(pCP);
    pCP->Load(m_pSegment->m_pReader);
    assert(pCP->GetTimeCode() >= 0);
#else
const long index = m_count - 1;

CuePoint* const* const pp = m_cue_points;
  assert(pp);

CuePoint* const pCP = pp[index];
  assert(pCP);
  assert(pCP->GetTimeCode() >= 0);
#endif

return pCP;
}
","[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 19, 20, 21, 22, 23, 24]",  if (m_cue_points == NULL)/~/  if (m_count <= 0)/~/    return NULL;/~/#if 0/~/    LoadCuePoint();  //init cues/~/    const size_t count = m_count + m_preload_count;/~/    if (count == 0)  //weird/~/        return NULL;/~/    const size_t index = count - 1;/~/    CuePoint* const* const pp = m_cue_points;/~/    assert(pp);/~/    CuePoint* const pCP = pp[index];/~/    assert(pCP);/~/    pCP->Load(m_pSegment->m_pReader);/~/    assert(pCP->GetTimeCode() >= 0);/~/#else/~/  assert(pp);/~/  assert(pCP);/~/  assert(pCP->GetTimeCode() >= 0);/~/#endif
623,"string16 ExtensionGlobalError::GenerateMessageSection(
const ExtensionIdSet* extensions,
int template_message_id) {
CHECK(extensions);
CHECK(template_message_id);
string16 message;

for (ExtensionIdSet::const_iterator iter = extensions->begin();
iter != extensions->end(); ++iter) {
const Extension* e = extension_service_->GetExtensionById(*iter, true);
    message += l10n_util::GetStringFUTF16(
        template_message_id,
        string16(ASCIIToUTF16(e->name())),
        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));
}
return message;
}
","[9, 10, 11, 12]","    message += l10n_util::GetStringFUTF16(/~/        template_message_id,/~/        string16(ASCIIToUTF16(e->name())),/~/        l10n_util::GetStringUTF16(IDS_SHORT_PRODUCT_NAME));"
624,"long AudioTrack::Parse(Segment* pSegment, const Info& info,
long long element_start, long long element_size,
AudioTrack*& pResult) {
if (pResult)
return -1;

if (info.type != Track::kAudio)
return -1;

IMkvReader* const pReader = pSegment->m_pReader;

const Settings& s = info.settings;
assert(s.start >= 0);
assert(s.size >= 0);

long long pos = s.start;
assert(pos >= 0);

const long long stop = pos + s.size;

double rate = 8000.0; // MKV default
long long channels = 1;
long long bit_depth = 0;

while (pos < stop) {
long long id, size;

long status = ParseElementHeader(pReader, pos, stop, id, size);

if (status < 0) // error
return status;

if (id == 0x35) { // Sample Rate
status = UnserializeFloat(pReader, pos, size, rate);

if (status < 0)
return status;

if (rate <= 0)
return E_FILE_FORMAT_INVALID;
} else if (id == 0x1F) { // Channel Count
channels = UnserializeUInt(pReader, pos, size);

if (channels <= 0)
return E_FILE_FORMAT_INVALID;
} else if (id == 0x2264) { // Bit Depth
bit_depth = UnserializeUInt(pReader, pos, size);

if (bit_depth <= 0)
return E_FILE_FORMAT_INVALID;

}

pos += size;  // consume payload
    assert(pos <= stop);
}

  assert(pos == stop);

AudioTrack* const pTrack =
new (std::nothrow) AudioTrack(pSegment, element_start, element_size);

if (pTrack == NULL)
return -1; // generic error

const int status = info.Copy(pTrack->m_info);

if (status) {
delete pTrack;
return status;
}

pTrack->m_rate = rate;
pTrack->m_channels = channels;
pTrack->m_bitDepth = bit_depth;

pResult = pTrack;
return 0; // success
}
","[38, 40]",    assert(pos <= stop);/~/  assert(pos == stop);
625,"NaClProcessHost::NaClProcessHost(const GURL& manifest_url, bool off_the_record)
: manifest_url_(manifest_url),
#if defined(OS_WIN)
process_launched_by_broker_(false),
#elif defined(OS_LINUX)
wait_for_nacl_gdb_(false),
#endif
reply_msg_(NULL),
#if defined(OS_WIN)
debug_exception_handler_requested_(false),
#endif
internal_(new NaClInternal()),
ALLOW_THIS_IN_INITIALIZER_LIST(weak_factory_(this)),
enable_exception_handling_(false),
off_the_record_(off_the_record) {
process_.reset(content::BrowserChildProcessHost::Create(
content::PROCESS_TYPE_NACL_LOADER, this));

// Set the display name so the user knows what plugin the process is running.
// We aren't on the UI thread so getting the pref locale for language
// formatting isn't possible, so IDN will be lost, but this is probably OK
// for this use case.
process_->SetName(net::FormatUrl(manifest_url_, std::string()));

// We allow untrusted hardware exception handling to be enabled via
// an env var for consistency with the standalone build of NaCl.
if (CommandLine::ForCurrentProcess()->HasSwitch(
switches::kEnableNaClExceptionHandling) ||
getenv(""NACL_UNTRUSTED_EXCEPTION_HANDLING"") != NULL) {
enable_exception_handling_ = true;
}
  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(
      switches::kEnableNaClIPCProxy);
}
","[29, 30]",  enable_ipc_proxy_ = CommandLine::ForCurrentProcess()->HasSwitch(/~/      switches::kEnableNaClIPCProxy);
626,"write_png(const char **name, FILE *fp, int color_type, int bit_depth,
volatile png_fixed_point gamma, chunk_insert * volatile insert,
   unsigned int filters, unsigned int *colors)
{
png_structp png_ptr = png_create_write_struct(PNG_LIBPNG_VER_STRING,
name, makepng_error, makepng_warning);
volatile png_infop info_ptr = NULL;
volatile png_bytep row = NULL;

if (png_ptr == NULL)
{
fprintf(stderr, ""makepng: OOM allocating write structure\n"");
return 1;
}

if (setjmp(png_jmpbuf(png_ptr)))
{
png_structp nv_ptr = png_ptr;
png_infop nv_info = info_ptr;

png_ptr = NULL;
info_ptr = NULL;
png_destroy_write_struct(&nv_ptr, &nv_info);
if (row != NULL) free(row);
return 1;
}


/* Allow benign errors so that we can write PNGs with errors */
png_set_benign_errors(png_ptr, 1/*allowed*/);
png_init_io(png_ptr, fp);

info_ptr = png_create_info_struct(png_ptr);
if (info_ptr == NULL)

png_error(png_ptr, ""OOM allocating info structure"");

{
      unsigned int size = image_size_of_type(color_type, bit_depth, colors);
png_fixed_point real_gamma = 45455; /* For sRGB */
png_byte gamma_table[256];
double conv;

/* This function uses the libpng values used on read to carry extra
* information about the gamma:
*/
if (gamma == PNG_GAMMA_MAC_18)
gamma = 65909;

else if (gamma > 0 && gamma < 1000)
gamma = PNG_FP_1;

if (gamma > 0)
real_gamma = gamma;

{
unsigned int i;

if (real_gamma == 45455) for (i=0; i<256; ++i)
{
gamma_table[i] = (png_byte)i;
conv = 1.;
}

else
{
/* Convert 'i' from sRGB (45455) to real_gamma, this makes
* the images look the same regardless of the gAMA chunk.
*/
conv = real_gamma;
conv /= 45455;


gamma_table[0] = 0;

for (i=1; i<255; ++i)
               gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5);

gamma_table[255] = 255;
}
}

      png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type,
PNG_INTERLACE_NONE, PNG_COMPRESSION_TYPE_BASE, PNG_FILTER_TYPE_BASE);

if (color_type & PNG_COLOR_MASK_PALETTE)
{
int npalette;
png_color palette[256];
png_byte trans[256];


npalette = generate_palette(palette, trans, bit_depth, gamma_table,
colors);
png_set_PLTE(png_ptr, info_ptr, palette, npalette);
         png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,
            NULL/*transparent color*/);

/* Reset gamma_table to prevent the image rows being changed */
for (npalette=0; npalette<256; ++npalette)
gamma_table[npalette] = (png_byte)npalette;
}

if (gamma == PNG_DEFAULT_sRGB)
png_set_sRGB(png_ptr, info_ptr, PNG_sRGB_INTENT_ABSOLUTE);

else if (gamma > 0) /* Else don't set color space information */
{
png_set_gAMA_fixed(png_ptr, info_ptr, real_gamma);

/* Just use the sRGB values here. */
png_set_cHRM_fixed(png_ptr, info_ptr,
/* color      x       y */
/* white */ 31270, 32900,
/* red   */ 64000, 33000,
/* green */ 30000, 60000,
/* blue  */ 15000, 6000
);
}

/* Insert extra information. */
while (insert != NULL)
{
insert->insert(png_ptr, info_ptr, insert->nparams, insert->parameters);
insert = insert->next;
}

/* Write the file header. */
png_write_info(png_ptr, info_ptr);

/* Restrict the filters */

png_set_filter(png_ptr, PNG_FILTER_TYPE_BASE, filters);

{
         int passes = png_set_interlace_handling(png_ptr);
int pass;
png_size_t rowbytes = png_get_rowbytes(png_ptr, info_ptr);

row = malloc(rowbytes);

if (row == NULL)
png_error(png_ptr, ""OOM allocating row buffer"");

for (pass = 0; pass < passes; ++pass)

{
unsigned int y;

            for (y=0; y<size; ++y)
{
               generate_row(row, rowbytes, y, color_type, bit_depth,
                  gamma_table, conv, colors);
png_write_row(png_ptr, row);
}
}
}
}

/* Finish writing the file. */
png_write_end(png_ptr, info_ptr);

{
png_structp nv_ptr = png_ptr;
png_infop nv_info = info_ptr;

png_ptr = NULL;
info_ptr = NULL;
png_destroy_write_struct(&nv_ptr, &nv_info);
}
free(row);
return 0;
}
","[2, 30]","   unsigned int filters, unsigned int *colors)/~/      unsigned int size = image_size_of_type(color_type, bit_depth, colors);/~/               gamma_table[i] = (png_byte)floor(pow(i/255.,conv) * 255 + .5);/~/      png_set_IHDR(png_ptr, info_ptr, size, size, bit_depth, color_type,/~/         png_set_tRNS(png_ptr, info_ptr, trans, npalette-1,/~/            NULL/*transparent color*/);/~/         int passes = png_set_interlace_handling(png_ptr);/~/            for (y=0; y<size; ++y)/~/               generate_row(row, rowbytes, y, color_type, bit_depth,/~/                  gamma_table, conv, colors);"
627,"virtual void SetUpCommandLine(CommandLine* command_line) {
    GpuFeatureTest::SetUpCommandLine(command_line);
    command_line->AppendSwitch(switches::kEnableThreadedCompositing);
  }
","[1, 2, 3]",    GpuFeatureTest::SetUpCommandLine(command_line);/~/    command_line->AppendSwitch(switches::kEnableThreadedCompositing);/~/  }
