[
    {
        "code": "void console_unlock(void)\n{\n\tunsigned long flags;\n\tunsigned _con_start, _log_end;\n\tunsigned wake_klogd = 0, retry = 0;\n\tif (console_suspended) {\n\t\tup(&console_sem);\n\t\treturn;\n\t}\n\tconsole_may_schedule = 0;\nagain:\n\tfor ( ; ; ) {\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\twake_klogd |= log_start - log_end;\n\t\tif (con_start == log_end)\n\t\t\tbreak;\t\t\t/* Nothing to print */\n\t\t_con_start = con_start;\n\t\t_log_end = log_end;\n\t\tcon_start = log_end;\t\t/* Flush */\n\t\traw_spin_unlock(&logbuf_lock);\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(_con_start, _log_end);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\t/* Release the exclusive_console once it is used */\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = NULL;\n\traw_spin_unlock(&logbuf_lock);\n\tup(&console_sem);\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tif (con_start != log_end)\n\t\tretry = 1;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\tif (retry && console_trylock())\n\t\tgoto again;\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}",
        "bug_line_number": [
            1,
            2,
            3,
            4,
            5,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            21,
            22,
            38,
            39,
            40
        ],
        "vul": 1,
        "id": 0
    },
    {
        "code": "asmlinkage int printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n#ifdef CONFIG_KGDB_KDB\n\tif (unlikely(kdb_trap_printk)) {\n\t\tva_start(args, fmt);\n\t\tr = vkdb_printf(fmt, args);\n\t\tva_end(args);\n\t\treturn r;\n\t}\n#endif\n\tva_start(args, fmt);\n\tr = vprintk(fmt, args);\n\tva_end(args);\n\treturn r;\n}",
        "bug_line_number": [
            13,
            14
        ],
        "vul": 1,
        "id": 2
    },
    {
        "code": "static ssize_t kmsg_writev(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   unsigned long count, loff_t pos)\n{\n\tchar *line, *p;\n\tint i;\n\tssize_t ret = -EFAULT;\n\tsize_t len = iov_length(iv, count);\n\tline = kmalloc(len + 1, GFP_KERNEL);\n\tif (line == NULL)\n\t\treturn -ENOMEM;\n\t/*\n\t * copy all vectors into a single string, to ensure we do\n\t * not interleave our log line with other printk calls\n\t */\n\tp = line;\n\tfor (i = 0; i < count; i++) {\n\t\tif (copy_from_user(p, iv[i].iov_base, iv[i].iov_len))\n\t\t\tgoto out;\n\t\tp += iv[i].iov_len;\n\t}\n\tp[0] = '\\0';\n\tret = printk(\"%s\", line);\n\t/* printk can add a prefix */\n\tif (ret > len)\n\t\tret = len;\nout:\n\tkfree(line);\n\treturn ret;\n}",
        "bug_line_number": [
            3,
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27
        ],
        "vul": 1,
        "id": 4
    },
    {
        "code": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tunsigned start, dest_idx, offset;\n\tchar *new_log_buf;\n\tint free;\n\tif (!new_log_buf_len)\n\t\treturn;\n\tif (early) {\n\t\tunsigned long mem;\n\t\tmem = memblock_alloc(new_log_buf_len, PAGE_SIZE);\n\t\tif (!mem)\n\t\t\treturn;\n\t\tnew_log_buf = __va(mem);\n\t} else {\n\t\tnew_log_buf = alloc_bootmem_nopanic(new_log_buf_len);\n\t}\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %ld bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_end;\n\toffset = start = min(con_start, log_start);\n\tdest_idx = 0;\n\twhile (start != log_end) {\n\t\tunsigned log_idx_mask = start & (__LOG_BUF_LEN - 1);\n\t\tlog_buf[dest_idx] = __log_buf[log_idx_mask];\n\t\tstart++;\n\t\tdest_idx++;\n\t}\n\tlog_start -= offset;\n\tcon_start -= offset;\n\tlog_end -= offset;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\tpr_info(\"log_buf_len: %d\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %d(%d%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
        "bug_line_number": [
            3,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34,
            35,
            36,
            37,
            38
        ],
        "vul": 1,
        "id": 6
    },
    {
        "code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\nretry:\n\t/* Prepare to wait on uaddr. */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\tif (!unqueue_me(&q))\n\t\tgoto out_put_key;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out_put_key;\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current)) {\n\t\tput_futex_key(fshared, &q.key);\n\t\tgoto retry;\n\t}\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out_put_key;\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\tret = -ERESTART_RESTARTBLOCK;\nout_put_key:\n\tput_futex_key(fshared, &q.key);\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [
            23,
            24,
            30,
            31,
            32,
            33,
            35,
            36,
            40,
            41,
            42,
            43,
            46,
            47,
            59,
            60
        ],
        "vul": 1,
        "id": 8
    },
    {
        "code": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 17 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}",
        "bug_line_number": [
            3,
            4
        ],
        "vul": 1,
        "id": 10
    },
    {
        "code": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
        "bug_line_number": [
            14,
            15
        ],
        "vul": 1,
        "id": 12
    },
    {
        "code": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tstruct mmu_notifier_range range;\n\tpmd_t *old_pmd, *new_pmd;\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,\n\t\t\t\told_addr, old_end);\n\tmmu_notifier_invalidate_range_start(&range);\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t} else if (extent == PMD_SIZE) {\n#ifdef CONFIG_HAVE_MOVE_PMD\n\t\t\t/*\n\t\t\t * If the extent is PMD-sized, try to speed the move by\n\t\t\t * moving at the PMD level if possible.\n\t\t\t */\n\t\t\tbool moved;\n\t\t\tif (need_rmap_locks)\n\t\t\t\ttake_rmap_locks(vma);\n\t\t\tmoved = move_normal_pmd(vma, old_addr, new_addr,\n\t\t\t\t\told_end, old_pmd, new_pmd);\n\t\t\tif (need_rmap_locks)\n\t\t\t\tdrop_rmap_locks(vma);\n\t\t\tif (moved)\n\t\t\t\tcontinue;\n#endif\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\tmmu_notifier_invalidate_range_end(&range);\n\treturn len + old_addr - old_end;\t/* how much done */\n}",
        "bug_line_number": [
            26,
            27
        ],
        "vul": 1,
        "id": 14
    },
    {
        "code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\t/* cannot select disc or select current disc */\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif ((unsigned int)arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}",
        "bug_line_number": [
            11,
            12
        ],
        "vul": 1,
        "id": 16
    },
    {
        "code": "\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\t\t\tkfree(caps.buf);\n\t\t}\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tu8 *data = NULL;\n\t\tint ret = 0;\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\t\tif (!(hdr.flags & VFIO_IRQ_SET_DATA_NONE)) {\n\t\t\tsize_t size;\n\t\t\tint max = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\t\tif (hdr.flags & VFIO_IRQ_SET_DATA_BOOL)\n\t\t\t\tsize = sizeof(uint8_t);\n\t\t\telse if (hdr.flags & VFIO_IRQ_SET_DATA_EVENTFD)\n\t\t\t\tsize = sizeof(int32_t);\n\t\t\telse\n\t\t\t\treturn -EINVAL;\n\t\t\tif (hdr.argsz - minsz < hdr.count * size ||\n\t\t\t    hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\t\treturn -EINVAL;\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\t\tmutex_lock(&vdev->igate);\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\t\treturn ret;\n\t} else if (cmd == VFIO_DEVICE_RESET) {\n\t\treturn vdev->reset_works ?\n\t\t\tpci_try_reset_function(vdev->pdev) : -EINVAL;\n\t} else if (cmd == VFIO_DEVICE_GET_PCI_HOT_RESET_INFO) {\n\t\tstruct vfio_pci_hot_reset_info hdr;\n\t\tstruct vfio_pci_fill_info fill = { 0 };\n\t\tstruct vfio_pci_dependent_device *devices = NULL;\n\t\tbool slot = false;",
        "bug_line_number": [
            53,
            54,
            55,
            56,
            59,
            60,
            63,
            64,
            65,
            66,
            67,
            68,
            69,
            70,
            71,
            72,
            73,
            74
        ],
        "vul": 1,
        "id": 18
    },
    {
        "code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}",
        "bug_line_number": [
            6,
            7
        ],
        "vul": 1,
        "id": 20
    },
    {
        "code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf)\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
        "bug_line_number": [
            50,
            51,
            52
        ],
        "vul": 1,
        "id": 22
    },
    {
        "code": "\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\tcase SO_SNDTIMEO:\n\t\tlv = sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\tcase SO_PASSCRED:\n\t\tv.val = test_bit(SOCK_PASSCRED, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\tcase SO_PASSSEC:\n\t\tv.val = test_bit(SOCK_PASSSEC, &sock->flags) ? 1 : 0;\n\t\tbreak;\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\tcase SO_RXQ_OVFL:\n\t\tv.val = !!sock_flag(sk, SOCK_RXQ_OVFL);\n\t\tbreak;\n\tcase SO_WIFI_STATUS:\n\t\tv.val = !!sock_flag(sk, SOCK_WIFI_STATUS);\n\t\tbreak;\n\tcase SO_PEEK_OFF:\n\t\tif (!sock->ops->set_peek_off)\n\t\t\treturn -EOPNOTSUPP;\n\t\tv.val = sk->sk_peek_off;\n\t\tbreak;\n\tcase SO_NOFCS:\n\t\tv.val = !!sock_flag(sk, SOCK_NOFCS);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "bug_line_number": [
            24,
            25,
            54,
            55
        ],
        "vul": 1,
        "id": 24
    },
    {
        "code": "static int\nsmbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tint rc;\n\tunsigned char key2[8];\n\tstruct crypto_skcipher *tfm_des;\n\tstruct scatterlist sgin, sgout;\n\tstruct skcipher_request *req;\n\tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_skcipher(\"ecb(des)\", 0, CRYPTO_ALG_ASYNC);\n\tif (IS_ERR(tfm_des)) {\n\t\trc = PTR_ERR(tfm_des);\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_err;\n\t}\n\treq = skcipher_request_alloc(tfm_des, GFP_KERNEL);\n\tif (!req) {\n\t\trc = -ENOMEM;\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\tgoto smbhash_free_skcipher;\n\t}\n\tcrypto_skcipher_setkey(tfm_des, key2, 8);\n\tsg_init_one(&sgin, in, 8);\n\tsg_init_one(&sgout, out, 8);\n\tskcipher_request_set_callback(req, 0, NULL, NULL);\n\tskcipher_request_set_crypt(req, &sgin, &sgout, 8, NULL);\n\trc = crypto_skcipher_encrypt(req);\n\tif (rc)\n\t\tcifs_dbg(VFS, \"could not encrypt crypt key rc: %d\\n\", rc);\n\tskcipher_request_free(req);\nsmbhash_free_skcipher:\n\tcrypto_free_skcipher(tfm_des);\nsmbhash_err:\n\treturn rc;\n}",
        "bug_line_number": [
            3,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23,
            24,
            25,
            26,
            27,
            28,
            29,
            30,
            31,
            32,
            33,
            34
        ],
        "vul": 1,
        "id": 26
    },
    {
        "code": "static int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\tvoid *c;\n\tif (desc->bLength < sizeof(*desc))\n\t\treturn -EINVAL;\n\tif (!desc->bNrInPins)\n\t\treturn -EINVAL;\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0; /* no bmControls -> skip */\n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\tif (!mu_channels)\n\t\treturn 0;\n\tc = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\tif (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength)\n\t\treturn 0; /* no bmControls -> skip */\n\treturn mu_channels;\n}",
        "bug_line_number": [
            7,
            8
        ],
        "vul": 1,
        "id": 28
    },
    {
        "code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen) {\n\t\tbase = maxlen;\n\t\tmaxlen = 0;\n\t} else\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
        "bug_line_number": [
            9,
            10,
            11,
            12,
            13
        ],
        "vul": 1,
        "id": 30
    },
    {
        "code": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct dj_receiver_dev *djrcv_dev;\n\tint retval;\n\tif (is_dj_device((struct dj_device *)hdev->driver_data))\n\t\treturn -ENODEV;\n\tdbg_hid(\"%s called for ifnum %d\\n\", __func__,\n\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t/* Ignore interfaces 0 and 1, they will not carry any data, dont create\n\t * any hid_device for them */\n\tif (intf->cur_altsetting->desc.bInterfaceNumber !=\n\t    LOGITECH_DJ_INTERFACE_NUMBER) {\n\t\tdbg_hid(\"%s: ignoring ifnum %d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\treturn -ENODEV;\n\t}\n\t/* Treat interface 2 */\n\tdjrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);\n\tif (!djrcv_dev) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating dj_receiver_dev\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdjrcv_dev->hdev = hdev;\n\tINIT_WORK(&djrcv_dev->work, delayedwork_callback);\n\tspin_lock_init(&djrcv_dev->lock);\n\tif (kfifo_alloc(&djrcv_dev->notif_fifo,\n\t\t\tDJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),\n\t\t\tGFP_KERNEL)) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating notif_fifo\\n\", __func__);\n\t\tkfree(djrcv_dev);\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, djrcv_dev);\n\t/* Call  to usbhid to fetch the HID descriptors of interface 2 and\n\t * subsequently call to the hid/hid-core to parse the fetched\n\t * descriptors, this will in turn create the hidraw and hiddev nodes\n\t * for interface 2 of the receiver */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:parse of interface 2 failed\\n\", __func__);\n\t\tgoto hid_parse_fail;\n\t}\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto switch_to_dj_mode_fail;\n\t}\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:logi_dj_recv_query_paired_devices \"\n\t\t\t\"error:%d\\n\", __func__, retval);\n\t\tgoto logi_dj_recv_query_paired_devices_failed;\n\t}\n\treturn retval;\nlogi_dj_recv_query_paired_devices_failed:\n\thid_hw_close(hdev);\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\nhid_hw_start_fail:\nhid_parse_fail:\n\tkfifo_free(&djrcv_dev->notif_fifo);\n\tkfree(djrcv_dev);\n\thid_set_drvdata(hdev, NULL);\n\treturn retval;\n}",
        "bug_line_number": [
            44,
            45
        ],
        "vul": 1,
        "id": 32
    },
    {
        "code": "static int airspy_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct airspy *s;\n\tint ret;\n\tu8 u8tmp, buf[BUF_SIZE];\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\n\tif (s == NULL) {\n\t\tdev_err(&intf->dev, \"Could not allocate memory for state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmutex_init(&s->v4l2_lock);\n\tmutex_init(&s->vb_queue_lock);\n\tspin_lock_init(&s->queued_bufs_lock);\n\tINIT_LIST_HEAD(&s->queued_bufs);\n\ts->dev = &intf->dev;\n\ts->udev = interface_to_usbdev(intf);\n\ts->f_adc = bands[0].rangelow;\n\ts->f_rf = bands_rf[0].rangelow;\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\t/* Detect device */\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not detect board\\n\");\n\t\tgoto err_free_mem;\n\t}\n\tbuf[BUF_SIZE - 1] = '\\0';\n\tdev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);\n\tdev_info(s->dev, \"Firmware version: %s\\n\", buf);\n\t/* Init videobuf2 queue structure */\n\ts->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\ts->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\ts->vb_queue.drv_priv = s;\n\ts->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\n\ts->vb_queue.ops = &airspy_vb2_ops;\n\ts->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\ts->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&s->vb_queue);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_free_mem;\n\t}\n\t/* Init video_device structure */\n\ts->vdev = airspy_template;\n\ts->vdev.queue = &s->vb_queue;\n\ts->vdev.queue->lock = &s->vb_queue_lock;\n\tvideo_set_drvdata(&s->vdev, s);\n\t/* Register the v4l2_device structure */\n\ts->v4l2_dev.release = airspy_video_release;\n\tret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\t/* Register controls */\n\tv4l2_ctrl_handler_init(&s->hdl, 5);\n\ts->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\n\ts->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\n\ts->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\n\ts->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\n\ts->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\n\tif (s->hdl.error) {\n\t\tret = s->hdl.error;\n\t\tdev_err(s->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_free_controls;\n\t}\n\tv4l2_ctrl_handler_setup(&s->hdl);\n\ts->v4l2_dev.ctrl_handler = &s->hdl;\n\ts->vdev.v4l2_dev = &s->v4l2_dev;\n\ts->vdev.lock = &s->v4l2_lock;\n\tret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\n\t\t\t\tret);\n\t\tgoto err_unregister_v4l2_dev;\n\t}\n\tdev_info(s->dev, \"Registered as %s\\n\",\n\t\t\tvideo_device_node_name(&s->vdev));\n\tdev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&s->hdl);\nerr_unregister_v4l2_dev:\n\tv4l2_device_unregister(&s->v4l2_dev);\nerr_free_mem:\n\tkfree(s);\n\treturn ret;\n}",
        "bug_line_number": [
            85,
            86,
            93
        ],
        "vul": 1,
        "id": 34
    },
    {
        "code": "static void\nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%d,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}",
        "bug_line_number": [
            4,
            5
        ],
        "vul": 1,
        "id": 36
    },
    {
        "code": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kmalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\tq->bufs[first]->baddr = vma->vm_start;\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\tvideobuf_vm_open(vma);\n\treturn (0);\n}",
        "bug_line_number": [
            25,
            26
        ],
        "vul": 1,
        "id": 38
    },
    {
        "code": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_ip6t_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ipv6, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\tt = compat_ip6t_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET6, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [
            31,
            32
        ],
        "vul": 1,
        "id": 40
    },
    {
        "code": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\tret = xt_compat_check_entry_offsets(e,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [
            31,
            32
        ],
        "vul": 1,
        "id": 42
    },
    {
        "code": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->target_offset, e->next_offset);\n\tif (err)\n\t\treturn err;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "bug_line_number": [
            25,
            26
        ],
        "vul": 1,
        "id": 44
    },
    {
        "code": "static int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config hconf = {\n\t\t.byte_order = 0x0000beef,\n\t};\n\tstruct gs_device_config dconf;\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     &hconf,\n\t\t\t     sizeof(hconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     &dconf,\n\t\t\t     sizeof(dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\ticount = dconf.icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\treturn -EINVAL;\n\t}\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev)\n\t\treturn -ENOMEM;\n\tinit_usb_anchor(&dev->rx_submitted);\n\tatomic_set(&dev->active_channels, 0);\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, &dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\treturn 0;\n}",
        "bug_line_number": [
            6,
            7,
            8,
            9,
            10,
            17,
            18,
            19,
            20,
            24,
            25,
            32,
            33,
            34,
            37,
            38,
            40,
            41,
            45,
            46,
            49,
            50,
            51,
            56,
            57,
            64,
            65,
            69,
            70
        ],
        "vul": 1,
        "id": 46
    },
    {
        "code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}",
        "bug_line_number": [
            14,
            15
        ],
        "vul": 1,
        "id": 48
    },
    {
        "code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size);\n\t\t\tgoto unmap_pages;\n\t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
        "bug_line_number": [
            39,
            40,
            50,
            51
        ],
        "vul": 1,
        "id": 50
    },
    {
        "code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
        "bug_line_number": [
            10,
            11
        ],
        "vul": 1,
        "id": 52
    },
    {
        "code": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n\t\t/* Expect four bytes of prefix, and N*9 bytes of touch data. */\n\t\tif (size < 4 || ((size - 4) % 9) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 4) / 9;\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\t\tclicks = data[1];\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;\n\t\t */\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n\t\t/* Expect six bytes of prefix, and N*8 bytes of touch data. */\n\t\tif (size < 6 || ((size - 6) % 8) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 6) / 8;\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\t\t/* When emulating three-button mode, it is important\n\t\t * to have the current touch information before\n\t\t * generating a click event.\n\t\t */\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;\n\t\t */\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\t/* Sometimes the trackpad sends two touch reports in one\n\t\t * packet.\n\t\t */\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */\n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\tinput_sync(input);\n\treturn 1;\n}",
        "bug_line_number": [
            11,
            12,
            26,
            27
        ],
        "vul": 1,
        "id": 54
    },
    {
        "code": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);",
        "bug_line_number": [
            104,
            105
        ],
        "vul": 1,
        "id": 56
    },
    {
        "code": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ctx_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);",
        "bug_line_number": [
            64,
            65
        ],
        "vul": 1,
        "id": 58
    },
    {
        "code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn (pmd_flags(pte) & (_PAGE_PSE | _PAGE_PRESENT)) ==\n\t\t(_PAGE_PSE | _PAGE_PRESENT);\n}",
        "bug_line_number": [
            2,
            3,
            4
        ],
        "vul": 1,
        "id": 60
    },
    {
        "code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}",
        "bug_line_number": [
            8,
            9
        ],
        "vul": 1,
        "id": 62
    },
    {
        "code": "static int __driver_rfc4106_decrypt(struct aead_request *req)\n{\n\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\t__be32 counter = cpu_to_be32(1);\n\tint retval = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n\tu32 key_len = ctx->aes_key_expanded.key_length;\n\tvoid *aes_ctx = &(ctx->aes_key_expanded);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 iv_and_authTag[32+AESNI_ALIGN];\n\tu8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);\n\tu8 *authTag = iv + 16;\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk assoc_sg_walk;\n\tstruct scatter_walk dst_sg_walk;\n\tunsigned int i;\n\tif (unlikely((req->cryptlen < auth_tag_len) ||\n\t\t(req->assoclen != 8 && req->assoclen != 12)))\n\t\treturn -EINVAL;\n\tif (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))\n\t        return -EINVAL;\n\tif (unlikely(key_len != AES_KEYSIZE_128 &&\n\t             key_len != AES_KEYSIZE_192 &&\n\t             key_len != AES_KEYSIZE_256))\n\t        return -EINVAL;\n\t/* Assuming we are supporting rfc4106 64-bit extended */\n\t/* sequence numbers We need to have the AAD length */\n\t/* equal to 8 or 12 bytes */\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\t/* IV below built */\n\tfor (i = 0; i < 4; i++)\n\t\t*(iv+i) = ctx->nonce[i];\n\tfor (i = 0; i < 8; i++)\n\t\t*(iv+4+i) = req->iv[i];\n\t*((__be32 *)(iv+12)) = counter;\n\tif ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tscatterwalk_start(&assoc_sg_walk, req->assoc);\n\t\tsrc = scatterwalk_map(&src_sg_walk);\n\t\tassoc = scatterwalk_map(&assoc_sg_walk);\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk);\n\t\t}\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n\t\tsrc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n\t\tif (!src)\n\t\t\treturn -ENOMEM;\n\t\tassoc = (src + req->cryptlen + auth_tag_len);\n\t\tscatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n\t\tscatterwalk_map_and_copy(assoc, req->assoc, 0,\n\t\t\treq->assoclen, 0);\n\t\tdst = src;\n\t}\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\tctx->hash_subkey, assoc, (unsigned long)req->assoclen,\n\t\tauthTag, auth_tag_len);\n\t/* Compare generated tag with passed in tag. */\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst);\n\t\t\tscatterwalk_done(&dst_sg_walk, 0, 0);\n\t\t}\n\t\tscatterwalk_unmap(src);\n\t\tscatterwalk_unmap(assoc);\n\t\tscatterwalk_done(&src_sg_walk, 0, 0);\n\t\tscatterwalk_done(&assoc_sg_walk, 0, 0);\n\t} else {\n\t\tscatterwalk_map_and_copy(dst, req->dst, 0, req->cryptlen, 1);\n\t\tkfree(src);\n\t}\n\treturn retval;\n}",
        "bug_line_number": [
            54,
            55,
            76,
            77
        ],
        "vul": 1,
        "id": 64
    },
    {
        "code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = *data++;\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}",
        "bug_line_number": [
            5,
            6
        ],
        "vul": 1,
        "id": 66
    },
    {
        "code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tu8 obuf[] = {0xde, 0};\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tstate->initialized = 1;\n\t\t/* reset board */\n\t\treturn dvb_usb_generic_rw(d, obuf, 2, NULL, 0, 0);\n\t}\n\treturn 0;\n}",
        "bug_line_number": [
            3,
            4,
            5,
            6,
            8,
            9,
            10,
            11
        ],
        "vul": 1,
        "id": 68
    },
    {
        "code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}",
        "bug_line_number": [
            17,
            18
        ],
        "vul": 1,
        "id": 70
    },
    {
        "code": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;",
        "bug_line_number": [
            5,
            6
        ],
        "vul": 1,
        "id": 72
    },
    {
        "code": "\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tmemcpy((void *)lp->StationName, (void *)&pLtv->u.u8[2], (size_t)pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;",
        "bug_line_number": [
            2,
            3
        ],
        "vul": 1,
        "id": 72
    },
    {
        "code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->arp))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "bug_line_number": [
            4,
            5
        ],
        "vul": 1,
        "id": 74
    },
    {
        "code": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(&e->ipv6))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "bug_line_number": [
            4,
            5
        ],
        "vul": 1,
        "id": 76
    },
    {
        "code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_err(\"Underflows must be unconditional and \"\n\t\t\t\t       \"use the STANDARD target with \"\n\t\t\t\t       \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "bug_line_number": [
            33,
            34,
            35,
            36
        ],
        "vul": 1,
        "id": 78
    },
    {
        "code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}",
        "bug_line_number": [
            2,
            3
        ],
        "vul": 1,
        "id": 80
    },
    {
        "code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar data[8];\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\treturn -EIO;\n\t}\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\treturn -EIO;\n\t}\n\treturn snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\n}",
        "bug_line_number": [
            7,
            8,
            16,
            17,
            28,
            29,
            30,
            31
        ],
        "vul": 1,
        "id": 82
    },
    {
        "code": "static int steelseries_srws1_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint ret, i;\n\tstruct led_classdev *led;\n\tsize_t name_sz;\n\tchar *name;\n\tstruct steelseries_srws1_data *drv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);\n\tif (drv_data == NULL) {\n\t\thid_err(hdev, \"can't alloc SRW-S1 memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, drv_data);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\t/* register led subsystem */\n\tdrv_data->led_state = 0;\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++)\n\t\tdrv_data->led[i] = NULL;\n\tsteelseries_srws1_set_leds(hdev, 0);\n\tname_sz = strlen(hdev->uniq) + 16;\n\t/* 'ALL', for setting all LEDs simultaneously */\n\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\tif (!led) {\n\t\thid_err(hdev, \"can't allocate memory for LED ALL\\n\");\n\t\tgoto err_led;\n\t}\n\tname = (void *)(&led[1]);\n\tsnprintf(name, name_sz, \"SRWS1::%s::RPMALL\", hdev->uniq);\n\tled->name = name;\n\tled->brightness = 0;\n\tled->max_brightness = 1;\n\tled->brightness_get = steelseries_srws1_led_all_get_brightness;\n\tled->brightness_set = steelseries_srws1_led_all_set_brightness;\n\tdrv_data->led[SRWS1_NUMBER_LEDS] = led;\n\tret = led_classdev_register(&hdev->dev, led);\n\tif (ret)\n\t\tgoto err_led;\n\t/* Each individual LED */\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS; i++) {\n\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\thid_err(hdev, \"can't allocate memory for LED %d\\n\", i);\n\t\t\tgoto err_led;\n\t\t}\n\t\tname = (void *)(&led[1]);\n\t\tsnprintf(name, name_sz, \"SRWS1::%s::RPM%d\", hdev->uniq, i+1);\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_get = steelseries_srws1_led_get_brightness;\n\t\tled->brightness_set = steelseries_srws1_led_set_brightness;\n\t\tdrv_data->led[i] = led;\n\t\tret = led_classdev_register(&hdev->dev, led);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"failed to register LED %d. Aborting.\\n\", i);\nerr_led:\n\t\t\t/* Deregister all LEDs (if any) */\n\t\t\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++) {\n\t\t\t\tled = drv_data->led[i];\n\t\t\t\tdrv_data->led[i] = NULL;\n\t\t\t\tif (!led)\n\t\t\t\t\tcontinue;\n\t\t\t\tled_classdev_unregister(led);\n\t\t\t\tkfree(led);\n\t\t\t}\n\t\t\tgoto out;\t/* but let the driver continue without LEDs */\n\t\t}\n\t}\nout:\n\treturn 0;\nerr_free:\n\tkfree(drv_data);\n\treturn ret;\n}",
        "bug_line_number": [
            15,
            16
        ],
        "vul": 1,
        "id": 84
    },
    {
        "code": "\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\tcork->length += length;\n\tif (length > mtu) {\n\t\tint proto = sk->sk_protocol;\n\t\tif (dontfrag && (proto == IPPROTO_UDP || proto == IPPROTO_RAW)){\n\t\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\t\treturn -EMSGSIZE;\n\t\t}\n\t\tif (proto == IPPROTO_UDP &&\n\t\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\t\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\t\tif (err)\n\t\t\t\tgoto error;\n\t\t\treturn 0;\n\t\t}\n\t}\n\tif ((skb = skb_peek_tail(&sk->sk_write_queue)) == NULL)\n\t\tgoto alloc_new_skb;\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\t\t\tskb_prev = skb;\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\t\t\talloclen += dst_exthdrlen;\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +",
        "bug_line_number": [
            4,
            5,
            6,
            7,
            8,
            9,
            10,
            11,
            12,
            13,
            14,
            15,
            16,
            17,
            18,
            19,
            20,
            21,
            22,
            23
        ],
        "vul": 1,
        "id": 86
    },
    {
        "code": "void console_unlock(void)\n{\n\tstatic u64 seen_seq;\n\tunsigned long flags;\n\tbool wake_klogd = false;\n\tbool retry;\n\tif (console_suspended) {\n\t\tup(&console_sem);\n\t\treturn;\n\t}\n\tconsole_may_schedule = 0;\nagain:\n\tfor (;;) {\n\t\tstruct log *msg;\n\t\tstatic char text[LOG_LINE_MAX];\n\t\tsize_t len;\n\t\tint level;\n\t\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\t\tif (seen_seq != log_next_seq) {\n\t\t\twake_klogd = true;\n\t\t\tseen_seq = log_next_seq;\n\t\t}\n\t\tif (console_seq < log_first_seq) {\n\t\t\t/* messages are gone, move to first one */\n\t\t\tconsole_seq = log_first_seq;\n\t\t\tconsole_idx = log_first_idx;\n\t\t}\n\t\tif (console_seq == log_next_seq)\n\t\t\tbreak;\n\t\tmsg = log_from_idx(console_idx);\n\t\tlevel = msg->level & 7;\n\t\tlen = msg->text_len;\n\t\tif (len+1 >= sizeof(text))\n\t\t\tlen = sizeof(text)-1;\n\t\tmemcpy(text, log_text(msg), len);\n\t\ttext[len++] = '\\n';\n\t\tconsole_idx = log_next(console_idx);\n\t\tconsole_seq++;\n\t\traw_spin_unlock(&logbuf_lock);\n\t\tstop_critical_timings();\t/* don't trace print latency */\n\t\tcall_console_drivers(level, text, len);\n\t\tstart_critical_timings();\n\t\tlocal_irq_restore(flags);\n\t}\n\tconsole_locked = 0;\n\t/* Release the exclusive_console once it is used */\n\tif (unlikely(exclusive_console))\n\t\texclusive_console = NULL;\n\traw_spin_unlock(&logbuf_lock);\n\tup(&console_sem);\n\t/*\n\t * Someone could have filled up the buffer again, so re-check if there's\n\t * something to flush. In case we cannot trylock the console_sem again,\n\t * there's a new owner and the console_unlock() from them will do the\n\t * flush, no worries.\n\t */\n\traw_spin_lock(&logbuf_lock);\n\tretry = console_seq != log_next_seq;\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\tif (retry && console_trylock())\n\t\tgoto again;\n\tif (wake_klogd)\n\t\twake_up_klogd();\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 1
    },
    {
        "code": "asmlinkage int printk(const char *fmt, ...)\n{\n\tva_list args;\n\tint r;\n#ifdef CONFIG_KGDB_KDB\n\tif (unlikely(kdb_trap_printk)) {\n\t\tva_start(args, fmt);\n\t\tr = vkdb_printf(fmt, args);\n\t\tva_end(args);\n\t\treturn r;\n\t}\n#endif\n\tva_start(args, fmt);\n\tr = vprintk_emit(0, -1, NULL, 0, fmt, args);\n\tva_end(args);\n\treturn r;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 3
    },
    {
        "code": "static ssize_t kmsg_writev(struct kiocb *iocb, const struct iovec *iv,\n\t\t\t   unsigned long count, loff_t pos)\n{\n\tchar *buf, *line;\n\tint i;\n\tint level = default_message_loglevel;\n\tint facility = 1;\t/* LOG_USER */\n\tsize_t len = iov_length(iv, count);\n\tssize_t ret = len;\n\tif (len > 1024)\n\t\treturn -EINVAL;\n\tbuf = kmalloc(len+1, GFP_KERNEL);\n\tif (buf == NULL)\n\t\treturn -ENOMEM;\n\tline = buf;\n\tfor (i = 0; i < count; i++) {\n\t\tif (copy_from_user(line, iv[i].iov_base, iv[i].iov_len))\n\t\t\tgoto out;\n\t\tline += iv[i].iov_len;\n\t}\n\t/*\n\t * Extract and skip the syslog prefix <[0-9]*>. Coming from userspace\n\t * the decimal value represents 32bit, the lower 3 bit are the log\n\t * level, the rest are the log facility.\n\t *\n\t * If no prefix or no userspace facility is specified, we\n\t * enforce LOG_USER, to be able to reliably distinguish\n\t * kernel-generated messages from userspace-injected ones.\n\t */\n\tline = buf;\n\tif (line[0] == '<') {\n\t\tchar *endp = NULL;\n\t\ti = simple_strtoul(line+1, &endp, 10);\n\t\tif (endp && endp[0] == '>') {\n\t\t\tlevel = i & 7;\n\t\t\tif (i >> 3)\n\t\t\t\tfacility = i >> 3;\n\t\t\tendp++;\n\t\t\tlen -= endp - line;\n\t\t\tline = endp;\n\t\t}\n\t}\n\tline[len] = '\\0';\n\tprintk_emit(facility, level, NULL, 0, \"%s\", line);\nout:\n\tkfree(buf);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 5
    },
    {
        "code": "void __init setup_log_buf(int early)\n{\n\tunsigned long flags;\n\tchar *new_log_buf;\n\tint free;\n\tif (!new_log_buf_len)\n\t\treturn;\n\tif (early) {\n\t\tunsigned long mem;\n\t\tmem = memblock_alloc(new_log_buf_len, PAGE_SIZE);\n\t\tif (!mem)\n\t\t\treturn;\n\t\tnew_log_buf = __va(mem);\n\t} else {\n\t\tnew_log_buf = alloc_bootmem_nopanic(new_log_buf_len);\n\t}\n\tif (unlikely(!new_log_buf)) {\n\t\tpr_err(\"log_buf_len: %ld bytes not available\\n\",\n\t\t\tnew_log_buf_len);\n\t\treturn;\n\t}\n\traw_spin_lock_irqsave(&logbuf_lock, flags);\n\tlog_buf_len = new_log_buf_len;\n\tlog_buf = new_log_buf;\n\tnew_log_buf_len = 0;\n\tfree = __LOG_BUF_LEN - log_next_idx;\n\tmemcpy(log_buf, __log_buf, __LOG_BUF_LEN);\n\traw_spin_unlock_irqrestore(&logbuf_lock, flags);\n\tpr_info(\"log_buf_len: %d\\n\", log_buf_len);\n\tpr_info(\"early log buf free: %d(%d%%)\\n\",\n\t\tfree, (free * 100) / __LOG_BUF_LEN);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 7
    },
    {
        "code": "static int futex_wait(u32 __user *uaddr, int fshared,\n\t\t      u32 val, ktime_t *abs_time, u32 bitset, int clockrt)\n{\n\tstruct hrtimer_sleeper timeout, *to = NULL;\n\tstruct restart_block *restart;\n\tstruct futex_hash_bucket *hb;\n\tstruct futex_q q;\n\tint ret;\n\tif (!bitset)\n\t\treturn -EINVAL;\n\tq.pi_state = NULL;\n\tq.bitset = bitset;\n\tq.rt_waiter = NULL;\n\tq.requeue_pi_key = NULL;\n\tif (abs_time) {\n\t\tto = &timeout;\n\t\thrtimer_init_on_stack(&to->timer, clockrt ? CLOCK_REALTIME :\n\t\t\t\t      CLOCK_MONOTONIC, HRTIMER_MODE_ABS);\n\t\thrtimer_init_sleeper(to, current);\n\t\thrtimer_set_expires_range_ns(&to->timer, *abs_time,\n\t\t\t\t\t     current->timer_slack_ns);\n\t}\nretry:\n\t/*\n\t * Prepare to wait on uaddr. On success, holds hb lock and increments\n\t * q.key refs.\n\t */\n\tret = futex_wait_setup(uaddr, val, fshared, &q, &hb);\n\tif (ret)\n\t\tgoto out;\n\t/* queue_me and wait for wakeup, timeout, or a signal. */\n\tfutex_wait_queue_me(hb, &q, to);\n\t/* If we were woken (and unqueued), we succeeded, whatever. */\n\tret = 0;\n\t/* unqueue_me() drops q.key ref */\n\tif (!unqueue_me(&q))\n\t\tgoto out;\n\tret = -ETIMEDOUT;\n\tif (to && !to->task)\n\t\tgoto out;\n\t/*\n\t * We expect signal_pending(current), but we might be the\n\t * victim of a spurious wakeup as well.\n\t */\n\tif (!signal_pending(current))\n\t\tgoto retry;\n\tret = -ERESTARTSYS;\n\tif (!abs_time)\n\t\tgoto out;\n\trestart = &current_thread_info()->restart_block;\n\trestart->fn = futex_wait_restart;\n\trestart->futex.uaddr = (u32 *)uaddr;\n\trestart->futex.val = val;\n\trestart->futex.time = abs_time->tv64;\n\trestart->futex.bitset = bitset;\n\trestart->futex.flags = FLAGS_HAS_TIMEOUT;\n\tif (fshared)\n\t\trestart->futex.flags |= FLAGS_SHARED;\n\tif (clockrt)\n\t\trestart->futex.flags |= FLAGS_CLOCKRT;\n\tret = -ERESTART_RESTARTBLOCK;\nout:\n\tif (to) {\n\t\thrtimer_cancel(&to->timer);\n\t\tdestroy_hrtimer_on_stack(&to->timer);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 9
    },
    {
        "code": "static __u8 *ch_report_fixup(struct hid_device *hdev, __u8 *rdesc,\n\t\tunsigned int *rsize)\n{\n\tif (*rsize >= 18 && rdesc[11] == 0x3c && rdesc[12] == 0x02) {\n\t\thid_info(hdev, \"fixing up Cherry Cymotion report descriptor\\n\");\n\t\trdesc[11] = rdesc[16] = 0xff;\n\t\trdesc[12] = rdesc[17] = 0x03;\n\t}\n\treturn rdesc;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 11
    },
    {
        "code": "STATIC int\nxfs_attrlist_by_handle(\n\tstruct file\t\t*parfilp,\n\tvoid\t\t\t__user *arg)\n{\n\tint\t\t\terror = -ENOMEM;\n\tattrlist_cursor_kern_t\t*cursor;\n\txfs_fsop_attrlist_handlereq_t al_hreq;\n\tstruct dentry\t\t*dentry;\n\tchar\t\t\t*kbuf;\n\tif (!capable(CAP_SYS_ADMIN))\n\t\treturn -XFS_ERROR(EPERM);\n\tif (copy_from_user(&al_hreq, arg, sizeof(xfs_fsop_attrlist_handlereq_t)))\n\t\treturn -XFS_ERROR(EFAULT);\n\tif (al_hreq.buflen < sizeof(struct attrlist) ||\n\t    al_hreq.buflen > XATTR_LIST_MAX)\n\t\treturn -XFS_ERROR(EINVAL);\n\t/*\n\t * Reject flags, only allow namespaces.\n\t */\n\tif (al_hreq.flags & ~(ATTR_ROOT | ATTR_SECURE))\n\t\treturn -XFS_ERROR(EINVAL);\n\tdentry = xfs_handlereq_to_dentry(parfilp, &al_hreq.hreq);\n\tif (IS_ERR(dentry))\n\t\treturn PTR_ERR(dentry);\n\tkbuf = kmem_zalloc_large(al_hreq.buflen, KM_SLEEP);\n\tif (!kbuf)\n\t\tgoto out_dput;\n\tcursor = (attrlist_cursor_kern_t *)&al_hreq.pos;\n\terror = -xfs_attr_list(XFS_I(dentry->d_inode), kbuf, al_hreq.buflen,\n\t\t\t\t\tal_hreq.flags, cursor);\n\tif (error)\n\t\tgoto out_kfree;\n\tif (copy_to_user(al_hreq.buffer, kbuf, al_hreq.buflen))\n\t\terror = -EFAULT;\nout_kfree:\n\tkmem_free(kbuf);\nout_dput:\n\tdput(dentry);\n\treturn error;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 13
    },
    {
        "code": "unsigned long move_page_tables(struct vm_area_struct *vma,\n\t\tunsigned long old_addr, struct vm_area_struct *new_vma,\n\t\tunsigned long new_addr, unsigned long len,\n\t\tbool need_rmap_locks)\n{\n\tunsigned long extent, next, old_end;\n\tstruct mmu_notifier_range range;\n\tpmd_t *old_pmd, *new_pmd;\n\told_end = old_addr + len;\n\tflush_cache_range(vma, old_addr, old_end);\n\tmmu_notifier_range_init(&range, MMU_NOTIFY_UNMAP, 0, vma, vma->vm_mm,\n\t\t\t\told_addr, old_end);\n\tmmu_notifier_invalidate_range_start(&range);\n\tfor (; old_addr < old_end; old_addr += extent, new_addr += extent) {\n\t\tcond_resched();\n\t\tnext = (old_addr + PMD_SIZE) & PMD_MASK;\n\t\t/* even if next overflowed, extent below will be ok */\n\t\textent = next - old_addr;\n\t\tif (extent > old_end - old_addr)\n\t\t\textent = old_end - old_addr;\n\t\told_pmd = get_old_pmd(vma->vm_mm, old_addr);\n\t\tif (!old_pmd)\n\t\t\tcontinue;\n\t\tnew_pmd = alloc_new_pmd(vma->vm_mm, vma, new_addr);\n\t\tif (!new_pmd)\n\t\t\tbreak;\n\t\tif (is_swap_pmd(*old_pmd) || pmd_trans_huge(*old_pmd) || pmd_devmap(*old_pmd)) {\n\t\t\tif (extent == HPAGE_PMD_SIZE) {\n\t\t\t\tbool moved;\n\t\t\t\t/* See comment in move_ptes() */\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\ttake_rmap_locks(vma);\n\t\t\t\tmoved = move_huge_pmd(vma, old_addr, new_addr,\n\t\t\t\t\t\t    old_end, old_pmd, new_pmd);\n\t\t\t\tif (need_rmap_locks)\n\t\t\t\t\tdrop_rmap_locks(vma);\n\t\t\t\tif (moved)\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsplit_huge_pmd(vma, old_pmd, old_addr);\n\t\t\tif (pmd_trans_unstable(old_pmd))\n\t\t\t\tcontinue;\n\t\t} else if (extent == PMD_SIZE) {\n#ifdef CONFIG_HAVE_MOVE_PMD\n\t\t\t/*\n\t\t\t * If the extent is PMD-sized, try to speed the move by\n\t\t\t * moving at the PMD level if possible.\n\t\t\t */\n\t\t\tbool moved;\n\t\t\tif (need_rmap_locks)\n\t\t\t\ttake_rmap_locks(vma);\n\t\t\tmoved = move_normal_pmd(vma, old_addr, new_addr,\n\t\t\t\t\told_end, old_pmd, new_pmd);\n\t\t\tif (need_rmap_locks)\n\t\t\t\tdrop_rmap_locks(vma);\n\t\t\tif (moved)\n\t\t\t\tcontinue;\n#endif\n\t\t}\n\t\tif (pte_alloc(new_vma->vm_mm, new_pmd))\n\t\t\tbreak;\n\t\tnext = (new_addr + PMD_SIZE) & PMD_MASK;\n\t\tif (extent > next - new_addr)\n\t\t\textent = next - new_addr;\n\t\tmove_ptes(vma, old_pmd, old_addr, old_addr + extent, new_vma,\n\t\t\t  new_pmd, new_addr, need_rmap_locks);\n\t}\n\tmmu_notifier_invalidate_range_end(&range);\n\treturn len + old_addr - old_end;\t/* how much done */\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 15
    },
    {
        "code": "static int cdrom_ioctl_media_changed(struct cdrom_device_info *cdi,\n\t\tunsigned long arg)\n{\n\tstruct cdrom_changer_info *info;\n\tint ret;\n\tcd_dbg(CD_DO_IOCTL, \"entering CDROM_MEDIA_CHANGED\\n\");\n\tif (!CDROM_CAN(CDC_MEDIA_CHANGED))\n\t\treturn -ENOSYS;\n\t/* cannot select disc or select current disc */\n\tif (!CDROM_CAN(CDC_SELECT_DISC) || arg == CDSL_CURRENT)\n\t\treturn media_changed(cdi, 1);\n\tif (arg >= cdi->capacity)\n\t\treturn -EINVAL;\n\tinfo = kmalloc(sizeof(*info), GFP_KERNEL);\n\tif (!info)\n\t\treturn -ENOMEM;\n\tret = cdrom_read_mech_status(cdi, info);\n\tif (!ret)\n\t\tret = info->slots[arg].change;\n\tkfree(info);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 17
    },
    {
        "code": "\t\t\tret = region_type_cap(vdev, &caps,\n\t\t\t\t\t      vdev->region[i].type,\n\t\t\t\t\t      vdev->region[i].subtype);\n\t\t\tif (ret)\n\t\t\t\treturn ret;\n\t\t}\n\t\tif (caps.size) {\n\t\t\tinfo.flags |= VFIO_REGION_INFO_FLAG_CAPS;\n\t\t\tif (info.argsz < sizeof(info) + caps.size) {\n\t\t\t\tinfo.argsz = sizeof(info) + caps.size;\n\t\t\t\tinfo.cap_offset = 0;\n\t\t\t} else {\n\t\t\t\tvfio_info_cap_shift(&caps, sizeof(info));\n\t\t\t\tif (copy_to_user((void __user *)arg +\n\t\t\t\t\t\t  sizeof(info), caps.buf,\n\t\t\t\t\t\t  caps.size)) {\n\t\t\t\t\tkfree(caps.buf);\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\t}\n\t\t\t\tinfo.cap_offset = sizeof(info);\n\t\t\t}\n\t\t\tkfree(caps.buf);\n\t\t}\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\t} else if (cmd == VFIO_DEVICE_GET_IRQ_INFO) {\n\t\tstruct vfio_irq_info info;\n\t\tminsz = offsetofend(struct vfio_irq_info, count);\n\t\tif (copy_from_user(&info, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\t\tif (info.argsz < minsz || info.index >= VFIO_PCI_NUM_IRQS)\n\t\t\treturn -EINVAL;\n\t\tswitch (info.index) {\n\t\tcase VFIO_PCI_INTX_IRQ_INDEX ... VFIO_PCI_MSIX_IRQ_INDEX:\n\t\tcase VFIO_PCI_REQ_IRQ_INDEX:\n\t\t\tbreak;\n\t\tcase VFIO_PCI_ERR_IRQ_INDEX:\n\t\t\tif (pci_is_pcie(vdev->pdev))\n\t\t\t\tbreak;\n\t\t/* pass thru to return error */\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tinfo.flags = VFIO_IRQ_INFO_EVENTFD;\n\t\tinfo.count = vfio_pci_get_irq_count(vdev, info.index);\n\t\tif (info.index == VFIO_PCI_INTX_IRQ_INDEX)\n\t\t\tinfo.flags |= (VFIO_IRQ_INFO_MASKABLE |\n\t\t\t\t       VFIO_IRQ_INFO_AUTOMASKED);\n\t\telse\n\t\t\tinfo.flags |= VFIO_IRQ_INFO_NORESIZE;\n\t\treturn copy_to_user((void __user *)arg, &info, minsz) ?\n\t\t\t-EFAULT : 0;\n\t} else if (cmd == VFIO_DEVICE_SET_IRQS) {\n\t\tstruct vfio_irq_set hdr;\n\t\tsize_t size;\n\t\tu8 *data = NULL;\n\t\tint max, ret = 0;\n\t\tminsz = offsetofend(struct vfio_irq_set, count);\n\t\tif (copy_from_user(&hdr, (void __user *)arg, minsz))\n\t\t\treturn -EFAULT;\n\t\tif (hdr.argsz < minsz || hdr.index >= VFIO_PCI_NUM_IRQS ||\n\t\t    hdr.count >= (U32_MAX - hdr.start) ||\n\t\t    hdr.flags & ~(VFIO_IRQ_SET_DATA_TYPE_MASK |\n\t\t\t\t  VFIO_IRQ_SET_ACTION_TYPE_MASK))\n\t\t\treturn -EINVAL;\n\t\tmax = vfio_pci_get_irq_count(vdev, hdr.index);\n\t\tif (hdr.start >= max || hdr.start + hdr.count > max)\n\t\t\treturn -EINVAL;\n\t\tswitch (hdr.flags & VFIO_IRQ_SET_DATA_TYPE_MASK) {\n\t\tcase VFIO_IRQ_SET_DATA_NONE:\n\t\t\tsize = 0;\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_BOOL:\n\t\t\tsize = sizeof(uint8_t);\n\t\t\tbreak;\n\t\tcase VFIO_IRQ_SET_DATA_EVENTFD:\n\t\t\tsize = sizeof(int32_t);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (size) {\n\t\t\tif (hdr.argsz - minsz < hdr.count * size)\n\t\t\t\treturn -EINVAL;\n\t\t\tdata = memdup_user((void __user *)(arg + minsz),\n\t\t\t\t\t   hdr.count * size);\n\t\t\tif (IS_ERR(data))\n\t\t\t\treturn PTR_ERR(data);\n\t\t}\n\t\tmutex_lock(&vdev->igate);\n\t\tret = vfio_pci_set_irqs_ioctl(vdev, hdr.flags, hdr.index,\n\t\t\t\t\t      hdr.start, hdr.count, data);\n\t\tmutex_unlock(&vdev->igate);\n\t\tkfree(data);\n\t\treturn ret;",
        "bug_line_number": [],
        "vul": 0,
        "id": 19
    },
    {
        "code": "int copy_creds(struct task_struct *p, unsigned long clone_flags)\n{\n#ifdef CONFIG_KEYS\n\tstruct thread_group_cred *tgcred;\n#endif\n\tstruct cred *new;\n\tint ret;\n\tp->replacement_session_keyring = NULL;\n\tif (\n#ifdef CONFIG_KEYS\n\t\t!p->cred->thread_keyring &&\n#endif\n\t\tclone_flags & CLONE_THREAD\n\t    ) {\n\t\tp->real_cred = get_cred(p->cred);\n\t\tget_cred(p->cred);\n\t\talter_cred_subscribers(p->cred, 2);\n\t\tkdebug(\"share_creds(%p{%d,%d})\",\n\t\t       p->cred, atomic_read(&p->cred->usage),\n\t\t       read_cred_subscribers(p->cred));\n\t\tatomic_inc(&p->cred->user->processes);\n\t\treturn 0;\n\t}\n\tnew = prepare_creds();\n\tif (!new)\n\t\treturn -ENOMEM;\n\tif (clone_flags & CLONE_NEWUSER) {\n\t\tret = create_user_ns(new);\n\t\tif (ret < 0)\n\t\t\tgoto error_put;\n\t}\n\t/* cache user_ns in cred.  Doesn't need a refcount because it will\n\t * stay pinned by cred->user\n\t */\n\tnew->user_ns = new->user->user_ns;\n#ifdef CONFIG_KEYS\n\t/* new threads get their own thread keyrings if their parent already\n\t * had one */\n\tif (new->thread_keyring) {\n\t\tkey_put(new->thread_keyring);\n\t\tnew->thread_keyring = NULL;\n\t\tif (clone_flags & CLONE_THREAD)\n\t\t\tinstall_thread_keyring_to_cred(new);\n\t}\n\t/* we share the process and session keyrings between all the threads in\n\t * a process - this is slightly icky as we violate COW credentials a\n\t * bit */\n\tif (!(clone_flags & CLONE_THREAD)) {\n\t\ttgcred = kmalloc(sizeof(*tgcred), GFP_KERNEL);\n\t\tif (!tgcred) {\n\t\t\tret = -ENOMEM;\n\t\t\tgoto error_put;\n\t\t}\n\t\tatomic_set(&tgcred->usage, 1);\n\t\tspin_lock_init(&tgcred->lock);\n\t\ttgcred->process_keyring = NULL;\n\t\ttgcred->session_keyring = key_get(new->tgcred->session_keyring);\n\t\trelease_tgcred(new);\n\t\tnew->tgcred = tgcred;\n\t}\n#endif\n\tatomic_inc(&new->user->processes);\n\tp->cred = p->real_cred = get_cred(new);\n\talter_cred_subscribers(new, 2);\n\tvalidate_creds(new);\n\treturn 0;\nerror_put:\n\tput_cred(new);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 21
    },
    {
        "code": "static ssize_t __nfs4_get_acl_uncached(struct inode *inode, void *buf, size_t buflen)\n{\n\tstruct page *pages[NFS4ACL_MAXPAGES] = {NULL, };\n\tstruct nfs_getaclargs args = {\n\t\t.fh = NFS_FH(inode),\n\t\t.acl_pages = pages,\n\t\t.acl_len = buflen,\n\t};\n\tstruct nfs_getaclres res = {\n\t\t.acl_len = buflen,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc = &nfs4_procedures[NFSPROC4_CLNT_GETACL],\n\t\t.rpc_argp = &args,\n\t\t.rpc_resp = &res,\n\t};\n\tunsigned int npages = DIV_ROUND_UP(buflen, PAGE_SIZE);\n\tint ret = -ENOMEM, i;\n\t/* As long as we're doing a round trip to the server anyway,\n\t * let's be prepared for a page of acl data. */\n\tif (npages == 0)\n\t\tnpages = 1;\n\tif (npages > ARRAY_SIZE(pages))\n\t\treturn -ERANGE;\n\tfor (i = 0; i < npages; i++) {\n\t\tpages[i] = alloc_page(GFP_KERNEL);\n\t\tif (!pages[i])\n\t\t\tgoto out_free;\n\t}\n\t/* for decoding across pages */\n\tres.acl_scratch = alloc_page(GFP_KERNEL);\n\tif (!res.acl_scratch)\n\t\tgoto out_free;\n\targs.acl_len = npages * PAGE_SIZE;\n\targs.acl_pgbase = 0;\n\tdprintk(\"%s  buf %p buflen %zu npages %d args.acl_len %zu\\n\",\n\t\t__func__, buf, buflen, npages, args.acl_len);\n\tret = nfs4_call_sync(NFS_SERVER(inode)->client, NFS_SERVER(inode),\n\t\t\t     &msg, &args.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\tgoto out_free;\n\t/* Handle the case where the passed-in buffer is too short */\n\tif (res.acl_flags & NFS4_ACL_TRUNC) {\n\t\t/* Did the user only issue a request for the acl length? */\n\t\tif (buf == NULL)\n\t\t\tgoto out_ok;\n\t\tret = -ERANGE;\n\t\tgoto out_free;\n\t}\n\tnfs4_write_cached_acl(inode, pages, res.acl_data_offset, res.acl_len);\n\tif (buf) {\n\t\tif (res.acl_len > buflen) {\n\t\t\tret = -ERANGE;\n\t\t\tgoto out_free;\n\t\t}\n\t\t_copy_from_pages(buf, pages, res.acl_data_offset, res.acl_len);\n\t}\nout_ok:\n\tret = res.acl_len;\nout_free:\n\tfor (i = 0; i < npages; i++)\n\t\tif (pages[i])\n\t\t\t__free_page(pages[i]);\n\tif (res.acl_scratch)\n\t\t__free_page(res.acl_scratch);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 23
    },
    {
        "code": "\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_rcvtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_rcvtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\tcase SO_SNDTIMEO:\n\t\tlv = sizeof(struct timeval);\n\t\tif (sk->sk_sndtimeo == MAX_SCHEDULE_TIMEOUT) {\n\t\t\tv.tm.tv_sec = 0;\n\t\t\tv.tm.tv_usec = 0;\n\t\t} else {\n\t\t\tv.tm.tv_sec = sk->sk_sndtimeo / HZ;\n\t\t\tv.tm.tv_usec = ((sk->sk_sndtimeo % HZ) * 1000000) / HZ;\n\t\t}\n\t\tbreak;\n\tcase SO_RCVLOWAT:\n\t\tv.val = sk->sk_rcvlowat;\n\t\tbreak;\n\tcase SO_SNDLOWAT:\n\t\tv.val = 1;\n\t\tbreak;\n\tcase SO_PASSCRED:\n\t\tv.val = !!test_bit(SOCK_PASSCRED, &sock->flags);\n\t\tbreak;\n\tcase SO_PEERCRED:\n\t{\n\t\tstruct ucred peercred;\n\t\tif (len > sizeof(peercred))\n\t\t\tlen = sizeof(peercred);\n\t\tcred_to_ucred(sk->sk_peer_pid, sk->sk_peer_cred, &peercred);\n\t\tif (copy_to_user(optval, &peercred, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\tcase SO_PEERNAME:\n\t{\n\t\tchar address[128];\n\t\tif (sock->ops->getname(sock, (struct sockaddr *)address, &lv, 2))\n\t\t\treturn -ENOTCONN;\n\t\tif (lv < len)\n\t\t\treturn -EINVAL;\n\t\tif (copy_to_user(optval, address, len))\n\t\t\treturn -EFAULT;\n\t\tgoto lenout;\n\t}\n\t/* Dubious BSD thing... Probably nobody even uses it, but\n\t * the UNIX standard wants it for whatever reason... -DaveM\n\t */\n\tcase SO_ACCEPTCONN:\n\t\tv.val = sk->sk_state == TCP_LISTEN;\n\t\tbreak;\n\tcase SO_PASSSEC:\n\t\tv.val = !!test_bit(SOCK_PASSSEC, &sock->flags);\n\t\tbreak;\n\tcase SO_PEERSEC:\n\t\treturn security_socket_getpeersec_stream(sock, optval, optlen, len);\n\tcase SO_MARK:\n\t\tv.val = sk->sk_mark;\n\t\tbreak;\n\tcase SO_RXQ_OVFL:\n\t\tv.val = !!sock_flag(sk, SOCK_RXQ_OVFL);\n\t\tbreak;\n\tcase SO_WIFI_STATUS:\n\t\tv.val = !!sock_flag(sk, SOCK_WIFI_STATUS);\n\t\tbreak;\n\tcase SO_PEEK_OFF:\n\t\tif (!sock->ops->set_peek_off)\n\t\t\treturn -EOPNOTSUPP;\n\t\tv.val = sk->sk_peek_off;\n\t\tbreak;\n\tcase SO_NOFCS:\n\t\tv.val = !!sock_flag(sk, SOCK_NOFCS);\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOPROTOOPT;\n\t}\n\tif (len > lv)\n\t\tlen = lv;\n\tif (copy_to_user(optval, &v, len))\n\t\treturn -EFAULT;\nlenout:\n\tif (put_user(len, optlen))\n\t\treturn -EFAULT;\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 25
    },
    {
        "code": "static int\nsmbhash(unsigned char *out, const unsigned char *in, unsigned char *key)\n{\n\tunsigned char key2[8];\n\tstruct crypto_cipher *tfm_des;\n\tstr_to_key(key, key2);\n\ttfm_des = crypto_alloc_cipher(\"des\", 0, 0);\n\tif (IS_ERR(tfm_des)) {\n\t\tcifs_dbg(VFS, \"could not allocate des crypto API\\n\");\n\t\treturn PTR_ERR(tfm_des);\n\t}\n\tcrypto_cipher_setkey(tfm_des, key2, 8);\n\tcrypto_cipher_encrypt_one(tfm_des, out, in);\n\tcrypto_free_cipher(tfm_des);\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 27
    },
    {
        "code": "static int uac_mixer_unit_get_channels(struct mixer_build *state,\n\t\t\t\t       struct uac_mixer_unit_descriptor *desc)\n{\n\tint mu_channels;\n\tvoid *c;\n\tif (desc->bLength < sizeof(*desc))\n\t\treturn -EINVAL;\n\tif (!desc->bNrInPins)\n\t\treturn -EINVAL;\n\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins)\n\t\treturn -EINVAL;\n\tswitch (state->mixer->protocol) {\n\tcase UAC_VERSION_1:\n\tcase UAC_VERSION_2:\n\tdefault:\n\t\tif (desc->bLength < sizeof(*desc) + desc->bNrInPins + 1)\n\t\t\treturn 0; /* no bmControls -> skip */\n\t\tmu_channels = uac_mixer_unit_bNrChannels(desc);\n\t\tbreak;\n\tcase UAC_VERSION_3:\n\t\tmu_channels = get_cluster_channels_v3(state,\n\t\t\t\tuac3_mixer_unit_wClusterDescrID(desc));\n\t\tbreak;\n\t}\n\tif (!mu_channels)\n\t\treturn 0;\n\tc = uac_mixer_unit_bmControls(desc, state->mixer->protocol);\n\tif (c - (void *)desc + (mu_channels - 1) / 8 >= desc->bLength)\n\t\treturn 0; /* no bmControls -> skip */\n\treturn mu_channels;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 29
    },
    {
        "code": "static unsigned int xdr_set_page_base(struct xdr_stream *xdr,\n\t\t\t\t      unsigned int base, unsigned int len)\n{\n\tunsigned int pgnr;\n\tunsigned int maxlen;\n\tunsigned int pgoff;\n\tunsigned int pgend;\n\tvoid *kaddr;\n\tmaxlen = xdr->buf->page_len;\n\tif (base >= maxlen)\n\t\treturn 0;\n\telse\n\t\tmaxlen -= base;\n\tif (len > maxlen)\n\t\tlen = maxlen;\n\txdr_stream_page_set_pos(xdr, base);\n\tbase += xdr->buf->page_base;\n\tpgnr = base >> PAGE_SHIFT;\n\txdr->page_ptr = &xdr->buf->pages[pgnr];\n\tkaddr = page_address(*xdr->page_ptr);\n\tpgoff = base & ~PAGE_MASK;\n\txdr->p = (__be32*)(kaddr + pgoff);\n\tpgend = pgoff + len;\n\tif (pgend > PAGE_SIZE)\n\t\tpgend = PAGE_SIZE;\n\txdr->end = (__be32*)(kaddr + pgend);\n\txdr->iov = NULL;\n\treturn len;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 31
    },
    {
        "code": "static int logi_dj_probe(struct hid_device *hdev,\n\t\t\t const struct hid_device_id *id)\n{\n\tstruct usb_interface *intf = to_usb_interface(hdev->dev.parent);\n\tstruct dj_receiver_dev *djrcv_dev;\n\tint retval;\n\tif (is_dj_device((struct dj_device *)hdev->driver_data))\n\t\treturn -ENODEV;\n\tdbg_hid(\"%s called for ifnum %d\\n\", __func__,\n\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t/* Ignore interfaces 0 and 1, they will not carry any data, dont create\n\t * any hid_device for them */\n\tif (intf->cur_altsetting->desc.bInterfaceNumber !=\n\t    LOGITECH_DJ_INTERFACE_NUMBER) {\n\t\tdbg_hid(\"%s: ignoring ifnum %d\\n\", __func__,\n\t\t\tintf->cur_altsetting->desc.bInterfaceNumber);\n\t\treturn -ENODEV;\n\t}\n\t/* Treat interface 2 */\n\tdjrcv_dev = kzalloc(sizeof(struct dj_receiver_dev), GFP_KERNEL);\n\tif (!djrcv_dev) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating dj_receiver_dev\\n\", __func__);\n\t\treturn -ENOMEM;\n\t}\n\tdjrcv_dev->hdev = hdev;\n\tINIT_WORK(&djrcv_dev->work, delayedwork_callback);\n\tspin_lock_init(&djrcv_dev->lock);\n\tif (kfifo_alloc(&djrcv_dev->notif_fifo,\n\t\t\tDJ_MAX_NUMBER_NOTIFICATIONS * sizeof(struct dj_report),\n\t\t\tGFP_KERNEL)) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:failed allocating notif_fifo\\n\", __func__);\n\t\tkfree(djrcv_dev);\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, djrcv_dev);\n\t/* Call  to usbhid to fetch the HID descriptors of interface 2 and\n\t * subsequently call to the hid/hid-core to parse the fetched\n\t * descriptors, this will in turn create the hidraw and hiddev nodes\n\t * for interface 2 of the receiver */\n\tretval = hid_parse(hdev);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:parse of interface 2 failed\\n\", __func__);\n\t\tgoto hid_parse_fail;\n\t}\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, REPORT_ID_DJ_SHORT,\n\t\t\t\t 0, DJREPORT_SHORT_LENGTH - 1)) {\n\t\tretval = -ENODEV;\n\t\tgoto hid_parse_fail;\n\t}\n\t/* Starts the usb device and connects to upper interfaces hiddev and\n\t * hidraw */\n\tretval = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (retval) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:hid_hw_start returned error\\n\", __func__);\n\t\tgoto hid_hw_start_fail;\n\t}\n\tretval = logi_dj_recv_switch_to_dj_mode(djrcv_dev, 0);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev,\n\t\t\t\"%s:logi_dj_recv_switch_to_dj_mode returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto switch_to_dj_mode_fail;\n\t}\n\t/* This is enabling the polling urb on the IN endpoint */\n\tretval = hid_hw_open(hdev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:hid_hw_open returned error:%d\\n\",\n\t\t\t__func__, retval);\n\t\tgoto llopen_failed;\n\t}\n\t/* Allow incoming packets to arrive: */\n\thid_device_io_start(hdev);\n\tretval = logi_dj_recv_query_paired_devices(djrcv_dev);\n\tif (retval < 0) {\n\t\tdev_err(&hdev->dev, \"%s:logi_dj_recv_query_paired_devices \"\n\t\t\t\"error:%d\\n\", __func__, retval);\n\t\tgoto logi_dj_recv_query_paired_devices_failed;\n\t}\n\treturn retval;\nlogi_dj_recv_query_paired_devices_failed:\n\thid_hw_close(hdev);\nllopen_failed:\nswitch_to_dj_mode_fail:\n\thid_hw_stop(hdev);\nhid_hw_start_fail:\nhid_parse_fail:\n\tkfifo_free(&djrcv_dev->notif_fifo);\n\tkfree(djrcv_dev);\n\thid_set_drvdata(hdev, NULL);\n\treturn retval;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 33
    },
    {
        "code": "static int airspy_probe(struct usb_interface *intf,\n\t\tconst struct usb_device_id *id)\n{\n\tstruct airspy *s;\n\tint ret;\n\tu8 u8tmp, buf[BUF_SIZE];\n\ts = kzalloc(sizeof(struct airspy), GFP_KERNEL);\n\tif (s == NULL) {\n\t\tdev_err(&intf->dev, \"Could not allocate memory for state\\n\");\n\t\treturn -ENOMEM;\n\t}\n\tmutex_init(&s->v4l2_lock);\n\tmutex_init(&s->vb_queue_lock);\n\tspin_lock_init(&s->queued_bufs_lock);\n\tINIT_LIST_HEAD(&s->queued_bufs);\n\ts->dev = &intf->dev;\n\ts->udev = interface_to_usbdev(intf);\n\ts->f_adc = bands[0].rangelow;\n\ts->f_rf = bands_rf[0].rangelow;\n\ts->pixelformat = formats[0].pixelformat;\n\ts->buffersize = formats[0].buffersize;\n\t/* Detect device */\n\tret = airspy_ctrl_msg(s, CMD_BOARD_ID_READ, 0, 0, &u8tmp, 1);\n\tif (ret == 0)\n\t\tret = airspy_ctrl_msg(s, CMD_VERSION_STRING_READ, 0, 0,\n\t\t\t\tbuf, BUF_SIZE);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not detect board\\n\");\n\t\tgoto err_free_mem;\n\t}\n\tbuf[BUF_SIZE - 1] = '\\0';\n\tdev_info(s->dev, \"Board ID: %02x\\n\", u8tmp);\n\tdev_info(s->dev, \"Firmware version: %s\\n\", buf);\n\t/* Init videobuf2 queue structure */\n\ts->vb_queue.type = V4L2_BUF_TYPE_SDR_CAPTURE;\n\ts->vb_queue.io_modes = VB2_MMAP | VB2_USERPTR | VB2_READ;\n\ts->vb_queue.drv_priv = s;\n\ts->vb_queue.buf_struct_size = sizeof(struct airspy_frame_buf);\n\ts->vb_queue.ops = &airspy_vb2_ops;\n\ts->vb_queue.mem_ops = &vb2_vmalloc_memops;\n\ts->vb_queue.timestamp_flags = V4L2_BUF_FLAG_TIMESTAMP_MONOTONIC;\n\tret = vb2_queue_init(&s->vb_queue);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Could not initialize vb2 queue\\n\");\n\t\tgoto err_free_mem;\n\t}\n\t/* Init video_device structure */\n\ts->vdev = airspy_template;\n\ts->vdev.queue = &s->vb_queue;\n\ts->vdev.queue->lock = &s->vb_queue_lock;\n\tvideo_set_drvdata(&s->vdev, s);\n\t/* Register the v4l2_device structure */\n\ts->v4l2_dev.release = airspy_video_release;\n\tret = v4l2_device_register(&intf->dev, &s->v4l2_dev);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register v4l2-device (%d)\\n\", ret);\n\t\tgoto err_free_mem;\n\t}\n\t/* Register controls */\n\tv4l2_ctrl_handler_init(&s->hdl, 5);\n\ts->lna_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN_AUTO, 0, 1, 1, 0);\n\ts->lna_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_LNA_GAIN, 0, 14, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->lna_gain_auto, 0, false);\n\ts->mixer_gain_auto = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN_AUTO, 0, 1, 1, 0);\n\ts->mixer_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_MIXER_GAIN, 0, 15, 1, 8);\n\tv4l2_ctrl_auto_cluster(2, &s->mixer_gain_auto, 0, false);\n\ts->if_gain = v4l2_ctrl_new_std(&s->hdl, &airspy_ctrl_ops,\n\t\t\tV4L2_CID_RF_TUNER_IF_GAIN, 0, 15, 1, 0);\n\tif (s->hdl.error) {\n\t\tret = s->hdl.error;\n\t\tdev_err(s->dev, \"Could not initialize controls\\n\");\n\t\tgoto err_free_controls;\n\t}\n\tv4l2_ctrl_handler_setup(&s->hdl);\n\ts->v4l2_dev.ctrl_handler = &s->hdl;\n\ts->vdev.v4l2_dev = &s->v4l2_dev;\n\ts->vdev.lock = &s->v4l2_lock;\n\tret = video_register_device(&s->vdev, VFL_TYPE_SDR, -1);\n\tif (ret) {\n\t\tdev_err(s->dev, \"Failed to register as video device (%d)\\n\",\n\t\t\t\tret);\n\t\tgoto err_free_controls;\n\t}\n\tdev_info(s->dev, \"Registered as %s\\n\",\n\t\t\tvideo_device_node_name(&s->vdev));\n\tdev_notice(s->dev, \"SDR API is still slightly experimental and functionality changes may follow\\n\");\n\treturn 0;\nerr_free_controls:\n\tv4l2_ctrl_handler_free(&s->hdl);\n\tv4l2_device_unregister(&s->v4l2_dev);\nerr_free_mem:\n\tkfree(s);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 35
    },
    {
        "code": "static void\nvideobuf_vm_open(struct vm_area_struct *vma)\n{\n\tstruct videobuf_mapping *map = vma->vm_private_data;\n\tdprintk(2,\"vm_open %p [count=%u,vma=%08lx-%08lx]\\n\",map,\n\t\tmap->count,vma->vm_start,vma->vm_end);\n\tmap->count++;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 37
    },
    {
        "code": "static int __videobuf_mmap_mapper(struct videobuf_queue *q,\n\t\t\t struct vm_area_struct *vma)\n{\n\tstruct videbuf_vmalloc_memory *mem;\n\tstruct videobuf_mapping *map;\n\tunsigned int first;\n\tint retval;\n\tunsigned long offset = vma->vm_pgoff << PAGE_SHIFT;\n\tif (! (vma->vm_flags & VM_WRITE) || ! (vma->vm_flags & VM_SHARED))\n\t\treturn -EINVAL;\n\t/* look for first buffer to map */\n\tfor (first = 0; first < VIDEO_MAX_FRAME; first++) {\n\t\tif (NULL == q->bufs[first])\n\t\t\tcontinue;\n\t\tif (V4L2_MEMORY_MMAP != q->bufs[first]->memory)\n\t\t\tcontinue;\n\t\tif (q->bufs[first]->boff == offset)\n\t\t\tbreak;\n\t}\n\tif (VIDEO_MAX_FRAME == first) {\n\t\tdprintk(1,\"mmap app bug: offset invalid [offset=0x%lx]\\n\",\n\t\t\t(vma->vm_pgoff << PAGE_SHIFT));\n\t\treturn -EINVAL;\n\t}\n\t/* create mapping + update buffer list */\n\tmap = q->bufs[first]->map = kzalloc(sizeof(struct videobuf_mapping),GFP_KERNEL);\n\tif (NULL == map)\n\t\treturn -ENOMEM;\n\tmap->start = vma->vm_start;\n\tmap->end   = vma->vm_end;\n\tmap->q     = q;\n\tq->bufs[first]->baddr = vma->vm_start;\n\tvma->vm_ops          = &videobuf_vm_ops;\n\tvma->vm_flags       |= VM_DONTEXPAND | VM_RESERVED;\n\tvma->vm_private_data = map;\n\tmem=q->bufs[first]->priv;\n\tBUG_ON (!mem);\n\tMAGIC_CHECK(mem->magic,MAGIC_VMAL_MEM);\n\t/* Try to remap memory */\n\tretval=remap_vmalloc_range(vma, mem->vmalloc,0);\n\tif (retval<0) {\n\t\tdprintk(1,\"mmap: postponing remap_vmalloc_range\\n\");\n\t\tmem->vma=kmalloc(sizeof(*vma),GFP_KERNEL);\n\t\tif (!mem->vma) {\n\t\t\tkfree(map);\n\t\t\tq->bufs[first]->map=NULL;\n\t\t\treturn -ENOMEM;\n\t\t}\n\t\tmemcpy(mem->vma,vma,sizeof(*vma));\n\t}\n\tdprintk(1,\"mmap %p: q=%p %08lx-%08lx (%lx) pgoff %08lx buf %d\\n\",\n\t\tmap,q,vma->vm_start,vma->vm_end,\n\t\t(long int) q->bufs[first]->bsize,\n\t\tvma->vm_pgoff,first);\n\tvideobuf_vm_open(vma);\n\treturn (0);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 39
    },
    {
        "code": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ip6t_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_ip6t_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct ip6t_entry) - sizeof(struct compat_ip6t_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ipv6, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\tt = compat_ip6t_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV6, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET6, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 41
    },
    {
        "code": "static int\ncheck_compat_entry_size_and_hooks(struct compat_ipt_entry *e,\n\t\t\t\t  struct xt_table_info *newinfo,\n\t\t\t\t  unsigned int *size,\n\t\t\t\t  const unsigned char *base,\n\t\t\t\t  const unsigned char *limit,\n\t\t\t\t  const unsigned int *hook_entries,\n\t\t\t\t  const unsigned int *underflows,\n\t\t\t\t  const char *name)\n{\n\tstruct xt_entry_match *ematch;\n\tstruct xt_entry_target *t;\n\tstruct xt_target *target;\n\tunsigned int entry_offset;\n\tunsigned int j;\n\tint ret, off, h;\n\tduprintf(\"check_compat_entry_size_and_hooks %p\\n\", e);\n\tif ((unsigned long)e % __alignof__(struct compat_ipt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct compat_ipt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p, limit = %p\\n\", e, limit);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset < sizeof(struct compat_ipt_entry) +\n\t\t\t     sizeof(struct compat_xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip_checkentry(&e->ip))\n\t\treturn -EINVAL;\n\tret = xt_compat_check_entry_offsets(e, e->elems,\n\t\t\t\t\t    e->target_offset, e->next_offset);\n\tif (ret)\n\t\treturn ret;\n\toff = sizeof(struct ipt_entry) - sizeof(struct compat_ipt_entry);\n\tentry_offset = (void *)e - (void *)base;\n\tj = 0;\n\txt_ematch_foreach(ematch, e) {\n\t\tret = compat_find_calc_match(ematch, name, &e->ip, &off);\n\t\tif (ret != 0)\n\t\t\tgoto release_matches;\n\t\t++j;\n\t}\n\tt = compat_ipt_get_target(e);\n\ttarget = xt_request_find_target(NFPROTO_IPV4, t->u.user.name,\n\t\t\t\t\tt->u.user.revision);\n\tif (IS_ERR(target)) {\n\t\tduprintf(\"check_compat_entry_size_and_hooks: `%s' not found\\n\",\n\t\t\t t->u.user.name);\n\t\tret = PTR_ERR(target);\n\t\tgoto release_matches;\n\t}\n\tt->u.kernel.target = target;\n\toff += xt_compat_target_offset(target);\n\t*size += off;\n\tret = xt_compat_add_offset(AF_INET, entry_offset, off);\n\tif (ret)\n\t\tgoto out;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h])\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t}\n\t/* Clear counters and comefrom */\n\tmemset(&e->counters, 0, sizeof(e->counters));\n\te->comefrom = 0;\n\treturn 0;\nout:\n\tmodule_put(t->u.kernel.target->me);\nrelease_matches:\n\txt_ematch_foreach(ematch, e) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tmodule_put(ematch->u.kernel.match->me);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 43
    },
    {
        "code": "static int\ncheck_entry_size_and_hooks(struct ip6t_entry *e,\n\t\t\t   struct xt_table_info *newinfo,\n\t\t\t   const unsigned char *base,\n\t\t\t   const unsigned char *limit,\n\t\t\t   const unsigned int *hook_entries,\n\t\t\t   const unsigned int *underflows,\n\t\t\t   unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct ip6t_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct ip6t_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct ip6t_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\tif (!ip6_checkentry(&e->ipv6))\n\t\treturn -EINVAL;\n\terr = xt_check_entry_offsets(e, e->elems, e->target_offset,\n\t\t\t\t     e->next_offset);\n\tif (err)\n\t\treturn err;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_INET_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 45
    },
    {
        "code": "static int gs_usb_probe(struct usb_interface *intf,\n\t\t\tconst struct usb_device_id *id)\n{\n\tstruct gs_usb *dev;\n\tint rc = -ENOMEM;\n\tunsigned int icount, i;\n\tstruct gs_host_config *hconf;\n\tstruct gs_device_config *dconf;\n\thconf = kmalloc(sizeof(*hconf), GFP_KERNEL);\n\tif (!hconf)\n\t\treturn -ENOMEM;\n\thconf->byte_order = 0x0000beef;\n\t/* send host config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_sndctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_HOST_FORMAT,\n\t\t\t     USB_DIR_OUT|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     hconf,\n\t\t\t     sizeof(*hconf),\n\t\t\t     1000);\n\tkfree(hconf);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't send data format (err=%d)\\n\",\n\t\t\trc);\n\t\treturn rc;\n\t}\n\tdconf = kmalloc(sizeof(*dconf), GFP_KERNEL);\n\tif (!dconf)\n\t\treturn -ENOMEM;\n\t/* read device config */\n\trc = usb_control_msg(interface_to_usbdev(intf),\n\t\t\t     usb_rcvctrlpipe(interface_to_usbdev(intf), 0),\n\t\t\t     GS_USB_BREQ_DEVICE_CONFIG,\n\t\t\t     USB_DIR_IN|USB_TYPE_VENDOR|USB_RECIP_INTERFACE,\n\t\t\t     1,\n\t\t\t     intf->altsetting[0].desc.bInterfaceNumber,\n\t\t\t     dconf,\n\t\t\t     sizeof(*dconf),\n\t\t\t     1000);\n\tif (rc < 0) {\n\t\tdev_err(&intf->dev, \"Couldn't get device config: (err=%d)\\n\",\n\t\t\trc);\n\t\tkfree(dconf);\n\t\treturn rc;\n\t}\n\ticount = dconf->icount + 1;\n\tdev_info(&intf->dev, \"Configuring for %d interfaces\\n\", icount);\n\tif (icount > GS_MAX_INTF) {\n\t\tdev_err(&intf->dev,\n\t\t\t\"Driver cannot handle more that %d CAN interfaces\\n\",\n\t\t\tGS_MAX_INTF);\n\t\tkfree(dconf);\n\t\treturn -EINVAL;\n\t}\n\tdev = kzalloc(sizeof(*dev), GFP_KERNEL);\n\tif (!dev) {\n\t\tkfree(dconf);\n\t\treturn -ENOMEM;\n\t}\n\tinit_usb_anchor(&dev->rx_submitted);\n\tatomic_set(&dev->active_channels, 0);\n\tusb_set_intfdata(intf, dev);\n\tdev->udev = interface_to_usbdev(intf);\n\tfor (i = 0; i < icount; i++) {\n\t\tdev->canch[i] = gs_make_candev(i, intf, dconf);\n\t\tif (IS_ERR_OR_NULL(dev->canch[i])) {\n\t\t\t/* save error code to return later */\n\t\t\trc = PTR_ERR(dev->canch[i]);\n\t\t\t/* on failure destroy previously created candevs */\n\t\t\ticount = i;\n\t\t\tfor (i = 0; i < icount; i++)\n\t\t\t\tgs_destroy_candev(dev->canch[i]);\n\t\t\tusb_kill_anchored_urbs(&dev->rx_submitted);\n\t\t\tkfree(dconf);\n\t\t\tkfree(dev);\n\t\t\treturn rc;\n\t\t}\n\t\tdev->canch[i]->parent = dev;\n\t}\n\tkfree(dconf);\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 47
    },
    {
        "code": "static int key_notify_policy_flush(const struct km_event *c)\n{\n\tstruct sk_buff *skb_out;\n\tstruct sadb_msg *hdr;\n\tskb_out = alloc_skb(sizeof(struct sadb_msg) + 16, GFP_ATOMIC);\n\tif (!skb_out)\n\t\treturn -ENOBUFS;\n\thdr = (struct sadb_msg *) skb_put(skb_out, sizeof(struct sadb_msg));\n\thdr->sadb_msg_type = SADB_X_SPDFLUSH;\n\thdr->sadb_msg_seq = c->seq;\n\thdr->sadb_msg_pid = c->portid;\n\thdr->sadb_msg_version = PF_KEY_V2;\n\thdr->sadb_msg_errno = (uint8_t) 0;\n\thdr->sadb_msg_satype = SADB_SATYPE_UNSPEC;\n\thdr->sadb_msg_len = (sizeof(struct sadb_msg) / sizeof(uint64_t));\n\thdr->sadb_msg_reserved = 0;\n\tpfkey_broadcast(skb_out, GFP_ATOMIC, BROADCAST_ALL, NULL, c->net);\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 49
    },
    {
        "code": "int kvm_iommu_map_pages(struct kvm *kvm, struct kvm_memory_slot *slot)\n{\n\tgfn_t gfn, end_gfn;\n\tpfn_t pfn;\n\tint r = 0;\n\tstruct iommu_domain *domain = kvm->arch.iommu_domain;\n\tint flags;\n\t/* check if iommu exists and in use */\n\tif (!domain)\n\t\treturn 0;\n\tgfn     = slot->base_gfn;\n\tend_gfn = gfn + slot->npages;\n\tflags = IOMMU_READ;\n\tif (!(slot->flags & KVM_MEM_READONLY))\n\t\tflags |= IOMMU_WRITE;\n\tif (!kvm->arch.iommu_noncoherent)\n\t\tflags |= IOMMU_CACHE;\n\twhile (gfn < end_gfn) {\n\t\tunsigned long page_size;\n\t\t/* Check if already mapped */\n\t\tif (iommu_iova_to_phys(domain, gfn_to_gpa(gfn))) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Get the page size we could use to map */\n\t\tpage_size = kvm_host_page_size(kvm, gfn);\n\t\t/* Make sure the page_size does not exceed the memslot */\n\t\twhile ((gfn + (page_size >> PAGE_SHIFT)) > end_gfn)\n\t\t\tpage_size >>= 1;\n\t\t/* Make sure gfn is aligned to the page size we want to map */\n\t\twhile ((gfn << PAGE_SHIFT) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\t/* Make sure hva is aligned to the page size we want to map */\n\t\twhile (__gfn_to_hva_memslot(slot, gfn) & (page_size - 1))\n\t\t\tpage_size >>= 1;\n\t\t/*\n\t\t * Pin all pages we are about to map in memory. This is\n\t\t * important because we unmap and unpin in 4kb steps later.\n\t\t */\n\t\tpfn = kvm_pin_pages(slot, gfn, page_size >> PAGE_SHIFT);\n\t\tif (is_error_noslot_pfn(pfn)) {\n\t\t\tgfn += 1;\n\t\t\tcontinue;\n\t\t}\n\t\t/* Map into IO address space */\n\t\tr = iommu_map(domain, gfn_to_gpa(gfn), pfn_to_hpa(pfn),\n\t\t\t      page_size, flags);\n\t\tif (r) {\n\t\t\tprintk(KERN_ERR \"kvm_iommu_map_address:\"\n\t\t\t       \"iommu failed to map pfn=%llx\\n\", pfn);\n\t\t\tkvm_unpin_pages(kvm, pfn, page_size >> PAGE_SHIFT);\n\t\t\tgoto unmap_pages;\n\t\t}\n\t\tgfn += page_size >> PAGE_SHIFT;\n\t}\n\treturn 0;\nunmap_pages:\n\tkvm_iommu_put_pages(kvm, slot->base_gfn, gfn - slot->base_gfn);\n\treturn r;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 51
    },
    {
        "code": "static int pit_ioport_read(struct kvm_io_device *this,\n\t\t\t   gpa_t addr, int len, void *data)\n{\n\tstruct kvm_pit *pit = dev_to_pit(this);\n\tstruct kvm_kpit_state *pit_state = &pit->pit_state;\n\tstruct kvm *kvm = pit->kvm;\n\tint ret, count;\n\tstruct kvm_kpit_channel_state *s;\n\tif (!pit_in_range(addr))\n\t\treturn -EOPNOTSUPP;\n\taddr &= KVM_PIT_CHANNEL_MASK;\n\tif (addr == 3)\n\t\treturn 0;\n\ts = &pit_state->channels[addr];\n\tmutex_lock(&pit_state->lock);\n\tif (s->status_latched) {\n\t\ts->status_latched = 0;\n\t\tret = s->status;\n\t} else if (s->count_latched) {\n\t\tswitch (s->count_latched) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tret = s->latched_count >> 8;\n\t\t\ts->count_latched = 0;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tret = s->latched_count & 0xff;\n\t\t\ts->count_latched = RW_STATE_MSB;\n\t\t\tbreak;\n\t\t}\n\t} else {\n\t\tswitch (s->read_state) {\n\t\tdefault:\n\t\tcase RW_STATE_LSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_MSB:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD0:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = count & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD1;\n\t\t\tbreak;\n\t\tcase RW_STATE_WORD1:\n\t\t\tcount = pit_get_count(kvm, addr);\n\t\t\tret = (count >> 8) & 0xff;\n\t\t\ts->read_state = RW_STATE_WORD0;\n\t\t\tbreak;\n\t\t}\n\t}\n\tif (len > sizeof(ret))\n\t\tlen = sizeof(ret);\n\tmemcpy(data, (char *)&ret, len);\n\tmutex_unlock(&pit_state->lock);\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 53
    },
    {
        "code": "static int magicmouse_raw_event(struct hid_device *hdev,\n\t\tstruct hid_report *report, u8 *data, int size)\n{\n\tstruct magicmouse_sc *msc = hid_get_drvdata(hdev);\n\tstruct input_dev *input = msc->input;\n\tint x = 0, y = 0, ii, clicks = 0, npoints;\n\tswitch (data[0]) {\n\tcase TRACKPAD_REPORT_ID:\n\t\t/* Expect four bytes of prefix, and N*9 bytes of touch data. */\n\t\tif (size < 4 || ((size - 4) % 9) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 4) / 9;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for TRACKPAD_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 9 + 4);\n\t\tclicks = data[1];\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[1] >> 6 | data[2] << 2 | data[3] << 10;\n\t\t */\n\t\tbreak;\n\tcase MOUSE_REPORT_ID:\n\t\t/* Expect six bytes of prefix, and N*8 bytes of touch data. */\n\t\tif (size < 6 || ((size - 6) % 8) != 0)\n\t\t\treturn 0;\n\t\tnpoints = (size - 6) / 8;\n\t\tif (npoints > 15) {\n\t\t\thid_warn(hdev, \"invalid size value (%d) for MOUSE_REPORT_ID\\n\",\n\t\t\t\t\tsize);\n\t\t\treturn 0;\n\t\t}\n\t\tmsc->ntouches = 0;\n\t\tfor (ii = 0; ii < npoints; ii++)\n\t\t\tmagicmouse_emit_touch(msc, ii, data + ii * 8 + 6);\n\t\t/* When emulating three-button mode, it is important\n\t\t * to have the current touch information before\n\t\t * generating a click event.\n\t\t */\n\t\tx = (int)(((data[3] & 0x0c) << 28) | (data[1] << 22)) >> 22;\n\t\ty = (int)(((data[3] & 0x30) << 26) | (data[2] << 22)) >> 22;\n\t\tclicks = data[3];\n\t\t/* The following bits provide a device specific timestamp. They\n\t\t * are unused here.\n\t\t *\n\t\t * ts = data[3] >> 6 | data[4] << 2 | data[5] << 10;\n\t\t */\n\t\tbreak;\n\tcase DOUBLE_REPORT_ID:\n\t\t/* Sometimes the trackpad sends two touch reports in one\n\t\t * packet.\n\t\t */\n\t\tmagicmouse_raw_event(hdev, report, data + 2, data[1]);\n\t\tmagicmouse_raw_event(hdev, report, data + 2 + data[1],\n\t\t\tsize - 2 - data[1]);\n\t\tbreak;\n\tdefault:\n\t\treturn 0;\n\t}\n\tif (input->id.product == USB_DEVICE_ID_APPLE_MAGICMOUSE) {\n\t\tmagicmouse_emit_buttons(msc, clicks & 3);\n\t\tinput_report_rel(input, REL_X, x);\n\t\tinput_report_rel(input, REL_Y, y);\n\t} else { /* USB_DEVICE_ID_APPLE_MAGICTRACKPAD */\n\t\tinput_report_key(input, BTN_MOUSE, clicks & 1);\n\t\tinput_mt_report_pointer_emulation(input, true);\n\t}\n\tinput_sync(input);\n\treturn 1;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 55
    },
    {
        "code": "static int\nisdn_ioctl(struct file *file, uint cmd, ulong arg)\n{\n\tuint minor = iminor(file_inode(file));\n\tisdn_ctrl c;\n\tint drvidx;\n\tint ret;\n\tint i;\n\tchar __user *p;\n\tchar *s;\n\tunion iocpar {\n\t\tchar name[10];\n\t\tchar bname[22];\n\t\tisdn_ioctl_struct iocts;\n\t\tisdn_net_ioctl_phone phone;\n\t\tisdn_net_ioctl_cfg cfg;\n\t} iocpar;\n\tvoid __user *argp = (void __user *)arg;\n#define name  iocpar.name\n#define bname iocpar.bname\n#define iocts iocpar.iocts\n#define phone iocpar.phone\n#define cfg   iocpar.cfg\n\tif (minor == ISDN_MINOR_STATUS) {\n\t\tswitch (cmd) {\n\t\tcase IIOCGETDVR:\n\t\t\treturn (TTY_DV +\n\t\t\t\t(NET_DV << 8) +\n\t\t\t\t(INF_DV << 16));\n\t\tcase IIOCGETCPS:\n\t\t\tif (arg) {\n\t\t\t\tulong __user *p = argp;\n\t\t\t\tint i;\n\t\t\t\tfor (i = 0; i < ISDN_MAX_CHANNELS; i++) {\n\t\t\t\t\tput_user(dev->ibytes[i], p++);\n\t\t\t\t\tput_user(dev->obytes[i], p++);\n\t\t\t\t}\n\t\t\t\treturn 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tbreak;\n\t\tcase IIOCNETGPN:\n\t\t\t/* Get peer phone number of a connected\n\t\t\t * isdn network interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(&phone, argp, sizeof(phone)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\treturn isdn_net_getpeer(&phone, argp);\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\tdefault:\n\t\t\treturn -EINVAL;\n\t\t}\n\t}\n\tif (!dev->drivers)\n\t\treturn -ENODEV;\n\tif (minor <= ISDN_MINOR_BMAX) {\n\t\tdrvidx = isdn_minor2drv(minor);\n\t\tif (drvidx < 0)\n\t\t\treturn -ENODEV;\n\t\tif (!(dev->drv[drvidx]->flags & DRV_FLAG_RUNNING))\n\t\t\treturn -ENODEV;\n\t\treturn 0;\n\t}\n\tif (minor <= ISDN_MINOR_CTRLMAX) {\n/*\n * isdn net devices manage lots of configuration variables as linked lists.\n * Those lists must only be manipulated from user space. Some of the ioctl's\n * service routines access user space and are not atomic. Therefore, ioctl's\n * manipulating the lists and ioctl's sleeping while accessing the lists\n * are serialized by means of a semaphore.\n */\n\t\tswitch (cmd) {\n\t\tcase IIOCNETDWRSET:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_DW_ABC_EXTENSION not enabled\\n\");\n\t\t\treturn (-EINVAL);\n\t\tcase IIOCNETLCR:\n\t\t\tprintk(KERN_INFO \"INFO: ISDN_ABC_LCR_SUPPORT not enabled\\n\");\n\t\t\treturn -ENODEV;\n\t\tcase IIOCNETAIF:\n\t\t\t/* Add a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(name, argp, sizeof(name)))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\ts = name;\n\t\t\t} else {\n\t\t\t\ts = NULL;\n\t\t\t}\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_new(s, NULL))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;\n\t\t\tmutex_unlock(&dev->mtx);\n\t\t\treturn ret;\n\t\tcase IIOCNETASL:\n\t\t\t/* Add a slave to a network-interface */\n\t\t\tif (arg) {\n\t\t\t\tif (copy_from_user(bname, argp, sizeof(bname) - 1))\n\t\t\t\t\treturn -EFAULT;\n\t\t\t\tbname[sizeof(bname)-1] = 0;\n\t\t\t} else\n\t\t\t\treturn -EINVAL;\n\t\t\tret = mutex_lock_interruptible(&dev->mtx);\n\t\t\tif (ret) return ret;\n\t\t\tif ((s = isdn_net_newslave(bname))) {\n\t\t\t\tif (copy_to_user(argp, s, strlen(s) + 1)) {\n\t\t\t\t\tret = -EFAULT;\n\t\t\t\t} else {\n\t\t\t\t\tret = 0;\n\t\t\t\t}\n\t\t\t} else\n\t\t\t\tret = -ENODEV;",
        "bug_line_number": [],
        "vul": 0,
        "id": 57
    },
    {
        "code": "static int btf_check_func_arg_match(struct bpf_verifier_env *env,\n\t\t\t\t    const struct btf *btf, u32 func_id,\n\t\t\t\t    struct bpf_reg_state *regs,\n\t\t\t\t    bool ptr_to_mem_ok)\n{\n\tstruct bpf_verifier_log *log = &env->log;\n\tbool is_kfunc = btf_is_kernel(btf);\n\tconst char *func_name, *ref_tname;\n\tconst struct btf_type *t, *ref_t;\n\tconst struct btf_param *args;\n\tu32 i, nargs, ref_id;\n\tt = btf_type_by_id(btf, func_id);\n\tif (!t || !btf_type_is_func(t)) {\n\t\t/* These checks were already done by the verifier while loading\n\t\t * struct bpf_func_info or in add_kfunc_call().\n\t\t */\n\t\tbpf_log(log, \"BTF of func_id %u doesn't point to KIND_FUNC\\n\",\n\t\t\tfunc_id);\n\t\treturn -EFAULT;\n\t}\n\tfunc_name = btf_name_by_offset(btf, t->name_off);\n\tt = btf_type_by_id(btf, t->type);\n\tif (!t || !btf_type_is_func_proto(t)) {\n\t\tbpf_log(log, \"Invalid BTF of func %s\\n\", func_name);\n\t\treturn -EFAULT;\n\t}\n\targs = (const struct btf_param *)(t + 1);\n\tnargs = btf_type_vlen(t);\n\tif (nargs > MAX_BPF_FUNC_REG_ARGS) {\n\t\tbpf_log(log, \"Function %s has %d > %d args\\n\", func_name, nargs,\n\t\t\tMAX_BPF_FUNC_REG_ARGS);\n\t\treturn -EINVAL;\n\t}\n\t/* check that BTF function arguments match actual types that the\n\t * verifier sees.\n\t */\n\tfor (i = 0; i < nargs; i++) {\n\t\tu32 regno = i + 1;\n\t\tstruct bpf_reg_state *reg = &regs[regno];\n\t\tt = btf_type_skip_modifiers(btf, args[i].type, NULL);\n\t\tif (btf_type_is_scalar(t)) {\n\t\t\tif (reg->type == SCALAR_VALUE)\n\t\t\t\tcontinue;\n\t\t\tbpf_log(log, \"R%d is not a scalar\\n\", regno);\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tif (!btf_type_is_ptr(t)) {\n\t\t\tbpf_log(log, \"Unrecognized arg#%d type %s\\n\",\n\t\t\t\ti, btf_type_str(t));\n\t\t\treturn -EINVAL;\n\t\t}\n\t\tref_t = btf_type_skip_modifiers(btf, t->type, &ref_id);\n\t\tref_tname = btf_name_by_offset(btf, ref_t->name_off);\n\t\tif (btf_get_prog_ctx_type(log, btf, t,\n\t\t\t\t\t  env->prog->type, i)) {\n\t\t\t/* If function expects ctx type in BTF check that caller\n\t\t\t * is passing PTR_TO_CTX.\n\t\t\t */\n\t\t\tif (reg->type != PTR_TO_CTX) {\n\t\t\t\tbpf_log(log,\n\t\t\t\t\t\"arg#%d expected pointer to ctx, but got %s\\n\",\n\t\t\t\t\ti, btf_type_str(t));\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (check_ptr_off_reg(env, reg, regno))\n\t\t\t\treturn -EINVAL;\n\t\t} else if (is_kfunc && (reg->type == PTR_TO_BTF_ID || reg2btf_ids[reg->type])) {\n\t\t\tconst struct btf_type *reg_ref_t;\n\t\t\tconst struct btf *reg_btf;\n\t\t\tconst char *reg_ref_tname;\n\t\t\tu32 reg_ref_id;\n\t\t\tif (!btf_type_is_struct(ref_t)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d pointer type %s %s is not supported\\n\",\n\t\t\t\t\tfunc_name, i, btf_type_str(ref_t),\n\t\t\t\t\tref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tif (reg->type == PTR_TO_BTF_ID) {\n\t\t\t\treg_btf = reg->btf;\n\t\t\t\treg_ref_id = reg->btf_id;\n\t\t\t} else {\n\t\t\t\treg_btf = btf_vmlinux;\n\t\t\t\treg_ref_id = *reg2btf_ids[reg->type];\n\t\t\t}\n\t\t\treg_ref_t = btf_type_skip_modifiers(reg_btf, reg_ref_id,\n\t\t\t\t\t\t\t    &reg_ref_id);\n\t\t\treg_ref_tname = btf_name_by_offset(reg_btf,\n\t\t\t\t\t\t\t   reg_ref_t->name_off);\n\t\t\tif (!btf_struct_ids_match(log, reg_btf, reg_ref_id,\n\t\t\t\t\t\t  reg->off, btf, ref_id)) {\n\t\t\t\tbpf_log(log, \"kernel function %s args#%d expected pointer to %s %s but R%d has a pointer to %s %s\\n\",\n\t\t\t\t\tfunc_name, i,\n\t\t\t\t\tbtf_type_str(ref_t), ref_tname,\n\t\t\t\t\tregno, btf_type_str(reg_ref_t),\n\t\t\t\t\treg_ref_tname);\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t} else if (ptr_to_mem_ok) {\n\t\t\tconst struct btf_type *resolve_ret;\n\t\t\tu32 type_size;\n\t\t\tif (is_kfunc) {\n\t\t\t\t/* Permit pointer to mem, but only when argument\n\t\t\t\t * type is pointer to scalar, or struct composed\n\t\t\t\t * (recursively) of scalars.\n\t\t\t\t */\n\t\t\t\tif (!btf_type_is_scalar(ref_t) &&\n\t\t\t\t    !__btf_type_is_scalar_struct(log, btf, ref_t, 0)) {\n\t\t\t\t\tbpf_log(log,\n\t\t\t\t\t\t\"arg#%d pointer type %s %s must point to scalar or struct with scalar\\n\",\n\t\t\t\t\t\ti, btf_type_str(ref_t), ref_tname);",
        "bug_line_number": [],
        "vul": 0,
        "id": 59
    },
    {
        "code": "static inline int pmd_large(pmd_t pte)\n{\n\treturn pmd_flags(pte) & _PAGE_PSE;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 61
    },
    {
        "code": "static ssize_t oz_cdev_write(struct file *filp, const char __user *buf,\n\t\tsize_t count, loff_t *fpos)\n{\n\tstruct oz_pd *pd;\n\tstruct oz_elt_buf *eb;\n\tstruct oz_elt_info *ei;\n\tstruct oz_elt *elt;\n\tstruct oz_app_hdr *app_hdr;\n\tstruct oz_serial_ctx *ctx;\n\tif (count > sizeof(ei->data) - sizeof(*elt) - sizeof(*app_hdr))\n\t\treturn -EINVAL;\n\tspin_lock_bh(&g_cdev.lock);\n\tpd = g_cdev.active_pd;\n\tif (pd)\n\t\toz_pd_get(pd);\n\tspin_unlock_bh(&g_cdev.lock);\n\tif (pd == NULL)\n\t\treturn -ENXIO;\n\tif (!(pd->state & OZ_PD_S_CONNECTED))\n\t\treturn -EAGAIN;\n\teb = &pd->elt_buff;\n\tei = oz_elt_info_alloc(eb);\n\tif (ei == NULL) {\n\t\tcount = 0;\n\t\tgoto out;\n\t}\n\telt = (struct oz_elt *)ei->data;\n\tapp_hdr = (struct oz_app_hdr *)(elt+1);\n\telt->length = sizeof(struct oz_app_hdr) + count;\n\telt->type = OZ_ELT_APP_DATA;\n\tei->app_id = OZ_APPID_SERIAL;\n\tei->length = elt->length + sizeof(struct oz_elt);\n\tapp_hdr->app_id = OZ_APPID_SERIAL;\n\tif (copy_from_user(app_hdr+1, buf, count))\n\t\tgoto out;\n\tspin_lock_bh(&pd->app_lock[OZ_APPID_USB-1]);\n\tctx = (struct oz_serial_ctx *)pd->app_ctx[OZ_APPID_SERIAL-1];\n\tif (ctx) {\n\t\tapp_hdr->elt_seq_num = ctx->tx_seq_num++;\n\t\tif (ctx->tx_seq_num == 0)\n\t\t\tctx->tx_seq_num = 1;\n\t\tspin_lock(&eb->lock);\n\t\tif (oz_queue_elt_info(eb, 0, 0, ei) == 0)\n\t\t\tei = NULL;\n\t\tspin_unlock(&eb->lock);\n\t}\n\tspin_unlock_bh(&pd->app_lock[OZ_APPID_USB-1]);\nout:\n\tif (ei) {\n\t\tcount = 0;\n\t\tspin_lock_bh(&eb->lock);\n\t\toz_elt_info_free(eb, ei);\n\t\tspin_unlock_bh(&eb->lock);\n\t}\n\toz_pd_put(pd);\n\treturn count;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 63
    },
    {
        "code": "static int __driver_rfc4106_decrypt(struct aead_request *req)\n{\n\tu8 one_entry_in_sg = 0;\n\tu8 *src, *dst, *assoc;\n\tunsigned long tempCipherLen = 0;\n\t__be32 counter = cpu_to_be32(1);\n\tint retval = 0;\n\tstruct crypto_aead *tfm = crypto_aead_reqtfm(req);\n\tstruct aesni_rfc4106_gcm_ctx *ctx = aesni_rfc4106_gcm_ctx_get(tfm);\n\tu32 key_len = ctx->aes_key_expanded.key_length;\n\tvoid *aes_ctx = &(ctx->aes_key_expanded);\n\tunsigned long auth_tag_len = crypto_aead_authsize(tfm);\n\tu8 iv_and_authTag[32+AESNI_ALIGN];\n\tu8 *iv = (u8 *) PTR_ALIGN((u8 *)iv_and_authTag, AESNI_ALIGN);\n\tu8 *authTag = iv + 16;\n\tstruct scatter_walk src_sg_walk;\n\tstruct scatter_walk assoc_sg_walk;\n\tstruct scatter_walk dst_sg_walk;\n\tunsigned int i;\n\tif (unlikely((req->cryptlen < auth_tag_len) ||\n\t\t(req->assoclen != 8 && req->assoclen != 12)))\n\t\treturn -EINVAL;\n\tif (unlikely(auth_tag_len != 8 && auth_tag_len != 12 && auth_tag_len != 16))\n\t        return -EINVAL;\n\tif (unlikely(key_len != AES_KEYSIZE_128 &&\n\t             key_len != AES_KEYSIZE_192 &&\n\t             key_len != AES_KEYSIZE_256))\n\t        return -EINVAL;\n\t/* Assuming we are supporting rfc4106 64-bit extended */\n\t/* sequence numbers We need to have the AAD length */\n\t/* equal to 8 or 12 bytes */\n\ttempCipherLen = (unsigned long)(req->cryptlen - auth_tag_len);\n\t/* IV below built */\n\tfor (i = 0; i < 4; i++)\n\t\t*(iv+i) = ctx->nonce[i];\n\tfor (i = 0; i < 8; i++)\n\t\t*(iv+4+i) = req->iv[i];\n\t*((__be32 *)(iv+12)) = counter;\n\tif ((sg_is_last(req->src)) && (sg_is_last(req->assoc))) {\n\t\tone_entry_in_sg = 1;\n\t\tscatterwalk_start(&src_sg_walk, req->src);\n\t\tscatterwalk_start(&assoc_sg_walk, req->assoc);\n\t\tsrc = scatterwalk_map(&src_sg_walk);\n\t\tassoc = scatterwalk_map(&assoc_sg_walk);\n\t\tdst = src;\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_start(&dst_sg_walk, req->dst);\n\t\t\tdst = scatterwalk_map(&dst_sg_walk);\n\t\t}\n\t} else {\n\t\t/* Allocate memory for src, dst, assoc */\n\t\tsrc = kmalloc(req->cryptlen + req->assoclen, GFP_ATOMIC);\n\t\tif (!src)\n\t\t\treturn -ENOMEM;\n\t\tassoc = (src + req->cryptlen);\n\t\tscatterwalk_map_and_copy(src, req->src, 0, req->cryptlen, 0);\n\t\tscatterwalk_map_and_copy(assoc, req->assoc, 0,\n\t\t\treq->assoclen, 0);\n\t\tdst = src;\n\t}\n\taesni_gcm_dec_tfm(aes_ctx, dst, src, tempCipherLen, iv,\n\t\tctx->hash_subkey, assoc, (unsigned long)req->assoclen,\n\t\tauthTag, auth_tag_len);\n\t/* Compare generated tag with passed in tag. */\n\tretval = crypto_memneq(src + tempCipherLen, authTag, auth_tag_len) ?\n\t\t-EBADMSG : 0;\n\tif (one_entry_in_sg) {\n\t\tif (unlikely(req->src != req->dst)) {\n\t\t\tscatterwalk_unmap(dst);\n\t\t\tscatterwalk_done(&dst_sg_walk, 0, 0);\n\t\t}\n\t\tscatterwalk_unmap(src);\n\t\tscatterwalk_unmap(assoc);\n\t\tscatterwalk_done(&src_sg_walk, 0, 0);\n\t\tscatterwalk_done(&assoc_sg_walk, 0, 0);\n\t} else {\n\t\tscatterwalk_map_and_copy(dst, req->dst, 0, tempCipherLen, 1);\n\t\tkfree(src);\n\t}\n\treturn retval;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 65
    },
    {
        "code": "static __u8 *nci_extract_rf_params_nfcf_passive_poll(struct nci_dev *ndev,\n\t\t\tstruct rf_tech_specific_params_nfcf_poll *nfcf_poll,\n\t\t\t\t\t\t     __u8 *data)\n{\n\tnfcf_poll->bit_rate = *data++;\n\tnfcf_poll->sensf_res_len = min_t(__u8, *data++, NFC_SENSF_RES_MAXSIZE);\n\tpr_debug(\"bit_rate %d, sensf_res_len %d\\n\",\n\t\t nfcf_poll->bit_rate, nfcf_poll->sensf_res_len);\n\tmemcpy(nfcf_poll->sensf_res, data, nfcf_poll->sensf_res_len);\n\tdata += nfcf_poll->sensf_res_len;\n\treturn data;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 67
    },
    {
        "code": "static int su3000_power_ctrl(struct dvb_usb_device *d, int i)\n{\n\tstruct dw2102_state *state = (struct dw2102_state *)d->priv;\n\tint ret = 0;\n\tinfo(\"%s: %d, initialized %d\", __func__, i, state->initialized);\n\tif (i && !state->initialized) {\n\t\tmutex_lock(&d->data_mutex);\n\t\tstate->data[0] = 0xde;\n\t\tstate->data[1] = 0;\n\t\tstate->initialized = 1;\n\t\t/* reset board */\n\t\tret = dvb_usb_generic_rw(d, state->data, 2, NULL, 0, 0);\n\t\tmutex_unlock(&d->data_mutex);\n\t}\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 69
    },
    {
        "code": "static long ioctl_file_dedupe_range(struct file *file, void __user *arg)\n{\n\tstruct file_dedupe_range __user *argp = arg;\n\tstruct file_dedupe_range *same = NULL;\n\tint ret;\n\tunsigned long size;\n\tu16 count;\n\tif (get_user(count, &argp->dest_count)) {\n\t\tret = -EFAULT;\n\t\tgoto out;\n\t}\n\tsize = offsetof(struct file_dedupe_range __user, info[count]);\n\tsame = memdup_user(argp, size);\n\tif (IS_ERR(same)) {\n\t\tret = PTR_ERR(same);\n\t\tsame = NULL;\n\t\tgoto out;\n\t}\n\tsame->dest_count = count;\n\tret = vfs_dedupe_file_range(file, same);\n\tif (ret)\n\t\tgoto out;\n\tret = copy_to_user(argp, same, size);\n\tif (ret)\n\t\tret = -EFAULT;\nout:\n\tkfree(same);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 71
    },
    {
        "code": "int wvlan_uil_put_info(struct uilreq *urq, struct wl_private *lp)\n{\n\tint                     result = 0;\n\tltv_t                   *pLtv;\n\tbool_t                  ltvAllocated = FALSE;\n\tENCSTRCT                sEncryption;\n\tsize_t\t\t\tlen;\n#ifdef USE_WDS\n\thcf_16                  hcfPort  = HCF_PORT_0;\n#endif  /* USE_WDS */\n\t/*------------------------------------------------------------------------*/\n\tDBG_FUNC(\"wvlan_uil_put_info\");\n\tDBG_ENTER(DbgInfo);\n\tif (urq->hcfCtx == &(lp->hcfCtx)) {\n\t\tif (capable(CAP_NET_ADMIN)) {\n\t\t\tif ((urq->data != NULL) && (urq->len != 0)) {\n\t\t\t\t/* Make sure that we have at least a command and length to send. */\n\t\t\t\tif (urq->len < (sizeof(hcf_16) * 2)) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"No Length/Type in LTV!!!\\n\");\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t/* Verify the user buffer */\n\t\t\t\tresult = verify_area(VERIFY_READ, urq->data, urq->len);\n\t\t\t\tif (result != 0) {\n\t\t\t\t\turq->result = UIL_FAILURE;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"verify_area(), VERIFY_READ FAILED\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t/* Get only the command and length information. */\n\t\t\t\tcopy_from_user(&(lp->ltvRecord), urq->data, sizeof(hcf_16) * 2);\n\t\t\t\t/* Make sure the incoming LTV record length is within the bounds of the\n\t\t\t\t   IOCTL length */\n\t\t\t\tif (((lp->ltvRecord.len + 1) * sizeof(hcf_16)) > urq->len) {\n\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\tDBG_ERROR(DbgInfo, \"UIL_ERR_LEN\\n\");\n\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\treturn result;\n\t\t\t\t}\n\t\t\t\t/* If the requested length is greater than the size of our local\n\t\t\t\t   LTV record, try to allocate it from the kernel stack.\n\t\t\t\t   Otherwise, we just use our local LTV record. */\n\t\t\t\tif (urq->len > sizeof(lp->ltvRecord)) {\n\t\t\t\t\tpLtv = kmalloc(urq->len, GFP_KERNEL);\n\t\t\t\t\tif (pLtv != NULL) {\n\t\t\t\t\t\tltvAllocated = TRUE;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tDBG_ERROR(DbgInfo, \"Alloc FAILED\\n\");\n\t\t\t\t\t\turq->len = sizeof(lp->ltvRecord);\n\t\t\t\t\t\turq->result = UIL_ERR_LEN;\n\t\t\t\t\t\tresult = -ENOMEM;\n\t\t\t\t\t\tDBG_LEAVE(DbgInfo);\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tpLtv = &(lp->ltvRecord);\n\t\t\t\t}\n\t\t\t\t/* Copy the data from the user's buffer into the local LTV\n\t\t\t\t   record data area. */\n\t\t\t\tcopy_from_user(pLtv, urq->data, urq->len);\n\t\t\t\t/* We need to snoop the commands to see if there is anything we\n\t\t\t\t   need to store for the purposes of a reset or start/stop\n\t\t\t\t   sequence. Perform endian translation as needed */\n\t\t\t\tswitch (pLtv->typ) {\n\t\t\t\tcase CFG_CNF_PORT_TYPE:\n\t\t\t\t\tlp->PortType    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_MAC_ADDR:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_CHANNEL:\n\t\t\t\t\tlp->Channel     = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* CFG_CNF_OWN_SSID currently same as CNF_DESIRED_SSID. Do we\n\t\t\t\t   need separate storage for this? */\n\t\t\t\t/* case CFG_CNF_OWN_SSID: */\n\t\t\t\tcase CFG_CNF_OWN_ATIM_WINDOW:\n\t\t\t\t\tlp->atimWindow  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_SYSTEM_SCALE:\n\t\t\t\t\tlp->DistanceBetweenAPs  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\tcase CFG_CNF_MAX_DATA_LEN:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based\n\t\t\t\t\t   on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_PM_ENABLED:\n\t\t\t\t\tlp->PMEnabled   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MCAST_RX:\n\t\t\t\t\tlp->MulticastReceive    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MAX_SLEEP_DURATION:\n\t\t\t\t\tlp->MaxSleepDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_HOLDOVER_DURATION:\n\t\t\t\t\tlp->holdoverDuration    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);",
        "bug_line_number": [],
        "vul": 0,
        "id": 73
    },
    {
        "code": "\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_OWN_NAME:\n\t\t\t\t\tmemset(lp->StationName, 0, sizeof(lp->StationName));\n\t\t\t\t\tlen = min_t(size_t, pLtv->u.u16[0], sizeof(lp->StationName));\n\t\t\t\t\tstrlcpy(lp->StationName, &pLtv->u.u8[2], len);\n\t\t\t\t\tpLtv->u.u16[0] = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_LOAD_BALANCING:\n\t\t\t\t\tlp->loadBalancing       = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_MEDIUM_DISTRIBUTION:\n\t\t\t\t\tlp->mediumDistribution  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_TX_POW_LVL:\n\t\t\t\t\tlp->txPowLevel          = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_CNF_SHORT_RETRY_LIMIT: */ /* Short Retry Limit */\n\t\t\t\t/* case 0xFC33: */   /* Long Retry Limit */\n\t\t\t\tcase CFG_SUPPORTED_RATE_SET_CNTL:        /* Supported Rate Set Control */\n\t\t\t\t\tlp->srsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->srsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_BASIC_RATE_SET_CNTL:        /* Basic Rate Set Control */\n\t\t\t\t\tlp->brsc[0]             = pLtv->u.u16[0];\n\t\t\t\t\tlp->brsc[1]             = pLtv->u.u16[1];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tpLtv->u.u16[1]          = CNV_INT_TO_LITTLE(pLtv->u.u16[1]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_CONNECTION_CNTL:\n\t\t\t\t\tlp->connectionControl   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\t/* case CFG_PROBE_DATA_RATE: */\n#endif  /* HERMES25 */\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\tcase CFG_CNF_OWN_DTIM_PERIOD:\n\t\t\t\t\tlp->DTIMPeriod  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef WARP\n\t\t\t\tcase CFG_CNF_OWN_BEACON_INTERVAL:        /* Own Beacon Interval */\n\t\t\t\t\tlp->ownBeaconInterval   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif /* WARP */\n\t\t\t\tcase CFG_COEXISTENSE_BEHAVIOUR:         /* Coexistence behavior */\n\t\t\t\t\tlp->coexistence         = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#ifdef USE_WDS\n\t\t\t\tcase CFG_CNF_WDS_ADDR1:\n\t\t\t\t\tmemcpy(&lp->wds_port[0].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR2:\n\t\t\t\t\tmemcpy(&lp->wds_port[1].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_2;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR3:\n\t\t\t\t\tmemcpy(&lp->wds_port[2].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_3;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR4:\n\t\t\t\t\tmemcpy(&lp->wds_port[3].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_4;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR5:\n\t\t\t\t\tmemcpy(&lp->wds_port[4].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_WDS_ADDR6:\n\t\t\t\t\tmemcpy(&lp->wds_port[5].wdsAddress, &pLtv->u.u8[0], ETH_ALEN);\n\t\t\t\t\thcfPort = HCF_PORT_6;\n\t\t\t\t\tbreak;\n#endif  /* USE_WDS */\n\t\t\t\tcase CFG_CNF_MCAST_PM_BUF:\n\t\t\t\t\tlp->multicastPMBuffering    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]              = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_REJECT_ANY:\n\t\t\t\t\tlp->RejectAny   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]  = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase CFG_CNF_ENCRYPTION:\n\t\t\t\t\tlp->EnableEncryption    = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_AUTHENTICATION:\n\t\t\t\t\tlp->authentication  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#if 1 /* ;? (HCF_TYPE) & HCF_TYPE_AP */\n\t\t/* ;?should we restore this to allow smaller memory footprint */\n\t\t\t\t/* case CFG_CNF_EXCL_UNENCRYPTED:\n\t\t\t\t\tlp->ExcludeUnencrypted  = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]          = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak; */\n\t\t\t\tcase CFG_CNF_MCAST_RATE:\n\t\t\t\t\t/* TODO: determine if we are going to store anything based on this */\n\t\t\t\t\tbreak;\n\t\t\t\tcase CFG_CNF_INTRA_BSS_RELAY:\n\t\t\t\t\tlp->intraBSSRelay   = pLtv->u.u16[0];\n\t\t\t\t\tpLtv->u.u16[0]      = CNV_INT_TO_LITTLE(pLtv->u.u16[0]);\n\t\t\t\t\tbreak;\n#endif\n\t\t\t\tcase CFG_CNF_MICRO_WAVE:",
        "bug_line_number": [],
        "vul": 0,
        "id": 73
    },
    {
        "code": "static bool check_underflow(const struct arpt_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = arpt_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 75
    },
    {
        "code": "static bool check_underflow(const struct ip6t_entry *e)\n{\n\tconst struct xt_entry_target *t;\n\tunsigned int verdict;\n\tif (!unconditional(e))\n\t\treturn false;\n\tt = ip6t_get_target_c(e);\n\tif (strcmp(t->u.user.name, XT_STANDARD_TARGET) != 0)\n\t\treturn false;\n\tverdict = ((struct xt_standard_target *)t)->verdict;\n\tverdict = -verdict - 1;\n\treturn verdict == NF_DROP || verdict == NF_ACCEPT;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 77
    },
    {
        "code": "static inline int check_entry_size_and_hooks(struct arpt_entry *e,\n\t\t\t\t\t     struct xt_table_info *newinfo,\n\t\t\t\t\t     const unsigned char *base,\n\t\t\t\t\t     const unsigned char *limit,\n\t\t\t\t\t     const unsigned int *hook_entries,\n\t\t\t\t\t     const unsigned int *underflows,\n\t\t\t\t\t     unsigned int valid_hooks)\n{\n\tunsigned int h;\n\tint err;\n\tif ((unsigned long)e % __alignof__(struct arpt_entry) != 0 ||\n\t    (unsigned char *)e + sizeof(struct arpt_entry) >= limit ||\n\t    (unsigned char *)e + e->next_offset > limit) {\n\t\tduprintf(\"Bad offset %p\\n\", e);\n\t\treturn -EINVAL;\n\t}\n\tif (e->next_offset\n\t    < sizeof(struct arpt_entry) + sizeof(struct xt_entry_target)) {\n\t\tduprintf(\"checking: element %p size %u\\n\",\n\t\t\t e, e->next_offset);\n\t\treturn -EINVAL;\n\t}\n\terr = check_entry(e);\n\tif (err)\n\t\treturn err;\n\t/* Check hooks & underflows */\n\tfor (h = 0; h < NF_ARP_NUMHOOKS; h++) {\n\t\tif (!(valid_hooks & (1 << h)))\n\t\t\tcontinue;\n\t\tif ((unsigned char *)e - base == hook_entries[h])\n\t\t\tnewinfo->hook_entry[h] = hook_entries[h];\n\t\tif ((unsigned char *)e - base == underflows[h]) {\n\t\t\tif (!check_underflow(e)) {\n\t\t\t\tpr_debug(\"Underflows must be unconditional and \"\n\t\t\t\t\t \"use the STANDARD target with \"\n\t\t\t\t\t \"ACCEPT/DROP\\n\");\n\t\t\t\treturn -EINVAL;\n\t\t\t}\n\t\t\tnewinfo->underflow[h] = underflows[h];\n\t\t}\n\t}\n\t/* Clear counters and comefrom */\n\te->counters = ((struct xt_counters) { 0, 0 });\n\te->comefrom = 0;\n\treturn 0;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 79
    },
    {
        "code": "void uwbd_stop(struct uwb_rc *rc)\n{\n\tif (rc->uwbd.task)\n\t\tkthread_stop(rc->uwbd.task);\n\tuwbd_flush(rc);\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 81
    },
    {
        "code": "static ssize_t k90_show_macro_mode(struct device *dev,\n\t\t\t\t   struct device_attribute *attr, char *buf)\n{\n\tint ret;\n\tstruct usb_interface *usbif = to_usb_interface(dev->parent);\n\tstruct usb_device *usbdev = interface_to_usbdev(usbif);\n\tconst char *macro_mode;\n\tchar *data;\n\tdata = kmalloc(2, GFP_KERNEL);\n\tif (!data)\n\t\treturn -ENOMEM;\n\tret = usb_control_msg(usbdev, usb_rcvctrlpipe(usbdev, 0),\n\t\t\t      K90_REQUEST_GET_MODE,\n\t\t\t      USB_DIR_IN | USB_TYPE_VENDOR |\n\t\t\t      USB_RECIP_DEVICE, 0, 0, data, 2,\n\t\t\t      USB_CTRL_SET_TIMEOUT);\n\tif (ret < 0) {\n\t\tdev_warn(dev, \"Failed to get K90 initial mode (error %d).\\n\",\n\t\t\t ret);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tswitch (data[0]) {\n\tcase K90_MACRO_MODE_HW:\n\t\tmacro_mode = \"HW\";\n\t\tbreak;\n\tcase K90_MACRO_MODE_SW:\n\t\tmacro_mode = \"SW\";\n\t\tbreak;\n\tdefault:\n\t\tdev_warn(dev, \"K90 in unknown mode: %02hhx.\\n\",\n\t\t\t data[0]);\n\t\tret = -EIO;\n\t\tgoto out;\n\t}\n\tret = snprintf(buf, PAGE_SIZE, \"%s\\n\", macro_mode);\nout:\n\tkfree(data);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 83
    },
    {
        "code": "static int steelseries_srws1_probe(struct hid_device *hdev,\n\t\tconst struct hid_device_id *id)\n{\n\tint ret, i;\n\tstruct led_classdev *led;\n\tsize_t name_sz;\n\tchar *name;\n\tstruct steelseries_srws1_data *drv_data = kzalloc(sizeof(*drv_data), GFP_KERNEL);\n\tif (drv_data == NULL) {\n\t\thid_err(hdev, \"can't alloc SRW-S1 memory\\n\");\n\t\treturn -ENOMEM;\n\t}\n\thid_set_drvdata(hdev, drv_data);\n\tret = hid_parse(hdev);\n\tif (ret) {\n\t\thid_err(hdev, \"parse failed\\n\");\n\t\tgoto err_free;\n\t}\n\tif (!hid_validate_values(hdev, HID_OUTPUT_REPORT, 0, 0, 16)) {\n\t\tret = -ENODEV;\n\t\tgoto err_free;\n\t}\n\tret = hid_hw_start(hdev, HID_CONNECT_DEFAULT);\n\tif (ret) {\n\t\thid_err(hdev, \"hw start failed\\n\");\n\t\tgoto err_free;\n\t}\n\t/* register led subsystem */\n\tdrv_data->led_state = 0;\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++)\n\t\tdrv_data->led[i] = NULL;\n\tsteelseries_srws1_set_leds(hdev, 0);\n\tname_sz = strlen(hdev->uniq) + 16;\n\t/* 'ALL', for setting all LEDs simultaneously */\n\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\tif (!led) {\n\t\thid_err(hdev, \"can't allocate memory for LED ALL\\n\");\n\t\tgoto err_led;\n\t}\n\tname = (void *)(&led[1]);\n\tsnprintf(name, name_sz, \"SRWS1::%s::RPMALL\", hdev->uniq);\n\tled->name = name;\n\tled->brightness = 0;\n\tled->max_brightness = 1;\n\tled->brightness_get = steelseries_srws1_led_all_get_brightness;\n\tled->brightness_set = steelseries_srws1_led_all_set_brightness;\n\tdrv_data->led[SRWS1_NUMBER_LEDS] = led;\n\tret = led_classdev_register(&hdev->dev, led);\n\tif (ret)\n\t\tgoto err_led;\n\t/* Each individual LED */\n\tfor (i = 0; i < SRWS1_NUMBER_LEDS; i++) {\n\t\tled = kzalloc(sizeof(struct led_classdev)+name_sz, GFP_KERNEL);\n\t\tif (!led) {\n\t\t\thid_err(hdev, \"can't allocate memory for LED %d\\n\", i);\n\t\t\tgoto err_led;\n\t\t}\n\t\tname = (void *)(&led[1]);\n\t\tsnprintf(name, name_sz, \"SRWS1::%s::RPM%d\", hdev->uniq, i+1);\n\t\tled->name = name;\n\t\tled->brightness = 0;\n\t\tled->max_brightness = 1;\n\t\tled->brightness_get = steelseries_srws1_led_get_brightness;\n\t\tled->brightness_set = steelseries_srws1_led_set_brightness;\n\t\tdrv_data->led[i] = led;\n\t\tret = led_classdev_register(&hdev->dev, led);\n\t\tif (ret) {\n\t\t\thid_err(hdev, \"failed to register LED %d. Aborting.\\n\", i);\nerr_led:\n\t\t\t/* Deregister all LEDs (if any) */\n\t\t\tfor (i = 0; i < SRWS1_NUMBER_LEDS + 1; i++) {\n\t\t\t\tled = drv_data->led[i];\n\t\t\t\tdrv_data->led[i] = NULL;\n\t\t\t\tif (!led)\n\t\t\t\t\tcontinue;\n\t\t\t\tled_classdev_unregister(led);\n\t\t\t\tkfree(led);\n\t\t\t}\n\t\t\tgoto out;\t/* but let the driver continue without LEDs */\n\t\t}\n\t}\nout:\n\treturn 0;\nerr_free:\n\tkfree(drv_data);\n\treturn ret;\n}",
        "bug_line_number": [],
        "vul": 0,
        "id": 85
    },
    {
        "code": "\t * FIXME: It may be fragmented into multiple chunks\n\t *        at once if non-fragmentable extension headers\n\t *        are too large.\n\t * --yoshfuji\n\t */\n\tif ((length > mtu) && dontfrag && (sk->sk_protocol == IPPROTO_UDP ||\n\t\t\t\t\t   sk->sk_protocol == IPPROTO_RAW)) {\n\t\tipv6_local_rxpmtu(sk, fl6, mtu-exthdrlen);\n\t\treturn -EMSGSIZE;\n\t}\n\tskb = skb_peek_tail(&sk->sk_write_queue);\n\tcork->length += length;\n\tif (((length > mtu) ||\n\t     (skb && skb_is_gso(skb))) &&\n\t    (sk->sk_protocol == IPPROTO_UDP) &&\n\t    (rt->dst.dev->features & NETIF_F_UFO)) {\n\t\terr = ip6_ufo_append_data(sk, getfrag, from, length,\n\t\t\t\t\t  hh_len, fragheaderlen,\n\t\t\t\t\t  transhdrlen, mtu, flags, rt);\n\t\tif (err)\n\t\t\tgoto error;\n\t\treturn 0;\n\t}\n\tif (!skb)\n\t\tgoto alloc_new_skb;\n\twhile (length > 0) {\n\t\t/* Check if the remaining data fits into current packet. */\n\t\tcopy = (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - skb->len;\n\t\tif (copy < length)\n\t\t\tcopy = maxfraglen - skb->len;\n\t\tif (copy <= 0) {\n\t\t\tchar *data;\n\t\t\tunsigned int datalen;\n\t\t\tunsigned int fraglen;\n\t\t\tunsigned int fraggap;\n\t\t\tunsigned int alloclen;\nalloc_new_skb:\n\t\t\t/* There's no room in the current skb */\n\t\t\tif (skb)\n\t\t\t\tfraggap = skb->len - maxfraglen;\n\t\t\telse\n\t\t\t\tfraggap = 0;\n\t\t\t/* update mtu and maxfraglen if necessary */\n\t\t\tif (skb == NULL || skb_prev == NULL)\n\t\t\t\tip6_append_data_mtu(&mtu, &maxfraglen,\n\t\t\t\t\t\t    fragheaderlen, skb, rt,\n\t\t\t\t\t\t    np->pmtudisc ==\n\t\t\t\t\t\t    IPV6_PMTUDISC_PROBE);\n\t\t\tskb_prev = skb;\n\t\t\t/*\n\t\t\t * If remaining data exceeds the mtu,\n\t\t\t * we know we need more fragment(s).\n\t\t\t */\n\t\t\tdatalen = length + fraggap;\n\t\t\tif (datalen > (cork->length <= mtu && !(cork->flags & IPCORK_ALLFRAG) ? mtu : maxfraglen) - fragheaderlen)\n\t\t\t\tdatalen = maxfraglen - fragheaderlen - rt->dst.trailer_len;\n\t\t\tif ((flags & MSG_MORE) &&\n\t\t\t    !(rt->dst.dev->features&NETIF_F_SG))\n\t\t\t\talloclen = mtu;\n\t\t\telse\n\t\t\t\talloclen = datalen + fragheaderlen;\n\t\t\talloclen += dst_exthdrlen;\n\t\t\tif (datalen != length + fraggap) {\n\t\t\t\t/*\n\t\t\t\t * this is not the last fragment, the trailer\n\t\t\t\t * space is regarded as data space.\n\t\t\t\t */\n\t\t\t\tdatalen += rt->dst.trailer_len;\n\t\t\t}\n\t\t\talloclen += rt->dst.trailer_len;\n\t\t\tfraglen = datalen + fragheaderlen;\n\t\t\t/*\n\t\t\t * We just reserve space for fragment header.\n\t\t\t * Note: this may be overallocation if the message\n\t\t\t * (without MSG_MORE) fits into the MTU.\n\t\t\t */\n\t\t\talloclen += sizeof(struct frag_hdr);\n\t\t\tif (transhdrlen) {\n\t\t\t\tskb = sock_alloc_send_skb(sk,\n\t\t\t\t\t\talloclen + hh_len,\n\t\t\t\t\t\t(flags & MSG_DONTWAIT), &err);\n\t\t\t} else {\n\t\t\t\tskb = NULL;\n\t\t\t\tif (atomic_read(&sk->sk_wmem_alloc) <=\n\t\t\t\t    2 * sk->sk_sndbuf)\n\t\t\t\t\tskb = sock_wmalloc(sk,\n\t\t\t\t\t\t\t   alloclen + hh_len, 1,\n\t\t\t\t\t\t\t   sk->sk_allocation);\n\t\t\t\tif (unlikely(skb == NULL))\n\t\t\t\t\terr = -ENOBUFS;\n\t\t\t\telse {\n\t\t\t\t\t/* Only the initial fragment\n\t\t\t\t\t * is time stamped.\n\t\t\t\t\t */\n\t\t\t\t\ttx_flags = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (skb == NULL)\n\t\t\t\tgoto error;\n\t\t\t/*\n\t\t\t *\tFill in the control structures\n\t\t\t */\n\t\t\tskb->protocol = htons(ETH_P_IPV6);\n\t\t\tskb->ip_summed = CHECKSUM_NONE;\n\t\t\tskb->csum = 0;\n\t\t\t/* reserve for fragmentation and ipsec header */\n\t\t\tskb_reserve(skb, hh_len + sizeof(struct frag_hdr) +",
        "bug_line_number": [],
        "vul": 0,
        "id": 87
    }
]