[
    {
        "cve_id": "CVE-2020-10742",
        "code_before_change": "static void ll_free_user_pages(struct page **pages, int npages, int do_dirty)\n{\n\tint i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tif (pages[i] == NULL)\n\t\t\tbreak;\n\t\tif (do_dirty)\n\t\t\tset_page_dirty_lock(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\n\tOBD_FREE_LARGE(pages, npages * sizeof(*pages));\n}",
        "code_after_change": "static void ll_free_user_pages(struct page **pages, int npages, int do_dirty)\n{\n\tint i;\n\n\tfor (i = 0; i < npages; i++) {\n\t\tif (do_dirty)\n\t\t\tset_page_dirty_lock(pages[i]);\n\t\tpage_cache_release(pages[i]);\n\t}\n\tkvfree(pages);\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,12 +3,9 @@\n \tint i;\n \n \tfor (i = 0; i < npages; i++) {\n-\t\tif (pages[i] == NULL)\n-\t\t\tbreak;\n \t\tif (do_dirty)\n \t\t\tset_page_dirty_lock(pages[i]);\n \t\tpage_cache_release(pages[i]);\n \t}\n-\n-\tOBD_FREE_LARGE(pages, npages * sizeof(*pages));\n+\tkvfree(pages);\n }",
        "function_modified_lines": {
            "added": [
                "\tkvfree(pages);"
            ],
            "deleted": [
                "\t\tif (pages[i] == NULL)",
                "\t\t\tbreak;",
                "",
                "\tOBD_FREE_LARGE(pages, npages * sizeof(*pages));"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel. An index buffer overflow during Direct IO write leading to the NFS client to crash. In some cases, a reach out of the index after one memory allocation by kmalloc will cause a kernel panic. The highest threat from this vulnerability is to data confidentiality and system availability.",
        "id": 2409
    },
    {
        "cve_id": "CVE-2022-21499",
        "code_before_change": "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
        "code_after_change": "static bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n\t\t\t\t   bool no_args)\n{\n\t/* permissions comes from userspace so needs massaging slightly */\n\tpermissions &= KDB_ENABLE_MASK;\n\tpermissions |= KDB_ENABLE_ALWAYS_SAFE;\n\n\t/* some commands change group when launched with no arguments */\n\tif (no_args)\n\t\tpermissions |= permissions << KDB_ENABLE_NO_ARGS_SHIFT;\n\n\tflags |= KDB_ENABLE_ALL;\n\n\treturn permissions & flags;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,4 +1,4 @@\n-static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n+static bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,\n \t\t\t\t   bool no_args)\n {\n \t/* permissions comes from userspace so needs massaging slightly */",
        "function_modified_lines": {
            "added": [
                "static bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,"
            ],
            "deleted": [
                "static inline bool kdb_check_flags(kdb_cmdflags_t flags, int permissions,"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "KGDB and KDB allow read and write access to kernel memory, and thus should be restricted during lockdown. An attacker with access to a serial port could trigger the debugger so it is important that the debugger respect the lockdown mode when/if it is triggered. CVSS 3.1 Base Score 6.7 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H).",
        "id": 3410
    },
    {
        "cve_id": "CVE-2022-21499",
        "code_before_change": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}",
        "code_after_change": "static int kgdb_cpu_enter(struct kgdb_state *ks, struct pt_regs *regs,\n\t\tint exception_state)\n{\n\tunsigned long flags;\n\tint sstep_tries = 100;\n\tint error;\n\tint cpu;\n\tint trace_on = 0;\n\tint online_cpus = num_online_cpus();\n\tu64 time_left;\n\n\tkgdb_info[ks->cpu].enter_kgdb++;\n\tkgdb_info[ks->cpu].exception_state |= exception_state;\n\n\tif (exception_state == DCPU_WANT_MASTER)\n\t\tatomic_inc(&masters_in_kgdb);\n\telse\n\t\tatomic_inc(&slaves_in_kgdb);\n\n\tif (arch_kgdb_ops.disable_hw_break)\n\t\tarch_kgdb_ops.disable_hw_break(regs);\n\nacquirelock:\n\trcu_read_lock();\n\t/*\n\t * Interrupts will be restored by the 'trap return' code, except when\n\t * single stepping.\n\t */\n\tlocal_irq_save(flags);\n\n\tcpu = ks->cpu;\n\tkgdb_info[cpu].debuggerinfo = regs;\n\tkgdb_info[cpu].task = current;\n\tkgdb_info[cpu].ret_state = 0;\n\tkgdb_info[cpu].irq_depth = hardirq_count() >> HARDIRQ_SHIFT;\n\n\t/* Make sure the above info reaches the primary CPU */\n\tsmp_mb();\n\n\tif (exception_level == 1) {\n\t\tif (raw_spin_trylock(&dbg_master_lock))\n\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\tgoto cpu_master_loop;\n\t}\n\n\t/*\n\t * CPU will loop if it is a slave or request to become a kgdb\n\t * master cpu and acquire the kgdb_active lock:\n\t */\n\twhile (1) {\ncpu_loop:\n\t\tif (kgdb_info[cpu].exception_state & DCPU_NEXT_MASTER) {\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_NEXT_MASTER;\n\t\t\tgoto cpu_master_loop;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_MASTER) {\n\t\t\tif (raw_spin_trylock(&dbg_master_lock)) {\n\t\t\t\tatomic_xchg(&kgdb_active, cpu);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_WANT_BT) {\n\t\t\tdump_stack();\n\t\t\tkgdb_info[cpu].exception_state &= ~DCPU_WANT_BT;\n\t\t} else if (kgdb_info[cpu].exception_state & DCPU_IS_SLAVE) {\n\t\t\tif (!raw_spin_is_locked(&dbg_slave_lock))\n\t\t\t\tgoto return_normal;\n\t\t} else {\nreturn_normal:\n\t\t\t/* Return to normal operation by executing any\n\t\t\t * hw breakpoint fixup.\n\t\t\t */\n\t\t\tif (arch_kgdb_ops.correct_hw_break)\n\t\t\t\tarch_kgdb_ops.correct_hw_break();\n\t\t\tif (trace_on)\n\t\t\t\ttracing_on();\n\t\t\tkgdb_info[cpu].debuggerinfo = NULL;\n\t\t\tkgdb_info[cpu].task = NULL;\n\t\t\tkgdb_info[cpu].exception_state &=\n\t\t\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\t\t\tkgdb_info[cpu].enter_kgdb--;\n\t\t\tsmp_mb__before_atomic();\n\t\t\tatomic_dec(&slaves_in_kgdb);\n\t\t\tdbg_touch_watchdogs();\n\t\t\tlocal_irq_restore(flags);\n\t\t\trcu_read_unlock();\n\t\t\treturn 0;\n\t\t}\n\t\tcpu_relax();\n\t}\n\n\t/*\n\t * For single stepping, try to only enter on the processor\n\t * that was single stepping.  To guard against a deadlock, the\n\t * kernel will only try for the value of sstep_tries before\n\t * giving up and continuing on.\n\t */\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1 &&\n\t    (kgdb_info[cpu].task &&\n\t     kgdb_info[cpu].task->pid != kgdb_sstep_pid) && --sstep_tries) {\n\t\tatomic_set(&kgdb_active, -1);\n\t\traw_spin_unlock(&dbg_master_lock);\n\t\tdbg_touch_watchdogs();\n\t\tlocal_irq_restore(flags);\n\t\trcu_read_unlock();\n\n\t\tgoto acquirelock;\n\t}\n\n\tif (!kgdb_io_ready(1)) {\n\t\tkgdb_info[cpu].ret_state = 1;\n\t\tgoto kgdb_restore; /* No I/O connection, resume the system */\n\t}\n\n\t/*\n\t * Don't enter if we have hit a removed breakpoint.\n\t */\n\tif (kgdb_skipexception(ks->ex_vector, ks->linux_regs))\n\t\tgoto kgdb_restore;\n\n\tatomic_inc(&ignore_console_lock_warning);\n\n\t/* Call the I/O driver's pre_exception routine */\n\tif (dbg_io_ops->pre_exception)\n\t\tdbg_io_ops->pre_exception();\n\n\t/*\n\t * Get the passive CPU lock which will hold all the non-primary\n\t * CPU in a spin state while the debugger is active\n\t */\n\tif (!kgdb_single_step)\n\t\traw_spin_lock(&dbg_slave_lock);\n\n#ifdef CONFIG_SMP\n\t/* If send_ready set, slaves are already waiting */\n\tif (ks->send_ready)\n\t\tatomic_set(ks->send_ready, 1);\n\n\t/* Signal the other CPUs to enter kgdb_wait() */\n\telse if ((!kgdb_single_step) && kgdb_do_roundup)\n\t\tkgdb_roundup_cpus();\n#endif\n\n\t/*\n\t * Wait for the other CPUs to be notified and be waiting for us:\n\t */\n\ttime_left = MSEC_PER_SEC;\n\twhile (kgdb_do_roundup && --time_left &&\n\t       (atomic_read(&masters_in_kgdb) + atomic_read(&slaves_in_kgdb)) !=\n\t\t   online_cpus)\n\t\tudelay(1000);\n\tif (!time_left)\n\t\tpr_crit(\"Timed out waiting for secondary CPUs.\\n\");\n\n\t/*\n\t * At this point the primary processor is completely\n\t * in the debugger and all secondary CPUs are quiescent\n\t */\n\tdbg_deactivate_sw_breakpoints();\n\tkgdb_single_step = 0;\n\tkgdb_contthread = current;\n\texception_level = 0;\n\ttrace_on = tracing_is_on();\n\tif (trace_on)\n\t\ttracing_off();\n\n\twhile (1) {\ncpu_master_loop:\n\t\tif (dbg_kdb_mode) {\n\t\t\tkgdb_connected = 1;\n\t\t\terror = kdb_stub(ks);\n\t\t\tif (error == -1)\n\t\t\t\tcontinue;\n\t\t\tkgdb_connected = 0;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This is a brutal way to interfere with the debugger\n\t\t\t * and prevent gdb being used to poke at kernel memory.\n\t\t\t * This could cause trouble if lockdown is applied when\n\t\t\t * there is already an active gdb session. For now the\n\t\t\t * answer is simply \"don't do that\". Typically lockdown\n\t\t\t * *will* be applied before the debug core gets started\n\t\t\t * so only developers using kgdb for fairly advanced\n\t\t\t * early kernel debug can be biten by this. Hopefully\n\t\t\t * they are sophisticated enough to take care of\n\t\t\t * themselves, especially with help from the lockdown\n\t\t\t * message printed on the console!\n\t\t\t */\n\t\t\tif (security_locked_down(LOCKDOWN_DBG_WRITE_KERNEL)) {\n\t\t\t\tif (IS_ENABLED(CONFIG_KGDB_KDB)) {\n\t\t\t\t\t/* Switch back to kdb if possible... */\n\t\t\t\t\tdbg_kdb_mode = 1;\n\t\t\t\t\tcontinue;\n\t\t\t\t} else {\n\t\t\t\t\t/* ... otherwise just bail */\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\terror = gdb_serial_stub(ks);\n\t\t}\n\n\t\tif (error == DBG_PASS_EVENT) {\n\t\t\tdbg_kdb_mode = !dbg_kdb_mode;\n\t\t} else if (error == DBG_SWITCH_CPU_EVENT) {\n\t\t\tkgdb_info[dbg_switch_cpu].exception_state |=\n\t\t\t\tDCPU_NEXT_MASTER;\n\t\t\tgoto cpu_loop;\n\t\t} else {\n\t\t\tkgdb_info[cpu].ret_state = error;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tdbg_activate_sw_breakpoints();\n\n\t/* Call the I/O driver's post_exception routine */\n\tif (dbg_io_ops->post_exception)\n\t\tdbg_io_ops->post_exception();\n\n\tatomic_dec(&ignore_console_lock_warning);\n\n\tif (!kgdb_single_step) {\n\t\traw_spin_unlock(&dbg_slave_lock);\n\t\t/* Wait till all the CPUs have quit from the debugger. */\n\t\twhile (kgdb_do_roundup && atomic_read(&slaves_in_kgdb))\n\t\t\tcpu_relax();\n\t}\n\nkgdb_restore:\n\tif (atomic_read(&kgdb_cpu_doing_single_step) != -1) {\n\t\tint sstep_cpu = atomic_read(&kgdb_cpu_doing_single_step);\n\t\tif (kgdb_info[sstep_cpu].task)\n\t\t\tkgdb_sstep_pid = kgdb_info[sstep_cpu].task->pid;\n\t\telse\n\t\t\tkgdb_sstep_pid = 0;\n\t}\n\tif (arch_kgdb_ops.correct_hw_break)\n\t\tarch_kgdb_ops.correct_hw_break();\n\tif (trace_on)\n\t\ttracing_on();\n\n\tkgdb_info[cpu].debuggerinfo = NULL;\n\tkgdb_info[cpu].task = NULL;\n\tkgdb_info[cpu].exception_state &=\n\t\t~(DCPU_WANT_MASTER | DCPU_IS_SLAVE);\n\tkgdb_info[cpu].enter_kgdb--;\n\tsmp_mb__before_atomic();\n\tatomic_dec(&masters_in_kgdb);\n\t/* Free kgdb_active */\n\tatomic_set(&kgdb_active, -1);\n\traw_spin_unlock(&dbg_master_lock);\n\tdbg_touch_watchdogs();\n\tlocal_irq_restore(flags);\n\trcu_read_unlock();\n\n\treturn kgdb_info[cpu].ret_state;\n}",
        "patch": "--- code before\n+++ code after\n@@ -171,6 +171,29 @@\n \t\t\t\tcontinue;\n \t\t\tkgdb_connected = 0;\n \t\t} else {\n+\t\t\t/*\n+\t\t\t * This is a brutal way to interfere with the debugger\n+\t\t\t * and prevent gdb being used to poke at kernel memory.\n+\t\t\t * This could cause trouble if lockdown is applied when\n+\t\t\t * there is already an active gdb session. For now the\n+\t\t\t * answer is simply \"don't do that\". Typically lockdown\n+\t\t\t * *will* be applied before the debug core gets started\n+\t\t\t * so only developers using kgdb for fairly advanced\n+\t\t\t * early kernel debug can be biten by this. Hopefully\n+\t\t\t * they are sophisticated enough to take care of\n+\t\t\t * themselves, especially with help from the lockdown\n+\t\t\t * message printed on the console!\n+\t\t\t */\n+\t\t\tif (security_locked_down(LOCKDOWN_DBG_WRITE_KERNEL)) {\n+\t\t\t\tif (IS_ENABLED(CONFIG_KGDB_KDB)) {\n+\t\t\t\t\t/* Switch back to kdb if possible... */\n+\t\t\t\t\tdbg_kdb_mode = 1;\n+\t\t\t\t\tcontinue;\n+\t\t\t\t} else {\n+\t\t\t\t\t/* ... otherwise just bail */\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t}\n \t\t\terror = gdb_serial_stub(ks);\n \t\t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\t/*",
                "\t\t\t * This is a brutal way to interfere with the debugger",
                "\t\t\t * and prevent gdb being used to poke at kernel memory.",
                "\t\t\t * This could cause trouble if lockdown is applied when",
                "\t\t\t * there is already an active gdb session. For now the",
                "\t\t\t * answer is simply \"don't do that\". Typically lockdown",
                "\t\t\t * *will* be applied before the debug core gets started",
                "\t\t\t * so only developers using kgdb for fairly advanced",
                "\t\t\t * early kernel debug can be biten by this. Hopefully",
                "\t\t\t * they are sophisticated enough to take care of",
                "\t\t\t * themselves, especially with help from the lockdown",
                "\t\t\t * message printed on the console!",
                "\t\t\t */",
                "\t\t\tif (security_locked_down(LOCKDOWN_DBG_WRITE_KERNEL)) {",
                "\t\t\t\tif (IS_ENABLED(CONFIG_KGDB_KDB)) {",
                "\t\t\t\t\t/* Switch back to kdb if possible... */",
                "\t\t\t\t\tdbg_kdb_mode = 1;",
                "\t\t\t\t\tcontinue;",
                "\t\t\t\t} else {",
                "\t\t\t\t\t/* ... otherwise just bail */",
                "\t\t\t\t\tbreak;",
                "\t\t\t\t}",
                "\t\t\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "KGDB and KDB allow read and write access to kernel memory, and thus should be restricted during lockdown. An attacker with access to a serial port could trigger the debugger so it is important that the debugger respect the lockdown mode when/if it is triggered. CVSS 3.1 Base Score 6.7 (Confidentiality, Integrity and Availability impacts). CVSS Vector: (CVSS:3.1/AV:L/AC:L/PR:H/UI:N/S:U/C:H/I:H/A:H).",
        "id": 3409
    },
    {
        "cve_id": "CVE-2017-1000251",
        "code_before_change": "static inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp);\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}",
        "code_after_change": "static inline int l2cap_config_req(struct l2cap_conn *conn,\n\t\t\t\t   struct l2cap_cmd_hdr *cmd, u16 cmd_len,\n\t\t\t\t   u8 *data)\n{\n\tstruct l2cap_conf_req *req = (struct l2cap_conf_req *) data;\n\tu16 dcid, flags;\n\tu8 rsp[64];\n\tstruct l2cap_chan *chan;\n\tint len, err = 0;\n\n\tif (cmd_len < sizeof(*req))\n\t\treturn -EPROTO;\n\n\tdcid  = __le16_to_cpu(req->dcid);\n\tflags = __le16_to_cpu(req->flags);\n\n\tBT_DBG(\"dcid 0x%4.4x flags 0x%2.2x\", dcid, flags);\n\n\tchan = l2cap_get_chan_by_scid(conn, dcid);\n\tif (!chan) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, dcid, 0);\n\t\treturn 0;\n\t}\n\n\tif (chan->state != BT_CONFIG && chan->state != BT_CONNECT2) {\n\t\tcmd_reject_invalid_cid(conn, cmd->ident, chan->scid,\n\t\t\t\t       chan->dcid);\n\t\tgoto unlock;\n\t}\n\n\t/* Reject if config buffer is too small. */\n\tlen = cmd_len - sizeof(*req);\n\tif (chan->conf_len + len > sizeof(chan->conf_req)) {\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_REJECT, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Store config. */\n\tmemcpy(chan->conf_req + chan->conf_len, req->data, len);\n\tchan->conf_len += len;\n\n\tif (flags & L2CAP_CONF_FLAG_CONTINUATION) {\n\t\t/* Incomplete config. Send empty response. */\n\t\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP,\n\t\t\t       l2cap_build_conf_rsp(chan, rsp,\n\t\t\t       L2CAP_CONF_SUCCESS, flags), rsp);\n\t\tgoto unlock;\n\t}\n\n\t/* Complete config. */\n\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n\tif (len < 0) {\n\t\tl2cap_send_disconn_req(chan, ECONNRESET);\n\t\tgoto unlock;\n\t}\n\n\tchan->ident = cmd->ident;\n\tl2cap_send_cmd(conn, cmd->ident, L2CAP_CONF_RSP, len, rsp);\n\tchan->num_conf_rsp++;\n\n\t/* Reset config buffer. */\n\tchan->conf_len = 0;\n\n\tif (!test_bit(CONF_OUTPUT_DONE, &chan->conf_state))\n\t\tgoto unlock;\n\n\tif (test_bit(CONF_INPUT_DONE, &chan->conf_state)) {\n\t\tset_default_fcs(chan);\n\n\t\tif (chan->mode == L2CAP_MODE_ERTM ||\n\t\t    chan->mode == L2CAP_MODE_STREAMING)\n\t\t\terr = l2cap_ertm_init(chan);\n\n\t\tif (err < 0)\n\t\t\tl2cap_send_disconn_req(chan, -err);\n\t\telse\n\t\t\tl2cap_chan_ready(chan);\n\n\t\tgoto unlock;\n\t}\n\n\tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n\t\tu8 buf[64];\n\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n\t\tchan->num_conf_req++;\n\t}\n\n\t/* Got Conf Rsp PENDING from remote side and assume we sent\n\t   Conf Rsp PENDING in the code above */\n\tif (test_bit(CONF_REM_CONF_PEND, &chan->conf_state) &&\n\t    test_bit(CONF_LOC_CONF_PEND, &chan->conf_state)) {\n\n\t\t/* check compatibility */\n\n\t\t/* Send rsp for BR/EDR channel */\n\t\tif (!chan->hs_hcon)\n\t\t\tl2cap_send_efs_conf_rsp(chan, rsp, cmd->ident, flags);\n\t\telse\n\t\t\tchan->ident = cmd->ident;\n\t}\n\nunlock:\n\tl2cap_chan_unlock(chan);\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -50,7 +50,7 @@\n \t}\n \n \t/* Complete config. */\n-\tlen = l2cap_parse_conf_req(chan, rsp);\n+\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));\n \tif (len < 0) {\n \t\tl2cap_send_disconn_req(chan, ECONNRESET);\n \t\tgoto unlock;\n@@ -84,7 +84,7 @@\n \tif (!test_and_set_bit(CONF_REQ_SENT, &chan->conf_state)) {\n \t\tu8 buf[64];\n \t\tl2cap_send_cmd(conn, l2cap_get_ident(conn), L2CAP_CONF_REQ,\n-\t\t\t       l2cap_build_conf_req(chan, buf), buf);\n+\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);\n \t\tchan->num_conf_req++;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\tlen = l2cap_parse_conf_req(chan, rsp, sizeof(rsp));",
                "\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)), buf);"
            ],
            "deleted": [
                "\tlen = l2cap_parse_conf_req(chan, rsp);",
                "\t\t\t       l2cap_build_conf_req(chan, buf), buf);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
        "id": 1189
    },
    {
        "cve_id": "CVE-2017-1000251",
        "code_before_change": "static void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"conn %p status 0x%2.2x encrypt %u\", conn, status, encrypt);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tBT_DBG(\"chan %p scid 0x%4.4x state %s\", chan, chan->scid,\n\t\t       state_to_string(chan->state));\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && encrypt)\n\t\t\tchan->sec_level = hcon->sec_level;\n\n\t\tif (!__l2cap_no_conn_pending(chan)) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (chan->state == BT_CONNECTED ||\n\t\t\t\tchan->state == BT_CONFIG)) {\n\t\t\tchan->ops->resume(chan);\n\t\t\tl2cap_check_encryption(chan, encrypt);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!status)\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t} else if (chan->state == BT_CONNECT2 &&\n\t\t\t   chan->mode != L2CAP_MODE_LE_FLOWCTL) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 res, stat;\n\n\t\t\tif (!status) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\tres = L2CAP_CR_PEND;\n\t\t\t\t\tstat = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\t\tchan->ops->defer(chan);\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tres = L2CAP_CR_SUCCESS;\n\t\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t\t\tres = L2CAP_CR_SEC_BLOCK;\n\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(chan->scid);\n\t\t\trsp.result = cpu_to_le16(res);\n\t\t\trsp.status = cpu_to_le16(stat);\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t\t\t    res == L2CAP_CR_SUCCESS) {\n\t\t\t\tchar buf[128];\n\t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t\t       l2cap_build_conf_req(chan, buf),\n\t\t\t\t\t       buf);\n\t\t\t\tchan->num_conf_req++;\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}",
        "code_after_change": "static void l2cap_security_cfm(struct hci_conn *hcon, u8 status, u8 encrypt)\n{\n\tstruct l2cap_conn *conn = hcon->l2cap_data;\n\tstruct l2cap_chan *chan;\n\n\tif (!conn)\n\t\treturn;\n\n\tBT_DBG(\"conn %p status 0x%2.2x encrypt %u\", conn, status, encrypt);\n\n\tmutex_lock(&conn->chan_lock);\n\n\tlist_for_each_entry(chan, &conn->chan_l, list) {\n\t\tl2cap_chan_lock(chan);\n\n\t\tBT_DBG(\"chan %p scid 0x%4.4x state %s\", chan, chan->scid,\n\t\t       state_to_string(chan->state));\n\n\t\tif (chan->scid == L2CAP_CID_A2MP) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && encrypt)\n\t\t\tchan->sec_level = hcon->sec_level;\n\n\t\tif (!__l2cap_no_conn_pending(chan)) {\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!status && (chan->state == BT_CONNECTED ||\n\t\t\t\tchan->state == BT_CONFIG)) {\n\t\t\tchan->ops->resume(chan);\n\t\t\tl2cap_check_encryption(chan, encrypt);\n\t\t\tl2cap_chan_unlock(chan);\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (chan->state == BT_CONNECT) {\n\t\t\tif (!status)\n\t\t\t\tl2cap_start_connection(chan);\n\t\t\telse\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t} else if (chan->state == BT_CONNECT2 &&\n\t\t\t   chan->mode != L2CAP_MODE_LE_FLOWCTL) {\n\t\t\tstruct l2cap_conn_rsp rsp;\n\t\t\t__u16 res, stat;\n\n\t\t\tif (!status) {\n\t\t\t\tif (test_bit(FLAG_DEFER_SETUP, &chan->flags)) {\n\t\t\t\t\tres = L2CAP_CR_PEND;\n\t\t\t\t\tstat = L2CAP_CS_AUTHOR_PEND;\n\t\t\t\t\tchan->ops->defer(chan);\n\t\t\t\t} else {\n\t\t\t\t\tl2cap_state_change(chan, BT_CONFIG);\n\t\t\t\t\tres = L2CAP_CR_SUCCESS;\n\t\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tl2cap_state_change(chan, BT_DISCONN);\n\t\t\t\t__set_chan_timer(chan, L2CAP_DISC_TIMEOUT);\n\t\t\t\tres = L2CAP_CR_SEC_BLOCK;\n\t\t\t\tstat = L2CAP_CS_NO_INFO;\n\t\t\t}\n\n\t\t\trsp.scid   = cpu_to_le16(chan->dcid);\n\t\t\trsp.dcid   = cpu_to_le16(chan->scid);\n\t\t\trsp.result = cpu_to_le16(res);\n\t\t\trsp.status = cpu_to_le16(stat);\n\t\t\tl2cap_send_cmd(conn, chan->ident, L2CAP_CONN_RSP,\n\t\t\t\t       sizeof(rsp), &rsp);\n\n\t\t\tif (!test_bit(CONF_REQ_SENT, &chan->conf_state) &&\n\t\t\t    res == L2CAP_CR_SUCCESS) {\n\t\t\t\tchar buf[128];\n\t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n\t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n\t\t\t\t\t       L2CAP_CONF_REQ,\n\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),\n\t\t\t\t\t       buf);\n\t\t\t\tchan->num_conf_req++;\n\t\t\t}\n\t\t}\n\n\t\tl2cap_chan_unlock(chan);\n\t}\n\n\tmutex_unlock(&conn->chan_lock);\n}",
        "patch": "--- code before\n+++ code after\n@@ -77,7 +77,7 @@\n \t\t\t\tset_bit(CONF_REQ_SENT, &chan->conf_state);\n \t\t\t\tl2cap_send_cmd(conn, l2cap_get_ident(conn),\n \t\t\t\t\t       L2CAP_CONF_REQ,\n-\t\t\t\t\t       l2cap_build_conf_req(chan, buf),\n+\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),\n \t\t\t\t\t       buf);\n \t\t\t\tchan->num_conf_req++;\n \t\t\t}",
        "function_modified_lines": {
            "added": [
                "\t\t\t\t\t       l2cap_build_conf_req(chan, buf, sizeof(buf)),"
            ],
            "deleted": [
                "\t\t\t\t\t       l2cap_build_conf_req(chan, buf),"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The native Bluetooth stack in the Linux Kernel (BlueZ), starting at the Linux kernel version 2.6.32 and up to and including 4.13.1, are vulnerable to a stack overflow vulnerability in the processing of L2CAP configuration responses resulting in Remote code execution in kernel space.",
        "id": 1192
    },
    {
        "cve_id": "CVE-2022-4378",
        "code_before_change": "static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tsize_t left;\n\tchar *p;\n\n\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = (int *) tbl_data;\n\tvleft = table->maxlen / sizeof(*i);\n\tleft = *lenp;\n\n\tif (!conv)\n\t\tconv = do_proc_dointvec_conv;\n\n\tif (write) {\n\t\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\t\tgoto out;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tp = buffer;\n\t}\n\n\tfor (; left && vleft--; i++, first=0) {\n\t\tunsigned long lval;\n\t\tbool neg;\n\n\t\tif (write) {\n\t\t\tleft -= proc_skip_spaces(&p);\n\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\t\t\terr = proc_get_long(&p, &left, &lval, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (conv(&neg, &lval, i, 1, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (conv(&neg, &lval, i, 0, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, '\\t');\n\t\t\tproc_put_long(&buffer, &left, lval, neg);\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\tproc_put_char(&buffer, &left, '\\n');\n\tif (write && !err && left)\n\t\tleft -= proc_skip_spaces(&p);\n\tif (write && first)\n\t\treturn err ? : -EINVAL;\n\t*lenp -= left;\nout:\n\t*ppos += *lenp;\n\treturn err;\n}",
        "code_after_change": "static int __do_proc_dointvec(void *tbl_data, struct ctl_table *table,\n\t\t  int write, void *buffer,\n\t\t  size_t *lenp, loff_t *ppos,\n\t\t  int (*conv)(bool *negp, unsigned long *lvalp, int *valp,\n\t\t\t      int write, void *data),\n\t\t  void *data)\n{\n\tint *i, vleft, first = 1, err = 0;\n\tsize_t left;\n\tchar *p;\n\n\tif (!tbl_data || !table->maxlen || !*lenp || (*ppos && !write)) {\n\t\t*lenp = 0;\n\t\treturn 0;\n\t}\n\n\ti = (int *) tbl_data;\n\tvleft = table->maxlen / sizeof(*i);\n\tleft = *lenp;\n\n\tif (!conv)\n\t\tconv = do_proc_dointvec_conv;\n\n\tif (write) {\n\t\tif (proc_first_pos_non_zero_ignore(ppos, table))\n\t\t\tgoto out;\n\n\t\tif (left > PAGE_SIZE - 1)\n\t\t\tleft = PAGE_SIZE - 1;\n\t\tp = buffer;\n\t}\n\n\tfor (; left && vleft--; i++, first=0) {\n\t\tunsigned long lval;\n\t\tbool neg;\n\n\t\tif (write) {\n\t\t\tproc_skip_spaces(&p, &left);\n\n\t\t\tif (!left)\n\t\t\t\tbreak;\n\t\t\terr = proc_get_long(&p, &left, &lval, &neg,\n\t\t\t\t\t     proc_wspace_sep,\n\t\t\t\t\t     sizeof(proc_wspace_sep), NULL);\n\t\t\tif (err)\n\t\t\t\tbreak;\n\t\t\tif (conv(&neg, &lval, i, 1, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tif (conv(&neg, &lval, i, 0, data)) {\n\t\t\t\terr = -EINVAL;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (!first)\n\t\t\t\tproc_put_char(&buffer, &left, '\\t');\n\t\t\tproc_put_long(&buffer, &left, lval, neg);\n\t\t}\n\t}\n\n\tif (!write && !first && left && !err)\n\t\tproc_put_char(&buffer, &left, '\\n');\n\tif (write && !err && left)\n\t\tproc_skip_spaces(&p, &left);\n\tif (write && first)\n\t\treturn err ? : -EINVAL;\n\t*lenp -= left;\nout:\n\t*ppos += *lenp;\n\treturn err;\n}",
        "patch": "--- code before\n+++ code after\n@@ -35,7 +35,7 @@\n \t\tbool neg;\n \n \t\tif (write) {\n-\t\t\tleft -= proc_skip_spaces(&p);\n+\t\t\tproc_skip_spaces(&p, &left);\n \n \t\t\tif (!left)\n \t\t\t\tbreak;\n@@ -62,7 +62,7 @@\n \tif (!write && !first && left && !err)\n \t\tproc_put_char(&buffer, &left, '\\n');\n \tif (write && !err && left)\n-\t\tleft -= proc_skip_spaces(&p);\n+\t\tproc_skip_spaces(&p, &left);\n \tif (write && first)\n \t\treturn err ? : -EINVAL;\n \t*lenp -= left;",
        "function_modified_lines": {
            "added": [
                "\t\t\tproc_skip_spaces(&p, &left);",
                "\t\tproc_skip_spaces(&p, &left);"
            ],
            "deleted": [
                "\t\t\tleft -= proc_skip_spaces(&p);",
                "\t\tleft -= proc_skip_spaces(&p);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A stack overflow flaw was found in the Linux kernel's SYSCTL subsystem in how a user changes certain kernel parameters and variables. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "id": 3743
    },
    {
        "cve_id": "CVE-2023-5717",
        "code_before_change": "static void perf_group_attach(struct perf_event *event)\n{\n\tstruct perf_event *group_leader = event->group_leader, *pos;\n\n\tlockdep_assert_held(&event->ctx->lock);\n\n\t/*\n\t * We can have double attach due to group movement (move_group) in\n\t * perf_event_open().\n\t */\n\tif (event->attach_state & PERF_ATTACH_GROUP)\n\t\treturn;\n\n\tevent->attach_state |= PERF_ATTACH_GROUP;\n\n\tif (group_leader == event)\n\t\treturn;\n\n\tWARN_ON_ONCE(group_leader->ctx != event->ctx);\n\n\tgroup_leader->group_caps &= event->event_caps;\n\n\tlist_add_tail(&event->sibling_list, &group_leader->sibling_list);\n\tgroup_leader->nr_siblings++;\n\n\tperf_event__header_size(group_leader);\n\n\tfor_each_sibling_event(pos, group_leader)\n\t\tperf_event__header_size(pos);\n}",
        "code_after_change": "static void perf_group_attach(struct perf_event *event)\n{\n\tstruct perf_event *group_leader = event->group_leader, *pos;\n\n\tlockdep_assert_held(&event->ctx->lock);\n\n\t/*\n\t * We can have double attach due to group movement (move_group) in\n\t * perf_event_open().\n\t */\n\tif (event->attach_state & PERF_ATTACH_GROUP)\n\t\treturn;\n\n\tevent->attach_state |= PERF_ATTACH_GROUP;\n\n\tif (group_leader == event)\n\t\treturn;\n\n\tWARN_ON_ONCE(group_leader->ctx != event->ctx);\n\n\tgroup_leader->group_caps &= event->event_caps;\n\n\tlist_add_tail(&event->sibling_list, &group_leader->sibling_list);\n\tgroup_leader->nr_siblings++;\n\tgroup_leader->group_generation++;\n\n\tperf_event__header_size(group_leader);\n\n\tfor_each_sibling_event(pos, group_leader)\n\t\tperf_event__header_size(pos);\n}",
        "patch": "--- code before\n+++ code after\n@@ -22,6 +22,7 @@\n \n \tlist_add_tail(&event->sibling_list, &group_leader->sibling_list);\n \tgroup_leader->nr_siblings++;\n+\tgroup_leader->group_generation++;\n \n \tperf_event__header_size(group_leader);\n ",
        "function_modified_lines": {
            "added": [
                "\tgroup_leader->group_generation++;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.\n\n",
        "id": 4292
    },
    {
        "cve_id": "CVE-2023-5717",
        "code_before_change": "static void perf_group_detach(struct perf_event *event)\n{\n\tstruct perf_event *leader = event->group_leader;\n\tstruct perf_event *sibling, *tmp;\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_GROUP))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_GROUP;\n\n\tperf_put_aux_event(event);\n\n\t/*\n\t * If this is a sibling, remove it from its group.\n\t */\n\tif (leader != event) {\n\t\tlist_del_init(&event->sibling_list);\n\t\tevent->group_leader->nr_siblings--;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this was a group event with sibling events then\n\t * upgrade the siblings to singleton events by adding them\n\t * to whatever list we are on.\n\t */\n\tlist_for_each_entry_safe(sibling, tmp, &event->sibling_list, sibling_list) {\n\n\t\tif (sibling->event_caps & PERF_EV_CAP_SIBLING)\n\t\t\tperf_remove_sibling_event(sibling);\n\n\t\tsibling->group_leader = sibling;\n\t\tlist_del_init(&sibling->sibling_list);\n\n\t\t/* Inherit group flags from the previous leader */\n\t\tsibling->group_caps = event->group_caps;\n\n\t\tif (sibling->attach_state & PERF_ATTACH_CONTEXT) {\n\t\t\tadd_event_to_groups(sibling, event->ctx);\n\n\t\t\tif (sibling->state == PERF_EVENT_STATE_ACTIVE)\n\t\t\t\tlist_add_tail(&sibling->active_list, get_event_list(sibling));\n\t\t}\n\n\t\tWARN_ON_ONCE(sibling->ctx != event->ctx);\n\t}\n\nout:\n\tfor_each_sibling_event(tmp, leader)\n\t\tperf_event__header_size(tmp);\n\n\tperf_event__header_size(leader);\n}",
        "code_after_change": "static void perf_group_detach(struct perf_event *event)\n{\n\tstruct perf_event *leader = event->group_leader;\n\tstruct perf_event *sibling, *tmp;\n\tstruct perf_event_context *ctx = event->ctx;\n\n\tlockdep_assert_held(&ctx->lock);\n\n\t/*\n\t * We can have double detach due to exit/hot-unplug + close.\n\t */\n\tif (!(event->attach_state & PERF_ATTACH_GROUP))\n\t\treturn;\n\n\tevent->attach_state &= ~PERF_ATTACH_GROUP;\n\n\tperf_put_aux_event(event);\n\n\t/*\n\t * If this is a sibling, remove it from its group.\n\t */\n\tif (leader != event) {\n\t\tlist_del_init(&event->sibling_list);\n\t\tevent->group_leader->nr_siblings--;\n\t\tevent->group_leader->group_generation++;\n\t\tgoto out;\n\t}\n\n\t/*\n\t * If this was a group event with sibling events then\n\t * upgrade the siblings to singleton events by adding them\n\t * to whatever list we are on.\n\t */\n\tlist_for_each_entry_safe(sibling, tmp, &event->sibling_list, sibling_list) {\n\n\t\tif (sibling->event_caps & PERF_EV_CAP_SIBLING)\n\t\t\tperf_remove_sibling_event(sibling);\n\n\t\tsibling->group_leader = sibling;\n\t\tlist_del_init(&sibling->sibling_list);\n\n\t\t/* Inherit group flags from the previous leader */\n\t\tsibling->group_caps = event->group_caps;\n\n\t\tif (sibling->attach_state & PERF_ATTACH_CONTEXT) {\n\t\t\tadd_event_to_groups(sibling, event->ctx);\n\n\t\t\tif (sibling->state == PERF_EVENT_STATE_ACTIVE)\n\t\t\t\tlist_add_tail(&sibling->active_list, get_event_list(sibling));\n\t\t}\n\n\t\tWARN_ON_ONCE(sibling->ctx != event->ctx);\n\t}\n\nout:\n\tfor_each_sibling_event(tmp, leader)\n\t\tperf_event__header_size(tmp);\n\n\tperf_event__header_size(leader);\n}",
        "patch": "--- code before\n+++ code after\n@@ -22,6 +22,7 @@\n \tif (leader != event) {\n \t\tlist_del_init(&event->sibling_list);\n \t\tevent->group_leader->nr_siblings--;\n+\t\tevent->group_leader->group_generation++;\n \t\tgoto out;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tevent->group_leader->group_generation++;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.\n\n",
        "id": 4288
    },
    {
        "cve_id": "CVE-2023-5717",
        "code_before_change": "static int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\t/*\n\t * By locking the child_mutex of the leader we effectively\n\t * lock the child list of all siblings.. XXX explain how.\n\t */\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}",
        "code_after_change": "static int perf_read_group(struct perf_event *event,\n\t\t\t\t   u64 read_format, char __user *buf)\n{\n\tstruct perf_event *leader = event->group_leader, *child;\n\tstruct perf_event_context *ctx = leader->ctx;\n\tint ret;\n\tu64 *values;\n\n\tlockdep_assert_held(&ctx->mutex);\n\n\tvalues = kzalloc(event->read_size, GFP_KERNEL);\n\tif (!values)\n\t\treturn -ENOMEM;\n\n\tvalues[0] = 1 + leader->nr_siblings;\n\n\tmutex_lock(&leader->child_mutex);\n\n\tret = __perf_read_group_add(leader, read_format, values);\n\tif (ret)\n\t\tgoto unlock;\n\n\tlist_for_each_entry(child, &leader->child_list, child_list) {\n\t\tret = __perf_read_group_add(child, read_format, values);\n\t\tif (ret)\n\t\t\tgoto unlock;\n\t}\n\n\tmutex_unlock(&leader->child_mutex);\n\n\tret = event->read_size;\n\tif (copy_to_user(buf, values, event->read_size))\n\t\tret = -EFAULT;\n\tgoto out;\n\nunlock:\n\tmutex_unlock(&leader->child_mutex);\nout:\n\tkfree(values);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -14,10 +14,6 @@\n \n \tvalues[0] = 1 + leader->nr_siblings;\n \n-\t/*\n-\t * By locking the child_mutex of the leader we effectively\n-\t * lock the child list of all siblings.. XXX explain how.\n-\t */\n \tmutex_lock(&leader->child_mutex);\n \n \tret = __perf_read_group_add(leader, read_format, values);",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t/*",
                "\t * By locking the child_mutex of the leader we effectively",
                "\t * lock the child list of all siblings.. XXX explain how.",
                "\t */"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux kernel's Linux Kernel Performance Events (perf) component can be exploited to achieve local privilege escalation.\n\nIf perf_read_group() is called while an event's sibling_list is smaller than its child's sibling_list, it can increment or write to memory locations outside of the allocated buffer.\n\nWe recommend upgrading past commit 32671e3799ca2e4590773fd0e63aaa4229e50c06.\n\n",
        "id": 4290
    },
    {
        "cve_id": "CVE-2021-27365",
        "code_before_change": "int iscsi_session_get_param(struct iscsi_cls_session *cls_session,\n\t\t\t    enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tint len;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tlen = sprintf(buf, \"%d\\n\", session->fast_abort);\n\t\tbreak;\n\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tlen = sprintf(buf, \"%d\\n\", session->abort_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tlen = sprintf(buf, \"%d\\n\", session->lu_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tlen = sprintf(buf, \"%d\\n\", session->tgt_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tlen = sprintf(buf, \"%d\\n\", session->initial_r2t_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_R2T:\n\t\tlen = sprintf(buf, \"%hu\\n\", session->max_r2t);\n\t\tbreak;\n\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tlen = sprintf(buf, \"%d\\n\", session->imm_data_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tlen = sprintf(buf, \"%u\\n\", session->first_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_BURST:\n\t\tlen = sprintf(buf, \"%u\\n\", session->max_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tlen = sprintf(buf, \"%d\\n\", session->pdu_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tlen = sprintf(buf, \"%d\\n\", session->dataseq_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TASKMGMT_TMO:\n\t\tlen = sprintf(buf, \"%d\\n\", session->def_taskmgmt_tmo);\n\t\tbreak;\n\tcase ISCSI_PARAM_ERL:\n\t\tlen = sprintf(buf, \"%d\\n\", session->erl);\n\t\tbreak;\n\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", session->targetname);\n\t\tbreak;\n\tcase ISCSI_PARAM_TARGET_ALIAS:\n\t\tlen = sprintf(buf, \"%s\\n\", session->targetalias);\n\t\tbreak;\n\tcase ISCSI_PARAM_TPGT:\n\t\tlen = sprintf(buf, \"%d\\n\", session->tpgt);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME:\n\t\tlen = sprintf(buf, \"%s\\n\", session->username);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tlen = sprintf(buf, \"%s\\n\", session->username_in);\n\t\tbreak;\n\tcase ISCSI_PARAM_PASSWORD:\n\t\tlen = sprintf(buf, \"%s\\n\", session->password);\n\t\tbreak;\n\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tlen = sprintf(buf, \"%s\\n\", session->password_in);\n\t\tbreak;\n\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", session->ifacename);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\tlen = sprintf(buf, \"%s\\n\", session->initiatorname);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_ROOT:\n\t\tlen = sprintf(buf, \"%s\\n\", session->boot_root);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_NIC:\n\t\tlen = sprintf(buf, \"%s\\n\", session->boot_nic);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_TARGET:\n\t\tlen = sprintf(buf, \"%s\\n\", session->boot_target);\n\t\tbreak;\n\tcase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\n\t\tlen = sprintf(buf, \"%u\\n\", session->auto_snd_tgt_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_sess);\n\t\tbreak;\n\tcase ISCSI_PARAM_PORTAL_TYPE:\n\t\tlen = sprintf(buf, \"%s\\n\", session->portal_type);\n\t\tbreak;\n\tcase ISCSI_PARAM_CHAP_AUTH_EN:\n\t\tlen = sprintf(buf, \"%u\\n\", session->chap_auth_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_logout_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_BIDI_CHAP_EN:\n\t\tlen = sprintf(buf, \"%u\\n\", session->bidi_chap_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_auth_optional);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TIME2WAIT:\n\t\tlen = sprintf(buf, \"%d\\n\", session->time2wait);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TIME2RETAIN:\n\t\tlen = sprintf(buf, \"%d\\n\", session->time2retain);\n\t\tbreak;\n\tcase ISCSI_PARAM_TSID:\n\t\tlen = sprintf(buf, \"%u\\n\", session->tsid);\n\t\tbreak;\n\tcase ISCSI_PARAM_ISID:\n\t\tlen = sprintf(buf, \"%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t      session->isid[0], session->isid[1],\n\t\t\t      session->isid[2], session->isid[3],\n\t\t\t      session->isid[4], session->isid[5]);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\n\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_parent_idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n\t\tif (session->discovery_parent_type)\n\t\t\tlen = sprintf(buf, \"%s\\n\",\n\t\t\t\t      session->discovery_parent_type);\n\t\telse\n\t\t\tlen = sprintf(buf, \"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}",
        "code_after_change": "int iscsi_session_get_param(struct iscsi_cls_session *cls_session,\n\t\t\t    enum iscsi_param param, char *buf)\n{\n\tstruct iscsi_session *session = cls_session->dd_data;\n\tint len;\n\n\tswitch(param) {\n\tcase ISCSI_PARAM_FAST_ABORT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->fast_abort);\n\t\tbreak;\n\tcase ISCSI_PARAM_ABORT_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->abort_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_LU_RESET_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->lu_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_TGT_RESET_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tgt_reset_timeout);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIAL_R2T_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->initial_r2t_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_R2T:\n\t\tlen = sysfs_emit(buf, \"%hu\\n\", session->max_r2t);\n\t\tbreak;\n\tcase ISCSI_PARAM_IMM_DATA_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->imm_data_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_FIRST_BURST:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->first_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_MAX_BURST:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->max_burst);\n\t\tbreak;\n\tcase ISCSI_PARAM_PDU_INORDER_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->pdu_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->dataseq_inorder_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TASKMGMT_TMO:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->def_taskmgmt_tmo);\n\t\tbreak;\n\tcase ISCSI_PARAM_ERL:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->erl);\n\t\tbreak;\n\tcase ISCSI_PARAM_TARGET_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetname);\n\t\tbreak;\n\tcase ISCSI_PARAM_TARGET_ALIAS:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetalias);\n\t\tbreak;\n\tcase ISCSI_PARAM_TPGT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tpgt);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username);\n\t\tbreak;\n\tcase ISCSI_PARAM_USERNAME_IN:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username_in);\n\t\tbreak;\n\tcase ISCSI_PARAM_PASSWORD:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password);\n\t\tbreak;\n\tcase ISCSI_PARAM_PASSWORD_IN:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password_in);\n\t\tbreak;\n\tcase ISCSI_PARAM_IFACE_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->ifacename);\n\t\tbreak;\n\tcase ISCSI_PARAM_INITIATOR_NAME:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->initiatorname);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_ROOT:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_root);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_NIC:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_nic);\n\t\tbreak;\n\tcase ISCSI_PARAM_BOOT_TARGET:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_target);\n\t\tbreak;\n\tcase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->auto_snd_tgt_disable);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_SESS:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_sess);\n\t\tbreak;\n\tcase ISCSI_PARAM_PORTAL_TYPE:\n\t\tlen = sysfs_emit(buf, \"%s\\n\", session->portal_type);\n\t\tbreak;\n\tcase ISCSI_PARAM_CHAP_AUTH_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->chap_auth_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_logout_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_BIDI_CHAP_EN:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->bidi_chap_en);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_auth_optional);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TIME2WAIT:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2wait);\n\t\tbreak;\n\tcase ISCSI_PARAM_DEF_TIME2RETAIN:\n\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2retain);\n\t\tbreak;\n\tcase ISCSI_PARAM_TSID:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->tsid);\n\t\tbreak;\n\tcase ISCSI_PARAM_ISID:\n\t\tlen = sysfs_emit(buf, \"%02x%02x%02x%02x%02x%02x\\n\",\n\t\t\t      session->isid[0], session->isid[1],\n\t\t\t      session->isid[2], session->isid[3],\n\t\t\t      session->isid[4], session->isid[5]);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\n\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_parent_idx);\n\t\tbreak;\n\tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n\t\tif (session->discovery_parent_type)\n\t\t\tlen = sysfs_emit(buf, \"%s\\n\",\n\t\t\t\t      session->discovery_parent_type);\n\t\telse\n\t\t\tlen = sysfs_emit(buf, \"\\n\");\n\t\tbreak;\n\tdefault:\n\t\treturn -ENOSYS;\n\t}\n\n\treturn len;\n}",
        "patch": "--- code before\n+++ code after\n@@ -6,125 +6,125 @@\n \n \tswitch(param) {\n \tcase ISCSI_PARAM_FAST_ABORT:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->fast_abort);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->fast_abort);\n \t\tbreak;\n \tcase ISCSI_PARAM_ABORT_TMO:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->abort_timeout);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->abort_timeout);\n \t\tbreak;\n \tcase ISCSI_PARAM_LU_RESET_TMO:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->lu_reset_timeout);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->lu_reset_timeout);\n \t\tbreak;\n \tcase ISCSI_PARAM_TGT_RESET_TMO:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->tgt_reset_timeout);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tgt_reset_timeout);\n \t\tbreak;\n \tcase ISCSI_PARAM_INITIAL_R2T_EN:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->initial_r2t_en);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->initial_r2t_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_MAX_R2T:\n-\t\tlen = sprintf(buf, \"%hu\\n\", session->max_r2t);\n+\t\tlen = sysfs_emit(buf, \"%hu\\n\", session->max_r2t);\n \t\tbreak;\n \tcase ISCSI_PARAM_IMM_DATA_EN:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->imm_data_en);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->imm_data_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_FIRST_BURST:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->first_burst);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->first_burst);\n \t\tbreak;\n \tcase ISCSI_PARAM_MAX_BURST:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->max_burst);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->max_burst);\n \t\tbreak;\n \tcase ISCSI_PARAM_PDU_INORDER_EN:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->pdu_inorder_en);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->pdu_inorder_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_DATASEQ_INORDER_EN:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->dataseq_inorder_en);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->dataseq_inorder_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_DEF_TASKMGMT_TMO:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->def_taskmgmt_tmo);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->def_taskmgmt_tmo);\n \t\tbreak;\n \tcase ISCSI_PARAM_ERL:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->erl);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->erl);\n \t\tbreak;\n \tcase ISCSI_PARAM_TARGET_NAME:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->targetname);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetname);\n \t\tbreak;\n \tcase ISCSI_PARAM_TARGET_ALIAS:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->targetalias);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetalias);\n \t\tbreak;\n \tcase ISCSI_PARAM_TPGT:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->tpgt);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tpgt);\n \t\tbreak;\n \tcase ISCSI_PARAM_USERNAME:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->username);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username);\n \t\tbreak;\n \tcase ISCSI_PARAM_USERNAME_IN:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->username_in);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username_in);\n \t\tbreak;\n \tcase ISCSI_PARAM_PASSWORD:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->password);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password);\n \t\tbreak;\n \tcase ISCSI_PARAM_PASSWORD_IN:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->password_in);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password_in);\n \t\tbreak;\n \tcase ISCSI_PARAM_IFACE_NAME:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->ifacename);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->ifacename);\n \t\tbreak;\n \tcase ISCSI_PARAM_INITIATOR_NAME:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->initiatorname);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->initiatorname);\n \t\tbreak;\n \tcase ISCSI_PARAM_BOOT_ROOT:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->boot_root);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_root);\n \t\tbreak;\n \tcase ISCSI_PARAM_BOOT_NIC:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->boot_nic);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_nic);\n \t\tbreak;\n \tcase ISCSI_PARAM_BOOT_TARGET:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->boot_target);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_target);\n \t\tbreak;\n \tcase ISCSI_PARAM_AUTO_SND_TGT_DISABLE:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->auto_snd_tgt_disable);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->auto_snd_tgt_disable);\n \t\tbreak;\n \tcase ISCSI_PARAM_DISCOVERY_SESS:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_sess);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_sess);\n \t\tbreak;\n \tcase ISCSI_PARAM_PORTAL_TYPE:\n-\t\tlen = sprintf(buf, \"%s\\n\", session->portal_type);\n+\t\tlen = sysfs_emit(buf, \"%s\\n\", session->portal_type);\n \t\tbreak;\n \tcase ISCSI_PARAM_CHAP_AUTH_EN:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->chap_auth_en);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->chap_auth_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_DISCOVERY_LOGOUT_EN:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_logout_en);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_logout_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_BIDI_CHAP_EN:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->bidi_chap_en);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->bidi_chap_en);\n \t\tbreak;\n \tcase ISCSI_PARAM_DISCOVERY_AUTH_OPTIONAL:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_auth_optional);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_auth_optional);\n \t\tbreak;\n \tcase ISCSI_PARAM_DEF_TIME2WAIT:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->time2wait);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2wait);\n \t\tbreak;\n \tcase ISCSI_PARAM_DEF_TIME2RETAIN:\n-\t\tlen = sprintf(buf, \"%d\\n\", session->time2retain);\n+\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2retain);\n \t\tbreak;\n \tcase ISCSI_PARAM_TSID:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->tsid);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->tsid);\n \t\tbreak;\n \tcase ISCSI_PARAM_ISID:\n-\t\tlen = sprintf(buf, \"%02x%02x%02x%02x%02x%02x\\n\",\n+\t\tlen = sysfs_emit(buf, \"%02x%02x%02x%02x%02x%02x\\n\",\n \t\t\t      session->isid[0], session->isid[1],\n \t\t\t      session->isid[2], session->isid[3],\n \t\t\t      session->isid[4], session->isid[5]);\n \t\tbreak;\n \tcase ISCSI_PARAM_DISCOVERY_PARENT_IDX:\n-\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_parent_idx);\n+\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_parent_idx);\n \t\tbreak;\n \tcase ISCSI_PARAM_DISCOVERY_PARENT_TYPE:\n \t\tif (session->discovery_parent_type)\n-\t\t\tlen = sprintf(buf, \"%s\\n\",\n+\t\t\tlen = sysfs_emit(buf, \"%s\\n\",\n \t\t\t\t      session->discovery_parent_type);\n \t\telse\n-\t\t\tlen = sprintf(buf, \"\\n\");\n+\t\t\tlen = sysfs_emit(buf, \"\\n\");\n \t\tbreak;\n \tdefault:\n \t\treturn -ENOSYS;",
        "function_modified_lines": {
            "added": [
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->fast_abort);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->abort_timeout);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->lu_reset_timeout);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tgt_reset_timeout);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->initial_r2t_en);",
                "\t\tlen = sysfs_emit(buf, \"%hu\\n\", session->max_r2t);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->imm_data_en);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->first_burst);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->max_burst);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->pdu_inorder_en);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->dataseq_inorder_en);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->def_taskmgmt_tmo);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->erl);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetname);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->targetalias);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->tpgt);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->username_in);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->password_in);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->ifacename);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->initiatorname);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_root);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_nic);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->boot_target);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->auto_snd_tgt_disable);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_sess);",
                "\t\tlen = sysfs_emit(buf, \"%s\\n\", session->portal_type);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->chap_auth_en);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_logout_en);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->bidi_chap_en);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_auth_optional);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2wait);",
                "\t\tlen = sysfs_emit(buf, \"%d\\n\", session->time2retain);",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->tsid);",
                "\t\tlen = sysfs_emit(buf, \"%02x%02x%02x%02x%02x%02x\\n\",",
                "\t\tlen = sysfs_emit(buf, \"%u\\n\", session->discovery_parent_idx);",
                "\t\t\tlen = sysfs_emit(buf, \"%s\\n\",",
                "\t\t\tlen = sysfs_emit(buf, \"\\n\");"
            ],
            "deleted": [
                "\t\tlen = sprintf(buf, \"%d\\n\", session->fast_abort);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->abort_timeout);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->lu_reset_timeout);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->tgt_reset_timeout);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->initial_r2t_en);",
                "\t\tlen = sprintf(buf, \"%hu\\n\", session->max_r2t);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->imm_data_en);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->first_burst);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->max_burst);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->pdu_inorder_en);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->dataseq_inorder_en);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->def_taskmgmt_tmo);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->erl);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->targetname);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->targetalias);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->tpgt);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->username);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->username_in);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->password);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->password_in);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->ifacename);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->initiatorname);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->boot_root);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->boot_nic);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->boot_target);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->auto_snd_tgt_disable);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_sess);",
                "\t\tlen = sprintf(buf, \"%s\\n\", session->portal_type);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->chap_auth_en);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_logout_en);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->bidi_chap_en);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_auth_optional);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->time2wait);",
                "\t\tlen = sprintf(buf, \"%d\\n\", session->time2retain);",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->tsid);",
                "\t\tlen = sprintf(buf, \"%02x%02x%02x%02x%02x%02x\\n\",",
                "\t\tlen = sprintf(buf, \"%u\\n\", session->discovery_parent_idx);",
                "\t\t\tlen = sprintf(buf, \"%s\\n\",",
                "\t\t\tlen = sprintf(buf, \"\\n\");"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in the Linux kernel through 5.11.3. Certain iSCSI data structures do not have appropriate length constraints or checks, and can exceed the PAGE_SIZE value. An unprivileged user can send a Netlink message that is associated with iSCSI, and has a length up to the maximum length of a Netlink message.",
        "id": 2902
    },
    {
        "cve_id": "CVE-2020-14390",
        "code_before_change": "static unsigned long fbcon_getxy(struct vc_data *vc, unsigned long pos,\n\t\t\t\t int *px, int *py)\n{\n\tunsigned long ret;\n\tint x, y;\n\n\tif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\n\t\tunsigned long offset = (pos - vc->vc_origin) / 2;\n\n\t\tx = offset % vc->vc_cols;\n\t\ty = offset / vc->vc_cols;\n\t\tif (vc->vc_num == fg_console)\n\t\t\ty += softback_lines;\n\t\tret = pos + (vc->vc_cols - x) * 2;\n\t} else if (vc->vc_num == fg_console && softback_lines) {\n\t\tunsigned long offset = pos - softback_curr;\n\n\t\tif (pos < softback_curr)\n\t\t\toffset += softback_end - softback_buf;\n\t\toffset /= 2;\n\t\tx = offset % vc->vc_cols;\n\t\ty = offset / vc->vc_cols;\n\t\tret = pos + (vc->vc_cols - x) * 2;\n\t\tif (ret == softback_end)\n\t\t\tret = softback_buf;\n\t\tif (ret == softback_in)\n\t\t\tret = vc->vc_origin;\n\t} else {\n\t\t/* Should not happen */\n\t\tx = y = 0;\n\t\tret = vc->vc_origin;\n\t}\n\tif (px)\n\t\t*px = x;\n\tif (py)\n\t\t*py = y;\n\treturn ret;\n}",
        "code_after_change": "static unsigned long fbcon_getxy(struct vc_data *vc, unsigned long pos,\n\t\t\t\t int *px, int *py)\n{\n\tunsigned long ret;\n\tint x, y;\n\n\tif (pos >= vc->vc_origin && pos < vc->vc_scr_end) {\n\t\tunsigned long offset = (pos - vc->vc_origin) / 2;\n\n\t\tx = offset % vc->vc_cols;\n\t\ty = offset / vc->vc_cols;\n\t\tret = pos + (vc->vc_cols - x) * 2;\n\t} else {\n\t\t/* Should not happen */\n\t\tx = y = 0;\n\t\tret = vc->vc_origin;\n\t}\n\tif (px)\n\t\t*px = x;\n\tif (py)\n\t\t*py = y;\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,22 +9,7 @@\n \n \t\tx = offset % vc->vc_cols;\n \t\ty = offset / vc->vc_cols;\n-\t\tif (vc->vc_num == fg_console)\n-\t\t\ty += softback_lines;\n \t\tret = pos + (vc->vc_cols - x) * 2;\n-\t} else if (vc->vc_num == fg_console && softback_lines) {\n-\t\tunsigned long offset = pos - softback_curr;\n-\n-\t\tif (pos < softback_curr)\n-\t\t\toffset += softback_end - softback_buf;\n-\t\toffset /= 2;\n-\t\tx = offset % vc->vc_cols;\n-\t\ty = offset / vc->vc_cols;\n-\t\tret = pos + (vc->vc_cols - x) * 2;\n-\t\tif (ret == softback_end)\n-\t\t\tret = softback_buf;\n-\t\tif (ret == softback_in)\n-\t\t\tret = vc->vc_origin;\n \t} else {\n \t\t/* Should not happen */\n \t\tx = y = 0;",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\tif (vc->vc_num == fg_console)",
                "\t\t\ty += softback_lines;",
                "\t} else if (vc->vc_num == fg_console && softback_lines) {",
                "\t\tunsigned long offset = pos - softback_curr;",
                "",
                "\t\tif (pos < softback_curr)",
                "\t\t\toffset += softback_end - softback_buf;",
                "\t\toffset /= 2;",
                "\t\tx = offset % vc->vc_cols;",
                "\t\ty = offset / vc->vc_cols;",
                "\t\tret = pos + (vc->vc_cols - x) * 2;",
                "\t\tif (ret == softback_end)",
                "\t\t\tret = softback_buf;",
                "\t\tif (ret == softback_in)",
                "\t\t\tret = vc->vc_origin;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel in versions before 5.9-rc6. When changing screen size, an out-of-bounds memory write can occur leading to memory corruption or a denial of service. Due to the nature of the flaw, privilege escalation cannot be fully ruled out.",
        "id": 2526
    },
    {
        "cve_id": "CVE-2019-3701",
        "code_before_change": "static void can_can_gw_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct cgw_job *gwj = (struct cgw_job *)data;\n\tstruct can_frame *cf;\n\tstruct sk_buff *nskb;\n\tint modidx = 0;\n\n\t/*\n\t * Do not handle CAN frames routed more than 'max_hops' times.\n\t * In general we should never catch this delimiter which is intended\n\t * to cover a misconfiguration protection (e.g. circular CAN routes).\n\t *\n\t * The Controller Area Network controllers only accept CAN frames with\n\t * correct CRCs - which are not visible in the controller registers.\n\t * According to skbuff.h documentation the csum_start element for IP\n\t * checksums is undefined/unused when ip_summed == CHECKSUM_UNNECESSARY.\n\t * Only CAN skbs can be processed here which already have this property.\n\t */\n\n#define cgw_hops(skb) ((skb)->csum_start)\n\n\tBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\n\n\tif (cgw_hops(skb) >= max_hops) {\n\t\t/* indicate deleted frames due to misconfiguration */\n\t\tgwj->deleted_frames++;\n\t\treturn;\n\t}\n\n\tif (!(gwj->dst.dev->flags & IFF_UP)) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\n\t/* is sending the skb back to the incoming interface not allowed? */\n\tif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\n\t    can_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\n\t\treturn;\n\n\t/*\n\t * clone the given skb, which has not been done in can_rcv()\n\t *\n\t * When there is at least one modification function activated,\n\t * we need to copy the skb as we want to modify skb->data.\n\t */\n\tif (gwj->mod.modfunc[0])\n\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (!nskb) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\n\t/* put the incremented hop counter in the cloned skb */\n\tcgw_hops(nskb) = cgw_hops(skb) + 1;\n\n\t/* first processing of this CAN frame -> adjust to private hop limit */\n\tif (gwj->limit_hops && cgw_hops(nskb) == 1)\n\t\tcgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\n\n\tnskb->dev = gwj->dst.dev;\n\n\t/* pointer to modifiable CAN frame */\n\tcf = (struct can_frame *)nskb->data;\n\n\t/* perform preprocessed modification functions if there are any */\n\twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n\t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n\n\t/* check for checksum updates when the CAN frame has been modified */\n\tif (modidx) {\n\t\tif (gwj->mod.csumfunc.crc8)\n\t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n\n\t\tif (gwj->mod.csumfunc.xor)\n\t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n\t}\n\n\t/* clear the skb timestamp if not configured the other way */\n\tif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\n\t\tnskb->tstamp = 0;\n\n\t/* send to netdevice */\n\tif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\n\t\tgwj->dropped_frames++;\n\telse\n\t\tgwj->handled_frames++;\n}",
        "code_after_change": "static void can_can_gw_rcv(struct sk_buff *skb, void *data)\n{\n\tstruct cgw_job *gwj = (struct cgw_job *)data;\n\tstruct can_frame *cf;\n\tstruct sk_buff *nskb;\n\tint modidx = 0;\n\n\t/*\n\t * Do not handle CAN frames routed more than 'max_hops' times.\n\t * In general we should never catch this delimiter which is intended\n\t * to cover a misconfiguration protection (e.g. circular CAN routes).\n\t *\n\t * The Controller Area Network controllers only accept CAN frames with\n\t * correct CRCs - which are not visible in the controller registers.\n\t * According to skbuff.h documentation the csum_start element for IP\n\t * checksums is undefined/unused when ip_summed == CHECKSUM_UNNECESSARY.\n\t * Only CAN skbs can be processed here which already have this property.\n\t */\n\n#define cgw_hops(skb) ((skb)->csum_start)\n\n\tBUG_ON(skb->ip_summed != CHECKSUM_UNNECESSARY);\n\n\tif (cgw_hops(skb) >= max_hops) {\n\t\t/* indicate deleted frames due to misconfiguration */\n\t\tgwj->deleted_frames++;\n\t\treturn;\n\t}\n\n\tif (!(gwj->dst.dev->flags & IFF_UP)) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\n\t/* is sending the skb back to the incoming interface not allowed? */\n\tif (!(gwj->flags & CGW_FLAGS_CAN_IIF_TX_OK) &&\n\t    can_skb_prv(skb)->ifindex == gwj->dst.dev->ifindex)\n\t\treturn;\n\n\t/*\n\t * clone the given skb, which has not been done in can_rcv()\n\t *\n\t * When there is at least one modification function activated,\n\t * we need to copy the skb as we want to modify skb->data.\n\t */\n\tif (gwj->mod.modfunc[0])\n\t\tnskb = skb_copy(skb, GFP_ATOMIC);\n\telse\n\t\tnskb = skb_clone(skb, GFP_ATOMIC);\n\n\tif (!nskb) {\n\t\tgwj->dropped_frames++;\n\t\treturn;\n\t}\n\n\t/* put the incremented hop counter in the cloned skb */\n\tcgw_hops(nskb) = cgw_hops(skb) + 1;\n\n\t/* first processing of this CAN frame -> adjust to private hop limit */\n\tif (gwj->limit_hops && cgw_hops(nskb) == 1)\n\t\tcgw_hops(nskb) = max_hops - gwj->limit_hops + 1;\n\n\tnskb->dev = gwj->dst.dev;\n\n\t/* pointer to modifiable CAN frame */\n\tcf = (struct can_frame *)nskb->data;\n\n\t/* perform preprocessed modification functions if there are any */\n\twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n\t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n\n\t/* Has the CAN frame been modified? */\n\tif (modidx) {\n\t\t/* get available space for the processed CAN frame type */\n\t\tint max_len = nskb->len - offsetof(struct can_frame, data);\n\n\t\t/* dlc may have changed, make sure it fits to the CAN frame */\n\t\tif (cf->can_dlc > max_len)\n\t\t\tgoto out_delete;\n\n\t\t/* check for checksum updates in classic CAN length only */\n\t\tif (gwj->mod.csumfunc.crc8) {\n\t\t\tif (cf->can_dlc > 8)\n\t\t\t\tgoto out_delete;\n\n\t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n\t\t}\n\n\t\tif (gwj->mod.csumfunc.xor) {\n\t\t\tif (cf->can_dlc > 8)\n\t\t\t\tgoto out_delete;\n\n\t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n\t\t}\n\t}\n\n\t/* clear the skb timestamp if not configured the other way */\n\tif (!(gwj->flags & CGW_FLAGS_CAN_SRC_TSTAMP))\n\t\tnskb->tstamp = 0;\n\n\t/* send to netdevice */\n\tif (can_send(nskb, gwj->flags & CGW_FLAGS_CAN_ECHO))\n\t\tgwj->dropped_frames++;\n\telse\n\t\tgwj->handled_frames++;\n\n\treturn;\n\n out_delete:\n\t/* delete frame due to misconfiguration */\n\tgwj->deleted_frames++;\n\tkfree_skb(nskb);\n\treturn;\n}",
        "patch": "--- code before\n+++ code after\n@@ -69,13 +69,29 @@\n \twhile (modidx < MAX_MODFUNCTIONS && gwj->mod.modfunc[modidx])\n \t\t(*gwj->mod.modfunc[modidx++])(cf, &gwj->mod);\n \n-\t/* check for checksum updates when the CAN frame has been modified */\n+\t/* Has the CAN frame been modified? */\n \tif (modidx) {\n-\t\tif (gwj->mod.csumfunc.crc8)\n+\t\t/* get available space for the processed CAN frame type */\n+\t\tint max_len = nskb->len - offsetof(struct can_frame, data);\n+\n+\t\t/* dlc may have changed, make sure it fits to the CAN frame */\n+\t\tif (cf->can_dlc > max_len)\n+\t\t\tgoto out_delete;\n+\n+\t\t/* check for checksum updates in classic CAN length only */\n+\t\tif (gwj->mod.csumfunc.crc8) {\n+\t\t\tif (cf->can_dlc > 8)\n+\t\t\t\tgoto out_delete;\n+\n \t\t\t(*gwj->mod.csumfunc.crc8)(cf, &gwj->mod.csum.crc8);\n+\t\t}\n \n-\t\tif (gwj->mod.csumfunc.xor)\n+\t\tif (gwj->mod.csumfunc.xor) {\n+\t\t\tif (cf->can_dlc > 8)\n+\t\t\t\tgoto out_delete;\n+\n \t\t\t(*gwj->mod.csumfunc.xor)(cf, &gwj->mod.csum.xor);\n+\t\t}\n \t}\n \n \t/* clear the skb timestamp if not configured the other way */\n@@ -87,4 +103,12 @@\n \t\tgwj->dropped_frames++;\n \telse\n \t\tgwj->handled_frames++;\n+\n+\treturn;\n+\n+ out_delete:\n+\t/* delete frame due to misconfiguration */\n+\tgwj->deleted_frames++;\n+\tkfree_skb(nskb);\n+\treturn;\n }",
        "function_modified_lines": {
            "added": [
                "\t/* Has the CAN frame been modified? */",
                "\t\t/* get available space for the processed CAN frame type */",
                "\t\tint max_len = nskb->len - offsetof(struct can_frame, data);",
                "",
                "\t\t/* dlc may have changed, make sure it fits to the CAN frame */",
                "\t\tif (cf->can_dlc > max_len)",
                "\t\t\tgoto out_delete;",
                "",
                "\t\t/* check for checksum updates in classic CAN length only */",
                "\t\tif (gwj->mod.csumfunc.crc8) {",
                "\t\t\tif (cf->can_dlc > 8)",
                "\t\t\t\tgoto out_delete;",
                "",
                "\t\t}",
                "\t\tif (gwj->mod.csumfunc.xor) {",
                "\t\t\tif (cf->can_dlc > 8)",
                "\t\t\t\tgoto out_delete;",
                "",
                "\t\t}",
                "",
                "\treturn;",
                "",
                " out_delete:",
                "\t/* delete frame due to misconfiguration */",
                "\tgwj->deleted_frames++;",
                "\tkfree_skb(nskb);",
                "\treturn;"
            ],
            "deleted": [
                "\t/* check for checksum updates when the CAN frame has been modified */",
                "\t\tif (gwj->mod.csumfunc.crc8)",
                "\t\tif (gwj->mod.csumfunc.xor)"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in can_can_gw_rcv in net/can/gw.c in the Linux kernel through 4.19.13. The CAN frame modification rules allow bitwise logical operations that can be also applied to the can_dlc field. The privileged user \"root\" with CAP_NET_ADMIN can create a CAN frame modification rule that makes the data length code a higher value than the available CAN frame data size. In combination with a configured checksum calculation where the result is stored relatively to the end of the data (e.g. cgw_csum_xor_rel) the tail of the skb (e.g. frag_list pointer in skb_shared_info) can be rewritten which finally can cause a system crash. Because of a missing check, the CAN drivers may write arbitrary content beyond the data registers in the CAN controller's I/O memory when processing can-gw manipulated outgoing frames.",
        "id": 2310
    },
    {
        "cve_id": "CVE-2020-8835",
        "code_before_change": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\tif (is_jmp32) {\n\t\t__reg_bound_offset32(false_reg);\n\t\t__reg_bound_offset32(true_reg);\n\t}\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
        "code_after_change": "static void reg_set_min_max(struct bpf_reg_state *true_reg,\n\t\t\t    struct bpf_reg_state *false_reg, u64 val,\n\t\t\t    u8 opcode, bool is_jmp32)\n{\n\ts64 sval;\n\n\t/* If the dst_reg is a pointer, we can't learn anything about its\n\t * variable offset from the compare (unless src_reg were a pointer into\n\t * the same object, but we don't bother with that.\n\t * Since false_reg and true_reg have the same type by construction, we\n\t * only need to check one of them for pointerness.\n\t */\n\tif (__is_pointer_value(false, false_reg))\n\t\treturn;\n\n\tval = is_jmp32 ? (u32)val : val;\n\tsval = is_jmp32 ? (s64)(s32)val : (s64)val;\n\n\tswitch (opcode) {\n\tcase BPF_JEQ:\n\tcase BPF_JNE:\n\t{\n\t\tstruct bpf_reg_state *reg =\n\t\t\topcode == BPF_JEQ ? true_reg : false_reg;\n\n\t\t/* For BPF_JEQ, if this is false we know nothing Jon Snow, but\n\t\t * if it is true we know the value for sure. Likewise for\n\t\t * BPF_JNE.\n\t\t */\n\t\tif (is_jmp32) {\n\t\t\tu64 old_v = reg->var_off.value;\n\t\t\tu64 hi_mask = ~0xffffffffULL;\n\n\t\t\treg->var_off.value = (old_v & hi_mask) | val;\n\t\t\treg->var_off.mask &= hi_mask;\n\t\t} else {\n\t\t\t__mark_reg_known(reg, val);\n\t\t}\n\t\tbreak;\n\t}\n\tcase BPF_JSET:\n\t\tfalse_reg->var_off = tnum_and(false_reg->var_off,\n\t\t\t\t\t      tnum_const(~val));\n\t\tif (is_power_of_2(val))\n\t\t\ttrue_reg->var_off = tnum_or(true_reg->var_off,\n\t\t\t\t\t\t    tnum_const(val));\n\t\tbreak;\n\tcase BPF_JGE:\n\tcase BPF_JGT:\n\t{\n\t\tu64 false_umax = opcode == BPF_JGT ? val    : val - 1;\n\t\tu64 true_umin = opcode == BPF_JGT ? val + 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umax += gen_hi_max(false_reg->var_off);\n\t\t\ttrue_umin += gen_hi_min(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umax_value = min(false_reg->umax_value, false_umax);\n\t\ttrue_reg->umin_value = max(true_reg->umin_value, true_umin);\n\t\tbreak;\n\t}\n\tcase BPF_JSGE:\n\tcase BPF_JSGT:\n\t{\n\t\ts64 false_smax = opcode == BPF_JSGT ? sval    : sval - 1;\n\t\ts64 true_smin = opcode == BPF_JSGT ? sval + 1 : sval;\n\n\t\t/* If the full s64 was not sign-extended from s32 then don't\n\t\t * deduct further info.\n\t\t */\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smax_value = min(false_reg->smax_value, false_smax);\n\t\ttrue_reg->smin_value = max(true_reg->smin_value, true_smin);\n\t\tbreak;\n\t}\n\tcase BPF_JLE:\n\tcase BPF_JLT:\n\t{\n\t\tu64 false_umin = opcode == BPF_JLT ? val    : val + 1;\n\t\tu64 true_umax = opcode == BPF_JLT ? val - 1 : val;\n\n\t\tif (is_jmp32) {\n\t\t\tfalse_umin += gen_hi_min(false_reg->var_off);\n\t\t\ttrue_umax += gen_hi_max(true_reg->var_off);\n\t\t}\n\t\tfalse_reg->umin_value = max(false_reg->umin_value, false_umin);\n\t\ttrue_reg->umax_value = min(true_reg->umax_value, true_umax);\n\t\tbreak;\n\t}\n\tcase BPF_JSLE:\n\tcase BPF_JSLT:\n\t{\n\t\ts64 false_smin = opcode == BPF_JSLT ? sval    : sval + 1;\n\t\ts64 true_smax = opcode == BPF_JSLT ? sval - 1 : sval;\n\n\t\tif (is_jmp32 && !cmp_val_with_extended_s64(sval, false_reg))\n\t\t\tbreak;\n\t\tfalse_reg->smin_value = max(false_reg->smin_value, false_smin);\n\t\ttrue_reg->smax_value = min(true_reg->smax_value, true_smax);\n\t\tbreak;\n\t}\n\tdefault:\n\t\tbreak;\n\t}\n\n\t__reg_deduce_bounds(false_reg);\n\t__reg_deduce_bounds(true_reg);\n\t/* We might have learned some bits from the bounds. */\n\t__reg_bound_offset(false_reg);\n\t__reg_bound_offset(true_reg);\n\t/* Intersecting with the old var_off might have improved our bounds\n\t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n\t * then new var_off is (0; 0x7f...fc) which improves our umax.\n\t */\n\t__update_reg_bounds(false_reg);\n\t__update_reg_bounds(true_reg);\n}",
        "patch": "--- code before\n+++ code after\n@@ -109,10 +109,6 @@\n \t/* We might have learned some bits from the bounds. */\n \t__reg_bound_offset(false_reg);\n \t__reg_bound_offset(true_reg);\n-\tif (is_jmp32) {\n-\t\t__reg_bound_offset32(false_reg);\n-\t\t__reg_bound_offset32(true_reg);\n-\t}\n \t/* Intersecting with the old var_off might have improved our bounds\n \t * slightly.  e.g. if umax was 0x7f...f and var_off was (0; 0xf...fc),\n \t * then new var_off is (0; 0x7f...fc) which improves our umax.",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tif (is_jmp32) {",
                "\t\t__reg_bound_offset32(false_reg);",
                "\t\t__reg_bound_offset32(true_reg);",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-125",
            "CWE-787"
        ],
        "cve_description": "In the Linux kernel 5.5.0 and newer, the bpf verifier (kernel/bpf/verifier.c) did not properly restrict the register bounds for 32-bit operations, leading to out-of-bounds reads and writes in kernel memory. The vulnerability also affects the Linux 5.4 stable series, starting with v5.4.7, as the introducing commit was backported to that branch. This vulnerability was fixed in 5.6.1, 5.5.14, and 5.4.29. (issue is aka ZDI-CAN-10780)",
        "id": 2809
    },
    {
        "cve_id": "CVE-2019-12817",
        "code_before_change": "static int hash__init_new_context(struct mm_struct *mm)\n{\n\tint index;\n\n\tindex = hash__alloc_context_id();\n\tif (index < 0)\n\t\treturn index;\n\n\t/*\n\t * The old code would re-promote on fork, we don't do that when using\n\t * slices as it could cause problem promoting slices that have been\n\t * forced down to 4K.\n\t *\n\t * For book3s we have MMU_NO_CONTEXT set to be ~0. Hence check\n\t * explicitly against context.id == 0. This ensures that we properly\n\t * initialize context slice details for newly allocated mm's (which will\n\t * have id == 0) and don't alter context slice inherited via fork (which\n\t * will have id != 0).\n\t *\n\t * We should not be calling init_new_context() on init_mm. Hence a\n\t * check against 0 is OK.\n\t */\n\tif (mm->context.id == 0)\n\t\tslice_init_new_context_exec(mm);\n\n\tsubpage_prot_init_new_context(mm);\n\n\tpkey_mm_init(mm);\n\treturn index;\n}",
        "code_after_change": "static int hash__init_new_context(struct mm_struct *mm)\n{\n\tint index;\n\n\t/*\n\t * The old code would re-promote on fork, we don't do that when using\n\t * slices as it could cause problem promoting slices that have been\n\t * forced down to 4K.\n\t *\n\t * For book3s we have MMU_NO_CONTEXT set to be ~0. Hence check\n\t * explicitly against context.id == 0. This ensures that we properly\n\t * initialize context slice details for newly allocated mm's (which will\n\t * have id == 0) and don't alter context slice inherited via fork (which\n\t * will have id != 0).\n\t *\n\t * We should not be calling init_new_context() on init_mm. Hence a\n\t * check against 0 is OK.\n\t */\n\tif (mm->context.id == 0)\n\t\tslice_init_new_context_exec(mm);\n\n\tindex = realloc_context_ids(&mm->context);\n\tif (index < 0)\n\t\treturn index;\n\n\tsubpage_prot_init_new_context(mm);\n\n\tpkey_mm_init(mm);\n\treturn index;\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,10 +1,6 @@\n static int hash__init_new_context(struct mm_struct *mm)\n {\n \tint index;\n-\n-\tindex = hash__alloc_context_id();\n-\tif (index < 0)\n-\t\treturn index;\n \n \t/*\n \t * The old code would re-promote on fork, we don't do that when using\n@@ -23,6 +19,10 @@\n \tif (mm->context.id == 0)\n \t\tslice_init_new_context_exec(mm);\n \n+\tindex = realloc_context_ids(&mm->context);\n+\tif (index < 0)\n+\t\treturn index;\n+\n \tsubpage_prot_init_new_context(mm);\n \n \tpkey_mm_init(mm);",
        "function_modified_lines": {
            "added": [
                "\tindex = realloc_context_ids(&mm->context);",
                "\tif (index < 0)",
                "\t\treturn index;",
                ""
            ],
            "deleted": [
                "",
                "\tindex = hash__alloc_context_id();",
                "\tif (index < 0)",
                "\t\treturn index;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "arch/powerpc/mm/mmu_context_book3s64.c in the Linux kernel before 5.1.15 for powerpc has a bug where unrelated processes may be able to read/write to one another's virtual memory under certain conditions via an mmap above 512 TB. Only a subset of powerpc systems are affected.",
        "id": 1950
    },
    {
        "cve_id": "CVE-2018-1068",
        "code_before_change": "static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, new_offset = 0;\n\t/* stores match/watchers/targets & offset of next struct ebt_entry: */\n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t/* pull in most part of ebt_entry, it does not need to be changed. */\n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry); /* matches come first */\n\tmemcpy(&offsets[1], &entry->watchers_offset,\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t/* 0: matches offset, always follows ebt_entry.\n\t * 1: watchers offset, from ebt_entry structure\n\t * 2: target offset, from ebt_entry structure\n\t * 3: next ebt_entry offset, from ebt_entry structure\n\t *\n\t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n\t */\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstartoff = state->buf_user_offset - startoff;\n\n\tif (WARN_ON(*total < startoff))\n\t\treturn -EINVAL;\n\t*total -= startoff;\n\treturn 0;\n}",
        "code_after_change": "static int size_entry_mwt(struct ebt_entry *entry, const unsigned char *base,\n\t\t\t  unsigned int *total,\n\t\t\t  struct ebt_entries_buf_state *state)\n{\n\tunsigned int i, j, startoff, new_offset = 0;\n\t/* stores match/watchers/targets & offset of next struct ebt_entry: */\n\tunsigned int offsets[4];\n\tunsigned int *offsets_update = NULL;\n\tint ret;\n\tchar *buf_start;\n\n\tif (*total < sizeof(struct ebt_entries))\n\t\treturn -EINVAL;\n\n\tif (!entry->bitmask) {\n\t\t*total -= sizeof(struct ebt_entries);\n\t\treturn ebt_buf_add(state, entry, sizeof(struct ebt_entries));\n\t}\n\tif (*total < sizeof(*entry) || entry->next_offset < sizeof(*entry))\n\t\treturn -EINVAL;\n\n\tstartoff = state->buf_user_offset;\n\t/* pull in most part of ebt_entry, it does not need to be changed. */\n\tret = ebt_buf_add(state, entry,\n\t\t\toffsetof(struct ebt_entry, watchers_offset));\n\tif (ret < 0)\n\t\treturn ret;\n\n\toffsets[0] = sizeof(struct ebt_entry); /* matches come first */\n\tmemcpy(&offsets[1], &entry->watchers_offset,\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\n\tif (state->buf_kern_start) {\n\t\tbuf_start = state->buf_kern_start + state->buf_kern_offset;\n\t\toffsets_update = (unsigned int *) buf_start;\n\t}\n\tret = ebt_buf_add(state, &offsets[1],\n\t\t\tsizeof(offsets) - sizeof(offsets[0]));\n\tif (ret < 0)\n\t\treturn ret;\n\tbuf_start = (char *) entry;\n\t/* 0: matches offset, always follows ebt_entry.\n\t * 1: watchers offset, from ebt_entry structure\n\t * 2: target offset, from ebt_entry structure\n\t * 3: next ebt_entry offset, from ebt_entry structure\n\t *\n\t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n\t */\n\tfor (i = 0; i < 4 ; ++i) {\n\t\tif (offsets[i] >= *total)\n\t\t\treturn -EINVAL;\n\t\tif (i == 0)\n\t\t\tcontinue;\n\t\tif (offsets[i-1] > offsets[i])\n\t\t\treturn -EINVAL;\n\t}\n\n\tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n\t\tstruct compat_ebt_entry_mwt *match32;\n\t\tunsigned int size;\n\t\tchar *buf = buf_start + offsets[i];\n\n\t\tif (offsets[i] > offsets[j])\n\t\t\treturn -EINVAL;\n\n\t\tmatch32 = (struct compat_ebt_entry_mwt *) buf;\n\t\tsize = offsets[j] - offsets[i];\n\t\tret = ebt_size_mwt(match32, size, i, state, base);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t\tnew_offset += ret;\n\t\tif (offsets_update && new_offset) {\n\t\t\tpr_debug(\"change offset %d to %d\\n\",\n\t\t\t\toffsets_update[i], offsets[j] + new_offset);\n\t\t\toffsets_update[i] = offsets[j] + new_offset;\n\t\t}\n\t}\n\n\tif (state->buf_kern_start == NULL) {\n\t\tunsigned int offset = buf_start - (char *) base;\n\n\t\tret = xt_compat_add_offset(NFPROTO_BRIDGE, offset, new_offset);\n\t\tif (ret < 0)\n\t\t\treturn ret;\n\t}\n\n\tstartoff = state->buf_user_offset - startoff;\n\n\tif (WARN_ON(*total < startoff))\n\t\treturn -EINVAL;\n\t*total -= startoff;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -46,6 +46,15 @@\n \t *\n \t * offsets are relative to beginning of struct ebt_entry (i.e., 0).\n \t */\n+\tfor (i = 0; i < 4 ; ++i) {\n+\t\tif (offsets[i] >= *total)\n+\t\t\treturn -EINVAL;\n+\t\tif (i == 0)\n+\t\t\tcontinue;\n+\t\tif (offsets[i-1] > offsets[i])\n+\t\t\treturn -EINVAL;\n+\t}\n+\n \tfor (i = 0, j = 1 ; j < 4 ; j++, i++) {\n \t\tstruct compat_ebt_entry_mwt *match32;\n \t\tunsigned int size;",
        "function_modified_lines": {
            "added": [
                "\tfor (i = 0; i < 4 ; ++i) {",
                "\t\tif (offsets[i] >= *total)",
                "\t\t\treturn -EINVAL;",
                "\t\tif (i == 0)",
                "\t\t\tcontinue;",
                "\t\tif (offsets[i-1] > offsets[i])",
                "\t\t\treturn -EINVAL;",
                "\t}",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux 4.x kernel's implementation of 32-bit syscall interface for bridging. This allowed a privileged user to arbitrarily write to a limited range of kernel memory.",
        "id": 1594
    },
    {
        "cve_id": "CVE-2021-42327",
        "code_before_change": "static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tstruct dc_link_settings prefer_link_settings;\n\tchar *wr_buf = NULL;\n\tconst uint32_t wr_buf_size = 40;\n\t/* 0: lane_count; 1: link_rate */\n\tint max_param_num = 2;\n\tuint8_t param_nums = 0;\n\tlong param[2];\n\tbool valid_input = true;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOSPC;\n\n\tif (parse_write_buffer_into_params(wr_buf, size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param[0]) {\n\tcase LANE_COUNT_ONE:\n\tcase LANE_COUNT_TWO:\n\tcase LANE_COUNT_FOUR:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tswitch (param[1]) {\n\tcase LINK_RATE_LOW:\n\tcase LINK_RATE_HIGH:\n\tcase LINK_RATE_RBR2:\n\tcase LINK_RATE_HIGH2:\n\tcase LINK_RATE_HIGH3:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tif (!valid_input) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Input value No HW will be programmed\\n\");\n\t\treturn size;\n\t}\n\n\t/* save user force lane_count, link_rate to preferred settings\n\t * spread spectrum will not be changed\n\t */\n\tprefer_link_settings.link_spread = link->cur_link_settings.link_spread;\n\tprefer_link_settings.use_link_rate_set = false;\n\tprefer_link_settings.lane_count = param[0];\n\tprefer_link_settings.link_rate = param[1];\n\n\tdp_retrain_link_dp_test(link, &prefer_link_settings, false);\n\n\tkfree(wr_buf);\n\treturn size;\n}",
        "code_after_change": "static ssize_t dp_link_settings_write(struct file *f, const char __user *buf,\n\t\t\t\t size_t size, loff_t *pos)\n{\n\tstruct amdgpu_dm_connector *connector = file_inode(f)->i_private;\n\tstruct dc_link *link = connector->dc_link;\n\tstruct dc_link_settings prefer_link_settings;\n\tchar *wr_buf = NULL;\n\tconst uint32_t wr_buf_size = 40;\n\t/* 0: lane_count; 1: link_rate */\n\tint max_param_num = 2;\n\tuint8_t param_nums = 0;\n\tlong param[2];\n\tbool valid_input = true;\n\n\tif (size == 0)\n\t\treturn -EINVAL;\n\n\twr_buf = kcalloc(wr_buf_size, sizeof(char), GFP_KERNEL);\n\tif (!wr_buf)\n\t\treturn -ENOSPC;\n\n\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n\t\t\t\t\t   (long *)param, buf,\n\t\t\t\t\t   max_param_num,\n\t\t\t\t\t   &param_nums)) {\n\t\tkfree(wr_buf);\n\t\treturn -EINVAL;\n\t}\n\n\tif (param_nums <= 0) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"user data not be read\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tswitch (param[0]) {\n\tcase LANE_COUNT_ONE:\n\tcase LANE_COUNT_TWO:\n\tcase LANE_COUNT_FOUR:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tswitch (param[1]) {\n\tcase LINK_RATE_LOW:\n\tcase LINK_RATE_HIGH:\n\tcase LINK_RATE_RBR2:\n\tcase LINK_RATE_HIGH2:\n\tcase LINK_RATE_HIGH3:\n\t\tbreak;\n\tdefault:\n\t\tvalid_input = false;\n\t\tbreak;\n\t}\n\n\tif (!valid_input) {\n\t\tkfree(wr_buf);\n\t\tDRM_DEBUG_DRIVER(\"Invalid Input value No HW will be programmed\\n\");\n\t\treturn size;\n\t}\n\n\t/* save user force lane_count, link_rate to preferred settings\n\t * spread spectrum will not be changed\n\t */\n\tprefer_link_settings.link_spread = link->cur_link_settings.link_spread;\n\tprefer_link_settings.use_link_rate_set = false;\n\tprefer_link_settings.lane_count = param[0];\n\tprefer_link_settings.link_rate = param[1];\n\n\tdp_retrain_link_dp_test(link, &prefer_link_settings, false);\n\n\tkfree(wr_buf);\n\treturn size;\n}",
        "patch": "--- code before\n+++ code after\n@@ -19,7 +19,7 @@\n \tif (!wr_buf)\n \t\treturn -ENOSPC;\n \n-\tif (parse_write_buffer_into_params(wr_buf, size,\n+\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,\n \t\t\t\t\t   (long *)param, buf,\n \t\t\t\t\t   max_param_num,\n \t\t\t\t\t   &param_nums)) {",
        "function_modified_lines": {
            "added": [
                "\tif (parse_write_buffer_into_params(wr_buf, wr_buf_size,"
            ],
            "deleted": [
                "\tif (parse_write_buffer_into_params(wr_buf, size,"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "dp_link_settings_write in drivers/gpu/drm/amd/display/amdgpu_dm/amdgpu_dm_debugfs.c in the Linux kernel through 5.14.14 allows a heap-based buffer overflow by an attacker who can write a string to the AMD GPU display drivers debug filesystem. There are no checks on size within parse_write_buffer_into_params when it uses the size of copy_from_user to copy a userspace buffer into a 40-byte heap buffer.",
        "id": 3156
    },
    {
        "cve_id": "CVE-2022-2991",
        "code_before_change": "static int nvme_ns_ioctl(struct nvme_ns *ns, unsigned int cmd,\n\t\tvoid __user *argp)\n{\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ID:\n\t\tforce_successful_syscall_return();\n\t\treturn ns->head->ns_id;\n\tcase NVME_IOCTL_IO_CMD:\n\t\treturn nvme_user_cmd(ns->ctrl, ns, argp);\n\t/*\n\t * struct nvme_user_io can have different padding on some 32-bit ABIs.\n\t * Just accept the compat version as all fields that are used are the\n\t * same size and at the same offset.\n\t */\n#ifdef COMPAT_FOR_U64_ALIGNMENT\n\tcase NVME_IOCTL_SUBMIT_IO32:\n#endif\n\tcase NVME_IOCTL_SUBMIT_IO:\n\t\treturn nvme_submit_io(ns, argp);\n\tcase NVME_IOCTL_IO64_CMD:\n\t\treturn nvme_user_cmd64(ns->ctrl, ns, argp);\n\tdefault:\n\t\tif (!ns->ndev)\n\t\t\treturn -ENOTTY;\n\t\treturn nvme_nvm_ioctl(ns, cmd, argp);\n\t}\n}",
        "code_after_change": "static int nvme_ns_ioctl(struct nvme_ns *ns, unsigned int cmd,\n\t\tvoid __user *argp)\n{\n\tswitch (cmd) {\n\tcase NVME_IOCTL_ID:\n\t\tforce_successful_syscall_return();\n\t\treturn ns->head->ns_id;\n\tcase NVME_IOCTL_IO_CMD:\n\t\treturn nvme_user_cmd(ns->ctrl, ns, argp);\n\t/*\n\t * struct nvme_user_io can have different padding on some 32-bit ABIs.\n\t * Just accept the compat version as all fields that are used are the\n\t * same size and at the same offset.\n\t */\n#ifdef COMPAT_FOR_U64_ALIGNMENT\n\tcase NVME_IOCTL_SUBMIT_IO32:\n#endif\n\tcase NVME_IOCTL_SUBMIT_IO:\n\t\treturn nvme_submit_io(ns, argp);\n\tcase NVME_IOCTL_IO64_CMD:\n\t\treturn nvme_user_cmd64(ns->ctrl, ns, argp);\n\tdefault:\n\t\treturn -ENOTTY;\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -20,8 +20,6 @@\n \tcase NVME_IOCTL_IO64_CMD:\n \t\treturn nvme_user_cmd64(ns->ctrl, ns, argp);\n \tdefault:\n-\t\tif (!ns->ndev)\n-\t\t\treturn -ENOTTY;\n-\t\treturn nvme_nvm_ioctl(ns, cmd, argp);\n+\t\treturn -ENOTTY;\n \t}\n }",
        "function_modified_lines": {
            "added": [
                "\t\treturn -ENOTTY;"
            ],
            "deleted": [
                "\t\tif (!ns->ndev)",
                "\t\t\treturn -ENOTTY;",
                "\t\treturn nvme_nvm_ioctl(ns, cmd, argp);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap-based buffer overflow was found in the Linux kernel's LightNVM subsystem. The issue results from the lack of proper validation of the length of user-supplied data prior to copying it to a fixed-length heap-based buffer. This vulnerability allows a local attacker to escalate privileges and execute arbitrary code in the context of the kernel. The attacker must first obtain the ability to execute high-privileged code on the target system to exploit this vulnerability.",
        "id": 3540
    },
    {
        "cve_id": "CVE-2017-8067",
        "code_before_change": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tsg_init_one(sg, buf, count);\n\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n}",
        "code_after_change": "static int put_chars(u32 vtermno, const char *buf, int count)\n{\n\tstruct port *port;\n\tstruct scatterlist sg[1];\n\tvoid *data;\n\tint ret;\n\n\tif (unlikely(early_put_chars))\n\t\treturn early_put_chars(vtermno, buf, count);\n\n\tport = find_port_by_vtermno(vtermno);\n\tif (!port)\n\t\treturn -EPIPE;\n\n\tdata = kmemdup(buf, count, GFP_ATOMIC);\n\tif (!data)\n\t\treturn -ENOMEM;\n\n\tsg_init_one(sg, data, count);\n\tret = __send_to_port(port, sg, 1, count, data, false);\n\tkfree(data);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,8 @@\n {\n \tstruct port *port;\n \tstruct scatterlist sg[1];\n+\tvoid *data;\n+\tint ret;\n \n \tif (unlikely(early_put_chars))\n \t\treturn early_put_chars(vtermno, buf, count);\n@@ -10,6 +12,12 @@\n \tif (!port)\n \t\treturn -EPIPE;\n \n-\tsg_init_one(sg, buf, count);\n-\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);\n+\tdata = kmemdup(buf, count, GFP_ATOMIC);\n+\tif (!data)\n+\t\treturn -ENOMEM;\n+\n+\tsg_init_one(sg, data, count);\n+\tret = __send_to_port(port, sg, 1, count, data, false);\n+\tkfree(data);\n+\treturn ret;\n }",
        "function_modified_lines": {
            "added": [
                "\tvoid *data;",
                "\tint ret;",
                "\tdata = kmemdup(buf, count, GFP_ATOMIC);",
                "\tif (!data)",
                "\t\treturn -ENOMEM;",
                "",
                "\tsg_init_one(sg, data, count);",
                "\tret = __send_to_port(port, sg, 1, count, data, false);",
                "\tkfree(data);",
                "\treturn ret;"
            ],
            "deleted": [
                "\tsg_init_one(sg, buf, count);",
                "\treturn __send_to_port(port, sg, 1, count, (void *)buf, false);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "drivers/char/virtio_console.c in the Linux kernel 4.9.x and 4.10.x before 4.10.12 interacts incorrectly with the CONFIG_VMAP_STACK option, which allows local users to cause a denial of service (system crash or memory corruption) or possibly have unspecified other impact by leveraging use of more than one virtual page for a DMA scatterlist.",
        "id": 1541
    },
    {
        "cve_id": "CVE-2023-3090",
        "code_before_change": "static int ipvlan_process_v4_outbound(struct sk_buff *skb)\n{\n\tconst struct iphdr *ip4h = ip_hdr(skb);\n\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct rtable *rt;\n\tint err, ret = NET_XMIT_DROP;\n\tstruct flowi4 fl4 = {\n\t\t.flowi4_oif = dev->ifindex,\n\t\t.flowi4_tos = RT_TOS(ip4h->tos),\n\t\t.flowi4_flags = FLOWI_FLAG_ANYSRC,\n\t\t.flowi4_mark = skb->mark,\n\t\t.daddr = ip4h->daddr,\n\t\t.saddr = ip4h->saddr,\n\t};\n\n\trt = ip_route_output_flow(net, &fl4, NULL);\n\tif (IS_ERR(rt))\n\t\tgoto err;\n\n\tif (rt->rt_type != RTN_UNICAST && rt->rt_type != RTN_LOCAL) {\n\t\tip_rt_put(rt);\n\t\tgoto err;\n\t}\n\tskb_dst_set(skb, &rt->dst);\n\terr = ip_local_out(net, skb->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tdev->stats.tx_errors++;\n\telse\n\t\tret = NET_XMIT_SUCCESS;\n\tgoto out;\nerr:\n\tdev->stats.tx_errors++;\n\tkfree_skb(skb);\nout:\n\treturn ret;\n}",
        "code_after_change": "static int ipvlan_process_v4_outbound(struct sk_buff *skb)\n{\n\tconst struct iphdr *ip4h = ip_hdr(skb);\n\tstruct net_device *dev = skb->dev;\n\tstruct net *net = dev_net(dev);\n\tstruct rtable *rt;\n\tint err, ret = NET_XMIT_DROP;\n\tstruct flowi4 fl4 = {\n\t\t.flowi4_oif = dev->ifindex,\n\t\t.flowi4_tos = RT_TOS(ip4h->tos),\n\t\t.flowi4_flags = FLOWI_FLAG_ANYSRC,\n\t\t.flowi4_mark = skb->mark,\n\t\t.daddr = ip4h->daddr,\n\t\t.saddr = ip4h->saddr,\n\t};\n\n\trt = ip_route_output_flow(net, &fl4, NULL);\n\tif (IS_ERR(rt))\n\t\tgoto err;\n\n\tif (rt->rt_type != RTN_UNICAST && rt->rt_type != RTN_LOCAL) {\n\t\tip_rt_put(rt);\n\t\tgoto err;\n\t}\n\tskb_dst_set(skb, &rt->dst);\n\n\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n\n\terr = ip_local_out(net, skb->sk, skb);\n\tif (unlikely(net_xmit_eval(err)))\n\t\tdev->stats.tx_errors++;\n\telse\n\t\tret = NET_XMIT_SUCCESS;\n\tgoto out;\nerr:\n\tdev->stats.tx_errors++;\n\tkfree_skb(skb);\nout:\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -23,6 +23,9 @@\n \t\tgoto err;\n \t}\n \tskb_dst_set(skb, &rt->dst);\n+\n+\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));\n+\n \terr = ip_local_out(net, skb->sk, skb);\n \tif (unlikely(net_xmit_eval(err)))\n \t\tdev->stats.tx_errors++;",
        "function_modified_lines": {
            "added": [
                "",
                "\tmemset(IPCB(skb), 0, sizeof(*IPCB(skb)));",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write vulnerability in the Linux Kernel ipvlan network driver can be exploited to achieve local privilege escalation.\n\nThe out-of-bounds write is caused by missing skb->cb  initialization in the ipvlan network driver. The vulnerability is reachable if CONFIG_IPVLAN is enabled.\n\n\nWe recommend upgrading past commit 90cbed5247439a966b645b34eb0a2e037836ea8e.\n\n",
        "id": 3990
    },
    {
        "cve_id": "CVE-2020-0429",
        "code_before_change": "void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\n{\n\tint hash;\n\tstruct hlist_node *walk;\n\tstruct hlist_node *tmp;\n\tstruct l2tp_session *session;\n\n\tBUG_ON(tunnel == NULL);\n\n\tl2tp_info(tunnel, L2TP_MSG_CONTROL, \"%s: closing all sessions...\\n\",\n\t\t  tunnel->name);\n\n\twrite_lock_bh(&tunnel->hlist_lock);\n\ttunnel->acpt_newsess = false;\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\nagain:\n\t\thlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\n\t\t\tsession = hlist_entry(walk, struct l2tp_session, hlist);\n\n\t\t\tl2tp_info(session, L2TP_MSG_CONTROL,\n\t\t\t\t  \"%s: closing session\\n\", session->name);\n\n\t\t\thlist_del_init(&session->hlist);\n\n\t\t\tif (session->ref != NULL)\n\t\t\t\t(*session->ref)(session);\n\n\t\t\twrite_unlock_bh(&tunnel->hlist_lock);\n\n\t\t\t__l2tp_session_unhash(session);\n\t\t\tl2tp_session_queue_purge(session);\n\n\t\t\tif (session->session_close != NULL)\n\t\t\t\t(*session->session_close)(session);\n\n\t\t\tif (session->deref != NULL)\n\t\t\t\t(*session->deref)(session);\n\n\t\t\tl2tp_session_dec_refcount(session);\n\n\t\t\twrite_lock_bh(&tunnel->hlist_lock);\n\n\t\t\t/* Now restart from the beginning of this hash\n\t\t\t * chain.  We always remove a session from the\n\t\t\t * list so we are guaranteed to make forward\n\t\t\t * progress.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\twrite_unlock_bh(&tunnel->hlist_lock);\n}",
        "code_after_change": "void l2tp_tunnel_closeall(struct l2tp_tunnel *tunnel)\n{\n\tint hash;\n\tstruct hlist_node *walk;\n\tstruct hlist_node *tmp;\n\tstruct l2tp_session *session;\n\n\tBUG_ON(tunnel == NULL);\n\n\tl2tp_info(tunnel, L2TP_MSG_CONTROL, \"%s: closing all sessions...\\n\",\n\t\t  tunnel->name);\n\n\twrite_lock_bh(&tunnel->hlist_lock);\n\ttunnel->acpt_newsess = false;\n\tfor (hash = 0; hash < L2TP_HASH_SIZE; hash++) {\nagain:\n\t\thlist_for_each_safe(walk, tmp, &tunnel->session_hlist[hash]) {\n\t\t\tsession = hlist_entry(walk, struct l2tp_session, hlist);\n\n\t\t\tl2tp_info(session, L2TP_MSG_CONTROL,\n\t\t\t\t  \"%s: closing session\\n\", session->name);\n\n\t\t\thlist_del_init(&session->hlist);\n\n\t\t\tif (test_and_set_bit(0, &session->dead))\n\t\t\t\tgoto again;\n\n\t\t\tif (session->ref != NULL)\n\t\t\t\t(*session->ref)(session);\n\n\t\t\twrite_unlock_bh(&tunnel->hlist_lock);\n\n\t\t\t__l2tp_session_unhash(session);\n\t\t\tl2tp_session_queue_purge(session);\n\n\t\t\tif (session->session_close != NULL)\n\t\t\t\t(*session->session_close)(session);\n\n\t\t\tif (session->deref != NULL)\n\t\t\t\t(*session->deref)(session);\n\n\t\t\tl2tp_session_dec_refcount(session);\n\n\t\t\twrite_lock_bh(&tunnel->hlist_lock);\n\n\t\t\t/* Now restart from the beginning of this hash\n\t\t\t * chain.  We always remove a session from the\n\t\t\t * list so we are guaranteed to make forward\n\t\t\t * progress.\n\t\t\t */\n\t\t\tgoto again;\n\t\t}\n\t}\n\twrite_unlock_bh(&tunnel->hlist_lock);\n}",
        "patch": "--- code before\n+++ code after\n@@ -21,6 +21,9 @@\n \t\t\t\t  \"%s: closing session\\n\", session->name);\n \n \t\t\thlist_del_init(&session->hlist);\n+\n+\t\t\tif (test_and_set_bit(0, &session->dead))\n+\t\t\t\tgoto again;\n \n \t\t\tif (session->ref != NULL)\n \t\t\t\t(*session->ref)(session);",
        "function_modified_lines": {
            "added": [
                "",
                "\t\t\tif (test_and_set_bit(0, &session->dead))",
                "\t\t\t\tgoto again;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "In l2tp_session_delete and related functions of l2tp_core.c, there is possible memory corruption due to a use after free. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-152735806",
        "id": 2381
    },
    {
        "cve_id": "CVE-2020-14386",
        "code_before_change": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, netoff, hdrlen;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec64 ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\tunsigned int slot_id = 0;\n\tbool do_vnet = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\t/* If we are flooded, just give up */\n\tif (__packet_rcv_has_room(po, skb) == ROOM_NONE) {\n\t\tatomic_inc(&po->tp_drops);\n\t\tgoto drop_n_restore;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\t\tdo_vnet = true;\n\t\t}\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0) {\n\t\t\t\tsnaplen = 0;\n\t\t\t\tdo_vnet = false;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t\tdo_vnet = false;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tslot_id = po->rx_ring.head;\n\t\tif (test_bit(slot_id, po->rx_ring.rx_owner_map))\n\t\t\tgoto drop_n_account;\n\t\t__set_bit(slot_id, po->rx_ring.rx_owner_map);\n\t}\n\n\tif (do_vnet &&\n\t    virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t    vio_le(), true, 0)) {\n\t\tif (po->tp_version == TPACKET_V3)\n\t\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t\tgoto drop_n_account;\n\t}\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (atomic_read(&po->tp_drops))\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tktime_get_real_ts64(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t__packet_set_status(po, h.raw, status);\n\t\t__clear_bit(slot_id, po->rx_ring.rx_owner_map);\n\t\tspin_unlock(&sk->sk_receive_queue.lock);\n\t\tsk->sk_data_ready(sk);\n\t} else if (po->tp_version == TPACKET_V3) {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\tatomic_inc(&po->tp_drops);\n\tis_drop_n_account = true;\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}",
        "code_after_change": "static int tpacket_rcv(struct sk_buff *skb, struct net_device *dev,\n\t\t       struct packet_type *pt, struct net_device *orig_dev)\n{\n\tstruct sock *sk;\n\tstruct packet_sock *po;\n\tstruct sockaddr_ll *sll;\n\tunion tpacket_uhdr h;\n\tu8 *skb_head = skb->data;\n\tint skb_len = skb->len;\n\tunsigned int snaplen, res;\n\tunsigned long status = TP_STATUS_USER;\n\tunsigned short macoff, hdrlen;\n\tunsigned int netoff;\n\tstruct sk_buff *copy_skb = NULL;\n\tstruct timespec64 ts;\n\t__u32 ts_status;\n\tbool is_drop_n_account = false;\n\tunsigned int slot_id = 0;\n\tbool do_vnet = false;\n\n\t/* struct tpacket{2,3}_hdr is aligned to a multiple of TPACKET_ALIGNMENT.\n\t * We may add members to them until current aligned size without forcing\n\t * userspace to call getsockopt(..., PACKET_HDRLEN, ...).\n\t */\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h2)) != 32);\n\tBUILD_BUG_ON(TPACKET_ALIGN(sizeof(*h.h3)) != 48);\n\n\tif (skb->pkt_type == PACKET_LOOPBACK)\n\t\tgoto drop;\n\n\tsk = pt->af_packet_priv;\n\tpo = pkt_sk(sk);\n\n\tif (!net_eq(dev_net(dev), sock_net(sk)))\n\t\tgoto drop;\n\n\tif (dev->header_ops) {\n\t\tif (sk->sk_type != SOCK_DGRAM)\n\t\t\tskb_push(skb, skb->data - skb_mac_header(skb));\n\t\telse if (skb->pkt_type == PACKET_OUTGOING) {\n\t\t\t/* Special case: outgoing packets have ll header at head */\n\t\t\tskb_pull(skb, skb_network_offset(skb));\n\t\t}\n\t}\n\n\tsnaplen = skb->len;\n\n\tres = run_filter(skb, sk, snaplen);\n\tif (!res)\n\t\tgoto drop_n_restore;\n\n\t/* If we are flooded, just give up */\n\tif (__packet_rcv_has_room(po, skb) == ROOM_NONE) {\n\t\tatomic_inc(&po->tp_drops);\n\t\tgoto drop_n_restore;\n\t}\n\n\tif (skb->ip_summed == CHECKSUM_PARTIAL)\n\t\tstatus |= TP_STATUS_CSUMNOTREADY;\n\telse if (skb->pkt_type != PACKET_OUTGOING &&\n\t\t (skb->ip_summed == CHECKSUM_COMPLETE ||\n\t\t  skb_csum_unnecessary(skb)))\n\t\tstatus |= TP_STATUS_CSUM_VALID;\n\n\tif (snaplen > res)\n\t\tsnaplen = res;\n\n\tif (sk->sk_type == SOCK_DGRAM) {\n\t\tmacoff = netoff = TPACKET_ALIGN(po->tp_hdrlen) + 16 +\n\t\t\t\t  po->tp_reserve;\n\t} else {\n\t\tunsigned int maclen = skb_network_offset(skb);\n\t\tnetoff = TPACKET_ALIGN(po->tp_hdrlen +\n\t\t\t\t       (maclen < 16 ? 16 : maclen)) +\n\t\t\t\t       po->tp_reserve;\n\t\tif (po->has_vnet_hdr) {\n\t\t\tnetoff += sizeof(struct virtio_net_hdr);\n\t\t\tdo_vnet = true;\n\t\t}\n\t\tmacoff = netoff - maclen;\n\t}\n\tif (netoff > USHRT_MAX) {\n\t\tatomic_inc(&po->tp_drops);\n\t\tgoto drop_n_restore;\n\t}\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tif (macoff + snaplen > po->rx_ring.frame_size) {\n\t\t\tif (po->copy_thresh &&\n\t\t\t    atomic_read(&sk->sk_rmem_alloc) < sk->sk_rcvbuf) {\n\t\t\t\tif (skb_shared(skb)) {\n\t\t\t\t\tcopy_skb = skb_clone(skb, GFP_ATOMIC);\n\t\t\t\t} else {\n\t\t\t\t\tcopy_skb = skb_get(skb);\n\t\t\t\t\tskb_head = skb->data;\n\t\t\t\t}\n\t\t\t\tif (copy_skb)\n\t\t\t\t\tskb_set_owner_r(copy_skb, sk);\n\t\t\t}\n\t\t\tsnaplen = po->rx_ring.frame_size - macoff;\n\t\t\tif ((int)snaplen < 0) {\n\t\t\t\tsnaplen = 0;\n\t\t\t\tdo_vnet = false;\n\t\t\t}\n\t\t}\n\t} else if (unlikely(macoff + snaplen >\n\t\t\t    GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len)) {\n\t\tu32 nval;\n\n\t\tnval = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len - macoff;\n\t\tpr_err_once(\"tpacket_rcv: packet too big, clamped from %u to %u. macoff=%u\\n\",\n\t\t\t    snaplen, nval, macoff);\n\t\tsnaplen = nval;\n\t\tif (unlikely((int)snaplen < 0)) {\n\t\t\tsnaplen = 0;\n\t\t\tmacoff = GET_PBDQC_FROM_RB(&po->rx_ring)->max_frame_len;\n\t\t\tdo_vnet = false;\n\t\t}\n\t}\n\tspin_lock(&sk->sk_receive_queue.lock);\n\th.raw = packet_current_rx_frame(po, skb,\n\t\t\t\t\tTP_STATUS_KERNEL, (macoff+snaplen));\n\tif (!h.raw)\n\t\tgoto drop_n_account;\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tslot_id = po->rx_ring.head;\n\t\tif (test_bit(slot_id, po->rx_ring.rx_owner_map))\n\t\t\tgoto drop_n_account;\n\t\t__set_bit(slot_id, po->rx_ring.rx_owner_map);\n\t}\n\n\tif (do_vnet &&\n\t    virtio_net_hdr_from_skb(skb, h.raw + macoff -\n\t\t\t\t    sizeof(struct virtio_net_hdr),\n\t\t\t\t    vio_le(), true, 0)) {\n\t\tif (po->tp_version == TPACKET_V3)\n\t\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t\tgoto drop_n_account;\n\t}\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tpacket_increment_rx_head(po, &po->rx_ring);\n\t/*\n\t * LOSING will be reported till you read the stats,\n\t * because it's COR - Clear On Read.\n\t * Anyways, moving it for V1/V2 only as V3 doesn't need this\n\t * at packet level.\n\t */\n\t\tif (atomic_read(&po->tp_drops))\n\t\t\tstatus |= TP_STATUS_LOSING;\n\t}\n\n\tpo->stats.stats1.tp_packets++;\n\tif (copy_skb) {\n\t\tstatus |= TP_STATUS_COPY;\n\t\t__skb_queue_tail(&sk->sk_receive_queue, copy_skb);\n\t}\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\n\tskb_copy_bits(skb, 0, h.raw + macoff, snaplen);\n\n\tif (!(ts_status = tpacket_get_timestamp(skb, &ts, po->tp_tstamp)))\n\t\tktime_get_real_ts64(&ts);\n\n\tstatus |= ts_status;\n\n\tswitch (po->tp_version) {\n\tcase TPACKET_V1:\n\t\th.h1->tp_len = skb->len;\n\t\th.h1->tp_snaplen = snaplen;\n\t\th.h1->tp_mac = macoff;\n\t\th.h1->tp_net = netoff;\n\t\th.h1->tp_sec = ts.tv_sec;\n\t\th.h1->tp_usec = ts.tv_nsec / NSEC_PER_USEC;\n\t\thdrlen = sizeof(*h.h1);\n\t\tbreak;\n\tcase TPACKET_V2:\n\t\th.h2->tp_len = skb->len;\n\t\th.h2->tp_snaplen = snaplen;\n\t\th.h2->tp_mac = macoff;\n\t\th.h2->tp_net = netoff;\n\t\th.h2->tp_sec = ts.tv_sec;\n\t\th.h2->tp_nsec = ts.tv_nsec;\n\t\tif (skb_vlan_tag_present(skb)) {\n\t\t\th.h2->tp_vlan_tci = skb_vlan_tag_get(skb);\n\t\t\th.h2->tp_vlan_tpid = ntohs(skb->vlan_proto);\n\t\t\tstatus |= TP_STATUS_VLAN_VALID | TP_STATUS_VLAN_TPID_VALID;\n\t\t} else {\n\t\t\th.h2->tp_vlan_tci = 0;\n\t\t\th.h2->tp_vlan_tpid = 0;\n\t\t}\n\t\tmemset(h.h2->tp_padding, 0, sizeof(h.h2->tp_padding));\n\t\thdrlen = sizeof(*h.h2);\n\t\tbreak;\n\tcase TPACKET_V3:\n\t\t/* tp_nxt_offset,vlan are already populated above.\n\t\t * So DONT clear those fields here\n\t\t */\n\t\th.h3->tp_status |= status;\n\t\th.h3->tp_len = skb->len;\n\t\th.h3->tp_snaplen = snaplen;\n\t\th.h3->tp_mac = macoff;\n\t\th.h3->tp_net = netoff;\n\t\th.h3->tp_sec  = ts.tv_sec;\n\t\th.h3->tp_nsec = ts.tv_nsec;\n\t\tmemset(h.h3->tp_padding, 0, sizeof(h.h3->tp_padding));\n\t\thdrlen = sizeof(*h.h3);\n\t\tbreak;\n\tdefault:\n\t\tBUG();\n\t}\n\n\tsll = h.raw + TPACKET_ALIGN(hdrlen);\n\tsll->sll_halen = dev_parse_header(skb, sll->sll_addr);\n\tsll->sll_family = AF_PACKET;\n\tsll->sll_hatype = dev->type;\n\tsll->sll_protocol = skb->protocol;\n\tsll->sll_pkttype = skb->pkt_type;\n\tif (unlikely(po->origdev))\n\t\tsll->sll_ifindex = orig_dev->ifindex;\n\telse\n\t\tsll->sll_ifindex = dev->ifindex;\n\n\tsmp_mb();\n\n#if ARCH_IMPLEMENTS_FLUSH_DCACHE_PAGE == 1\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tu8 *start, *end;\n\n\t\tend = (u8 *) PAGE_ALIGN((unsigned long) h.raw +\n\t\t\t\t\tmacoff + snaplen);\n\n\t\tfor (start = h.raw; start < end; start += PAGE_SIZE)\n\t\t\tflush_dcache_page(pgv_to_page(start));\n\t}\n\tsmp_wmb();\n#endif\n\n\tif (po->tp_version <= TPACKET_V2) {\n\t\tspin_lock(&sk->sk_receive_queue.lock);\n\t\t__packet_set_status(po, h.raw, status);\n\t\t__clear_bit(slot_id, po->rx_ring.rx_owner_map);\n\t\tspin_unlock(&sk->sk_receive_queue.lock);\n\t\tsk->sk_data_ready(sk);\n\t} else if (po->tp_version == TPACKET_V3) {\n\t\tprb_clear_blk_fill_status(&po->rx_ring);\n\t}\n\ndrop_n_restore:\n\tif (skb_head != skb->data && skb_shared(skb)) {\n\t\tskb->data = skb_head;\n\t\tskb->len = skb_len;\n\t}\ndrop:\n\tif (!is_drop_n_account)\n\t\tconsume_skb(skb);\n\telse\n\t\tkfree_skb(skb);\n\treturn 0;\n\ndrop_n_account:\n\tspin_unlock(&sk->sk_receive_queue.lock);\n\tatomic_inc(&po->tp_drops);\n\tis_drop_n_account = true;\n\n\tsk->sk_data_ready(sk);\n\tkfree_skb(copy_skb);\n\tgoto drop_n_restore;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,7 +9,8 @@\n \tint skb_len = skb->len;\n \tunsigned int snaplen, res;\n \tunsigned long status = TP_STATUS_USER;\n-\tunsigned short macoff, netoff, hdrlen;\n+\tunsigned short macoff, hdrlen;\n+\tunsigned int netoff;\n \tstruct sk_buff *copy_skb = NULL;\n \tstruct timespec64 ts;\n \t__u32 ts_status;\n@@ -77,6 +78,10 @@\n \t\t\tdo_vnet = true;\n \t\t}\n \t\tmacoff = netoff - maclen;\n+\t}\n+\tif (netoff > USHRT_MAX) {\n+\t\tatomic_inc(&po->tp_drops);\n+\t\tgoto drop_n_restore;\n \t}\n \tif (po->tp_version <= TPACKET_V2) {\n \t\tif (macoff + snaplen > po->rx_ring.frame_size) {",
        "function_modified_lines": {
            "added": [
                "\tunsigned short macoff, hdrlen;",
                "\tunsigned int netoff;",
                "\t}",
                "\tif (netoff > USHRT_MAX) {",
                "\t\tatomic_inc(&po->tp_drops);",
                "\t\tgoto drop_n_restore;"
            ],
            "deleted": [
                "\tunsigned short macoff, netoff, hdrlen;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel before 5.9-rc4. Memory corruption can be exploited to gain root privileges from unprivileged processes. The highest threat from this vulnerability is to data confidentiality and integrity.",
        "id": 2524
    },
    {
        "cve_id": "CVE-2017-13166",
        "code_before_change": "static int v4l_enum_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_fmtdesc *p = arg;\n\tstruct video_device *vfd = video_devdata(file);\n\tbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\n\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\n\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\n\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\n\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\n\tint ret = -EINVAL;\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_enum_fmt_vid_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_cap_mplane))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_cap_mplane(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_overlay(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_out(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out_mplane))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_out_mplane(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!is_rx || !is_sdr || !ops->vidioc_enum_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_sdr_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!is_tx || !is_sdr || !ops->vidioc_enum_fmt_sdr_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_sdr_out(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_meta_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_meta_cap(file, fh, arg);\n\t\tbreak;\n\t}\n\tif (ret == 0)\n\t\tv4l_fill_fmtdesc(p);\n\treturn ret;\n}",
        "code_after_change": "static int v4l_enum_fmt(const struct v4l2_ioctl_ops *ops,\n\t\t\t\tstruct file *file, void *fh, void *arg)\n{\n\tstruct v4l2_fmtdesc *p = arg;\n\tint ret = check_fmt(file, p->type);\n\n\tif (ret)\n\t\treturn ret;\n\tret = -EINVAL;\n\n\tswitch (p->type) {\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap_mplane))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_cap_mplane(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_overlay))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_overlay(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_out(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out_mplane))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_vid_out_mplane(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_sdr_cap(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_out))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_sdr_out(file, fh, arg);\n\t\tbreak;\n\tcase V4L2_BUF_TYPE_META_CAPTURE:\n\t\tif (unlikely(!ops->vidioc_enum_fmt_meta_cap))\n\t\t\tbreak;\n\t\tret = ops->vidioc_enum_fmt_meta_cap(file, fh, arg);\n\t\tbreak;\n\t}\n\tif (ret == 0)\n\t\tv4l_fill_fmtdesc(p);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,52 +2,50 @@\n \t\t\t\tstruct file *file, void *fh, void *arg)\n {\n \tstruct v4l2_fmtdesc *p = arg;\n-\tstruct video_device *vfd = video_devdata(file);\n-\tbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;\n-\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;\n-\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;\n-\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;\n-\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;\n-\tint ret = -EINVAL;\n+\tint ret = check_fmt(file, p->type);\n+\n+\tif (ret)\n+\t\treturn ret;\n+\tret = -EINVAL;\n \n \tswitch (p->type) {\n \tcase V4L2_BUF_TYPE_VIDEO_CAPTURE:\n-\t\tif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_enum_fmt_vid_cap))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_vid_cap(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_VIDEO_CAPTURE_MPLANE:\n-\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_cap_mplane))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap_mplane))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_vid_cap_mplane(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_VIDEO_OVERLAY:\n-\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_overlay))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_overlay))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_vid_overlay(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_VIDEO_OUTPUT:\n-\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_vid_out(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE:\n-\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out_mplane))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out_mplane))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_vid_out_mplane(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_SDR_CAPTURE:\n-\t\tif (unlikely(!is_rx || !is_sdr || !ops->vidioc_enum_fmt_sdr_cap))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_cap))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_sdr_cap(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_SDR_OUTPUT:\n-\t\tif (unlikely(!is_tx || !is_sdr || !ops->vidioc_enum_fmt_sdr_out))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_out))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_sdr_out(file, fh, arg);\n \t\tbreak;\n \tcase V4L2_BUF_TYPE_META_CAPTURE:\n-\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_meta_cap))\n+\t\tif (unlikely(!ops->vidioc_enum_fmt_meta_cap))\n \t\t\tbreak;\n \t\tret = ops->vidioc_enum_fmt_meta_cap(file, fh, arg);\n \t\tbreak;",
        "function_modified_lines": {
            "added": [
                "\tint ret = check_fmt(file, p->type);",
                "",
                "\tif (ret)",
                "\t\treturn ret;",
                "\tret = -EINVAL;",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_cap_mplane))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_overlay))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_vid_out_mplane))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_cap))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_sdr_out))",
                "\t\tif (unlikely(!ops->vidioc_enum_fmt_meta_cap))"
            ],
            "deleted": [
                "\tstruct video_device *vfd = video_devdata(file);",
                "\tbool is_vid = vfd->vfl_type == VFL_TYPE_GRABBER;",
                "\tbool is_sdr = vfd->vfl_type == VFL_TYPE_SDR;",
                "\tbool is_tch = vfd->vfl_type == VFL_TYPE_TOUCH;",
                "\tbool is_rx = vfd->vfl_dir != VFL_DIR_TX;",
                "\tbool is_tx = vfd->vfl_dir != VFL_DIR_RX;",
                "\tint ret = -EINVAL;",
                "\t\tif (unlikely(!is_rx || (!is_vid && !is_tch) || !ops->vidioc_enum_fmt_vid_cap))",
                "\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_cap_mplane))",
                "\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_vid_overlay))",
                "\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out))",
                "\t\tif (unlikely(!is_tx || !is_vid || !ops->vidioc_enum_fmt_vid_out_mplane))",
                "\t\tif (unlikely(!is_rx || !is_sdr || !ops->vidioc_enum_fmt_sdr_cap))",
                "\t\tif (unlikely(!is_tx || !is_sdr || !ops->vidioc_enum_fmt_sdr_out))",
                "\t\tif (unlikely(!is_rx || !is_vid || !ops->vidioc_enum_fmt_meta_cap))"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An elevation of privilege vulnerability in the kernel v4l2 video driver. Product: Android. Versions: Android kernel. Android ID A-34624167.",
        "id": 1267
    },
    {
        "cve_id": "CVE-2021-33656",
        "code_before_change": "static int con_font_get(struct vc_data *vc, struct console_font_op *op)\n{\n\tstruct console_font font;\n\tint rc = -EINVAL;\n\tint c;\n\n\tif (op->data) {\n\t\tfont.data = kmalloc(max_font_size, GFP_KERNEL);\n\t\tif (!font.data)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tfont.data = NULL;\n\n\tconsole_lock();\n\tif (vc->vc_mode != KD_TEXT)\n\t\trc = -EINVAL;\n\telse if (vc->vc_sw->con_font_get)\n\t\trc = vc->vc_sw->con_font_get(vc, &font);\n\telse\n\t\trc = -ENOSYS;\n\tconsole_unlock();\n\n\tif (rc)\n\t\tgoto out;\n\n\tc = (font.width+7)/8 * 32 * font.charcount;\n\n\tif (op->data && font.charcount > op->charcount)\n\t\trc = -ENOSPC;\n\tif (!(op->flags & KD_FONT_FLAG_OLD)) {\n\t\tif (font.width > op->width || font.height > op->height)\n\t\t\trc = -ENOSPC;\n\t} else {\n\t\tif (font.width != 8)\n\t\t\trc = -EIO;\n\t\telse if ((op->height && font.height > op->height) ||\n\t\t\t font.height > 32)\n\t\t\trc = -ENOSPC;\n\t}\n\tif (rc)\n\t\tgoto out;\n\n\top->height = font.height;\n\top->width = font.width;\n\top->charcount = font.charcount;\n\n\tif (op->data && copy_to_user(op->data, font.data, c))\n\t\trc = -EFAULT;\n\nout:\n\tkfree(font.data);\n\treturn rc;\n}",
        "code_after_change": "static int con_font_get(struct vc_data *vc, struct console_font_op *op)\n{\n\tstruct console_font font;\n\tint rc = -EINVAL;\n\tint c;\n\n\tif (op->data) {\n\t\tfont.data = kmalloc(max_font_size, GFP_KERNEL);\n\t\tif (!font.data)\n\t\t\treturn -ENOMEM;\n\t} else\n\t\tfont.data = NULL;\n\n\tconsole_lock();\n\tif (vc->vc_mode != KD_TEXT)\n\t\trc = -EINVAL;\n\telse if (vc->vc_sw->con_font_get)\n\t\trc = vc->vc_sw->con_font_get(vc, &font);\n\telse\n\t\trc = -ENOSYS;\n\tconsole_unlock();\n\n\tif (rc)\n\t\tgoto out;\n\n\tc = (font.width+7)/8 * 32 * font.charcount;\n\n\tif (op->data && font.charcount > op->charcount)\n\t\trc = -ENOSPC;\n\tif (font.width > op->width || font.height > op->height)\n\t\trc = -ENOSPC;\n\tif (rc)\n\t\tgoto out;\n\n\top->height = font.height;\n\top->width = font.width;\n\top->charcount = font.charcount;\n\n\tif (op->data && copy_to_user(op->data, font.data, c))\n\t\trc = -EFAULT;\n\nout:\n\tkfree(font.data);\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -27,16 +27,8 @@\n \n \tif (op->data && font.charcount > op->charcount)\n \t\trc = -ENOSPC;\n-\tif (!(op->flags & KD_FONT_FLAG_OLD)) {\n-\t\tif (font.width > op->width || font.height > op->height)\n-\t\t\trc = -ENOSPC;\n-\t} else {\n-\t\tif (font.width != 8)\n-\t\t\trc = -EIO;\n-\t\telse if ((op->height && font.height > op->height) ||\n-\t\t\t font.height > 32)\n-\t\t\trc = -ENOSPC;\n-\t}\n+\tif (font.width > op->width || font.height > op->height)\n+\t\trc = -ENOSPC;\n \tif (rc)\n \t\tgoto out;\n ",
        "function_modified_lines": {
            "added": [
                "\tif (font.width > op->width || font.height > op->height)",
                "\t\trc = -ENOSPC;"
            ],
            "deleted": [
                "\tif (!(op->flags & KD_FONT_FLAG_OLD)) {",
                "\t\tif (font.width > op->width || font.height > op->height)",
                "\t\t\trc = -ENOSPC;",
                "\t} else {",
                "\t\tif (font.width != 8)",
                "\t\t\trc = -EIO;",
                "\t\telse if ((op->height && font.height > op->height) ||",
                "\t\t\t font.height > 32)",
                "\t\t\trc = -ENOSPC;",
                "\t}"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "When setting font with malicous data by ioctl cmd PIO_FONT,kernel will write memory out of bounds.",
        "id": 2983
    },
    {
        "cve_id": "CVE-2022-47942",
        "code_before_change": "int smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t parent, &parent_pntsd);\n\tif (acl_len <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces =\n\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\t\tpgroup_sid_size + sizeof(struct smb_acl) +\n\t\t\t\tnt_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, pntsd_size);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}",
        "code_after_change": "int smb_inherit_dacl(struct ksmbd_conn *conn,\n\t\t     struct path *path,\n\t\t     unsigned int uid, unsigned int gid)\n{\n\tconst struct smb_sid *psid, *creator = NULL;\n\tstruct smb_ace *parent_aces, *aces;\n\tstruct smb_acl *parent_pdacl;\n\tstruct smb_ntsd *parent_pntsd = NULL;\n\tstruct smb_sid owner_sid, group_sid;\n\tstruct dentry *parent = path->dentry->d_parent;\n\tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n\tchar *aces_base;\n\tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n\n\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n\t\t\t\t\t    parent, &parent_pntsd);\n\tif (pntsd_size <= 0)\n\t\treturn -ENOENT;\n\tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n\tacl_len = pntsd_size - dacloffset;\n\tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n\tpntsd_type = le16_to_cpu(parent_pntsd->type);\n\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n\n\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n\t\trc = -EINVAL;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n\tif (!aces_base) {\n\t\trc = -ENOMEM;\n\t\tgoto free_parent_pntsd;\n\t}\n\n\taces = (struct smb_ace *)aces_base;\n\tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n\t\t\tsizeof(struct smb_acl));\n\taces_size = acl_len - sizeof(struct smb_acl);\n\n\tif (pntsd_type & DACL_AUTO_INHERITED)\n\t\tinherited_flags = INHERITED_ACE;\n\n\tfor (i = 0; i < num_aces; i++) {\n\t\tint pace_size;\n\n\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n\t\t\tbreak;\n\n\t\tpace_size = le16_to_cpu(parent_aces->size);\n\t\tif (pace_size > aces_size)\n\t\t\tbreak;\n\n\t\taces_size -= pace_size;\n\n\t\tflags = parent_aces->flags;\n\t\tif (!smb_inherit_flags(flags, is_dir))\n\t\t\tgoto pass;\n\t\tif (is_dir) {\n\t\t\tflags &= ~(INHERIT_ONLY_ACE | INHERITED_ACE);\n\t\t\tif (!(flags & CONTAINER_INHERIT_ACE))\n\t\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tif (flags & NO_PROPAGATE_INHERIT_ACE)\n\t\t\t\tflags = 0;\n\t\t} else {\n\t\t\tflags = 0;\n\t\t}\n\n\t\tif (!compare_sids(&creator_owner, &parent_aces->sid)) {\n\t\t\tcreator = &creator_owner;\n\t\t\tid_to_sid(uid, SIDOWNER, &owner_sid);\n\t\t\tpsid = &owner_sid;\n\t\t} else if (!compare_sids(&creator_group, &parent_aces->sid)) {\n\t\t\tcreator = &creator_group;\n\t\t\tid_to_sid(gid, SIDUNIX_GROUP, &group_sid);\n\t\t\tpsid = &group_sid;\n\t\t} else {\n\t\t\tcreator = NULL;\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tif (is_dir && creator && flags & CONTAINER_INHERIT_ACE) {\n\t\t\tsmb_set_ace(aces, psid, parent_aces->type, inherited_flags,\n\t\t\t\t    parent_aces->access_req);\n\t\t\tnt_size += le16_to_cpu(aces->size);\n\t\t\tace_cnt++;\n\t\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\t\tflags |= INHERIT_ONLY_ACE;\n\t\t\tpsid = creator;\n\t\t} else if (is_dir && !(parent_aces->flags & NO_PROPAGATE_INHERIT_ACE)) {\n\t\t\tpsid = &parent_aces->sid;\n\t\t}\n\n\t\tsmb_set_ace(aces, psid, parent_aces->type, flags | inherited_flags,\n\t\t\t    parent_aces->access_req);\n\t\tnt_size += le16_to_cpu(aces->size);\n\t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n\t\tace_cnt++;\npass:\n\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n\t}\n\n\tif (nt_size > 0) {\n\t\tstruct smb_ntsd *pntsd;\n\t\tstruct smb_acl *pdacl;\n\t\tstruct smb_sid *powner_sid = NULL, *pgroup_sid = NULL;\n\t\tint powner_sid_size = 0, pgroup_sid_size = 0, pntsd_size;\n\n\t\tif (parent_pntsd->osidoffset) {\n\t\t\tpowner_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->osidoffset));\n\t\t\tpowner_sid_size = 1 + 1 + 6 + (powner_sid->num_subauth * 4);\n\t\t}\n\t\tif (parent_pntsd->gsidoffset) {\n\t\t\tpgroup_sid = (struct smb_sid *)((char *)parent_pntsd +\n\t\t\t\t\tle32_to_cpu(parent_pntsd->gsidoffset));\n\t\t\tpgroup_sid_size = 1 + 1 + 6 + (pgroup_sid->num_subauth * 4);\n\t\t}\n\n\t\tpntsd = kzalloc(sizeof(struct smb_ntsd) + powner_sid_size +\n\t\t\t\tpgroup_sid_size + sizeof(struct smb_acl) +\n\t\t\t\tnt_size, GFP_KERNEL);\n\t\tif (!pntsd) {\n\t\t\trc = -ENOMEM;\n\t\t\tgoto free_aces_base;\n\t\t}\n\n\t\tpntsd->revision = cpu_to_le16(1);\n\t\tpntsd->type = cpu_to_le16(SELF_RELATIVE | DACL_PRESENT);\n\t\tif (le16_to_cpu(parent_pntsd->type) & DACL_AUTO_INHERITED)\n\t\t\tpntsd->type |= cpu_to_le16(DACL_AUTO_INHERITED);\n\t\tpntsd_size = sizeof(struct smb_ntsd);\n\t\tpntsd->osidoffset = parent_pntsd->osidoffset;\n\t\tpntsd->gsidoffset = parent_pntsd->gsidoffset;\n\t\tpntsd->dacloffset = parent_pntsd->dacloffset;\n\n\t\tif (pntsd->osidoffset) {\n\t\t\tstruct smb_sid *owner_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->osidoffset));\n\t\t\tmemcpy(owner_sid, powner_sid, powner_sid_size);\n\t\t\tpntsd_size += powner_sid_size;\n\t\t}\n\n\t\tif (pntsd->gsidoffset) {\n\t\t\tstruct smb_sid *group_sid = (struct smb_sid *)((char *)pntsd +\n\t\t\t\t\tle32_to_cpu(pntsd->gsidoffset));\n\t\t\tmemcpy(group_sid, pgroup_sid, pgroup_sid_size);\n\t\t\tpntsd_size += pgroup_sid_size;\n\t\t}\n\n\t\tif (pntsd->dacloffset) {\n\t\t\tstruct smb_ace *pace;\n\n\t\t\tpdacl = (struct smb_acl *)((char *)pntsd + le32_to_cpu(pntsd->dacloffset));\n\t\t\tpdacl->revision = cpu_to_le16(2);\n\t\t\tpdacl->size = cpu_to_le16(sizeof(struct smb_acl) + nt_size);\n\t\t\tpdacl->num_aces = cpu_to_le32(ace_cnt);\n\t\t\tpace = (struct smb_ace *)((char *)pdacl + sizeof(struct smb_acl));\n\t\t\tmemcpy(pace, aces_base, nt_size);\n\t\t\tpntsd_size += sizeof(struct smb_acl) + nt_size;\n\t\t}\n\n\t\tksmbd_vfs_set_sd_xattr(conn, user_ns,\n\t\t\t\t       path->dentry, pntsd, pntsd_size);\n\t\tkfree(pntsd);\n\t}\n\nfree_aces_base:\n\tkfree(aces_base);\nfree_parent_pntsd:\n\tkfree(parent_pntsd);\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -9,24 +9,31 @@\n \tstruct smb_sid owner_sid, group_sid;\n \tstruct dentry *parent = path->dentry->d_parent;\n \tstruct user_namespace *user_ns = mnt_user_ns(path->mnt);\n-\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;\n-\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;\n+\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;\n+\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;\n \tchar *aces_base;\n \tbool is_dir = S_ISDIR(d_inode(path->dentry)->i_mode);\n \n-\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n-\t\t\t\t\t parent, &parent_pntsd);\n-\tif (acl_len <= 0)\n+\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,\n+\t\t\t\t\t    parent, &parent_pntsd);\n+\tif (pntsd_size <= 0)\n \t\treturn -ENOENT;\n \tdacloffset = le32_to_cpu(parent_pntsd->dacloffset);\n-\tif (!dacloffset) {\n+\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {\n \t\trc = -EINVAL;\n \t\tgoto free_parent_pntsd;\n \t}\n \n \tparent_pdacl = (struct smb_acl *)((char *)parent_pntsd + dacloffset);\n+\tacl_len = pntsd_size - dacloffset;\n \tnum_aces = le32_to_cpu(parent_pdacl->num_aces);\n \tpntsd_type = le16_to_cpu(parent_pntsd->type);\n+\tpdacl_size = le16_to_cpu(parent_pdacl->size);\n+\n+\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {\n+\t\trc = -EINVAL;\n+\t\tgoto free_parent_pntsd;\n+\t}\n \n \taces_base = kmalloc(sizeof(struct smb_ace) * num_aces * 2, GFP_KERNEL);\n \tif (!aces_base) {\n@@ -37,11 +44,23 @@\n \taces = (struct smb_ace *)aces_base;\n \tparent_aces = (struct smb_ace *)((char *)parent_pdacl +\n \t\t\tsizeof(struct smb_acl));\n+\taces_size = acl_len - sizeof(struct smb_acl);\n \n \tif (pntsd_type & DACL_AUTO_INHERITED)\n \t\tinherited_flags = INHERITED_ACE;\n \n \tfor (i = 0; i < num_aces; i++) {\n+\t\tint pace_size;\n+\n+\t\tif (offsetof(struct smb_ace, access_req) > aces_size)\n+\t\t\tbreak;\n+\n+\t\tpace_size = le16_to_cpu(parent_aces->size);\n+\t\tif (pace_size > aces_size)\n+\t\t\tbreak;\n+\n+\t\taces_size -= pace_size;\n+\n \t\tflags = parent_aces->flags;\n \t\tif (!smb_inherit_flags(flags, is_dir))\n \t\t\tgoto pass;\n@@ -86,8 +105,7 @@\n \t\taces = (struct smb_ace *)((char *)aces + le16_to_cpu(aces->size));\n \t\tace_cnt++;\n pass:\n-\t\tparent_aces =\n-\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));\n+\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);\n \t}\n \n \tif (nt_size > 0) {",
        "function_modified_lines": {
            "added": [
                "\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0, pdacl_size;",
                "\tint rc = 0, num_aces, dacloffset, pntsd_type, pntsd_size, acl_len, aces_size;",
                "\tpntsd_size = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
                "\t\t\t\t\t    parent, &parent_pntsd);",
                "\tif (pntsd_size <= 0)",
                "\tif (!dacloffset || (dacloffset + sizeof(struct smb_acl) > pntsd_size)) {",
                "\tacl_len = pntsd_size - dacloffset;",
                "\tpdacl_size = le16_to_cpu(parent_pdacl->size);",
                "",
                "\tif (pdacl_size > acl_len || pdacl_size < sizeof(struct smb_acl)) {",
                "\t\trc = -EINVAL;",
                "\t\tgoto free_parent_pntsd;",
                "\t}",
                "\taces_size = acl_len - sizeof(struct smb_acl);",
                "\t\tint pace_size;",
                "",
                "\t\tif (offsetof(struct smb_ace, access_req) > aces_size)",
                "\t\t\tbreak;",
                "",
                "\t\tpace_size = le16_to_cpu(parent_aces->size);",
                "\t\tif (pace_size > aces_size)",
                "\t\t\tbreak;",
                "",
                "\t\taces_size -= pace_size;",
                "",
                "\t\tparent_aces = (struct smb_ace *)((char *)parent_aces + pace_size);"
            ],
            "deleted": [
                "\tint inherited_flags = 0, flags = 0, i, ace_cnt = 0, nt_size = 0;",
                "\tint rc = 0, num_aces, dacloffset, pntsd_type, acl_len;",
                "\tacl_len = ksmbd_vfs_get_sd_xattr(conn, user_ns,",
                "\t\t\t\t\t parent, &parent_pntsd);",
                "\tif (acl_len <= 0)",
                "\tif (!dacloffset) {",
                "\t\tparent_aces =",
                "\t\t\t(struct smb_ace *)((char *)parent_aces + le16_to_cpu(parent_aces->size));"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.",
        "id": 3774
    },
    {
        "cve_id": "CVE-2022-47942",
        "code_before_change": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\n\tfree_len = (int)(work->response_sz -\n\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n\t\thdr2_len;\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\n\treturn min_t(int, out_buf_len, free_len);\n}",
        "code_after_change": "static int smb2_calc_max_out_buf_len(struct ksmbd_work *work,\n\t\t\t\t     unsigned short hdr2_len,\n\t\t\t\t     unsigned int out_buf_len)\n{\n\tint free_len;\n\n\tif (out_buf_len > work->conn->vals->max_trans_size)\n\t\treturn -EINVAL;\n\n\tfree_len = smb2_resp_buf_len(work, hdr2_len);\n\tif (free_len < 0)\n\t\treturn -EINVAL;\n\n\treturn min_t(int, out_buf_len, free_len);\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,9 +7,7 @@\n \tif (out_buf_len > work->conn->vals->max_trans_size)\n \t\treturn -EINVAL;\n \n-\tfree_len = (int)(work->response_sz -\n-\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -\n-\t\thdr2_len;\n+\tfree_len = smb2_resp_buf_len(work, hdr2_len);\n \tif (free_len < 0)\n \t\treturn -EINVAL;\n ",
        "function_modified_lines": {
            "added": [
                "\tfree_len = smb2_resp_buf_len(work, hdr2_len);"
            ],
            "deleted": [
                "\tfree_len = (int)(work->response_sz -",
                "\t\t\t (get_rfc1002_len(work->response_buf) + 4)) -",
                "\t\thdr2_len;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An issue was discovered in ksmbd in the Linux kernel 5.15 through 5.19 before 5.19.2. There is a heap-based buffer overflow in set_ntacl_dacl, related to use of SMB2_QUERY_INFO_HE after a malformed SMB2_SET_INFO_HE command.",
        "id": 3772
    },
    {
        "cve_id": "CVE-2022-20369",
        "code_before_change": "int v4l2_m2m_dqbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\n\t\t   struct v4l2_buffer *buf)\n{\n\tstruct vb2_queue *vq;\n\n\tvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\n\treturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n}",
        "code_after_change": "int v4l2_m2m_dqbuf(struct file *file, struct v4l2_m2m_ctx *m2m_ctx,\n\t\t   struct v4l2_buffer *buf)\n{\n\tstruct vb2_queue *vq;\n\tint ret;\n\n\tvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\n\tret = vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n\tif (ret)\n\t\treturn ret;\n\n\t/* Adjust MMAP memory offsets for the CAPTURE queue */\n\tv4l2_m2m_adjust_mem_offset(vq, buf);\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,7 +2,15 @@\n \t\t   struct v4l2_buffer *buf)\n {\n \tstruct vb2_queue *vq;\n+\tint ret;\n \n \tvq = v4l2_m2m_get_vq(m2m_ctx, buf->type);\n-\treturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n+\tret = vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);\n+\tif (ret)\n+\t\treturn ret;\n+\n+\t/* Adjust MMAP memory offsets for the CAPTURE queue */\n+\tv4l2_m2m_adjust_mem_offset(vq, buf);\n+\n+\treturn 0;\n }",
        "function_modified_lines": {
            "added": [
                "\tint ret;",
                "\tret = vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);",
                "\tif (ret)",
                "\t\treturn ret;",
                "",
                "\t/* Adjust MMAP memory offsets for the CAPTURE queue */",
                "\tv4l2_m2m_adjust_mem_offset(vq, buf);",
                "",
                "\treturn 0;"
            ],
            "deleted": [
                "\treturn vb2_dqbuf(vq, buf, file->f_flags & O_NONBLOCK);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "In v4l2_m2m_querybuf of v4l2-mem2mem.c, there is a possible out of bounds write due to improper input validation. This could lead to local escalation of privilege with System execution privileges needed. User interaction is not needed for exploitation.Product: AndroidVersions: Android kernelAndroid ID: A-223375145References: Upstream kernel",
        "id": 3349
    },
    {
        "cve_id": "CVE-2020-25212",
        "code_before_change": "static int _nfs4_get_security_label(struct inode *inode, void *buf,\n\t\t\t\t\tsize_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_label label = {0, 0, buflen, buf};\n\n\tu32 bitmask[3] = { 0, 0, FATTR4_WORD2_SECURITY_LABEL };\n\tstruct nfs4_getattr_arg arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.bitmask\t= bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr\t\t= &fattr,\n\t\t.label\t\t= &label,\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint ret;\n\n\tnfs_fattr_init(&fattr);\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (!(fattr.valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL))\n\t\treturn -ENOENT;\n\tif (buflen < label.len)\n\t\treturn -ERANGE;\n\treturn 0;\n}",
        "code_after_change": "static int _nfs4_get_security_label(struct inode *inode, void *buf,\n\t\t\t\t\tsize_t buflen)\n{\n\tstruct nfs_server *server = NFS_SERVER(inode);\n\tstruct nfs_fattr fattr;\n\tstruct nfs4_label label = {0, 0, buflen, buf};\n\n\tu32 bitmask[3] = { 0, 0, FATTR4_WORD2_SECURITY_LABEL };\n\tstruct nfs4_getattr_arg arg = {\n\t\t.fh\t\t= NFS_FH(inode),\n\t\t.bitmask\t= bitmask,\n\t};\n\tstruct nfs4_getattr_res res = {\n\t\t.fattr\t\t= &fattr,\n\t\t.label\t\t= &label,\n\t\t.server\t\t= server,\n\t};\n\tstruct rpc_message msg = {\n\t\t.rpc_proc\t= &nfs4_procedures[NFSPROC4_CLNT_GETATTR],\n\t\t.rpc_argp\t= &arg,\n\t\t.rpc_resp\t= &res,\n\t};\n\tint ret;\n\n\tnfs_fattr_init(&fattr);\n\n\tret = nfs4_call_sync(server->client, server, &msg, &arg.seq_args, &res.seq_res, 0);\n\tif (ret)\n\t\treturn ret;\n\tif (!(fattr.valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL))\n\t\treturn -ENOENT;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -29,7 +29,5 @@\n \t\treturn ret;\n \tif (!(fattr.valid & NFS_ATTR_FATTR_V4_SECURITY_LABEL))\n \t\treturn -ENOENT;\n-\tif (buflen < label.len)\n-\t\treturn -ERANGE;\n \treturn 0;\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\tif (buflen < label.len)",
                "\t\treturn -ERANGE;"
            ]
        },
        "cwe": [
            "CWE-787",
            "CWE-367"
        ],
        "cve_description": "A TOCTOU mismatch in the NFS client code in the Linux kernel before 5.8.3 could be used by local attackers to corrupt memory or possibly have unspecified other impact because a size check is in fs/nfs/nfs4proc.c instead of fs/nfs/nfs4xdr.c, aka CID-b4487b935452.",
        "id": 2578
    },
    {
        "cve_id": "CVE-2019-19332",
        "code_before_change": "static int do_cpuid_func(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\t int *nent, int maxnent, unsigned int type)\n{\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_func_emulated(entry, func, nent, maxnent);\n\n\treturn __do_cpuid_func(entry, func, nent, maxnent);\n}",
        "code_after_change": "static int do_cpuid_func(struct kvm_cpuid_entry2 *entry, u32 func,\n\t\t\t int *nent, int maxnent, unsigned int type)\n{\n\tif (*nent >= maxnent)\n\t\treturn -E2BIG;\n\n\tif (type == KVM_GET_EMULATED_CPUID)\n\t\treturn __do_cpuid_func_emulated(entry, func, nent, maxnent);\n\n\treturn __do_cpuid_func(entry, func, nent, maxnent);\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,6 +1,9 @@\n static int do_cpuid_func(struct kvm_cpuid_entry2 *entry, u32 func,\n \t\t\t int *nent, int maxnent, unsigned int type)\n {\n+\tif (*nent >= maxnent)\n+\t\treturn -E2BIG;\n+\n \tif (type == KVM_GET_EMULATED_CPUID)\n \t\treturn __do_cpuid_func_emulated(entry, func, nent, maxnent);\n ",
        "function_modified_lines": {
            "added": [
                "\tif (*nent >= maxnent)",
                "\t\treturn -E2BIG;",
                ""
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write issue was found in the Linux Kernel, version 3.13 through 5.4, in the way the Linux kernel's KVM hypervisor handled the 'KVM_GET_EMULATED_CPUID' ioctl(2) request to get CPUID features emulated by the KVM hypervisor. A user or process able to access the '/dev/kvm' device could use this flaw to crash the system, resulting in a denial of service.",
        "id": 2191
    },
    {
        "cve_id": "CVE-2022-43750",
        "code_before_change": "static int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\t/* don't do anything here: \"fault\" will set up page table entries */\n\tvma->vm_ops = &mon_bin_vm_ops;\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_private_data = filp->private_data;\n\tmon_bin_vma_open(vma);\n\treturn 0;\n}",
        "code_after_change": "static int mon_bin_mmap(struct file *filp, struct vm_area_struct *vma)\n{\n\t/* don't do anything here: \"fault\" will set up page table entries */\n\tvma->vm_ops = &mon_bin_vm_ops;\n\n\tif (vma->vm_flags & VM_WRITE)\n\t\treturn -EPERM;\n\n\tvma->vm_flags &= ~VM_MAYWRITE;\n\tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n\tvma->vm_private_data = filp->private_data;\n\tmon_bin_vma_open(vma);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -2,6 +2,11 @@\n {\n \t/* don't do anything here: \"fault\" will set up page table entries */\n \tvma->vm_ops = &mon_bin_vm_ops;\n+\n+\tif (vma->vm_flags & VM_WRITE)\n+\t\treturn -EPERM;\n+\n+\tvma->vm_flags &= ~VM_MAYWRITE;\n \tvma->vm_flags |= VM_DONTEXPAND | VM_DONTDUMP;\n \tvma->vm_private_data = filp->private_data;\n \tmon_bin_vma_open(vma);",
        "function_modified_lines": {
            "added": [
                "",
                "\tif (vma->vm_flags & VM_WRITE)",
                "\t\treturn -EPERM;",
                "",
                "\tvma->vm_flags &= ~VM_MAYWRITE;"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "drivers/usb/mon/mon_bin.c in usbmon in the Linux kernel before 5.19.15 and 6.x before 6.0.1 allows a user-space client to corrupt the monitor's internal memory.",
        "id": 3741
    },
    {
        "cve_id": "CVE-2021-3491",
        "code_before_change": "static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tbreak;\n\n\t\tbuf->addr = addr;\n\t\tbuf->len = pbuf->len;\n\t\tbuf->bid = bid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tif (!*head) {\n\t\t\tINIT_LIST_HEAD(&buf->list);\n\t\t\t*head = buf;\n\t\t} else {\n\t\t\tlist_add_tail(&buf->list, &(*head)->list);\n\t\t}\n\t}\n\n\treturn i ? i : -ENOMEM;\n}",
        "code_after_change": "static int io_add_buffers(struct io_provide_buf *pbuf, struct io_buffer **head)\n{\n\tstruct io_buffer *buf;\n\tu64 addr = pbuf->addr;\n\tint i, bid = pbuf->bid;\n\n\tfor (i = 0; i < pbuf->nbufs; i++) {\n\t\tbuf = kmalloc(sizeof(*buf), GFP_KERNEL);\n\t\tif (!buf)\n\t\t\tbreak;\n\n\t\tbuf->addr = addr;\n\t\tbuf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);\n\t\tbuf->bid = bid;\n\t\taddr += pbuf->len;\n\t\tbid++;\n\t\tif (!*head) {\n\t\t\tINIT_LIST_HEAD(&buf->list);\n\t\t\t*head = buf;\n\t\t} else {\n\t\t\tlist_add_tail(&buf->list, &(*head)->list);\n\t\t}\n\t}\n\n\treturn i ? i : -ENOMEM;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,7 +10,7 @@\n \t\t\tbreak;\n \n \t\tbuf->addr = addr;\n-\t\tbuf->len = pbuf->len;\n+\t\tbuf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);\n \t\tbuf->bid = bid;\n \t\taddr += pbuf->len;\n \t\tbid++;",
        "function_modified_lines": {
            "added": [
                "\t\tbuf->len = min_t(__u32, pbuf->len, MAX_RW_COUNT);"
            ],
            "deleted": [
                "\t\tbuf->len = pbuf->len;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The io_uring subsystem in the Linux kernel allowed the MAX_RW_COUNT limit to be bypassed in the PROVIDE_BUFFERS operation, which led to negative values being usedin mem_rw when reading /proc/<PID>/mem. This could be used to create a heap overflow leading to arbitrary code execution in the kernel. It was addressed via commit d1f82808877b (\"io_uring: truncate lengths larger than MAX_RW_COUNT on provide buffers\") (v5.13-rc1) and backported to the stable kernels in v5.12.4, v5.11.21, and v5.10.37. It was introduced in ddf0322db79c (\"io_uring: add IORING_OP_PROVIDE_BUFFERS\") (v5.7-rc1).",
        "id": 3013
    },
    {
        "cve_id": "CVE-2023-3812",
        "code_before_change": "static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile,\n\t\t\t\t\t    size_t len,\n\t\t\t\t\t    const struct iov_iter *it)\n{\n\tstruct sk_buff *skb;\n\tsize_t linear;\n\tint err;\n\tint i;\n\n\tif (it->nr_segs > MAX_SKB_FRAGS + 1)\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tlocal_bh_disable();\n\tskb = napi_get_frags(&tfile->napi);\n\tlocal_bh_enable();\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlinear = iov_iter_single_seg_count(it);\n\terr = __skb_grow(skb, linear);\n\tif (err)\n\t\tgoto free;\n\n\tskb->len = len;\n\tskb->data_len = len - linear;\n\tskb->truesize += skb->data_len;\n\n\tfor (i = 1; i < it->nr_segs; i++) {\n\t\tsize_t fragsz = it->iov[i].iov_len;\n\t\tstruct page *page;\n\t\tvoid *frag;\n\n\t\tif (fragsz == 0 || fragsz > PAGE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tfrag = netdev_alloc_frag(fragsz);\n\t\tif (!frag) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tpage = virt_to_head_page(frag);\n\t\tskb_fill_page_desc(skb, i - 1, page,\n\t\t\t\t   frag - page_address(page), fragsz);\n\t}\n\n\treturn skb;\nfree:\n\t/* frees skb and all frags allocated with napi_alloc_frag() */\n\tnapi_free_frags(&tfile->napi);\n\treturn ERR_PTR(err);\n}",
        "code_after_change": "static struct sk_buff *tun_napi_alloc_frags(struct tun_file *tfile,\n\t\t\t\t\t    size_t len,\n\t\t\t\t\t    const struct iov_iter *it)\n{\n\tstruct sk_buff *skb;\n\tsize_t linear;\n\tint err;\n\tint i;\n\n\tif (it->nr_segs > MAX_SKB_FRAGS + 1 ||\n\t    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))\n\t\treturn ERR_PTR(-EMSGSIZE);\n\n\tlocal_bh_disable();\n\tskb = napi_get_frags(&tfile->napi);\n\tlocal_bh_enable();\n\tif (!skb)\n\t\treturn ERR_PTR(-ENOMEM);\n\n\tlinear = iov_iter_single_seg_count(it);\n\terr = __skb_grow(skb, linear);\n\tif (err)\n\t\tgoto free;\n\n\tskb->len = len;\n\tskb->data_len = len - linear;\n\tskb->truesize += skb->data_len;\n\n\tfor (i = 1; i < it->nr_segs; i++) {\n\t\tsize_t fragsz = it->iov[i].iov_len;\n\t\tstruct page *page;\n\t\tvoid *frag;\n\n\t\tif (fragsz == 0 || fragsz > PAGE_SIZE) {\n\t\t\terr = -EINVAL;\n\t\t\tgoto free;\n\t\t}\n\t\tfrag = netdev_alloc_frag(fragsz);\n\t\tif (!frag) {\n\t\t\terr = -ENOMEM;\n\t\t\tgoto free;\n\t\t}\n\t\tpage = virt_to_head_page(frag);\n\t\tskb_fill_page_desc(skb, i - 1, page,\n\t\t\t\t   frag - page_address(page), fragsz);\n\t}\n\n\treturn skb;\nfree:\n\t/* frees skb and all frags allocated with napi_alloc_frag() */\n\tnapi_free_frags(&tfile->napi);\n\treturn ERR_PTR(err);\n}",
        "patch": "--- code before\n+++ code after\n@@ -7,7 +7,8 @@\n \tint err;\n \tint i;\n \n-\tif (it->nr_segs > MAX_SKB_FRAGS + 1)\n+\tif (it->nr_segs > MAX_SKB_FRAGS + 1 ||\n+\t    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))\n \t\treturn ERR_PTR(-EMSGSIZE);\n \n \tlocal_bh_disable();",
        "function_modified_lines": {
            "added": [
                "\tif (it->nr_segs > MAX_SKB_FRAGS + 1 ||",
                "\t    len > (ETH_MAX_MTU - NET_SKB_PAD - NET_IP_ALIGN))"
            ],
            "deleted": [
                "\tif (it->nr_segs > MAX_SKB_FRAGS + 1)"
            ]
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "An out-of-bounds memory access flaw was found in the Linux kernel’s TUN/TAP device driver functionality in how a user generates a malicious (too big) networking packet when napi frags is enabled. This flaw allows a local user to crash or potentially escalate their privileges on the system.",
        "id": 4136
    },
    {
        "cve_id": "CVE-2021-22555",
        "code_before_change": "void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_target *target = t->u.kernel.target;\n\tstruct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;\n\tint pad, off = xt_compat_target_offset(target);\n\tu_int16_t tsize = ct->u.user.target_size;\n\tchar name[sizeof(t->u.user.name)];\n\n\tt = *dstptr;\n\tmemcpy(t, ct, sizeof(*ct));\n\tif (target->compat_from_user)\n\t\ttarget->compat_from_user(t->data, ct->data);\n\telse\n\t\tmemcpy(t->data, ct->data, tsize - sizeof(*ct));\n\tpad = XT_ALIGN(target->targetsize) - target->targetsize;\n\tif (pad > 0)\n\t\tmemset(t->data + target->targetsize, 0, pad);\n\n\ttsize += off;\n\tt->u.user.target_size = tsize;\n\tstrlcpy(name, target->name, sizeof(name));\n\tmodule_put(target->me);\n\tstrncpy(t->u.user.name, name, sizeof(t->u.user.name));\n\n\t*size += off;\n\t*dstptr += tsize;\n}",
        "code_after_change": "void xt_compat_target_from_user(struct xt_entry_target *t, void **dstptr,\n\t\t\t\tunsigned int *size)\n{\n\tconst struct xt_target *target = t->u.kernel.target;\n\tstruct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;\n\tint off = xt_compat_target_offset(target);\n\tu_int16_t tsize = ct->u.user.target_size;\n\tchar name[sizeof(t->u.user.name)];\n\n\tt = *dstptr;\n\tmemcpy(t, ct, sizeof(*ct));\n\tif (target->compat_from_user)\n\t\ttarget->compat_from_user(t->data, ct->data);\n\telse\n\t\tmemcpy(t->data, ct->data, tsize - sizeof(*ct));\n\n\ttsize += off;\n\tt->u.user.target_size = tsize;\n\tstrlcpy(name, target->name, sizeof(name));\n\tmodule_put(target->me);\n\tstrncpy(t->u.user.name, name, sizeof(t->u.user.name));\n\n\t*size += off;\n\t*dstptr += tsize;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n {\n \tconst struct xt_target *target = t->u.kernel.target;\n \tstruct compat_xt_entry_target *ct = (struct compat_xt_entry_target *)t;\n-\tint pad, off = xt_compat_target_offset(target);\n+\tint off = xt_compat_target_offset(target);\n \tu_int16_t tsize = ct->u.user.target_size;\n \tchar name[sizeof(t->u.user.name)];\n \n@@ -13,9 +13,6 @@\n \t\ttarget->compat_from_user(t->data, ct->data);\n \telse\n \t\tmemcpy(t->data, ct->data, tsize - sizeof(*ct));\n-\tpad = XT_ALIGN(target->targetsize) - target->targetsize;\n-\tif (pad > 0)\n-\t\tmemset(t->data + target->targetsize, 0, pad);\n \n \ttsize += off;\n \tt->u.user.target_size = tsize;",
        "function_modified_lines": {
            "added": [
                "\tint off = xt_compat_target_offset(target);"
            ],
            "deleted": [
                "\tint pad, off = xt_compat_target_offset(target);",
                "\tpad = XT_ALIGN(target->targetsize) - target->targetsize;",
                "\tif (pad > 0)",
                "\t\tmemset(t->data + target->targetsize, 0, pad);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "id": 2885
    },
    {
        "cve_id": "CVE-2021-22555",
        "code_before_change": "void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,\n\t\t\t       unsigned int *size)\n{\n\tconst struct xt_match *match = m->u.kernel.match;\n\tstruct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;\n\tint pad, off = xt_compat_match_offset(match);\n\tu_int16_t msize = cm->u.user.match_size;\n\tchar name[sizeof(m->u.user.name)];\n\n\tm = *dstptr;\n\tmemcpy(m, cm, sizeof(*cm));\n\tif (match->compat_from_user)\n\t\tmatch->compat_from_user(m->data, cm->data);\n\telse\n\t\tmemcpy(m->data, cm->data, msize - sizeof(*cm));\n\tpad = XT_ALIGN(match->matchsize) - match->matchsize;\n\tif (pad > 0)\n\t\tmemset(m->data + match->matchsize, 0, pad);\n\n\tmsize += off;\n\tm->u.user.match_size = msize;\n\tstrlcpy(name, match->name, sizeof(name));\n\tmodule_put(match->me);\n\tstrncpy(m->u.user.name, name, sizeof(m->u.user.name));\n\n\t*size += off;\n\t*dstptr += msize;\n}",
        "code_after_change": "void xt_compat_match_from_user(struct xt_entry_match *m, void **dstptr,\n\t\t\t       unsigned int *size)\n{\n\tconst struct xt_match *match = m->u.kernel.match;\n\tstruct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;\n\tint off = xt_compat_match_offset(match);\n\tu_int16_t msize = cm->u.user.match_size;\n\tchar name[sizeof(m->u.user.name)];\n\n\tm = *dstptr;\n\tmemcpy(m, cm, sizeof(*cm));\n\tif (match->compat_from_user)\n\t\tmatch->compat_from_user(m->data, cm->data);\n\telse\n\t\tmemcpy(m->data, cm->data, msize - sizeof(*cm));\n\n\tmsize += off;\n\tm->u.user.match_size = msize;\n\tstrlcpy(name, match->name, sizeof(name));\n\tmodule_put(match->me);\n\tstrncpy(m->u.user.name, name, sizeof(m->u.user.name));\n\n\t*size += off;\n\t*dstptr += msize;\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,7 +3,7 @@\n {\n \tconst struct xt_match *match = m->u.kernel.match;\n \tstruct compat_xt_entry_match *cm = (struct compat_xt_entry_match *)m;\n-\tint pad, off = xt_compat_match_offset(match);\n+\tint off = xt_compat_match_offset(match);\n \tu_int16_t msize = cm->u.user.match_size;\n \tchar name[sizeof(m->u.user.name)];\n \n@@ -13,9 +13,6 @@\n \t\tmatch->compat_from_user(m->data, cm->data);\n \telse\n \t\tmemcpy(m->data, cm->data, msize - sizeof(*cm));\n-\tpad = XT_ALIGN(match->matchsize) - match->matchsize;\n-\tif (pad > 0)\n-\t\tmemset(m->data + match->matchsize, 0, pad);\n \n \tmsize += off;\n \tm->u.user.match_size = msize;",
        "function_modified_lines": {
            "added": [
                "\tint off = xt_compat_match_offset(match);"
            ],
            "deleted": [
                "\tint pad, off = xt_compat_match_offset(match);",
                "\tpad = XT_ALIGN(match->matchsize) - match->matchsize;",
                "\tif (pad > 0)",
                "\t\tmemset(m->data + match->matchsize, 0, pad);"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "id": 2884
    },
    {
        "cve_id": "CVE-2021-22555",
        "code_before_change": "static int\ntranslate_compat_table(struct net *net,\n\t\t       struct xt_table_info **pinfo,\n\t\t       void **pentry0,\n\t\t       const struct compat_ipt_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_ipt_entry *iter0;\n\tstruct ipt_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(AF_INET);\n\tret = xt_compat_init_offsets(AF_INET, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone.\n\t * entry1/newinfo contains a 64bit ruleset that looks exactly as\n\t * generated by 64bit userspace.\n\t *\n\t * Call standard translate_table() to validate all hook_entrys,\n\t * underflows, check for loops, etc.\n\t */\n\txt_compat_flush_offsets(AF_INET);\n\txt_compat_unlock(AF_INET);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(AF_INET);\n\txt_compat_unlock(AF_INET);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}",
        "code_after_change": "static int\ntranslate_compat_table(struct net *net,\n\t\t       struct xt_table_info **pinfo,\n\t\t       void **pentry0,\n\t\t       const struct compat_ipt_replace *compatr)\n{\n\tunsigned int i, j;\n\tstruct xt_table_info *newinfo, *info;\n\tvoid *pos, *entry0, *entry1;\n\tstruct compat_ipt_entry *iter0;\n\tstruct ipt_replace repl;\n\tunsigned int size;\n\tint ret;\n\n\tinfo = *pinfo;\n\tentry0 = *pentry0;\n\tsize = compatr->size;\n\tinfo->number = compatr->num_entries;\n\n\tj = 0;\n\txt_compat_lock(AF_INET);\n\tret = xt_compat_init_offsets(AF_INET, compatr->num_entries);\n\tif (ret)\n\t\tgoto out_unlock;\n\t/* Walk through entries, checking offsets. */\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tret = check_compat_entry_size_and_hooks(iter0, info, &size,\n\t\t\t\t\t\t\tentry0,\n\t\t\t\t\t\t\tentry0 + compatr->size);\n\t\tif (ret != 0)\n\t\t\tgoto out_unlock;\n\t\t++j;\n\t}\n\n\tret = -EINVAL;\n\tif (j != compatr->num_entries)\n\t\tgoto out_unlock;\n\n\tret = -ENOMEM;\n\tnewinfo = xt_alloc_table_info(size);\n\tif (!newinfo)\n\t\tgoto out_unlock;\n\n\tmemset(newinfo->entries, 0, size);\n\n\tnewinfo->number = compatr->num_entries;\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\tnewinfo->hook_entry[i] = compatr->hook_entry[i];\n\t\tnewinfo->underflow[i] = compatr->underflow[i];\n\t}\n\tentry1 = newinfo->entries;\n\tpos = entry1;\n\tsize = compatr->size;\n\txt_entry_foreach(iter0, entry0, compatr->size)\n\t\tcompat_copy_entry_from_user(iter0, &pos, &size,\n\t\t\t\t\t    newinfo, entry1);\n\n\t/* all module references in entry0 are now gone.\n\t * entry1/newinfo contains a 64bit ruleset that looks exactly as\n\t * generated by 64bit userspace.\n\t *\n\t * Call standard translate_table() to validate all hook_entrys,\n\t * underflows, check for loops, etc.\n\t */\n\txt_compat_flush_offsets(AF_INET);\n\txt_compat_unlock(AF_INET);\n\n\tmemcpy(&repl, compatr, sizeof(*compatr));\n\n\tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {\n\t\trepl.hook_entry[i] = newinfo->hook_entry[i];\n\t\trepl.underflow[i] = newinfo->underflow[i];\n\t}\n\n\trepl.num_counters = 0;\n\trepl.counters = NULL;\n\trepl.size = newinfo->size;\n\tret = translate_table(net, newinfo, entry1, &repl);\n\tif (ret)\n\t\tgoto free_newinfo;\n\n\t*pinfo = newinfo;\n\t*pentry0 = entry1;\n\txt_free_table_info(info);\n\treturn 0;\n\nfree_newinfo:\n\txt_free_table_info(newinfo);\n\treturn ret;\nout_unlock:\n\txt_compat_flush_offsets(AF_INET);\n\txt_compat_unlock(AF_INET);\n\txt_entry_foreach(iter0, entry0, compatr->size) {\n\t\tif (j-- == 0)\n\t\t\tbreak;\n\t\tcompat_release_entry(iter0);\n\t}\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -40,6 +40,8 @@\n \tnewinfo = xt_alloc_table_info(size);\n \tif (!newinfo)\n \t\tgoto out_unlock;\n+\n+\tmemset(newinfo->entries, 0, size);\n \n \tnewinfo->number = compatr->num_entries;\n \tfor (i = 0; i < NF_INET_NUMHOOKS; i++) {",
        "function_modified_lines": {
            "added": [
                "",
                "\tmemset(newinfo->entries, 0, size);"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A heap out-of-bounds write affecting Linux since v2.6.19-rc1 was discovered in net/netfilter/x_tables.c. This allows an attacker to gain privileges or cause a DoS (via heap memory corruption) through user name space",
        "id": 2882
    },
    {
        "cve_id": "CVE-2018-10882",
        "code_before_change": "static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\tino == EXT4_USR_QUOTA_INO ||\n\t\tino == EXT4_GRP_QUOTA_INO ||\n\t\tino == EXT4_BOOT_LOADER_INO ||\n\t\tino == EXT4_JOURNAL_INO ||\n\t\tino == EXT4_RESIZE_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}",
        "code_after_change": "static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n{\n\treturn ino == EXT4_ROOT_INO ||\n\t\t(ino >= EXT4_FIRST_INO(sb) &&\n\t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n}",
        "patch": "--- code before\n+++ code after\n@@ -1,11 +1,6 @@\n static inline int ext4_valid_inum(struct super_block *sb, unsigned long ino)\n {\n \treturn ino == EXT4_ROOT_INO ||\n-\t\tino == EXT4_USR_QUOTA_INO ||\n-\t\tino == EXT4_GRP_QUOTA_INO ||\n-\t\tino == EXT4_BOOT_LOADER_INO ||\n-\t\tino == EXT4_JOURNAL_INO ||\n-\t\tino == EXT4_RESIZE_INO ||\n \t\t(ino >= EXT4_FIRST_INO(sb) &&\n \t\t ino <= le32_to_cpu(EXT4_SB(sb)->s_es->s_inodes_count));\n }",
        "function_modified_lines": {
            "added": [],
            "deleted": [
                "\t\tino == EXT4_USR_QUOTA_INO ||",
                "\t\tino == EXT4_GRP_QUOTA_INO ||",
                "\t\tino == EXT4_BOOT_LOADER_INO ||",
                "\t\tino == EXT4_JOURNAL_INO ||",
                "\t\tino == EXT4_RESIZE_INO ||"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bound write in in fs/jbd2/transaction.c code, a denial of service, and a system crash by unmounting a crafted ext4 filesystem image.",
        "id": 1615
    },
    {
        "cve_id": "CVE-2014-0077",
        "code_before_change": "static void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr_mrg_rxbuf hdr = {\n\t\t.hdr.flags = 0,\n\t\t.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\tstruct socket *sock;\n\n\tmutex_lock(&vq->mutex);\n\tsock = vq->private_data;\n\tif (!sock)\n\t\tgoto out;\n\tvhost_disable_notify(&net->dev, vq);\n\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = peek_head_len(sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(headcount < 0))\n\t\t\tbreak;\n\t\t/* OK, now we need to know about added descriptors. */\n\t\tif (!headcount) {\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tbreak;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tif (unlikely((vhost_hlen)))\n\t\t\t/* Skip header. TODO: support TSO. */\n\t\t\tmove_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);\n\t\telse\n\t\t\t/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:\n\t\t\t * needed because recvmsg can modify msg_iov. */\n\t\t\tcopy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);\n\t\tmsg.msg_iovlen = in;\n\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(vhost_hlen) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,\n\t\t\t\t      vhost_hlen)) {\n\t\t\tvq_err(vq, \"Unable to write vnet_hdr at addr %p\\n\",\n\t\t\t       vq->iov->iov_base);\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\t\tif (likely(mergeable) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,\n\t\t\t\t      offsetof(typeof(hdr), num_buffers),\n\t\t\t\t      sizeof hdr.num_buffers)) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    headcount);\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&vq->mutex);\n}",
        "code_after_change": "static void handle_rx(struct vhost_net *net)\n{\n\tstruct vhost_net_virtqueue *nvq = &net->vqs[VHOST_NET_VQ_RX];\n\tstruct vhost_virtqueue *vq = &nvq->vq;\n\tunsigned uninitialized_var(in), log;\n\tstruct vhost_log *vq_log;\n\tstruct msghdr msg = {\n\t\t.msg_name = NULL,\n\t\t.msg_namelen = 0,\n\t\t.msg_control = NULL, /* FIXME: get and handle RX aux data. */\n\t\t.msg_controllen = 0,\n\t\t.msg_iov = vq->iov,\n\t\t.msg_flags = MSG_DONTWAIT,\n\t};\n\tstruct virtio_net_hdr_mrg_rxbuf hdr = {\n\t\t.hdr.flags = 0,\n\t\t.hdr.gso_type = VIRTIO_NET_HDR_GSO_NONE\n\t};\n\tsize_t total_len = 0;\n\tint err, mergeable;\n\ts16 headcount;\n\tsize_t vhost_hlen, sock_hlen;\n\tsize_t vhost_len, sock_len;\n\tstruct socket *sock;\n\n\tmutex_lock(&vq->mutex);\n\tsock = vq->private_data;\n\tif (!sock)\n\t\tgoto out;\n\tvhost_disable_notify(&net->dev, vq);\n\n\tvhost_hlen = nvq->vhost_hlen;\n\tsock_hlen = nvq->sock_hlen;\n\n\tvq_log = unlikely(vhost_has_feature(&net->dev, VHOST_F_LOG_ALL)) ?\n\t\tvq->log : NULL;\n\tmergeable = vhost_has_feature(&net->dev, VIRTIO_NET_F_MRG_RXBUF);\n\n\twhile ((sock_len = peek_head_len(sock->sk))) {\n\t\tsock_len += sock_hlen;\n\t\tvhost_len = sock_len + vhost_hlen;\n\t\theadcount = get_rx_bufs(vq, vq->heads, vhost_len,\n\t\t\t\t\t&in, vq_log, &log,\n\t\t\t\t\tlikely(mergeable) ? UIO_MAXIOV : 1);\n\t\t/* On error, stop handling until the next kick. */\n\t\tif (unlikely(headcount < 0))\n\t\t\tbreak;\n\t\t/* On overrun, truncate and discard */\n\t\tif (unlikely(headcount > UIO_MAXIOV)) {\n\t\t\tmsg.msg_iovlen = 1;\n\t\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t\t 1, MSG_DONTWAIT | MSG_TRUNC);\n\t\t\tpr_debug(\"Discarded rx packet: len %zd\\n\", sock_len);\n\t\t\tcontinue;\n\t\t}\n\t\t/* OK, now we need to know about added descriptors. */\n\t\tif (!headcount) {\n\t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {\n\t\t\t\t/* They have slipped one in as we were\n\t\t\t\t * doing that: check again. */\n\t\t\t\tvhost_disable_notify(&net->dev, vq);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* Nothing new?  Wait for eventfd to tell us\n\t\t\t * they refilled. */\n\t\t\tbreak;\n\t\t}\n\t\t/* We don't need to be notified again. */\n\t\tif (unlikely((vhost_hlen)))\n\t\t\t/* Skip header. TODO: support TSO. */\n\t\t\tmove_iovec_hdr(vq->iov, nvq->hdr, vhost_hlen, in);\n\t\telse\n\t\t\t/* Copy the header for use in VIRTIO_NET_F_MRG_RXBUF:\n\t\t\t * needed because recvmsg can modify msg_iov. */\n\t\t\tcopy_iovec_hdr(vq->iov, nvq->hdr, sock_hlen, in);\n\t\tmsg.msg_iovlen = in;\n\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n\t\t\t\t\t sock_len, MSG_DONTWAIT | MSG_TRUNC);\n\t\t/* Userspace might have consumed the packet meanwhile:\n\t\t * it's not supposed to do this usually, but might be hard\n\t\t * to prevent. Discard data we got (if any) and keep going. */\n\t\tif (unlikely(err != sock_len)) {\n\t\t\tpr_debug(\"Discarded rx packet: \"\n\t\t\t\t \" len %d, expected %zd\\n\", err, sock_len);\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tcontinue;\n\t\t}\n\t\tif (unlikely(vhost_hlen) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&hdr, 0,\n\t\t\t\t      vhost_hlen)) {\n\t\t\tvq_err(vq, \"Unable to write vnet_hdr at addr %p\\n\",\n\t\t\t       vq->iov->iov_base);\n\t\t\tbreak;\n\t\t}\n\t\t/* TODO: Should check and handle checksum. */\n\t\tif (likely(mergeable) &&\n\t\t    memcpy_toiovecend(nvq->hdr, (unsigned char *)&headcount,\n\t\t\t\t      offsetof(typeof(hdr), num_buffers),\n\t\t\t\t      sizeof hdr.num_buffers)) {\n\t\t\tvq_err(vq, \"Failed num_buffers write\");\n\t\t\tvhost_discard_vq_desc(vq, headcount);\n\t\t\tbreak;\n\t\t}\n\t\tvhost_add_used_and_signal_n(&net->dev, vq, vq->heads,\n\t\t\t\t\t    headcount);\n\t\tif (unlikely(vq_log))\n\t\t\tvhost_log_write(vq, vq_log, log, vhost_len);\n\t\ttotal_len += vhost_len;\n\t\tif (unlikely(total_len >= VHOST_NET_WEIGHT)) {\n\t\t\tvhost_poll_queue(&vq->poll);\n\t\t\tbreak;\n\t\t}\n\t}\nout:\n\tmutex_unlock(&vq->mutex);\n}",
        "patch": "--- code before\n+++ code after\n@@ -45,6 +45,14 @@\n \t\t/* On error, stop handling until the next kick. */\n \t\tif (unlikely(headcount < 0))\n \t\t\tbreak;\n+\t\t/* On overrun, truncate and discard */\n+\t\tif (unlikely(headcount > UIO_MAXIOV)) {\n+\t\t\tmsg.msg_iovlen = 1;\n+\t\t\terr = sock->ops->recvmsg(NULL, sock, &msg,\n+\t\t\t\t\t\t 1, MSG_DONTWAIT | MSG_TRUNC);\n+\t\t\tpr_debug(\"Discarded rx packet: len %zd\\n\", sock_len);\n+\t\t\tcontinue;\n+\t\t}\n \t\t/* OK, now we need to know about added descriptors. */\n \t\tif (!headcount) {\n \t\t\tif (unlikely(vhost_enable_notify(&net->dev, vq))) {",
        "function_modified_lines": {
            "added": [
                "\t\t/* On overrun, truncate and discard */",
                "\t\tif (unlikely(headcount > UIO_MAXIOV)) {",
                "\t\t\tmsg.msg_iovlen = 1;",
                "\t\t\terr = sock->ops->recvmsg(NULL, sock, &msg,",
                "\t\t\t\t\t\t 1, MSG_DONTWAIT | MSG_TRUNC);",
                "\t\t\tpr_debug(\"Discarded rx packet: len %zd\\n\", sock_len);",
                "\t\t\tcontinue;",
                "\t\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "drivers/vhost/net.c in the Linux kernel before 3.13.10, when mergeable buffers are disabled, does not properly validate packet lengths, which allows guest OS users to cause a denial of service (memory corruption and host OS crash) or possibly gain privileges on the host OS via crafted packets, related to the handle_rx and get_rx_bufs functions.",
        "id": 427
    },
    {
        "cve_id": "CVE-2016-9755",
        "code_before_change": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn -EINVAL;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn -EINVAL;\n\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* after queue has assumed skb ownership, only 0 or -EINPROGRESS\n\t * must be returned.\n\t */\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\n\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}",
        "code_after_change": "int nf_ct_frag6_gather(struct net *net, struct sk_buff *skb, u32 user)\n{\n\tstruct net_device *dev = skb->dev;\n\tint fhoff, nhoff, ret;\n\tstruct frag_hdr *fhdr;\n\tstruct frag_queue *fq;\n\tstruct ipv6hdr *hdr;\n\tu8 prevhdr;\n\n\t/* Jumbo payload inhibits frag. header */\n\tif (ipv6_hdr(skb)->payload_len == 0) {\n\t\tpr_debug(\"payload len = 0\\n\");\n\t\treturn 0;\n\t}\n\n\tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n\t\treturn 0;\n\n\tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n\t\treturn -ENOMEM;\n\n\tskb_set_transport_header(skb, fhoff);\n\thdr = ipv6_hdr(skb);\n\tfhdr = (struct frag_hdr *)skb_transport_header(skb);\n\n\tfq = fq_find(net, fhdr->identification, user, &hdr->saddr, &hdr->daddr,\n\t\t     skb->dev ? skb->dev->ifindex : 0, ip6_frag_ecn(hdr));\n\tif (fq == NULL) {\n\t\tpr_debug(\"Can't find and can't create new queue\\n\");\n\t\treturn -ENOMEM;\n\t}\n\n\tspin_lock_bh(&fq->q.lock);\n\n\tif (nf_ct_frag6_queue(fq, skb, fhdr, nhoff) < 0) {\n\t\tret = -EINVAL;\n\t\tgoto out_unlock;\n\t}\n\n\t/* after queue has assumed skb ownership, only 0 or -EINPROGRESS\n\t * must be returned.\n\t */\n\tret = -EINPROGRESS;\n\tif (fq->q.flags == (INET_FRAG_FIRST_IN | INET_FRAG_LAST_IN) &&\n\t    fq->q.meat == fq->q.len &&\n\t    nf_ct_frag6_reasm(fq, skb, dev))\n\t\tret = 0;\n\nout_unlock:\n\tspin_unlock_bh(&fq->q.lock);\n\tinet_frag_put(&fq->q, &nf_frags);\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -10,11 +10,11 @@\n \t/* Jumbo payload inhibits frag. header */\n \tif (ipv6_hdr(skb)->payload_len == 0) {\n \t\tpr_debug(\"payload len = 0\\n\");\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \t}\n \n \tif (find_prev_fhdr(skb, &prevhdr, &nhoff, &fhoff) < 0)\n-\t\treturn -EINVAL;\n+\t\treturn 0;\n \n \tif (!pskb_may_pull(skb, fhoff + sizeof(*fhdr)))\n \t\treturn -ENOMEM;",
        "function_modified_lines": {
            "added": [
                "\t\treturn 0;",
                "\t\treturn 0;"
            ],
            "deleted": [
                "\t\treturn -EINVAL;",
                "\t\treturn -EINVAL;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The netfilter subsystem in the Linux kernel before 4.9 mishandles IPv6 reassembly, which allows local users to cause a denial of service (integer overflow, out-of-bounds write, and GPF) or possibly have unspecified other impact via a crafted application that makes socket, connect, and writev system calls, related to net/ipv6/netfilter/nf_conntrack_reasm.c and net/ipv6/netfilter/nf_defrag_ipv6_hooks.c.",
        "id": 1162
    },
    {
        "cve_id": "CVE-2017-17558",
        "code_before_change": "static int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_warn(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "code_after_change": "static int usb_parse_configuration(struct usb_device *dev, int cfgidx,\n    struct usb_host_config *config, unsigned char *buffer, int size)\n{\n\tstruct device *ddev = &dev->dev;\n\tunsigned char *buffer0 = buffer;\n\tint cfgno;\n\tint nintf, nintf_orig;\n\tint i, j, n;\n\tstruct usb_interface_cache *intfc;\n\tunsigned char *buffer2;\n\tint size2;\n\tstruct usb_descriptor_header *header;\n\tint len, retval;\n\tu8 inums[USB_MAXINTERFACES], nalts[USB_MAXINTERFACES];\n\tunsigned iad_num = 0;\n\n\tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n\tnintf = nintf_orig = config->desc.bNumInterfaces;\n\tconfig->desc.bNumInterfaces = 0;\t// Adjusted later\n\n\tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n\t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n\t    config->desc.bLength > size) {\n\t\tdev_err(ddev, \"invalid descriptor for config index %d: \"\n\t\t    \"type = 0x%X, length = %d\\n\", cfgidx,\n\t\t    config->desc.bDescriptorType, config->desc.bLength);\n\t\treturn -EINVAL;\n\t}\n\tcfgno = config->desc.bConfigurationValue;\n\n\tbuffer += config->desc.bLength;\n\tsize -= config->desc.bLength;\n\n\tif (nintf > USB_MAXINTERFACES) {\n\t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n\t\t    \"using maximum allowed: %d\\n\",\n\t\t    cfgno, nintf, USB_MAXINTERFACES);\n\t\tnintf = USB_MAXINTERFACES;\n\t}\n\n\t/* Go through the descriptors, checking their length and counting the\n\t * number of altsettings for each interface */\n\tn = 0;\n\tfor ((buffer2 = buffer, size2 = size);\n\t      size2 > 0;\n\t     (buffer2 += header->bLength, size2 -= header->bLength)) {\n\n\t\tif (size2 < sizeof(struct usb_descriptor_header)) {\n\t\t\tdev_warn(ddev, \"config %d descriptor has %d excess \"\n\t\t\t    \"byte%s, ignoring\\n\",\n\t\t\t    cfgno, size2, plural(size2));\n\t\t\tbreak;\n\t\t}\n\n\t\theader = (struct usb_descriptor_header *) buffer2;\n\t\tif ((header->bLength > size2) || (header->bLength < 2)) {\n\t\t\tdev_warn(ddev, \"config %d has an invalid descriptor \"\n\t\t\t    \"of length %d, skipping remainder of the config\\n\",\n\t\t\t    cfgno, header->bLength);\n\t\t\tbreak;\n\t\t}\n\n\t\tif (header->bDescriptorType == USB_DT_INTERFACE) {\n\t\t\tstruct usb_interface_descriptor *d;\n\t\t\tint inum;\n\n\t\t\td = (struct usb_interface_descriptor *) header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_SIZE) {\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface descriptor of length %d, \"\n\t\t\t\t    \"skipping\\n\", cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tinum = d->bInterfaceNumber;\n\n\t\t\tif ((dev->quirks & USB_QUIRK_HONOR_BNUMINTERFACES) &&\n\t\t\t    n >= nintf_orig) {\n\t\t\t\tdev_warn(ddev, \"config %d has more interface \"\n\t\t\t\t    \"descriptors, than it declares in \"\n\t\t\t\t    \"bNumInterfaces, ignoring interface \"\n\t\t\t\t    \"number: %d\\n\", cfgno, inum);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (inum >= nintf_orig)\n\t\t\t\tdev_warn(ddev, \"config %d has an invalid \"\n\t\t\t\t    \"interface number: %d but max is %d\\n\",\n\t\t\t\t    cfgno, inum, nintf_orig - 1);\n\n\t\t\t/* Have we already encountered this interface?\n\t\t\t * Count its altsettings */\n\t\t\tfor (i = 0; i < n; ++i) {\n\t\t\t\tif (inums[i] == inum)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i < n) {\n\t\t\t\tif (nalts[i] < 255)\n\t\t\t\t\t++nalts[i];\n\t\t\t} else if (n < USB_MAXINTERFACES) {\n\t\t\t\tinums[n] = inum;\n\t\t\t\tnalts[n] = 1;\n\t\t\t\t++n;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType ==\n\t\t\t\tUSB_DT_INTERFACE_ASSOCIATION) {\n\t\t\tstruct usb_interface_assoc_descriptor *d;\n\n\t\t\td = (struct usb_interface_assoc_descriptor *)header;\n\t\t\tif (d->bLength < USB_DT_INTERFACE_ASSOCIATION_SIZE) {\n\t\t\t\tdev_warn(ddev,\n\t\t\t\t\t \"config %d has an invalid interface association descriptor of length %d, skipping\\n\",\n\t\t\t\t\t cfgno, d->bLength);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iad_num == USB_MAXIADS) {\n\t\t\t\tdev_warn(ddev, \"found more Interface \"\n\t\t\t\t\t       \"Association Descriptors \"\n\t\t\t\t\t       \"than allocated for in \"\n\t\t\t\t\t       \"configuration %d\\n\", cfgno);\n\t\t\t} else {\n\t\t\t\tconfig->intf_assoc[iad_num] = d;\n\t\t\t\tiad_num++;\n\t\t\t}\n\n\t\t} else if (header->bDescriptorType == USB_DT_DEVICE ||\n\t\t\t    header->bDescriptorType == USB_DT_CONFIG)\n\t\t\tdev_warn(ddev, \"config %d contains an unexpected \"\n\t\t\t    \"descriptor of type 0x%X, skipping\\n\",\n\t\t\t    cfgno, header->bDescriptorType);\n\n\t}\t/* for ((buffer2 = buffer, size2 = size); ...) */\n\tsize = buffer2 - buffer;\n\tconfig->desc.wTotalLength = cpu_to_le16(buffer2 - buffer0);\n\n\tif (n != nintf)\n\t\tdev_warn(ddev, \"config %d has %d interface%s, different from \"\n\t\t    \"the descriptor's value: %d\\n\",\n\t\t    cfgno, n, plural(n), nintf_orig);\n\telse if (n == 0)\n\t\tdev_warn(ddev, \"config %d has no interfaces?\\n\", cfgno);\n\tconfig->desc.bNumInterfaces = nintf = n;\n\n\t/* Check for missing interface numbers */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tfor (j = 0; j < nintf; ++j) {\n\t\t\tif (inums[j] == i)\n\t\t\t\tbreak;\n\t\t}\n\t\tif (j >= nintf)\n\t\t\tdev_warn(ddev, \"config %d has no interface number \"\n\t\t\t    \"%d\\n\", cfgno, i);\n\t}\n\n\t/* Allocate the usb_interface_caches and altsetting arrays */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tj = nalts[i];\n\t\tif (j > USB_MAXALTSETTING) {\n\t\t\tdev_warn(ddev, \"too many alternate settings for \"\n\t\t\t    \"config %d interface %d: %d, \"\n\t\t\t    \"using maximum allowed: %d\\n\",\n\t\t\t    cfgno, inums[i], j, USB_MAXALTSETTING);\n\t\t\tnalts[i] = j = USB_MAXALTSETTING;\n\t\t}\n\n\t\tlen = sizeof(*intfc) + sizeof(struct usb_host_interface) * j;\n\t\tconfig->intf_cache[i] = intfc = kzalloc(len, GFP_KERNEL);\n\t\tif (!intfc)\n\t\t\treturn -ENOMEM;\n\t\tkref_init(&intfc->ref);\n\t}\n\n\t/* FIXME: parse the BOS descriptor */\n\n\t/* Skip over any Class Specific or Vendor Specific descriptors;\n\t * find the first interface descriptor */\n\tconfig->extra = buffer;\n\ti = find_next_descriptor(buffer, size, USB_DT_INTERFACE,\n\t    USB_DT_INTERFACE, &n);\n\tconfig->extralen = i;\n\tif (n > 0)\n\t\tdev_dbg(ddev, \"skipped %d descriptor%s after %s\\n\",\n\t\t    n, plural(n), \"configuration\");\n\tbuffer += i;\n\tsize -= i;\n\n\t/* Parse all the interface/altsetting descriptors */\n\twhile (size > 0) {\n\t\tretval = usb_parse_interface(ddev, cfgno, config,\n\t\t    buffer, size, inums, nalts);\n\t\tif (retval < 0)\n\t\t\treturn retval;\n\n\t\tbuffer += retval;\n\t\tsize -= retval;\n\t}\n\n\t/* Check for missing altsettings */\n\tfor (i = 0; i < nintf; ++i) {\n\t\tintfc = config->intf_cache[i];\n\t\tfor (j = 0; j < intfc->num_altsetting; ++j) {\n\t\t\tfor (n = 0; n < intfc->num_altsetting; ++n) {\n\t\t\t\tif (intfc->altsetting[n].desc.\n\t\t\t\t    bAlternateSetting == j)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (n >= intfc->num_altsetting)\n\t\t\t\tdev_warn(ddev, \"config %d interface %d has no \"\n\t\t\t\t    \"altsetting %d\\n\", cfgno, inums[i], j);\n\t\t}\n\t}\n\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -15,6 +15,9 @@\n \tunsigned iad_num = 0;\n \n \tmemcpy(&config->desc, buffer, USB_DT_CONFIG_SIZE);\n+\tnintf = nintf_orig = config->desc.bNumInterfaces;\n+\tconfig->desc.bNumInterfaces = 0;\t// Adjusted later\n+\n \tif (config->desc.bDescriptorType != USB_DT_CONFIG ||\n \t    config->desc.bLength < USB_DT_CONFIG_SIZE ||\n \t    config->desc.bLength > size) {\n@@ -28,7 +31,6 @@\n \tbuffer += config->desc.bLength;\n \tsize -= config->desc.bLength;\n \n-\tnintf = nintf_orig = config->desc.bNumInterfaces;\n \tif (nintf > USB_MAXINTERFACES) {\n \t\tdev_warn(ddev, \"config %d has too many interfaces: %d, \"\n \t\t    \"using maximum allowed: %d\\n\",",
        "function_modified_lines": {
            "added": [
                "\tnintf = nintf_orig = config->desc.bNumInterfaces;",
                "\tconfig->desc.bNumInterfaces = 0;\t// Adjusted later",
                ""
            ],
            "deleted": [
                "\tnintf = nintf_orig = config->desc.bNumInterfaces;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The usb_destroy_configuration function in drivers/usb/core/config.c in the USB core subsystem in the Linux kernel through 4.14.5 does not consider the maximum number of configurations and interfaces before attempting to release resources, which allows local users to cause a denial of service (out-of-bounds write access) or possibly have unspecified other impact via a crafted USB device.",
        "id": 1365
    },
    {
        "cve_id": "CVE-2018-10883",
        "code_before_change": "int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tif (!buffer_jbd(bh)) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't grab jh reference here since the buffer must be part\n\t * of the running transaction.\n\t */\n\tjh = bh2jh(bh);\n\t/*\n\t * This and the following assertions are unreliable since we may see jh\n\t * in inconsistent state unless we grab bh_state lock. But this is\n\t * crucial to catch bugs so let's do a reliable check until the\n\t * lockless handling is fully proven.\n\t */\n\tif (jh->b_transaction != transaction &&\n\t    jh->b_next_transaction != transaction) {\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_next_transaction == transaction);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\tif (jh->b_modified == 1) {\n\t\t/* If it's in our transaction it must be in BJ_Metadata list. */\n\t\tif (jh->b_transaction == transaction &&\n\t\t    jh->b_jlist != BJ_Metadata) {\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction != transaction ||\n\t\t\t\t\tjh->b_jlist == BJ_Metadata);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tjournal = transaction->t_journal;\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tjh->b_modified = 1;\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}",
        "code_after_change": "int jbd2_journal_dirty_metadata(handle_t *handle, struct buffer_head *bh)\n{\n\ttransaction_t *transaction = handle->h_transaction;\n\tjournal_t *journal;\n\tstruct journal_head *jh;\n\tint ret = 0;\n\n\tif (is_handle_aborted(handle))\n\t\treturn -EROFS;\n\tif (!buffer_jbd(bh)) {\n\t\tret = -EUCLEAN;\n\t\tgoto out;\n\t}\n\t/*\n\t * We don't grab jh reference here since the buffer must be part\n\t * of the running transaction.\n\t */\n\tjh = bh2jh(bh);\n\t/*\n\t * This and the following assertions are unreliable since we may see jh\n\t * in inconsistent state unless we grab bh_state lock. But this is\n\t * crucial to catch bugs so let's do a reliable check until the\n\t * lockless handling is fully proven.\n\t */\n\tif (jh->b_transaction != transaction &&\n\t    jh->b_next_transaction != transaction) {\n\t\tjbd_lock_bh_state(bh);\n\t\tJ_ASSERT_JH(jh, jh->b_transaction == transaction ||\n\t\t\t\tjh->b_next_transaction == transaction);\n\t\tjbd_unlock_bh_state(bh);\n\t}\n\tif (jh->b_modified == 1) {\n\t\t/* If it's in our transaction it must be in BJ_Metadata list. */\n\t\tif (jh->b_transaction == transaction &&\n\t\t    jh->b_jlist != BJ_Metadata) {\n\t\t\tjbd_lock_bh_state(bh);\n\t\t\tif (jh->b_transaction == transaction &&\n\t\t\t    jh->b_jlist != BJ_Metadata)\n\t\t\t\tpr_err(\"JBD2: assertion failure: h_type=%u \"\n\t\t\t\t       \"h_line_no=%u block_no=%llu jlist=%u\\n\",\n\t\t\t\t       handle->h_type, handle->h_line_no,\n\t\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t\t       jh->b_jlist);\n\t\t\tJ_ASSERT_JH(jh, jh->b_transaction != transaction ||\n\t\t\t\t\tjh->b_jlist == BJ_Metadata);\n\t\t\tjbd_unlock_bh_state(bh);\n\t\t}\n\t\tgoto out;\n\t}\n\n\tjournal = transaction->t_journal;\n\tjbd_debug(5, \"journal_head %p\\n\", jh);\n\tJBUFFER_TRACE(jh, \"entry\");\n\n\tjbd_lock_bh_state(bh);\n\n\tif (jh->b_modified == 0) {\n\t\t/*\n\t\t * This buffer's got modified and becoming part\n\t\t * of the transaction. This needs to be done\n\t\t * once a transaction -bzzz\n\t\t */\n\t\tif (handle->h_buffer_credits <= 0) {\n\t\t\tret = -ENOSPC;\n\t\t\tgoto out_unlock_bh;\n\t\t}\n\t\tjh->b_modified = 1;\n\t\thandle->h_buffer_credits--;\n\t}\n\n\t/*\n\t * fastpath, to avoid expensive locking.  If this buffer is already\n\t * on the running transaction's metadata list there is nothing to do.\n\t * Nobody can take it off again because there is a handle open.\n\t * I _think_ we're OK here with SMP barriers - a mistaken decision will\n\t * result in this test being false, so we go in and take the locks.\n\t */\n\tif (jh->b_transaction == transaction && jh->b_jlist == BJ_Metadata) {\n\t\tJBUFFER_TRACE(jh, \"fastpath\");\n\t\tif (unlikely(jh->b_transaction !=\n\t\t\t     journal->j_running_transaction)) {\n\t\t\tprintk(KERN_ERR \"JBD2: %s: \"\n\t\t\t       \"jh->b_transaction (%llu, %p, %u) != \"\n\t\t\t       \"journal->j_running_transaction (%p, %u)\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ? jh->b_transaction->t_tid : 0,\n\t\t\t       journal->j_running_transaction,\n\t\t\t       journal->j_running_transaction ?\n\t\t\t       journal->j_running_transaction->t_tid : 0);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\tgoto out_unlock_bh;\n\t}\n\n\tset_buffer_jbddirty(bh);\n\n\t/*\n\t * Metadata already on the current transaction list doesn't\n\t * need to be filed.  Metadata on another transaction's list must\n\t * be committing, and will be refiled once the commit completes:\n\t * leave it alone for now.\n\t */\n\tif (jh->b_transaction != transaction) {\n\t\tJBUFFER_TRACE(jh, \"already on other transaction\");\n\t\tif (unlikely(((jh->b_transaction !=\n\t\t\t       journal->j_committing_transaction)) ||\n\t\t\t     (jh->b_next_transaction != transaction))) {\n\t\t\tprintk(KERN_ERR \"jbd2_journal_dirty_metadata: %s: \"\n\t\t\t       \"bad jh for block %llu: \"\n\t\t\t       \"transaction (%p, %u), \"\n\t\t\t       \"jh->b_transaction (%p, %u), \"\n\t\t\t       \"jh->b_next_transaction (%p, %u), jlist %u\\n\",\n\t\t\t       journal->j_devname,\n\t\t\t       (unsigned long long) bh->b_blocknr,\n\t\t\t       transaction, transaction->t_tid,\n\t\t\t       jh->b_transaction,\n\t\t\t       jh->b_transaction ?\n\t\t\t       jh->b_transaction->t_tid : 0,\n\t\t\t       jh->b_next_transaction,\n\t\t\t       jh->b_next_transaction ?\n\t\t\t       jh->b_next_transaction->t_tid : 0,\n\t\t\t       jh->b_jlist);\n\t\t\tWARN_ON(1);\n\t\t\tret = -EINVAL;\n\t\t}\n\t\t/* And this case is illegal: we can't reuse another\n\t\t * transaction's data buffer, ever. */\n\t\tgoto out_unlock_bh;\n\t}\n\n\t/* That test should have eliminated the following case: */\n\tJ_ASSERT_JH(jh, jh->b_frozen_data == NULL);\n\n\tJBUFFER_TRACE(jh, \"file as BJ_Metadata\");\n\tspin_lock(&journal->j_list_lock);\n\t__jbd2_journal_file_buffer(jh, transaction, BJ_Metadata);\n\tspin_unlock(&journal->j_list_lock);\nout_unlock_bh:\n\tjbd_unlock_bh_state(bh);\nout:\n\tJBUFFER_TRACE(jh, \"exit\");\n\treturn ret;\n}",
        "patch": "--- code before\n+++ code after\n@@ -34,6 +34,13 @@\n \t\tif (jh->b_transaction == transaction &&\n \t\t    jh->b_jlist != BJ_Metadata) {\n \t\t\tjbd_lock_bh_state(bh);\n+\t\t\tif (jh->b_transaction == transaction &&\n+\t\t\t    jh->b_jlist != BJ_Metadata)\n+\t\t\t\tpr_err(\"JBD2: assertion failure: h_type=%u \"\n+\t\t\t\t       \"h_line_no=%u block_no=%llu jlist=%u\\n\",\n+\t\t\t\t       handle->h_type, handle->h_line_no,\n+\t\t\t\t       (unsigned long long) bh->b_blocknr,\n+\t\t\t\t       jh->b_jlist);\n \t\t\tJ_ASSERT_JH(jh, jh->b_transaction != transaction ||\n \t\t\t\t\tjh->b_jlist == BJ_Metadata);\n \t\t\tjbd_unlock_bh_state(bh);\n@@ -53,11 +60,11 @@\n \t\t * of the transaction. This needs to be done\n \t\t * once a transaction -bzzz\n \t\t */\n-\t\tjh->b_modified = 1;\n \t\tif (handle->h_buffer_credits <= 0) {\n \t\t\tret = -ENOSPC;\n \t\t\tgoto out_unlock_bh;\n \t\t}\n+\t\tjh->b_modified = 1;\n \t\thandle->h_buffer_credits--;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\t\tif (jh->b_transaction == transaction &&",
                "\t\t\t    jh->b_jlist != BJ_Metadata)",
                "\t\t\t\tpr_err(\"JBD2: assertion failure: h_type=%u \"",
                "\t\t\t\t       \"h_line_no=%u block_no=%llu jlist=%u\\n\",",
                "\t\t\t\t       handle->h_type, handle->h_line_no,",
                "\t\t\t\t       (unsigned long long) bh->b_blocknr,",
                "\t\t\t\t       jh->b_jlist);",
                "\t\tjh->b_modified = 1;"
            ],
            "deleted": [
                "\t\tjh->b_modified = 1;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel's ext4 filesystem. A local user can cause an out-of-bounds write in jbd2_journal_dirty_metadata(), a denial of service, and a system crash by mounting and operating on a crafted ext4 filesystem image.",
        "id": 1618
    },
    {
        "cve_id": "CVE-2021-3612",
        "code_before_change": "static int joydev_handle_JSIOCSAXMAP(struct joydev *joydev,\n\t\t\t\t     void __user *argp, size_t len)\n{\n\t__u8 *abspam;\n\tint i;\n\tint retval = 0;\n\n\tlen = min(len, sizeof(joydev->abspam));\n\n\t/* Validate the map. */\n\tabspam = memdup_user(argp, len);\n\tif (IS_ERR(abspam))\n\t\treturn PTR_ERR(abspam);\n\n\tfor (i = 0; i < joydev->nabs; i++) {\n\t\tif (abspam[i] > ABS_MAX) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(joydev->abspam, abspam, len);\n\n\tfor (i = 0; i < joydev->nabs; i++)\n\t\tjoydev->absmap[joydev->abspam[i]] = i;\n\n out:\n\tkfree(abspam);\n\treturn retval;\n}",
        "code_after_change": "static int joydev_handle_JSIOCSAXMAP(struct joydev *joydev,\n\t\t\t\t     void __user *argp, size_t len)\n{\n\t__u8 *abspam;\n\tint i;\n\tint retval = 0;\n\n\tlen = min(len, sizeof(joydev->abspam));\n\n\t/* Validate the map. */\n\tabspam = memdup_user(argp, len);\n\tif (IS_ERR(abspam))\n\t\treturn PTR_ERR(abspam);\n\n\tfor (i = 0; i < len && i < joydev->nabs; i++) {\n\t\tif (abspam[i] > ABS_MAX) {\n\t\t\tretval = -EINVAL;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\tmemcpy(joydev->abspam, abspam, len);\n\n\tfor (i = 0; i < joydev->nabs; i++)\n\t\tjoydev->absmap[joydev->abspam[i]] = i;\n\n out:\n\tkfree(abspam);\n\treturn retval;\n}",
        "patch": "--- code before\n+++ code after\n@@ -12,7 +12,7 @@\n \tif (IS_ERR(abspam))\n \t\treturn PTR_ERR(abspam);\n \n-\tfor (i = 0; i < joydev->nabs; i++) {\n+\tfor (i = 0; i < len && i < joydev->nabs; i++) {\n \t\tif (abspam[i] > ABS_MAX) {\n \t\t\tretval = -EINVAL;\n \t\t\tgoto out;",
        "function_modified_lines": {
            "added": [
                "\tfor (i = 0; i < len && i < joydev->nabs; i++) {"
            ],
            "deleted": [
                "\tfor (i = 0; i < joydev->nabs; i++) {"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "An out-of-bounds memory write flaw was found in the Linux kernel's joystick devices subsystem in versions before 5.9-rc1, in the way the user calls ioctl JSIOCSBTNMAP. This flaw allows a local user to crash the system or possibly escalate their privileges on the system. The highest threat from this vulnerability is to confidentiality, integrity, as well as system availability.",
        "id": 3024
    },
    {
        "cve_id": "CVE-2021-4093",
        "code_before_change": "int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t unsigned int port, void *data,  unsigned int count,\n\t\t\t int in)\n{\n\tvcpu->arch.sev_pio_data = data;\n\treturn in ? kvm_sev_es_ins(vcpu, size, port, count)\n\t\t  : kvm_sev_es_outs(vcpu, size, port, count);\n}",
        "code_after_change": "int kvm_sev_es_string_io(struct kvm_vcpu *vcpu, unsigned int size,\n\t\t\t unsigned int port, void *data,  unsigned int count,\n\t\t\t int in)\n{\n\tvcpu->arch.sev_pio_data = data;\n\tvcpu->arch.sev_pio_count = count;\n\treturn in ? kvm_sev_es_ins(vcpu, size, port)\n\t\t  : kvm_sev_es_outs(vcpu, size, port);\n}",
        "patch": "--- code before\n+++ code after\n@@ -3,6 +3,7 @@\n \t\t\t int in)\n {\n \tvcpu->arch.sev_pio_data = data;\n-\treturn in ? kvm_sev_es_ins(vcpu, size, port, count)\n-\t\t  : kvm_sev_es_outs(vcpu, size, port, count);\n+\tvcpu->arch.sev_pio_count = count;\n+\treturn in ? kvm_sev_es_ins(vcpu, size, port)\n+\t\t  : kvm_sev_es_outs(vcpu, size, port);\n }",
        "function_modified_lines": {
            "added": [
                "\tvcpu->arch.sev_pio_count = count;",
                "\treturn in ? kvm_sev_es_ins(vcpu, size, port)",
                "\t\t  : kvm_sev_es_outs(vcpu, size, port);"
            ],
            "deleted": [
                "\treturn in ? kvm_sev_es_ins(vcpu, size, port, count)",
                "\t\t  : kvm_sev_es_outs(vcpu, size, port, count);"
            ]
        },
        "cwe": [
            "CWE-125",
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the KVM's AMD code for supporting the Secure Encrypted Virtualization-Encrypted State (SEV-ES). A KVM guest using SEV-ES can trigger out-of-bounds reads and writes in the host kernel via a malicious VMGEXIT for a string I/O instruction (for example, outs or ins) using the exit reason SVM_EXIT_IOIO. This issue results in a crash of the entire system or a potential guest-to-host escape scenario.",
        "id": 3131
    },
    {
        "cve_id": "CVE-2021-3501",
        "code_before_change": "static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunion vmx_exit_reason exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\tu16 exit_handler_index;\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.  Note, PML is never enabled in hardware while\n\t * running L2.\n\t */\n\tif (enable_pml && !is_guest_mode(vcpu))\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/*\n\t * We should never reach this point with a pending nested VM-Enter, and\n\t * more specifically emulation of L2 due to invalid guest state (see\n\t * below) should never happen as that means we incorrectly allowed a\n\t * nested VM-Enter with an invalid vmcs12.\n\t */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * PML is never enabled when running L2, bail immediately if a\n\t\t * PML full exit occurs as something is horribly wrong.\n\t\t */\n\t\tif (exit_reason.basic == EXIT_REASON_PML_FULL)\n\t\t\tgoto unexpected_vmexit;\n\n\t\t/*\n\t\t * The host physical addresses of some pages of guest memory\n\t\t * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC\n\t\t * Page). The CPU may write to these pages via their host\n\t\t * physical address while L2 is running, bypassing any\n\t\t * address-translation-based dirty tracking (e.g. EPT write\n\t\t * protection).\n\t\t *\n\t\t * Mark them dirty on every exit from L2 to prevent them from\n\t\t * getting out of sync with dirty tracking.\n\t\t */\n\t\tnested_mark_vmcs12_pages_dirty(vcpu);\n\n\t\tif (nested_vmx_reflect_vmexit(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (exit_reason.failed_vmentry) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason.full;\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t    (exit_reason.basic != EXIT_REASON_EXCEPTION_NMI &&\n\t     exit_reason.basic != EXIT_REASON_EPT_VIOLATION &&\n\t     exit_reason.basic != EXIT_REASON_PML_FULL &&\n\t     exit_reason.basic != EXIT_REASON_APIC_ACCESS &&\n\t     exit_reason.basic != EXIT_REASON_TASK_SWITCH)) {\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.ndata = 3;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason.full;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.ndata++;\n\t\t\tvcpu->run->internal.data[3] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\tvcpu->run->internal.data[vcpu->run->internal.ndata++] =\n\t\t\tvcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked)) {\n\t\tif (!vmx_interrupt_blocked(vcpu)) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_fastpath != EXIT_FASTPATH_NONE)\n\t\treturn 1;\n\n\tif (exit_reason.basic >= kvm_vmx_max_exit_handlers)\n\t\tgoto unexpected_vmexit;\n#ifdef CONFIG_RETPOLINE\n\tif (exit_reason.basic == EXIT_REASON_MSR_WRITE)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_PREEMPTION_TIMER)\n\t\treturn handle_preemption_timer(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_INTERRUPT_WINDOW)\n\t\treturn handle_interrupt_window(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\treturn handle_external_interrupt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG)\n\t\treturn handle_ept_misconfig(vcpu);\n#endif\n\n\texit_handler_index = array_index_nospec((u16)exit_reason.basic,\n\t\t\t\t\t\tkvm_vmx_max_exit_handlers);\n\tif (!kvm_vmx_exit_handlers[exit_handler_index])\n\t\tgoto unexpected_vmexit;\n\n\treturn kvm_vmx_exit_handlers[exit_handler_index](vcpu);\n\nunexpected_vmexit:\n\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\",\n\t\t    exit_reason.full);\n\tdump_vmcs();\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 2;\n\tvcpu->run->internal.data[0] = exit_reason.full;\n\tvcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;\n\treturn 0;\n}",
        "code_after_change": "static int __vmx_handle_exit(struct kvm_vcpu *vcpu, fastpath_t exit_fastpath)\n{\n\tstruct vcpu_vmx *vmx = to_vmx(vcpu);\n\tunion vmx_exit_reason exit_reason = vmx->exit_reason;\n\tu32 vectoring_info = vmx->idt_vectoring_info;\n\tu16 exit_handler_index;\n\n\t/*\n\t * Flush logged GPAs PML buffer, this will make dirty_bitmap more\n\t * updated. Another good is, in kvm_vm_ioctl_get_dirty_log, before\n\t * querying dirty_bitmap, we only need to kick all vcpus out of guest\n\t * mode as if vcpus is in root mode, the PML buffer must has been\n\t * flushed already.  Note, PML is never enabled in hardware while\n\t * running L2.\n\t */\n\tif (enable_pml && !is_guest_mode(vcpu))\n\t\tvmx_flush_pml_buffer(vcpu);\n\n\t/*\n\t * We should never reach this point with a pending nested VM-Enter, and\n\t * more specifically emulation of L2 due to invalid guest state (see\n\t * below) should never happen as that means we incorrectly allowed a\n\t * nested VM-Enter with an invalid vmcs12.\n\t */\n\tWARN_ON_ONCE(vmx->nested.nested_run_pending);\n\n\t/* If guest state is invalid, start emulating */\n\tif (vmx->emulation_required)\n\t\treturn handle_invalid_guest_state(vcpu);\n\n\tif (is_guest_mode(vcpu)) {\n\t\t/*\n\t\t * PML is never enabled when running L2, bail immediately if a\n\t\t * PML full exit occurs as something is horribly wrong.\n\t\t */\n\t\tif (exit_reason.basic == EXIT_REASON_PML_FULL)\n\t\t\tgoto unexpected_vmexit;\n\n\t\t/*\n\t\t * The host physical addresses of some pages of guest memory\n\t\t * are loaded into the vmcs02 (e.g. vmcs12's Virtual APIC\n\t\t * Page). The CPU may write to these pages via their host\n\t\t * physical address while L2 is running, bypassing any\n\t\t * address-translation-based dirty tracking (e.g. EPT write\n\t\t * protection).\n\t\t *\n\t\t * Mark them dirty on every exit from L2 to prevent them from\n\t\t * getting out of sync with dirty tracking.\n\t\t */\n\t\tnested_mark_vmcs12_pages_dirty(vcpu);\n\n\t\tif (nested_vmx_reflect_vmexit(vcpu))\n\t\t\treturn 1;\n\t}\n\n\tif (exit_reason.failed_vmentry) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= exit_reason.full;\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(vmx->fail)) {\n\t\tdump_vmcs();\n\t\tvcpu->run->exit_reason = KVM_EXIT_FAIL_ENTRY;\n\t\tvcpu->run->fail_entry.hardware_entry_failure_reason\n\t\t\t= vmcs_read32(VM_INSTRUCTION_ERROR);\n\t\tvcpu->run->fail_entry.cpu = vcpu->arch.last_vmentry_cpu;\n\t\treturn 0;\n\t}\n\n\t/*\n\t * Note:\n\t * Do not try to fix EXIT_REASON_EPT_MISCONFIG if it caused by\n\t * delivery event since it indicates guest is accessing MMIO.\n\t * The vm-exit can be triggered again after return to guest that\n\t * will cause infinite loop.\n\t */\n\tif ((vectoring_info & VECTORING_INFO_VALID_MASK) &&\n\t    (exit_reason.basic != EXIT_REASON_EXCEPTION_NMI &&\n\t     exit_reason.basic != EXIT_REASON_EPT_VIOLATION &&\n\t     exit_reason.basic != EXIT_REASON_PML_FULL &&\n\t     exit_reason.basic != EXIT_REASON_APIC_ACCESS &&\n\t     exit_reason.basic != EXIT_REASON_TASK_SWITCH)) {\n\t\tint ndata = 3;\n\n\t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n\t\tvcpu->run->internal.data[0] = vectoring_info;\n\t\tvcpu->run->internal.data[1] = exit_reason.full;\n\t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n\t\tif (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG) {\n\t\t\tvcpu->run->internal.data[ndata++] =\n\t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n\t\t}\n\t\tvcpu->run->internal.data[ndata++] = vcpu->arch.last_vmentry_cpu;\n\t\tvcpu->run->internal.ndata = ndata;\n\t\treturn 0;\n\t}\n\n\tif (unlikely(!enable_vnmi &&\n\t\t     vmx->loaded_vmcs->soft_vnmi_blocked)) {\n\t\tif (!vmx_interrupt_blocked(vcpu)) {\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t} else if (vmx->loaded_vmcs->vnmi_blocked_time > 1000000000LL &&\n\t\t\t   vcpu->arch.nmi_pending) {\n\t\t\t/*\n\t\t\t * This CPU don't support us in finding the end of an\n\t\t\t * NMI-blocked window if the guest runs with IRQs\n\t\t\t * disabled. So we pull the trigger after 1 s of\n\t\t\t * futile waiting, but inform the user about this.\n\t\t\t */\n\t\t\tprintk(KERN_WARNING \"%s: Breaking out of NMI-blocked \"\n\t\t\t       \"state on VCPU %d after 1 s timeout\\n\",\n\t\t\t       __func__, vcpu->vcpu_id);\n\t\t\tvmx->loaded_vmcs->soft_vnmi_blocked = 0;\n\t\t}\n\t}\n\n\tif (exit_fastpath != EXIT_FASTPATH_NONE)\n\t\treturn 1;\n\n\tif (exit_reason.basic >= kvm_vmx_max_exit_handlers)\n\t\tgoto unexpected_vmexit;\n#ifdef CONFIG_RETPOLINE\n\tif (exit_reason.basic == EXIT_REASON_MSR_WRITE)\n\t\treturn kvm_emulate_wrmsr(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_PREEMPTION_TIMER)\n\t\treturn handle_preemption_timer(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_INTERRUPT_WINDOW)\n\t\treturn handle_interrupt_window(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EXTERNAL_INTERRUPT)\n\t\treturn handle_external_interrupt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_HLT)\n\t\treturn kvm_emulate_halt(vcpu);\n\telse if (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG)\n\t\treturn handle_ept_misconfig(vcpu);\n#endif\n\n\texit_handler_index = array_index_nospec((u16)exit_reason.basic,\n\t\t\t\t\t\tkvm_vmx_max_exit_handlers);\n\tif (!kvm_vmx_exit_handlers[exit_handler_index])\n\t\tgoto unexpected_vmexit;\n\n\treturn kvm_vmx_exit_handlers[exit_handler_index](vcpu);\n\nunexpected_vmexit:\n\tvcpu_unimpl(vcpu, \"vmx: unexpected exit reason 0x%x\\n\",\n\t\t    exit_reason.full);\n\tdump_vmcs();\n\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n\tvcpu->run->internal.suberror =\n\t\t\tKVM_INTERNAL_ERROR_UNEXPECTED_EXIT_REASON;\n\tvcpu->run->internal.ndata = 2;\n\tvcpu->run->internal.data[0] = exit_reason.full;\n\tvcpu->run->internal.data[1] = vcpu->arch.last_vmentry_cpu;\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -84,19 +84,19 @@\n \t     exit_reason.basic != EXIT_REASON_PML_FULL &&\n \t     exit_reason.basic != EXIT_REASON_APIC_ACCESS &&\n \t     exit_reason.basic != EXIT_REASON_TASK_SWITCH)) {\n+\t\tint ndata = 3;\n+\n \t\tvcpu->run->exit_reason = KVM_EXIT_INTERNAL_ERROR;\n \t\tvcpu->run->internal.suberror = KVM_INTERNAL_ERROR_DELIVERY_EV;\n-\t\tvcpu->run->internal.ndata = 3;\n \t\tvcpu->run->internal.data[0] = vectoring_info;\n \t\tvcpu->run->internal.data[1] = exit_reason.full;\n \t\tvcpu->run->internal.data[2] = vcpu->arch.exit_qualification;\n \t\tif (exit_reason.basic == EXIT_REASON_EPT_MISCONFIG) {\n-\t\t\tvcpu->run->internal.ndata++;\n-\t\t\tvcpu->run->internal.data[3] =\n+\t\t\tvcpu->run->internal.data[ndata++] =\n \t\t\t\tvmcs_read64(GUEST_PHYSICAL_ADDRESS);\n \t\t}\n-\t\tvcpu->run->internal.data[vcpu->run->internal.ndata++] =\n-\t\t\tvcpu->arch.last_vmentry_cpu;\n+\t\tvcpu->run->internal.data[ndata++] = vcpu->arch.last_vmentry_cpu;\n+\t\tvcpu->run->internal.ndata = ndata;\n \t\treturn 0;\n \t}\n ",
        "function_modified_lines": {
            "added": [
                "\t\tint ndata = 3;",
                "",
                "\t\t\tvcpu->run->internal.data[ndata++] =",
                "\t\tvcpu->run->internal.data[ndata++] = vcpu->arch.last_vmentry_cpu;",
                "\t\tvcpu->run->internal.ndata = ndata;"
            ],
            "deleted": [
                "\t\tvcpu->run->internal.ndata = 3;",
                "\t\t\tvcpu->run->internal.ndata++;",
                "\t\t\tvcpu->run->internal.data[3] =",
                "\t\tvcpu->run->internal.data[vcpu->run->internal.ndata++] =",
                "\t\t\tvcpu->arch.last_vmentry_cpu;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "A flaw was found in the Linux kernel in versions before 5.12. The value of internal.ndata, in the KVM API, is mapped to an array index, which can be updated by a user process at anytime which could lead to an out-of-bounds write. The highest threat from this vulnerability is to data integrity and system availability.",
        "id": 3015
    },
    {
        "cve_id": "CVE-2019-19319",
        "code_before_change": "int ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (sbi->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (sbi->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(sbi);\n\treturn 0;\n}",
        "code_after_change": "int ext4_setup_system_zone(struct super_block *sb)\n{\n\text4_group_t ngroups = ext4_get_groups_count(sb);\n\tstruct ext4_sb_info *sbi = EXT4_SB(sb);\n\tstruct ext4_group_desc *gdp;\n\text4_group_t i;\n\tint flex_size = ext4_flex_bg_size(sbi);\n\tint ret;\n\n\tif (!test_opt(sb, BLOCK_VALIDITY)) {\n\t\tif (sbi->system_blks.rb_node)\n\t\t\text4_release_system_zone(sb);\n\t\treturn 0;\n\t}\n\tif (sbi->system_blks.rb_node)\n\t\treturn 0;\n\n\tfor (i=0; i < ngroups; i++) {\n\t\tif (ext4_bg_has_super(sb, i) &&\n\t\t    ((i < 5) || ((i % flex_size) == 0)))\n\t\t\tadd_system_zone(sbi, ext4_group_first_block_no(sb, i),\n\t\t\t\t\text4_bg_num_gdb(sb, i) + 1);\n\t\tgdp = ext4_get_group_desc(sb, i, NULL);\n\t\tret = add_system_zone(sbi, ext4_block_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_bitmap(sb, gdp), 1);\n\t\tif (ret)\n\t\t\treturn ret;\n\t\tret = add_system_zone(sbi, ext4_inode_table(sb, gdp),\n\t\t\t\tsbi->s_itb_per_group);\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\tif (ext4_has_feature_journal(sb) && sbi->s_es->s_journal_inum) {\n\t\tret = ext4_protect_reserved_inode(sb,\n\t\t\t\tle32_to_cpu(sbi->s_es->s_journal_inum));\n\t\tif (ret)\n\t\t\treturn ret;\n\t}\n\n\tif (test_opt(sb, DEBUG))\n\t\tdebug_print_tree(sbi);\n\treturn 0;\n}",
        "patch": "--- code before\n+++ code after\n@@ -32,6 +32,12 @@\n \t\tif (ret)\n \t\t\treturn ret;\n \t}\n+\tif (ext4_has_feature_journal(sb) && sbi->s_es->s_journal_inum) {\n+\t\tret = ext4_protect_reserved_inode(sb,\n+\t\t\t\tle32_to_cpu(sbi->s_es->s_journal_inum));\n+\t\tif (ret)\n+\t\t\treturn ret;\n+\t}\n \n \tif (test_opt(sb, DEBUG))\n \t\tdebug_print_tree(sbi);",
        "function_modified_lines": {
            "added": [
                "\tif (ext4_has_feature_journal(sb) && sbi->s_es->s_journal_inum) {",
                "\t\tret = ext4_protect_reserved_inode(sb,",
                "\t\t\t\tle32_to_cpu(sbi->s_es->s_journal_inum));",
                "\t\tif (ret)",
                "\t\t\treturn ret;",
                "\t}"
            ],
            "deleted": []
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "In the Linux kernel before 5.2, a setxattr operation, after a mount of a crafted ext4 image, can cause a slab-out-of-bounds write access because of an ext4_xattr_set_entry use-after-free in fs/ext4/xattr.c when a large old_size value is used in a memset call, aka CID-345c0dbf3a30.",
        "id": 2188
    },
    {
        "cve_id": "CVE-2021-37576",
        "code_before_change": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer. That means we can't get to the args, and so we\n\t * can't fail the RTAS call. So fail right out to userspace,\n\t * which should kill the guest.\n\t */\n\treturn rc;\n}",
        "code_after_change": "int kvmppc_rtas_hcall(struct kvm_vcpu *vcpu)\n{\n\tstruct rtas_token_definition *d;\n\tstruct rtas_args args;\n\trtas_arg_t *orig_rets;\n\tgpa_t args_phys;\n\tint rc;\n\n\t/*\n\t * r4 contains the guest physical address of the RTAS args\n\t * Mask off the top 4 bits since this is a guest real address\n\t */\n\targs_phys = kvmppc_get_gpr(vcpu, 4) & KVM_PAM;\n\n\tvcpu->srcu_idx = srcu_read_lock(&vcpu->kvm->srcu);\n\trc = kvm_read_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\tsrcu_read_unlock(&vcpu->kvm->srcu, vcpu->srcu_idx);\n\tif (rc)\n\t\tgoto fail;\n\n\t/*\n\t * args->rets is a pointer into args->args. Now that we've\n\t * copied args we need to fix it up to point into our copy,\n\t * not the guest args. We also need to save the original\n\t * value so we can restore it on the way out.\n\t */\n\torig_rets = args.rets;\n\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n\t\t/*\n\t\t * Don't overflow our args array: ensure there is room for\n\t\t * at least rets[0] (even if the call specifies 0 nret).\n\t\t *\n\t\t * Each handler must then check for the correct nargs and nret\n\t\t * values, but they may always return failure in rets[0].\n\t\t */\n\t\trc = -EINVAL;\n\t\tgoto fail;\n\t}\n\targs.rets = &args.args[be32_to_cpu(args.nargs)];\n\n\tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n\n\trc = -ENOENT;\n\tlist_for_each_entry(d, &vcpu->kvm->arch.rtas_tokens, list) {\n\t\tif (d->token == be32_to_cpu(args.token)) {\n\t\t\td->handler->handler(vcpu, &args);\n\t\t\trc = 0;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tmutex_unlock(&vcpu->kvm->arch.rtas_token_lock);\n\n\tif (rc == 0) {\n\t\targs.rets = orig_rets;\n\t\trc = kvm_write_guest(vcpu->kvm, args_phys, &args, sizeof(args));\n\t\tif (rc)\n\t\t\tgoto fail;\n\t}\n\n\treturn rc;\n\nfail:\n\t/*\n\t * We only get here if the guest has called RTAS with a bogus\n\t * args pointer or nargs/nret values that would overflow the\n\t * array. That means we can't get to the args, and so we can't\n\t * fail the RTAS call. So fail right out to userspace, which\n\t * should kill the guest.\n\t *\n\t * SLOF should actually pass the hcall return value from the\n\t * rtas handler call in r3, so enter_rtas could be modified to\n\t * return a failure indication in r3 and we could return such\n\t * errors to the guest rather than failing to host userspace.\n\t * However old guests that don't test for failure could then\n\t * continue silently after errors, so for now we won't do this.\n\t */\n\treturn rc;\n}",
        "patch": "--- code before\n+++ code after\n@@ -25,6 +25,17 @@\n \t * value so we can restore it on the way out.\n \t */\n \torig_rets = args.rets;\n+\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {\n+\t\t/*\n+\t\t * Don't overflow our args array: ensure there is room for\n+\t\t * at least rets[0] (even if the call specifies 0 nret).\n+\t\t *\n+\t\t * Each handler must then check for the correct nargs and nret\n+\t\t * values, but they may always return failure in rets[0].\n+\t\t */\n+\t\trc = -EINVAL;\n+\t\tgoto fail;\n+\t}\n \targs.rets = &args.args[be32_to_cpu(args.nargs)];\n \n \tmutex_lock(&vcpu->kvm->arch.rtas_token_lock);\n@@ -52,9 +63,17 @@\n fail:\n \t/*\n \t * We only get here if the guest has called RTAS with a bogus\n-\t * args pointer. That means we can't get to the args, and so we\n-\t * can't fail the RTAS call. So fail right out to userspace,\n-\t * which should kill the guest.\n+\t * args pointer or nargs/nret values that would overflow the\n+\t * array. That means we can't get to the args, and so we can't\n+\t * fail the RTAS call. So fail right out to userspace, which\n+\t * should kill the guest.\n+\t *\n+\t * SLOF should actually pass the hcall return value from the\n+\t * rtas handler call in r3, so enter_rtas could be modified to\n+\t * return a failure indication in r3 and we could return such\n+\t * errors to the guest rather than failing to host userspace.\n+\t * However old guests that don't test for failure could then\n+\t * continue silently after errors, so for now we won't do this.\n \t */\n \treturn rc;\n }",
        "function_modified_lines": {
            "added": [
                "\tif (be32_to_cpu(args.nargs) >= ARRAY_SIZE(args.args)) {",
                "\t\t/*",
                "\t\t * Don't overflow our args array: ensure there is room for",
                "\t\t * at least rets[0] (even if the call specifies 0 nret).",
                "\t\t *",
                "\t\t * Each handler must then check for the correct nargs and nret",
                "\t\t * values, but they may always return failure in rets[0].",
                "\t\t */",
                "\t\trc = -EINVAL;",
                "\t\tgoto fail;",
                "\t}",
                "\t * args pointer or nargs/nret values that would overflow the",
                "\t * array. That means we can't get to the args, and so we can't",
                "\t * fail the RTAS call. So fail right out to userspace, which",
                "\t * should kill the guest.",
                "\t *",
                "\t * SLOF should actually pass the hcall return value from the",
                "\t * rtas handler call in r3, so enter_rtas could be modified to",
                "\t * return a failure indication in r3 and we could return such",
                "\t * errors to the guest rather than failing to host userspace.",
                "\t * However old guests that don't test for failure could then",
                "\t * continue silently after errors, so for now we won't do this."
            ],
            "deleted": [
                "\t * args pointer. That means we can't get to the args, and so we",
                "\t * can't fail the RTAS call. So fail right out to userspace,",
                "\t * which should kill the guest."
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "arch/powerpc/kvm/book3s_rtas.c in the Linux kernel through 5.13.5 on the powerpc platform allows KVM guest OS users to cause host OS memory corruption via rtas_args.nargs, aka CID-f62f3c20647e.",
        "id": 3058
    },
    {
        "cve_id": "CVE-2023-21255",
        "code_before_change": "static void\nbinder_free_buf(struct binder_proc *proc,\n\t\tstruct binder_thread *thread,\n\t\tstruct binder_buffer *buffer, bool is_failure)\n{\n\tbinder_inner_proc_lock(proc);\n\tif (buffer->transaction) {\n\t\tbuffer->transaction->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t}\n\tbinder_inner_proc_unlock(proc);\n\tif (buffer->async_transaction && buffer->target_node) {\n\t\tstruct binder_node *buf_node;\n\t\tstruct binder_work *w;\n\n\t\tbuf_node = buffer->target_node;\n\t\tbinder_node_inner_lock(buf_node);\n\t\tBUG_ON(!buf_node->has_async_transaction);\n\t\tBUG_ON(buf_node->proc != proc);\n\t\tw = binder_dequeue_work_head_ilocked(\n\t\t\t\t&buf_node->async_todo);\n\t\tif (!w) {\n\t\t\tbuf_node->has_async_transaction = false;\n\t\t} else {\n\t\t\tbinder_enqueue_work_ilocked(\n\t\t\t\t\tw, &proc->todo);\n\t\t\tbinder_wakeup_proc_ilocked(proc);\n\t\t}\n\t\tbinder_node_inner_unlock(buf_node);\n\t}\n\ttrace_binder_transaction_buffer_release(buffer);\n\tbinder_transaction_buffer_release(proc, thread, buffer, 0, is_failure);\n\tbinder_alloc_free_buf(&proc->alloc, buffer);\n}",
        "code_after_change": "static void\nbinder_free_buf(struct binder_proc *proc,\n\t\tstruct binder_thread *thread,\n\t\tstruct binder_buffer *buffer, bool is_failure)\n{\n\tbinder_inner_proc_lock(proc);\n\tif (buffer->transaction) {\n\t\tbuffer->transaction->buffer = NULL;\n\t\tbuffer->transaction = NULL;\n\t}\n\tbinder_inner_proc_unlock(proc);\n\tif (buffer->async_transaction && buffer->target_node) {\n\t\tstruct binder_node *buf_node;\n\t\tstruct binder_work *w;\n\n\t\tbuf_node = buffer->target_node;\n\t\tbinder_node_inner_lock(buf_node);\n\t\tBUG_ON(!buf_node->has_async_transaction);\n\t\tBUG_ON(buf_node->proc != proc);\n\t\tw = binder_dequeue_work_head_ilocked(\n\t\t\t\t&buf_node->async_todo);\n\t\tif (!w) {\n\t\t\tbuf_node->has_async_transaction = false;\n\t\t} else {\n\t\t\tbinder_enqueue_work_ilocked(\n\t\t\t\t\tw, &proc->todo);\n\t\t\tbinder_wakeup_proc_ilocked(proc);\n\t\t}\n\t\tbinder_node_inner_unlock(buf_node);\n\t}\n\ttrace_binder_transaction_buffer_release(buffer);\n\tbinder_release_entire_buffer(proc, thread, buffer, is_failure);\n\tbinder_alloc_free_buf(&proc->alloc, buffer);\n}",
        "patch": "--- code before\n+++ code after\n@@ -29,6 +29,6 @@\n \t\tbinder_node_inner_unlock(buf_node);\n \t}\n \ttrace_binder_transaction_buffer_release(buffer);\n-\tbinder_transaction_buffer_release(proc, thread, buffer, 0, is_failure);\n+\tbinder_release_entire_buffer(proc, thread, buffer, is_failure);\n \tbinder_alloc_free_buf(&proc->alloc, buffer);\n }",
        "function_modified_lines": {
            "added": [
                "\tbinder_release_entire_buffer(proc, thread, buffer, is_failure);"
            ],
            "deleted": [
                "\tbinder_transaction_buffer_release(proc, thread, buffer, 0, is_failure);"
            ]
        },
        "cwe": [
            "CWE-787",
            "CWE-416"
        ],
        "cve_description": "In multiple functions of binder.c, there is a possible memory corruption due to a use after free. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is not needed for exploitation.\n\n",
        "id": 3916
    },
    {
        "cve_id": "CVE-2022-2380",
        "code_before_change": "static ssize_t smtcfb_read(struct fb_info *info, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\n\tu32 *buffer, *dst;\n\tu32 __iomem *src;\n\tint c, i, cnt = 0, err = 0;\n\tunsigned long total_size;\n\n\tif (!info || !info->screen_base)\n\t\treturn -ENODEV;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\ttotal_size = info->screen_size;\n\n\tif (total_size == 0)\n\t\ttotal_size = info->fix.smem_len;\n\n\tif (p >= total_size)\n\t\treturn 0;\n\n\tif (count >= total_size)\n\t\tcount = total_size;\n\n\tif (count + p > total_size)\n\t\tcount = total_size - p;\n\n\tbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tsrc = (u32 __iomem *)(info->screen_base + p);\n\n\tif (info->fbops->fb_sync)\n\t\tinfo->fbops->fb_sync(info);\n\n\twhile (count) {\n\t\tc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tdst = buffer;\n\t\tfor (i = c >> 2; i--;) {\n\t\t\t*dst = fb_readl(src++);\n\t\t\t*dst = big_swap(*dst);\n\t\t\tdst++;\n\t\t}\n\t\tif (c & 3) {\n\t\t\tu8 *dst8 = (u8 *)dst;\n\t\t\tu8 __iomem *src8 = (u8 __iomem *)src;\n\n\t\t\tfor (i = c & 3; i--;) {\n\t\t\t\tif (i & 1) {\n\t\t\t\t\t*dst8++ = fb_readb(++src8);\n\t\t\t\t} else {\n\t\t\t\t\t*dst8++ = fb_readb(--src8);\n\t\t\t\t\tsrc8 += 2;\n\t\t\t\t}\n\t\t\t}\n\t\t\tsrc = (u32 __iomem *)src8;\n\t\t}\n\n\t\tif (copy_to_user(buf, buffer, c)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t*ppos += c;\n\t\tbuf += c;\n\t\tcnt += c;\n\t\tcount -= c;\n\t}\n\n\tkfree(buffer);\n\n\treturn (err) ? err : cnt;\n}",
        "code_after_change": "static ssize_t smtcfb_read(struct fb_info *info, char __user *buf,\n\t\t\t   size_t count, loff_t *ppos)\n{\n\tunsigned long p = *ppos;\n\n\tu32 *buffer, *dst;\n\tu32 __iomem *src;\n\tint c, i, cnt = 0, err = 0;\n\tunsigned long total_size;\n\n\tif (!info || !info->screen_base)\n\t\treturn -ENODEV;\n\n\tif (info->state != FBINFO_STATE_RUNNING)\n\t\treturn -EPERM;\n\n\ttotal_size = info->screen_size;\n\n\tif (total_size == 0)\n\t\ttotal_size = info->fix.smem_len;\n\n\tif (p >= total_size)\n\t\treturn 0;\n\n\tif (count >= total_size)\n\t\tcount = total_size;\n\n\tif (count + p > total_size)\n\t\tcount = total_size - p;\n\n\tbuffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\n\tif (!buffer)\n\t\treturn -ENOMEM;\n\n\tsrc = (u32 __iomem *)(info->screen_base + p);\n\n\tif (info->fbops->fb_sync)\n\t\tinfo->fbops->fb_sync(info);\n\n\twhile (count) {\n\t\tc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n\t\tdst = buffer;\n\t\tfor (i = (c + 3) >> 2; i--;) {\n\t\t\tu32 val;\n\n\t\t\tval = fb_readl(src);\n\t\t\t*dst = big_swap(val);\n\t\t\tsrc++;\n\t\t\tdst++;\n\t\t}\n\n\t\tif (copy_to_user(buf, buffer, c)) {\n\t\t\terr = -EFAULT;\n\t\t\tbreak;\n\t\t}\n\t\t*ppos += c;\n\t\tbuf += c;\n\t\tcnt += c;\n\t\tcount -= c;\n\t}\n\n\tkfree(buffer);\n\n\treturn (err) ? err : cnt;\n}",
        "patch": "--- code before\n+++ code after\n@@ -28,7 +28,7 @@\n \tif (count + p > total_size)\n \t\tcount = total_size - p;\n \n-\tbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);\n+\tbuffer = kmalloc(PAGE_SIZE, GFP_KERNEL);\n \tif (!buffer)\n \t\treturn -ENOMEM;\n \n@@ -40,24 +40,13 @@\n \twhile (count) {\n \t\tc = (count > PAGE_SIZE) ? PAGE_SIZE : count;\n \t\tdst = buffer;\n-\t\tfor (i = c >> 2; i--;) {\n-\t\t\t*dst = fb_readl(src++);\n-\t\t\t*dst = big_swap(*dst);\n+\t\tfor (i = (c + 3) >> 2; i--;) {\n+\t\t\tu32 val;\n+\n+\t\t\tval = fb_readl(src);\n+\t\t\t*dst = big_swap(val);\n+\t\t\tsrc++;\n \t\t\tdst++;\n-\t\t}\n-\t\tif (c & 3) {\n-\t\t\tu8 *dst8 = (u8 *)dst;\n-\t\t\tu8 __iomem *src8 = (u8 __iomem *)src;\n-\n-\t\t\tfor (i = c & 3; i--;) {\n-\t\t\t\tif (i & 1) {\n-\t\t\t\t\t*dst8++ = fb_readb(++src8);\n-\t\t\t\t} else {\n-\t\t\t\t\t*dst8++ = fb_readb(--src8);\n-\t\t\t\t\tsrc8 += 2;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tsrc = (u32 __iomem *)src8;\n \t\t}\n \n \t\tif (copy_to_user(buf, buffer, c)) {",
        "function_modified_lines": {
            "added": [
                "\tbuffer = kmalloc(PAGE_SIZE, GFP_KERNEL);",
                "\t\tfor (i = (c + 3) >> 2; i--;) {",
                "\t\t\tu32 val;",
                "",
                "\t\t\tval = fb_readl(src);",
                "\t\t\t*dst = big_swap(val);",
                "\t\t\tsrc++;"
            ],
            "deleted": [
                "\tbuffer = kmalloc((count > PAGE_SIZE) ? PAGE_SIZE : count, GFP_KERNEL);",
                "\t\tfor (i = c >> 2; i--;) {",
                "\t\t\t*dst = fb_readl(src++);",
                "\t\t\t*dst = big_swap(*dst);",
                "\t\t}",
                "\t\tif (c & 3) {",
                "\t\t\tu8 *dst8 = (u8 *)dst;",
                "\t\t\tu8 __iomem *src8 = (u8 __iomem *)src;",
                "",
                "\t\t\tfor (i = c & 3; i--;) {",
                "\t\t\t\tif (i & 1) {",
                "\t\t\t\t\t*dst8++ = fb_readb(++src8);",
                "\t\t\t\t} else {",
                "\t\t\t\t\t*dst8++ = fb_readb(--src8);",
                "\t\t\t\t\tsrc8 += 2;",
                "\t\t\t\t}",
                "\t\t\t}",
                "\t\t\tsrc = (u32 __iomem *)src8;"
            ]
        },
        "cwe": [
            "CWE-787"
        ],
        "cve_description": "The Linux kernel was found vulnerable out of bounds memory access in the drivers/video/fbdev/sm712fb.c:smtcfb_read() function. The vulnerability could result in local attackers being able to crash the kernel.",
        "id": 3462
    },
    {
        "cve_id": "CVE-2019-2181",
        "code_before_change": "static void binder_transaction(struct binder_proc *proc,\n\t\t\t       struct binder_thread *thread,\n\t\t\t       struct binder_transaction_data *tr, int reply,\n\t\t\t       binder_size_t extra_buffers_size)\n{\n\tint ret;\n\tstruct binder_transaction *t;\n\tstruct binder_work *w;\n\tstruct binder_work *tcomplete;\n\tbinder_size_t buffer_offset = 0;\n\tbinder_size_t off_start_offset, off_end_offset;\n\tbinder_size_t off_min;\n\tbinder_size_t sg_buf_offset, sg_buf_end_offset;\n\tstruct binder_proc *target_proc = NULL;\n\tstruct binder_thread *target_thread = NULL;\n\tstruct binder_node *target_node = NULL;\n\tstruct binder_transaction *in_reply_to = NULL;\n\tstruct binder_transaction_log_entry *e;\n\tuint32_t return_error = 0;\n\tuint32_t return_error_param = 0;\n\tuint32_t return_error_line = 0;\n\tbinder_size_t last_fixup_obj_off = 0;\n\tbinder_size_t last_fixup_min_off = 0;\n\tstruct binder_context *context = proc->context;\n\tint t_debug_id = atomic_inc_return(&binder_last_id);\n\tchar *secctx = NULL;\n\tu32 secctx_sz = 0;\n\n\te = binder_transaction_log_add(&binder_transaction_log);\n\te->debug_id = t_debug_id;\n\te->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);\n\te->from_proc = proc->pid;\n\te->from_thread = thread->pid;\n\te->target_handle = tr->target.handle;\n\te->data_size = tr->data_size;\n\te->offsets_size = tr->offsets_size;\n\te->context_name = proc->context->name;\n\n\tif (reply) {\n\t\tbinder_inner_proc_lock(proc);\n\t\tin_reply_to = thread->transaction_stack;\n\t\tif (in_reply_to == NULL) {\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with no transaction stack\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_empty_call_stack;\n\t\t}\n\t\tif (in_reply_to->to_thread != thread) {\n\t\t\tspin_lock(&in_reply_to->lock);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\tproc->pid, thread->pid, in_reply_to->debug_id,\n\t\t\t\tin_reply_to->to_proc ?\n\t\t\t\tin_reply_to->to_proc->pid : 0,\n\t\t\t\tin_reply_to->to_thread ?\n\t\t\t\tin_reply_to->to_thread->pid : 0);\n\t\t\tspin_unlock(&in_reply_to->lock);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\tgoto err_bad_call_stack;\n\t\t}\n\t\tthread->transaction_stack = in_reply_to->to_parent;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_set_nice(in_reply_to->saved_priority);\n\t\ttarget_thread = binder_get_txn_from_and_acq_inner(in_reply_to);\n\t\tif (target_thread == NULL) {\n\t\t\t/* annotation for sparse */\n\t\t\t__release(&target_thread->proc->inner_lock);\n\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\tif (target_thread->transaction_stack != in_reply_to) {\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad target transaction stack %d, expected %d\\n\",\n\t\t\t\tproc->pid, thread->pid,\n\t\t\t\ttarget_thread->transaction_stack ?\n\t\t\t\ttarget_thread->transaction_stack->debug_id : 0,\n\t\t\t\tin_reply_to->debug_id);\n\t\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\ttarget_thread = NULL;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\ttarget_proc = target_thread->proc;\n\t\ttarget_proc->tmp_ref++;\n\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t} else {\n\t\tif (tr->target.handle) {\n\t\t\tstruct binder_ref *ref;\n\n\t\t\t/*\n\t\t\t * There must already be a strong ref\n\t\t\t * on this node. If so, do a strong\n\t\t\t * increment on the node to ensure it\n\t\t\t * stays alive until the transaction is\n\t\t\t * done.\n\t\t\t */\n\t\t\tbinder_proc_lock(proc);\n\t\t\tref = binder_get_ref_olocked(proc, tr->target.handle,\n\t\t\t\t\t\t     true);\n\t\t\tif (ref) {\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\tref->node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\t} else {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to invalid handle\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t}\n\t\t\tbinder_proc_unlock(proc);\n\t\t} else {\n\t\t\tmutex_lock(&context->context_mgr_node_lock);\n\t\t\ttarget_node = context->binder_context_mgr_node;\n\t\t\tif (target_node)\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\ttarget_node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\telse\n\t\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\tmutex_unlock(&context->context_mgr_node_lock);\n\t\t\tif (target_node && target_proc == proc) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to context manager from process owning it\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_invalid_target_handle;\n\t\t\t}\n\t\t}\n\t\tif (!target_node) {\n\t\t\t/*\n\t\t\t * return_error is set above\n\t\t\t */\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\te->to_node = target_node->debug_id;\n\t\tif (security_binder_transaction(proc->tsk,\n\t\t\t\t\t\ttarget_proc->tsk) < 0) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPERM;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tbinder_inner_proc_lock(proc);\n\n\t\tw = list_first_entry_or_null(&thread->todo,\n\t\t\t\t\t     struct binder_work, entry);\n\t\tif (!(tr->flags & TF_ONE_WAY) && w &&\n\t\t    w->type == BINDER_WORK_TRANSACTION) {\n\t\t\t/*\n\t\t\t * Do not allow new outgoing transaction from a\n\t\t\t * thread that has a transaction at the head of\n\t\t\t * its todo list. Only need to check the head\n\t\t\t * because binder_select_thread_ilocked picks a\n\t\t\t * thread from proc->waiting_threads to enqueue\n\t\t\t * the transaction, and nothing is queued to the\n\t\t\t * todo list while the thread is on waiting_threads.\n\t\t\t */\n\t\t\tbinder_user_error(\"%d:%d new transaction not allowed when there is a transaction on thread todo\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_todo_list;\n\t\t}\n\n\t\tif (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {\n\t\t\tstruct binder_transaction *tmp;\n\n\t\t\ttmp = thread->transaction_stack;\n\t\t\tif (tmp->to_thread != thread) {\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tbinder_user_error(\"%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\t\tproc->pid, thread->pid, tmp->debug_id,\n\t\t\t\t\ttmp->to_proc ? tmp->to_proc->pid : 0,\n\t\t\t\t\ttmp->to_thread ?\n\t\t\t\t\ttmp->to_thread->pid : 0);\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EPROTO;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_call_stack;\n\t\t\t}\n\t\t\twhile (tmp) {\n\t\t\t\tstruct binder_thread *from;\n\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tfrom = tmp->from;\n\t\t\t\tif (from && from->proc == target_proc) {\n\t\t\t\t\tatomic_inc(&from->tmp_ref);\n\t\t\t\t\ttarget_thread = from;\n\t\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\ttmp = tmp->from_parent;\n\t\t\t}\n\t\t}\n\t\tbinder_inner_proc_unlock(proc);\n\t}\n\tif (target_thread)\n\t\te->to_thread = target_thread->pid;\n\te->to_proc = target_proc->pid;\n\n\t/* TODO: reuse incoming transaction for reply */\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (t == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_t_failed;\n\t}\n\tINIT_LIST_HEAD(&t->fd_fixups);\n\tbinder_stats_created(BINDER_STAT_TRANSACTION);\n\tspin_lock_init(&t->lock);\n\n\ttcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);\n\tif (tcomplete == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_tcomplete_failed;\n\t}\n\tbinder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);\n\n\tt->debug_id = t_debug_id;\n\n\tif (reply)\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_REPLY %d -> %d:%d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_thread->pid,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\telse\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_TRANSACTION %d -> %d - node %d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_node->debug_id,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\n\tif (!reply && !(tr->flags & TF_ONE_WAY))\n\t\tt->from = thread;\n\telse\n\t\tt->from = NULL;\n\tt->sender_euid = task_euid(proc->tsk);\n\tt->to_proc = target_proc;\n\tt->to_thread = target_thread;\n\tt->code = tr->code;\n\tt->flags = tr->flags;\n\tt->priority = task_nice(current);\n\n\tif (target_node && target_node->txn_security_ctx) {\n\t\tu32 secid;\n\n\t\tsecurity_task_getsecid(proc->tsk, &secid);\n\t\tret = security_secid_to_secctx(secid, &secctx, &secctx_sz);\n\t\tif (ret) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = ret;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_get_secctx_failed;\n\t\t}\n\t\textra_buffers_size += ALIGN(secctx_sz, sizeof(u64));\n\t}\n\n\ttrace_binder_transaction(reply, t, target_node);\n\n\tt->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,\n\t\ttr->offsets_size, extra_buffers_size,\n\t\t!reply && (t->flags & TF_ONE_WAY));\n\tif (IS_ERR(t->buffer)) {\n\t\t/*\n\t\t * -ESRCH indicates VMA cleared. The target is dying.\n\t\t */\n\t\treturn_error_param = PTR_ERR(t->buffer);\n\t\treturn_error = return_error_param == -ESRCH ?\n\t\t\tBR_DEAD_REPLY : BR_FAILED_REPLY;\n\t\treturn_error_line = __LINE__;\n\t\tt->buffer = NULL;\n\t\tgoto err_binder_alloc_buf_failed;\n\t}\n\tif (secctx) {\n\t\tsize_t buf_offset = ALIGN(tr->data_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(tr->offsets_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(extra_buffers_size, sizeof(void *)) -\n\t\t\t\t    ALIGN(secctx_sz, sizeof(u64));\n\n\t\tt->security_ctx = (uintptr_t)t->buffer->user_data + buf_offset;\n\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t    t->buffer, buf_offset,\n\t\t\t\t\t    secctx, secctx_sz);\n\t\tsecurity_release_secctx(secctx, secctx_sz);\n\t\tsecctx = NULL;\n\t}\n\tt->buffer->debug_id = t->debug_id;\n\tt->buffer->transaction = t;\n\tt->buffer->target_node = target_node;\n\ttrace_binder_transaction_alloc_buf(t->buffer);\n\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer, 0,\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.buffer,\n\t\t\t\ttr->data_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid data ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer,\n\t\t\t\tALIGN(tr->data_size, sizeof(void *)),\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.offsets,\n\t\t\t\ttr->offsets_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (!IS_ALIGNED(tr->offsets_size, sizeof(binder_size_t))) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets size, %lld\\n\",\n\t\t\t\tproc->pid, thread->pid, (u64)tr->offsets_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\tif (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) {\n\t\tbinder_user_error(\"%d:%d got transaction with unaligned buffers size, %lld\\n\",\n\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t  (u64)extra_buffers_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\toff_start_offset = ALIGN(tr->data_size, sizeof(void *));\n\tbuffer_offset = off_start_offset;\n\toff_end_offset = off_start_offset + tr->offsets_size;\n\tsg_buf_offset = ALIGN(off_end_offset, sizeof(void *));\n\tsg_buf_end_offset = sg_buf_offset + extra_buffers_size;\n\toff_min = 0;\n\tfor (buffer_offset = off_start_offset; buffer_offset < off_end_offset;\n\t     buffer_offset += sizeof(binder_size_t)) {\n\t\tstruct binder_object_header *hdr;\n\t\tsize_t object_size;\n\t\tstruct binder_object object;\n\t\tbinder_size_t object_offset;\n\n\t\tbinder_alloc_copy_from_buffer(&target_proc->alloc,\n\t\t\t\t\t      &object_offset,\n\t\t\t\t\t      t->buffer,\n\t\t\t\t\t      buffer_offset,\n\t\t\t\t\t      sizeof(object_offset));\n\t\tobject_size = binder_get_object(target_proc, t->buffer,\n\t\t\t\t\t\tobject_offset, &object);\n\t\tif (object_size == 0 || object_offset < off_min) {\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\\n\",\n\t\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t\t  (u64)object_offset,\n\t\t\t\t\t  (u64)off_min,\n\t\t\t\t\t  (u64)t->buffer->data_size);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\n\t\thdr = &object.hdr;\n\t\toff_min = object_offset + object_size;\n\t\tswitch (hdr->type) {\n\t\tcase BINDER_TYPE_BINDER:\n\t\tcase BINDER_TYPE_WEAK_BINDER: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_binder(fp, t, thread);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    fp, sizeof(*fp));\n\t\t} break;\n\t\tcase BINDER_TYPE_HANDLE:\n\t\tcase BINDER_TYPE_WEAK_HANDLE: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_handle(fp, t, thread);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    fp, sizeof(*fp));\n\t\t} break;\n\n\t\tcase BINDER_TYPE_FD: {\n\t\t\tstruct binder_fd_object *fp = to_binder_fd_object(hdr);\n\t\t\tbinder_size_t fd_offset = object_offset +\n\t\t\t\t(uintptr_t)&fp->fd - (uintptr_t)fp;\n\t\t\tint ret = binder_translate_fd(fp->fd, fd_offset, t,\n\t\t\t\t\t\t      thread, in_reply_to);\n\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tfp->pad_binder = 0;\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    fp, sizeof(*fp));\n\t\t} break;\n\t\tcase BINDER_TYPE_FDA: {\n\t\t\tstruct binder_object ptr_object;\n\t\t\tbinder_size_t parent_offset;\n\t\t\tstruct binder_fd_array_object *fda =\n\t\t\t\tto_binder_fd_array_object(hdr);\n\t\t\tsize_t num_valid = (buffer_offset - off_start_offset) *\n\t\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tstruct binder_buffer_object *parent =\n\t\t\t\tbinder_validate_ptr(target_proc, t->buffer,\n\t\t\t\t\t\t    &ptr_object, fda->parent,\n\t\t\t\t\t\t    off_start_offset,\n\t\t\t\t\t\t    &parent_offset,\n\t\t\t\t\t\t    num_valid);\n\t\t\tif (!parent) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid parent offset or type\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tif (!binder_validate_fixup(target_proc, t->buffer,\n\t\t\t\t\t\t   off_start_offset,\n\t\t\t\t\t\t   parent_offset,\n\t\t\t\t\t\t   fda->parent_offset,\n\t\t\t\t\t\t   last_fixup_obj_off,\n\t\t\t\t\t\t   last_fixup_min_off)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with out-of-order buffer fixup\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tret = binder_translate_fd_array(fda, parent, t, thread,\n\t\t\t\t\t\t\tin_reply_to);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = parent_offset;\n\t\t\tlast_fixup_min_off =\n\t\t\t\tfda->parent_offset + sizeof(u32) * fda->num_fds;\n\t\t} break;\n\t\tcase BINDER_TYPE_PTR: {\n\t\t\tstruct binder_buffer_object *bp =\n\t\t\t\tto_binder_buffer_object(hdr);\n\t\t\tsize_t buf_left = sg_buf_end_offset - sg_buf_offset;\n\t\t\tsize_t num_valid;\n\n\t\t\tif (bp->length > buf_left) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with too large buffer\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_offset;\n\t\t\t}\n\t\t\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t\t\t&target_proc->alloc,\n\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\tsg_buf_offset,\n\t\t\t\t\t\t(const void __user *)\n\t\t\t\t\t\t\t(uintptr_t)bp->buffer,\n\t\t\t\t\t\tbp->length)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error_param = -EFAULT;\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_copy_data_failed;\n\t\t\t}\n\t\t\t/* Fixup buffer pointer to target proc address space */\n\t\t\tbp->buffer = (uintptr_t)\n\t\t\t\tt->buffer->user_data + sg_buf_offset;\n\t\t\tsg_buf_offset += ALIGN(bp->length, sizeof(u64));\n\n\t\t\tnum_valid = (buffer_offset - off_start_offset) *\n\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tret = binder_fixup_parent(t, thread, bp,\n\t\t\t\t\t\t  off_start_offset,\n\t\t\t\t\t\t  num_valid,\n\t\t\t\t\t\t  last_fixup_obj_off,\n\t\t\t\t\t\t  last_fixup_min_off);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    bp, sizeof(*bp));\n\t\t\tlast_fixup_obj_off = object_offset;\n\t\t\tlast_fixup_min_off = 0;\n\t\t} break;\n\t\tdefault:\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid object type, %x\\n\",\n\t\t\t\tproc->pid, thread->pid, hdr->type);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_object_type;\n\t\t}\n\t}\n\ttcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;\n\tt->work.type = BINDER_WORK_TRANSACTION;\n\n\tif (reply) {\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tbinder_inner_proc_lock(target_proc);\n\t\tif (target_thread->is_dead) {\n\t\t\tbinder_inner_proc_unlock(target_proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_pop_transaction_ilocked(target_thread, in_reply_to);\n\t\tbinder_enqueue_thread_work_ilocked(target_thread, &t->work);\n\t\tbinder_inner_proc_unlock(target_proc);\n\t\twake_up_interruptible_sync(&target_thread->wait);\n\t\tbinder_free_transaction(in_reply_to);\n\t} else if (!(t->flags & TF_ONE_WAY)) {\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_inner_proc_lock(proc);\n\t\t/*\n\t\t * Defer the TRANSACTION_COMPLETE, so we don't return to\n\t\t * userspace immediately; this allows the target process to\n\t\t * immediately start processing this transaction, reducing\n\t\t * latency. We will then return the TRANSACTION_COMPLETE when\n\t\t * the target replies (or there is an error).\n\t\t */\n\t\tbinder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);\n\t\tt->need_reply = 1;\n\t\tt->from_parent = thread->transaction_stack;\n\t\tthread->transaction_stack = t;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tif (!binder_proc_transaction(t, target_proc, target_thread)) {\n\t\t\tbinder_inner_proc_lock(proc);\n\t\t\tbinder_pop_transaction_ilocked(thread, t);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t} else {\n\t\tBUG_ON(target_node == NULL);\n\t\tBUG_ON(t->buffer->async_transaction != 1);\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tif (!binder_proc_transaction(t, target_proc, NULL))\n\t\t\tgoto err_dead_proc_or_thread;\n\t}\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\t/*\n\t * write barrier to synchronize with initialization\n\t * of log entry\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\treturn;\n\nerr_dead_proc_or_thread:\n\treturn_error = BR_DEAD_REPLY;\n\treturn_error_line = __LINE__;\n\tbinder_dequeue_work(proc, tcomplete);\nerr_translate_failed:\nerr_bad_object_type:\nerr_bad_offset:\nerr_bad_parent:\nerr_copy_data_failed:\n\tbinder_free_txn_fixups(t);\n\ttrace_binder_transaction_failed_buffer_release(t->buffer);\n\tbinder_transaction_buffer_release(target_proc, t->buffer,\n\t\t\t\t\t  buffer_offset, true);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\ttarget_node = NULL;\n\tt->buffer->transaction = NULL;\n\tbinder_alloc_free_buf(&target_proc->alloc, t->buffer);\nerr_binder_alloc_buf_failed:\n\tif (secctx)\n\t\tsecurity_release_secctx(secctx, secctx_sz);\nerr_get_secctx_failed:\n\tkfree(tcomplete);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\nerr_alloc_tcomplete_failed:\n\tkfree(t);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\nerr_alloc_t_failed:\nerr_bad_todo_list:\nerr_bad_call_stack:\nerr_empty_call_stack:\nerr_dead_binder:\nerr_invalid_target_handle:\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tif (target_proc)\n\t\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node) {\n\t\tbinder_dec_node(target_node, 1, 0);\n\t\tbinder_dec_node_tmpref(target_node);\n\t}\n\n\tbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\n\t\t     \"%d:%d transaction failed %d/%d, size %lld-%lld line %d\\n\",\n\t\t     proc->pid, thread->pid, return_error, return_error_param,\n\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t     return_error_line);\n\n\t{\n\t\tstruct binder_transaction_log_entry *fe;\n\n\t\te->return_error = return_error;\n\t\te->return_error_param = return_error_param;\n\t\te->return_error_line = return_error_line;\n\t\tfe = binder_transaction_log_add(&binder_transaction_log_failed);\n\t\t*fe = *e;\n\t\t/*\n\t\t * write barrier to synchronize with initialization\n\t\t * of log entry\n\t\t */\n\t\tsmp_wmb();\n\t\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\t\tWRITE_ONCE(fe->debug_id_done, t_debug_id);\n\t}\n\n\tBUG_ON(thread->return_error.cmd != BR_OK);\n\tif (in_reply_to) {\n\t\tthread->return_error.cmd = BR_TRANSACTION_COMPLETE;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t\tbinder_send_failed_reply(in_reply_to, return_error);\n\t} else {\n\t\tthread->return_error.cmd = return_error;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t}\n}",
        "code_after_change": "static void binder_transaction(struct binder_proc *proc,\n\t\t\t       struct binder_thread *thread,\n\t\t\t       struct binder_transaction_data *tr, int reply,\n\t\t\t       binder_size_t extra_buffers_size)\n{\n\tint ret;\n\tstruct binder_transaction *t;\n\tstruct binder_work *w;\n\tstruct binder_work *tcomplete;\n\tbinder_size_t buffer_offset = 0;\n\tbinder_size_t off_start_offset, off_end_offset;\n\tbinder_size_t off_min;\n\tbinder_size_t sg_buf_offset, sg_buf_end_offset;\n\tstruct binder_proc *target_proc = NULL;\n\tstruct binder_thread *target_thread = NULL;\n\tstruct binder_node *target_node = NULL;\n\tstruct binder_transaction *in_reply_to = NULL;\n\tstruct binder_transaction_log_entry *e;\n\tuint32_t return_error = 0;\n\tuint32_t return_error_param = 0;\n\tuint32_t return_error_line = 0;\n\tbinder_size_t last_fixup_obj_off = 0;\n\tbinder_size_t last_fixup_min_off = 0;\n\tstruct binder_context *context = proc->context;\n\tint t_debug_id = atomic_inc_return(&binder_last_id);\n\tchar *secctx = NULL;\n\tu32 secctx_sz = 0;\n\n\te = binder_transaction_log_add(&binder_transaction_log);\n\te->debug_id = t_debug_id;\n\te->call_type = reply ? 2 : !!(tr->flags & TF_ONE_WAY);\n\te->from_proc = proc->pid;\n\te->from_thread = thread->pid;\n\te->target_handle = tr->target.handle;\n\te->data_size = tr->data_size;\n\te->offsets_size = tr->offsets_size;\n\te->context_name = proc->context->name;\n\n\tif (reply) {\n\t\tbinder_inner_proc_lock(proc);\n\t\tin_reply_to = thread->transaction_stack;\n\t\tif (in_reply_to == NULL) {\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with no transaction stack\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_empty_call_stack;\n\t\t}\n\t\tif (in_reply_to->to_thread != thread) {\n\t\t\tspin_lock(&in_reply_to->lock);\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\tproc->pid, thread->pid, in_reply_to->debug_id,\n\t\t\t\tin_reply_to->to_proc ?\n\t\t\t\tin_reply_to->to_proc->pid : 0,\n\t\t\t\tin_reply_to->to_thread ?\n\t\t\t\tin_reply_to->to_thread->pid : 0);\n\t\t\tspin_unlock(&in_reply_to->lock);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\tgoto err_bad_call_stack;\n\t\t}\n\t\tthread->transaction_stack = in_reply_to->to_parent;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tbinder_set_nice(in_reply_to->saved_priority);\n\t\ttarget_thread = binder_get_txn_from_and_acq_inner(in_reply_to);\n\t\tif (target_thread == NULL) {\n\t\t\t/* annotation for sparse */\n\t\t\t__release(&target_thread->proc->inner_lock);\n\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\tif (target_thread->transaction_stack != in_reply_to) {\n\t\t\tbinder_user_error(\"%d:%d got reply transaction with bad target transaction stack %d, expected %d\\n\",\n\t\t\t\tproc->pid, thread->pid,\n\t\t\t\ttarget_thread->transaction_stack ?\n\t\t\t\ttarget_thread->transaction_stack->debug_id : 0,\n\t\t\t\tin_reply_to->debug_id);\n\t\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tin_reply_to = NULL;\n\t\t\ttarget_thread = NULL;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\ttarget_proc = target_thread->proc;\n\t\ttarget_proc->tmp_ref++;\n\t\tbinder_inner_proc_unlock(target_thread->proc);\n\t} else {\n\t\tif (tr->target.handle) {\n\t\t\tstruct binder_ref *ref;\n\n\t\t\t/*\n\t\t\t * There must already be a strong ref\n\t\t\t * on this node. If so, do a strong\n\t\t\t * increment on the node to ensure it\n\t\t\t * stays alive until the transaction is\n\t\t\t * done.\n\t\t\t */\n\t\t\tbinder_proc_lock(proc);\n\t\t\tref = binder_get_ref_olocked(proc, tr->target.handle,\n\t\t\t\t\t\t     true);\n\t\t\tif (ref) {\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\tref->node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\t} else {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to invalid handle\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t}\n\t\t\tbinder_proc_unlock(proc);\n\t\t} else {\n\t\t\tmutex_lock(&context->context_mgr_node_lock);\n\t\t\ttarget_node = context->binder_context_mgr_node;\n\t\t\tif (target_node)\n\t\t\t\ttarget_node = binder_get_node_refs_for_txn(\n\t\t\t\t\t\ttarget_node, &target_proc,\n\t\t\t\t\t\t&return_error);\n\t\t\telse\n\t\t\t\treturn_error = BR_DEAD_REPLY;\n\t\t\tmutex_unlock(&context->context_mgr_node_lock);\n\t\t\tif (target_node && target_proc == proc) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction to context manager from process owning it\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_invalid_target_handle;\n\t\t\t}\n\t\t}\n\t\tif (!target_node) {\n\t\t\t/*\n\t\t\t * return_error is set above\n\t\t\t */\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_dead_binder;\n\t\t}\n\t\te->to_node = target_node->debug_id;\n\t\tif (security_binder_transaction(proc->tsk,\n\t\t\t\t\t\ttarget_proc->tsk) < 0) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPERM;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_invalid_target_handle;\n\t\t}\n\t\tbinder_inner_proc_lock(proc);\n\n\t\tw = list_first_entry_or_null(&thread->todo,\n\t\t\t\t\t     struct binder_work, entry);\n\t\tif (!(tr->flags & TF_ONE_WAY) && w &&\n\t\t    w->type == BINDER_WORK_TRANSACTION) {\n\t\t\t/*\n\t\t\t * Do not allow new outgoing transaction from a\n\t\t\t * thread that has a transaction at the head of\n\t\t\t * its todo list. Only need to check the head\n\t\t\t * because binder_select_thread_ilocked picks a\n\t\t\t * thread from proc->waiting_threads to enqueue\n\t\t\t * the transaction, and nothing is queued to the\n\t\t\t * todo list while the thread is on waiting_threads.\n\t\t\t */\n\t\t\tbinder_user_error(\"%d:%d new transaction not allowed when there is a transaction on thread todo\\n\",\n\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EPROTO;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_todo_list;\n\t\t}\n\n\t\tif (!(tr->flags & TF_ONE_WAY) && thread->transaction_stack) {\n\t\t\tstruct binder_transaction *tmp;\n\n\t\t\ttmp = thread->transaction_stack;\n\t\t\tif (tmp->to_thread != thread) {\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tbinder_user_error(\"%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\\n\",\n\t\t\t\t\tproc->pid, thread->pid, tmp->debug_id,\n\t\t\t\t\ttmp->to_proc ? tmp->to_proc->pid : 0,\n\t\t\t\t\ttmp->to_thread ?\n\t\t\t\t\ttmp->to_thread->pid : 0);\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EPROTO;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_call_stack;\n\t\t\t}\n\t\t\twhile (tmp) {\n\t\t\t\tstruct binder_thread *from;\n\n\t\t\t\tspin_lock(&tmp->lock);\n\t\t\t\tfrom = tmp->from;\n\t\t\t\tif (from && from->proc == target_proc) {\n\t\t\t\t\tatomic_inc(&from->tmp_ref);\n\t\t\t\t\ttarget_thread = from;\n\t\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tspin_unlock(&tmp->lock);\n\t\t\t\ttmp = tmp->from_parent;\n\t\t\t}\n\t\t}\n\t\tbinder_inner_proc_unlock(proc);\n\t}\n\tif (target_thread)\n\t\te->to_thread = target_thread->pid;\n\te->to_proc = target_proc->pid;\n\n\t/* TODO: reuse incoming transaction for reply */\n\tt = kzalloc(sizeof(*t), GFP_KERNEL);\n\tif (t == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_t_failed;\n\t}\n\tINIT_LIST_HEAD(&t->fd_fixups);\n\tbinder_stats_created(BINDER_STAT_TRANSACTION);\n\tspin_lock_init(&t->lock);\n\n\ttcomplete = kzalloc(sizeof(*tcomplete), GFP_KERNEL);\n\tif (tcomplete == NULL) {\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -ENOMEM;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_alloc_tcomplete_failed;\n\t}\n\tbinder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);\n\n\tt->debug_id = t_debug_id;\n\n\tif (reply)\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_REPLY %d -> %d:%d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_thread->pid,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\telse\n\t\tbinder_debug(BINDER_DEBUG_TRANSACTION,\n\t\t\t     \"%d:%d BC_TRANSACTION %d -> %d - node %d, data %016llx-%016llx size %lld-%lld-%lld\\n\",\n\t\t\t     proc->pid, thread->pid, t->debug_id,\n\t\t\t     target_proc->pid, target_node->debug_id,\n\t\t\t     (u64)tr->data.ptr.buffer,\n\t\t\t     (u64)tr->data.ptr.offsets,\n\t\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t\t     (u64)extra_buffers_size);\n\n\tif (!reply && !(tr->flags & TF_ONE_WAY))\n\t\tt->from = thread;\n\telse\n\t\tt->from = NULL;\n\tt->sender_euid = task_euid(proc->tsk);\n\tt->to_proc = target_proc;\n\tt->to_thread = target_thread;\n\tt->code = tr->code;\n\tt->flags = tr->flags;\n\tt->priority = task_nice(current);\n\n\tif (target_node && target_node->txn_security_ctx) {\n\t\tu32 secid;\n\t\tsize_t added_size;\n\n\t\tsecurity_task_getsecid(proc->tsk, &secid);\n\t\tret = security_secid_to_secctx(secid, &secctx, &secctx_sz);\n\t\tif (ret) {\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = ret;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_get_secctx_failed;\n\t\t}\n\t\tadded_size = ALIGN(secctx_sz, sizeof(u64));\n\t\textra_buffers_size += added_size;\n\t\tif (extra_buffers_size < added_size) {\n\t\t\t/* integer overflow of extra_buffers_size */\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_extra_size;\n\t\t}\n\t}\n\n\ttrace_binder_transaction(reply, t, target_node);\n\n\tt->buffer = binder_alloc_new_buf(&target_proc->alloc, tr->data_size,\n\t\ttr->offsets_size, extra_buffers_size,\n\t\t!reply && (t->flags & TF_ONE_WAY));\n\tif (IS_ERR(t->buffer)) {\n\t\t/*\n\t\t * -ESRCH indicates VMA cleared. The target is dying.\n\t\t */\n\t\treturn_error_param = PTR_ERR(t->buffer);\n\t\treturn_error = return_error_param == -ESRCH ?\n\t\t\tBR_DEAD_REPLY : BR_FAILED_REPLY;\n\t\treturn_error_line = __LINE__;\n\t\tt->buffer = NULL;\n\t\tgoto err_binder_alloc_buf_failed;\n\t}\n\tif (secctx) {\n\t\tsize_t buf_offset = ALIGN(tr->data_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(tr->offsets_size, sizeof(void *)) +\n\t\t\t\t    ALIGN(extra_buffers_size, sizeof(void *)) -\n\t\t\t\t    ALIGN(secctx_sz, sizeof(u64));\n\n\t\tt->security_ctx = (uintptr_t)t->buffer->user_data + buf_offset;\n\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t    t->buffer, buf_offset,\n\t\t\t\t\t    secctx, secctx_sz);\n\t\tsecurity_release_secctx(secctx, secctx_sz);\n\t\tsecctx = NULL;\n\t}\n\tt->buffer->debug_id = t->debug_id;\n\tt->buffer->transaction = t;\n\tt->buffer->target_node = target_node;\n\ttrace_binder_transaction_alloc_buf(t->buffer);\n\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer, 0,\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.buffer,\n\t\t\t\ttr->data_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid data ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t&target_proc->alloc,\n\t\t\t\tt->buffer,\n\t\t\t\tALIGN(tr->data_size, sizeof(void *)),\n\t\t\t\t(const void __user *)\n\t\t\t\t\t(uintptr_t)tr->data.ptr.offsets,\n\t\t\t\ttr->offsets_size)) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\tproc->pid, thread->pid);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EFAULT;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_copy_data_failed;\n\t}\n\tif (!IS_ALIGNED(tr->offsets_size, sizeof(binder_size_t))) {\n\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets size, %lld\\n\",\n\t\t\t\tproc->pid, thread->pid, (u64)tr->offsets_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\tif (!IS_ALIGNED(extra_buffers_size, sizeof(u64))) {\n\t\tbinder_user_error(\"%d:%d got transaction with unaligned buffers size, %lld\\n\",\n\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t  (u64)extra_buffers_size);\n\t\treturn_error = BR_FAILED_REPLY;\n\t\treturn_error_param = -EINVAL;\n\t\treturn_error_line = __LINE__;\n\t\tgoto err_bad_offset;\n\t}\n\toff_start_offset = ALIGN(tr->data_size, sizeof(void *));\n\tbuffer_offset = off_start_offset;\n\toff_end_offset = off_start_offset + tr->offsets_size;\n\tsg_buf_offset = ALIGN(off_end_offset, sizeof(void *));\n\tsg_buf_end_offset = sg_buf_offset + extra_buffers_size;\n\toff_min = 0;\n\tfor (buffer_offset = off_start_offset; buffer_offset < off_end_offset;\n\t     buffer_offset += sizeof(binder_size_t)) {\n\t\tstruct binder_object_header *hdr;\n\t\tsize_t object_size;\n\t\tstruct binder_object object;\n\t\tbinder_size_t object_offset;\n\n\t\tbinder_alloc_copy_from_buffer(&target_proc->alloc,\n\t\t\t\t\t      &object_offset,\n\t\t\t\t\t      t->buffer,\n\t\t\t\t\t      buffer_offset,\n\t\t\t\t\t      sizeof(object_offset));\n\t\tobject_size = binder_get_object(target_proc, t->buffer,\n\t\t\t\t\t\tobject_offset, &object);\n\t\tif (object_size == 0 || object_offset < off_min) {\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\\n\",\n\t\t\t\t\t  proc->pid, thread->pid,\n\t\t\t\t\t  (u64)object_offset,\n\t\t\t\t\t  (u64)off_min,\n\t\t\t\t\t  (u64)t->buffer->data_size);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_offset;\n\t\t}\n\n\t\thdr = &object.hdr;\n\t\toff_min = object_offset + object_size;\n\t\tswitch (hdr->type) {\n\t\tcase BINDER_TYPE_BINDER:\n\t\tcase BINDER_TYPE_WEAK_BINDER: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_binder(fp, t, thread);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    fp, sizeof(*fp));\n\t\t} break;\n\t\tcase BINDER_TYPE_HANDLE:\n\t\tcase BINDER_TYPE_WEAK_HANDLE: {\n\t\t\tstruct flat_binder_object *fp;\n\n\t\t\tfp = to_flat_binder_object(hdr);\n\t\t\tret = binder_translate_handle(fp, t, thread);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    fp, sizeof(*fp));\n\t\t} break;\n\n\t\tcase BINDER_TYPE_FD: {\n\t\t\tstruct binder_fd_object *fp = to_binder_fd_object(hdr);\n\t\t\tbinder_size_t fd_offset = object_offset +\n\t\t\t\t(uintptr_t)&fp->fd - (uintptr_t)fp;\n\t\t\tint ret = binder_translate_fd(fp->fd, fd_offset, t,\n\t\t\t\t\t\t      thread, in_reply_to);\n\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tfp->pad_binder = 0;\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    fp, sizeof(*fp));\n\t\t} break;\n\t\tcase BINDER_TYPE_FDA: {\n\t\t\tstruct binder_object ptr_object;\n\t\t\tbinder_size_t parent_offset;\n\t\t\tstruct binder_fd_array_object *fda =\n\t\t\t\tto_binder_fd_array_object(hdr);\n\t\t\tsize_t num_valid = (buffer_offset - off_start_offset) *\n\t\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tstruct binder_buffer_object *parent =\n\t\t\t\tbinder_validate_ptr(target_proc, t->buffer,\n\t\t\t\t\t\t    &ptr_object, fda->parent,\n\t\t\t\t\t\t    off_start_offset,\n\t\t\t\t\t\t    &parent_offset,\n\t\t\t\t\t\t    num_valid);\n\t\t\tif (!parent) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid parent offset or type\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tif (!binder_validate_fixup(target_proc, t->buffer,\n\t\t\t\t\t\t   off_start_offset,\n\t\t\t\t\t\t   parent_offset,\n\t\t\t\t\t\t   fda->parent_offset,\n\t\t\t\t\t\t   last_fixup_obj_off,\n\t\t\t\t\t\t   last_fixup_min_off)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with out-of-order buffer fixup\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_parent;\n\t\t\t}\n\t\t\tret = binder_translate_fd_array(fda, parent, t, thread,\n\t\t\t\t\t\t\tin_reply_to);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tlast_fixup_obj_off = parent_offset;\n\t\t\tlast_fixup_min_off =\n\t\t\t\tfda->parent_offset + sizeof(u32) * fda->num_fds;\n\t\t} break;\n\t\tcase BINDER_TYPE_PTR: {\n\t\t\tstruct binder_buffer_object *bp =\n\t\t\t\tto_binder_buffer_object(hdr);\n\t\t\tsize_t buf_left = sg_buf_end_offset - sg_buf_offset;\n\t\t\tsize_t num_valid;\n\n\t\t\tif (bp->length > buf_left) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with too large buffer\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = -EINVAL;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_bad_offset;\n\t\t\t}\n\t\t\tif (binder_alloc_copy_user_to_buffer(\n\t\t\t\t\t\t&target_proc->alloc,\n\t\t\t\t\t\tt->buffer,\n\t\t\t\t\t\tsg_buf_offset,\n\t\t\t\t\t\t(const void __user *)\n\t\t\t\t\t\t\t(uintptr_t)bp->buffer,\n\t\t\t\t\t\tbp->length)) {\n\t\t\t\tbinder_user_error(\"%d:%d got transaction with invalid offsets ptr\\n\",\n\t\t\t\t\t\t  proc->pid, thread->pid);\n\t\t\t\treturn_error_param = -EFAULT;\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_copy_data_failed;\n\t\t\t}\n\t\t\t/* Fixup buffer pointer to target proc address space */\n\t\t\tbp->buffer = (uintptr_t)\n\t\t\t\tt->buffer->user_data + sg_buf_offset;\n\t\t\tsg_buf_offset += ALIGN(bp->length, sizeof(u64));\n\n\t\t\tnum_valid = (buffer_offset - off_start_offset) *\n\t\t\t\t\tsizeof(binder_size_t);\n\t\t\tret = binder_fixup_parent(t, thread, bp,\n\t\t\t\t\t\t  off_start_offset,\n\t\t\t\t\t\t  num_valid,\n\t\t\t\t\t\t  last_fixup_obj_off,\n\t\t\t\t\t\t  last_fixup_min_off);\n\t\t\tif (ret < 0) {\n\t\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\t\treturn_error_param = ret;\n\t\t\t\treturn_error_line = __LINE__;\n\t\t\t\tgoto err_translate_failed;\n\t\t\t}\n\t\t\tbinder_alloc_copy_to_buffer(&target_proc->alloc,\n\t\t\t\t\t\t    t->buffer, object_offset,\n\t\t\t\t\t\t    bp, sizeof(*bp));\n\t\t\tlast_fixup_obj_off = object_offset;\n\t\t\tlast_fixup_min_off = 0;\n\t\t} break;\n\t\tdefault:\n\t\t\tbinder_user_error(\"%d:%d got transaction with invalid object type, %x\\n\",\n\t\t\t\tproc->pid, thread->pid, hdr->type);\n\t\t\treturn_error = BR_FAILED_REPLY;\n\t\t\treturn_error_param = -EINVAL;\n\t\t\treturn_error_line = __LINE__;\n\t\t\tgoto err_bad_object_type;\n\t\t}\n\t}\n\ttcomplete->type = BINDER_WORK_TRANSACTION_COMPLETE;\n\tt->work.type = BINDER_WORK_TRANSACTION;\n\n\tif (reply) {\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tbinder_inner_proc_lock(target_proc);\n\t\tif (target_thread->is_dead) {\n\t\t\tbinder_inner_proc_unlock(target_proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_pop_transaction_ilocked(target_thread, in_reply_to);\n\t\tbinder_enqueue_thread_work_ilocked(target_thread, &t->work);\n\t\tbinder_inner_proc_unlock(target_proc);\n\t\twake_up_interruptible_sync(&target_thread->wait);\n\t\tbinder_free_transaction(in_reply_to);\n\t} else if (!(t->flags & TF_ONE_WAY)) {\n\t\tBUG_ON(t->buffer->async_transaction != 0);\n\t\tbinder_inner_proc_lock(proc);\n\t\t/*\n\t\t * Defer the TRANSACTION_COMPLETE, so we don't return to\n\t\t * userspace immediately; this allows the target process to\n\t\t * immediately start processing this transaction, reducing\n\t\t * latency. We will then return the TRANSACTION_COMPLETE when\n\t\t * the target replies (or there is an error).\n\t\t */\n\t\tbinder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);\n\t\tt->need_reply = 1;\n\t\tt->from_parent = thread->transaction_stack;\n\t\tthread->transaction_stack = t;\n\t\tbinder_inner_proc_unlock(proc);\n\t\tif (!binder_proc_transaction(t, target_proc, target_thread)) {\n\t\t\tbinder_inner_proc_lock(proc);\n\t\t\tbinder_pop_transaction_ilocked(thread, t);\n\t\t\tbinder_inner_proc_unlock(proc);\n\t\t\tgoto err_dead_proc_or_thread;\n\t\t}\n\t} else {\n\t\tBUG_ON(target_node == NULL);\n\t\tBUG_ON(t->buffer->async_transaction != 1);\n\t\tbinder_enqueue_thread_work(thread, tcomplete);\n\t\tif (!binder_proc_transaction(t, target_proc, NULL))\n\t\t\tgoto err_dead_proc_or_thread;\n\t}\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\t/*\n\t * write barrier to synchronize with initialization\n\t * of log entry\n\t */\n\tsmp_wmb();\n\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\treturn;\n\nerr_dead_proc_or_thread:\n\treturn_error = BR_DEAD_REPLY;\n\treturn_error_line = __LINE__;\n\tbinder_dequeue_work(proc, tcomplete);\nerr_translate_failed:\nerr_bad_object_type:\nerr_bad_offset:\nerr_bad_parent:\nerr_copy_data_failed:\n\tbinder_free_txn_fixups(t);\n\ttrace_binder_transaction_failed_buffer_release(t->buffer);\n\tbinder_transaction_buffer_release(target_proc, t->buffer,\n\t\t\t\t\t  buffer_offset, true);\n\tif (target_node)\n\t\tbinder_dec_node_tmpref(target_node);\n\ttarget_node = NULL;\n\tt->buffer->transaction = NULL;\n\tbinder_alloc_free_buf(&target_proc->alloc, t->buffer);\nerr_binder_alloc_buf_failed:\nerr_bad_extra_size:\n\tif (secctx)\n\t\tsecurity_release_secctx(secctx, secctx_sz);\nerr_get_secctx_failed:\n\tkfree(tcomplete);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION_COMPLETE);\nerr_alloc_tcomplete_failed:\n\tkfree(t);\n\tbinder_stats_deleted(BINDER_STAT_TRANSACTION);\nerr_alloc_t_failed:\nerr_bad_todo_list:\nerr_bad_call_stack:\nerr_empty_call_stack:\nerr_dead_binder:\nerr_invalid_target_handle:\n\tif (target_thread)\n\t\tbinder_thread_dec_tmpref(target_thread);\n\tif (target_proc)\n\t\tbinder_proc_dec_tmpref(target_proc);\n\tif (target_node) {\n\t\tbinder_dec_node(target_node, 1, 0);\n\t\tbinder_dec_node_tmpref(target_node);\n\t}\n\n\tbinder_debug(BINDER_DEBUG_FAILED_TRANSACTION,\n\t\t     \"%d:%d transaction failed %d/%d, size %lld-%lld line %d\\n\",\n\t\t     proc->pid, thread->pid, return_error, return_error_param,\n\t\t     (u64)tr->data_size, (u64)tr->offsets_size,\n\t\t     return_error_line);\n\n\t{\n\t\tstruct binder_transaction_log_entry *fe;\n\n\t\te->return_error = return_error;\n\t\te->return_error_param = return_error_param;\n\t\te->return_error_line = return_error_line;\n\t\tfe = binder_transaction_log_add(&binder_transaction_log_failed);\n\t\t*fe = *e;\n\t\t/*\n\t\t * write barrier to synchronize with initialization\n\t\t * of log entry\n\t\t */\n\t\tsmp_wmb();\n\t\tWRITE_ONCE(e->debug_id_done, t_debug_id);\n\t\tWRITE_ONCE(fe->debug_id_done, t_debug_id);\n\t}\n\n\tBUG_ON(thread->return_error.cmd != BR_OK);\n\tif (in_reply_to) {\n\t\tthread->return_error.cmd = BR_TRANSACTION_COMPLETE;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t\tbinder_send_failed_reply(in_reply_to, return_error);\n\t} else {\n\t\tthread->return_error.cmd = return_error;\n\t\tbinder_enqueue_thread_work(thread, &thread->return_error.work);\n\t}\n}",
        "patch": "--- code before\n+++ code after\n@@ -269,6 +269,7 @@\n \n \tif (target_node && target_node->txn_security_ctx) {\n \t\tu32 secid;\n+\t\tsize_t added_size;\n \n \t\tsecurity_task_getsecid(proc->tsk, &secid);\n \t\tret = security_secid_to_secctx(secid, &secctx, &secctx_sz);\n@@ -278,7 +279,15 @@\n \t\t\treturn_error_line = __LINE__;\n \t\t\tgoto err_get_secctx_failed;\n \t\t}\n-\t\textra_buffers_size += ALIGN(secctx_sz, sizeof(u64));\n+\t\tadded_size = ALIGN(secctx_sz, sizeof(u64));\n+\t\textra_buffers_size += added_size;\n+\t\tif (extra_buffers_size < added_size) {\n+\t\t\t/* integer overflow of extra_buffers_size */\n+\t\t\treturn_error = BR_FAILED_REPLY;\n+\t\t\treturn_error_param = EINVAL;\n+\t\t\treturn_error_line = __LINE__;\n+\t\t\tgoto err_bad_extra_size;\n+\t\t}\n \t}\n \n \ttrace_binder_transaction(reply, t, target_node);\n@@ -628,6 +637,7 @@\n \tt->buffer->transaction = NULL;\n \tbinder_alloc_free_buf(&target_proc->alloc, t->buffer);\n err_binder_alloc_buf_failed:\n+err_bad_extra_size:\n \tif (secctx)\n \t\tsecurity_release_secctx(secctx, secctx_sz);\n err_get_secctx_failed:",
        "function_modified_lines": {
            "added": [
                "\t\tsize_t added_size;",
                "\t\tadded_size = ALIGN(secctx_sz, sizeof(u64));",
                "\t\textra_buffers_size += added_size;",
                "\t\tif (extra_buffers_size < added_size) {",
                "\t\t\t/* integer overflow of extra_buffers_size */",
                "\t\t\treturn_error = BR_FAILED_REPLY;",
                "\t\t\treturn_error_param = EINVAL;",
                "\t\t\treturn_error_line = __LINE__;",
                "\t\t\tgoto err_bad_extra_size;",
                "\t\t}",
                "err_bad_extra_size:"
            ],
            "deleted": [
                "\t\textra_buffers_size += ALIGN(secctx_sz, sizeof(u64));"
            ]
        },
        "cwe": [
            "CWE-787",
            "CWE-190"
        ],
        "cve_description": "In binder_transaction of binder.c in the Android kernel, there is a possible out of bounds write due to an integer overflow. This could lead to local escalation of privilege with no additional execution privileges needed. User interaction is needed for exploitation.",
        "id": 2291
    }
]